ca65 V2.19 - Git 1093d16
Main file   : ann_fdswrap.asm
Current file: ann_fdswrap.asm

000000r 1               ;This file takes the assembled binaries of the program files and puts
000000r 1               ;them into an FDS file along with the character files that are needed.
000000r 1               ;In order for this to work, the program files need to already be assembled
000000r 1               ;and the character files from the disk or disk image are also needed.
000000r 1               
000000r 1               DiskInfoBlock     = 1
000000r 1               FileAmountBlock   = 2
000000r 1               FileHeaderBlock   = 3
000000r 1               FileDataBlock     = 4
000000r 1               PRG = 0
000000r 1               CHR = 1
000000r 1               VRAM = 2
000000r 1               
000000r 1               ;FWNES header
000000r 1               ;.byte "FDS",$1a,1,0,0,0,0,0,0,0,0,0,0,0
000000r 1               
000000r 1  01           .byte DiskInfoBlock
000001r 1  2A 4E 49 4E  .byte "*NINTENDO-HVC*"
000005r 1  54 45 4E 44  
000009r 1  4F 2D 48 56  
00000Fr 1  01 4E 53 4D  .byte $01,"NSM ",0,0,0,0,0,$0f
000013r 1  20 00 00 00  
000017r 1  00 00 0F     
00001Ar 1  FF FF FF FF  .byte $ff,$ff,$ff,$ff,$ff
00001Er 1  FF           
00001Fr 1  61 12 13     .byte $61,$12,$13
000022r 1  49 61 00 00  .byte $49,$61,$00,$00,$02,$06,$9a,$05,$25,$01
000026r 1  02 06 9A 05  
00002Ar 1  25 01        
00002Cr 1  61 12 13     .byte $61,$12,$13
00002Fr 1  FF FF FF FF  .byte $ff,$ff,$ff,$ff,$ff,$00,$00,$00,$00
000033r 1  FF 00 00 00  
000037r 1  00           
000038r 1               
000038r 1  02           .byte FileAmountBlock
000039r 1  08           .byte 8
00003Ar 1               
00003Ar 1  03           .byte FileHeaderBlock
00003Br 1  00 00        .byte $00,$00
00003Dr 1  4B 59 4F 44  .byte "KYODAKU-"
000041r 1  41 4B 55 2D  
000045r 1  00 28        .word $2800
000047r 1  E0 00        .word KyodakuEnd-KyodakuStart
000049r 1  02           .byte VRAM
00004Ar 1               
00004Ar 1  04           .byte FileDataBlock
00004Br 1               KyodakuStart:
00004Br 1  24 24 24 24  .byte $24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$17,$12,$17,$1d,$0e
00004Fr 1  24 24 24 24  
000053r 1  24 24 24 17  
00005Br 1  17 0D 18 24  .byte $17,$0d,$18,$24,$28,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24
00005Fr 1  28 24 24 24  
000063r 1  24 24 24 24  
00006Br 1  24 24 24 24  .byte $24,$24,$24,$24,$24,$24,$24,$0f,$0a,$16,$12,$15,$22,$24,$0c,$18
00006Fr 1  24 24 24 0F  
000073r 1  0A 16 12 15  
00007Br 1  16 19 1E 1D  .byte $16,$19,$1e,$1d,$0e,$1b,$24,$1d,$16,$24,$24,$24,$24,$24,$24,$24
00007Fr 1  0E 1B 24 1D  
000083r 1  16 24 24 24  
00008Br 1  24 24 24 24  .byte $24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24
00008Fr 1  24 24 24 24  
000093r 1  24 24 24 24  
00009Br 1  24 24 24 24  .byte $24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24
00009Fr 1  24 24 24 24  
0000A3r 1  24 24 24 24  
0000ABr 1  24 24 1D 11  .byte $24,$24,$1d,$11,$12,$1c,$24,$19,$1b,$18,$0d,$1e,$0c,$1d,$24,$12
0000AFr 1  12 1C 24 19  
0000B3r 1  1B 18 0D 1E  
0000BBr 1  1C 24 16 0A  .byte $1c,$24,$16,$0a,$17,$1e,$0f,$0a,$0c,$1d,$1e,$1b,$0e,$0d,$24,$24
0000BFr 1  17 1E 0F 0A  
0000C3r 1  0C 1D 1E 1B  
0000CBr 1  24 24 0A 17  .byte $24,$24,$0a,$17,$0d,$24,$1c,$18,$15,$0d,$24,$0b,$22,$24,$17,$12
0000CFr 1  0D 24 1C 18  
0000D3r 1  15 0D 24 0B  
0000DBr 1  17 1D 0E 17  .byte $17,$1d,$0e,$17,$0d,$18,$24,$0c,$18,$27,$15,$1d,$0d,$26,$24,$24
0000DFr 1  0D 18 24 0C  
0000E3r 1  18 27 15 1D  
0000EBr 1  24 24 18 1B  .byte $24,$24,$18,$1b,$24,$0b,$22,$24,$18,$1d,$11,$0e,$1b,$24,$0c,$18
0000EFr 1  24 0B 22 24  
0000F3r 1  18 1D 11 0E  
0000FBr 1  16 19 0A 17  .byte $16,$19,$0a,$17,$22,$24,$1e,$17,$0d,$0e,$1b,$24,$24,$24,$24,$24
0000FFr 1  22 24 1E 17  
000103r 1  0D 0E 1B 24  
00010Br 1  24 24 15 12  .byte $24,$24,$15,$12,$0c,$0e,$17,$1c,$0e,$24,$18,$0f,$24,$17,$12,$17
00010Fr 1  0C 0E 17 1C  
000113r 1  0E 24 18 0F  
00011Br 1  1D 0E 17 0D  .byte $1d,$0e,$17,$0d,$18,$24,$0c,$18,$27,$15,$1d,$0d,$26,$26,$24,$24
00011Fr 1  18 24 0C 18  
000123r 1  27 15 1D 0D  
00012Br 1               KyodakuEnd:
00012Br 1               
00012Br 1  03           .byte FileHeaderBlock
00012Cr 1  01 01        .byte $01,$01
00012Er 1  4E 53 4D 43  .byte "NSMCHAR1"
000132r 1  48 41 52 31  
000136r 1  00 00        .word $0000
000138r 1  00 20        .word Char1End-Char1Start
00013Ar 1  01 04        .byte CHR,FileDataBlock
00013Cr 1               Char1Start:
00013Cr 1  03 0F 1F 1F  .incbin "NSMCHAR1.chr"
000140r 1  1C 24 26 66  
000144r 1  00 00 00 00  
00213Cr 1               Char1End:
00213Cr 1               
00213Cr 1  03           .byte FileHeaderBlock
00213Dr 1  02 10        .byte $02,$10
00213Fr 1  4E 53 4D 43  .byte "NSMCHAR2"
002143r 1  48 41 52 32  
002147r 1  60 07        .word $0760
002149r 1  60 04        .word Char2End-Char2Start
00214Br 1  01 04        .byte CHR,FileDataBlock
00214Dr 1               Char2Start:
00214Dr 1  03 07 07 07  .incbin "NSMCHAR2.chr"
002151r 1  1F 3F 3F 3F  
002155r 1  03 1F 07 07  
0025ADr 1               Char2End:
0025ADr 1               
0025ADr 1  03 03 05     .byte FileHeaderBlock,$03,$05
0025B0r 1  4E 53 4D 4D  .byte "NSMMAIN "
0025B4r 1  41 49 4E 20  
0025B8r 1  00 60 00 80  .word $6000, MainEnd-MainStart
0025BCr 1  00 04        .byte PRG, FileDataBlock
0025BEr 1               MainStart:
0025BEr 1               .scope FILE_SM2MAIN
0025BEr 1               .org $6000
006000  1               .include "ann_sm2main.asm"
006000  2               ;SMB2J DISASSEMBLY (SM2MAIN portion)
006000  2               
006000  2               ;-------------------------------------------------------------------------------------
006000  2               ;DEFINES
006000  2               
006000  2               ;NES specific hardware defines
006000  2               
006000  2               ANN                   = $40
006000  2               PPU_CTRL              = $2000
006000  2               PPU_MASK              = $2001
006000  2               PPU_STATUS            = $2002
006000  2               PPU_SPR_ADDR          = $2003
006000  2               PPU_SPR_DATA          = $2004
006000  2               PPU_SCROLL            = $2005
006000  2               PPU_ADDRESS           = $2006
006000  2               PPU_DATA              = $2007
006000  2               
006000  2               SND_REGISTER          = $4000
006000  2               SND_SQUARE1_REG       = $4000
006000  2               SND_SQUARE2_REG       = $4004
006000  2               SND_TRIANGLE_REG      = $4008
006000  2               SND_NOISE_REG         = $400c
006000  2               SND_DELTA_REG         = $4010
006000  2               SND_MASTERCTRL_REG    = $4015
006000  2               
006000  2               SPR_DMA               = $4014
006000  2               JOYPAD_PORT           = $4016
006000  2               JOYPAD_PORT1          = $4016
006000  2               JOYPAD_PORT2          = $4017
006000  2               
006000  2               FDS_IRQTIMER_LOW      = $4020
006000  2               FDS_IRQTIMER_HIGH     = $4021
006000  2               FDS_IRQTIMER_CTRL     = $4022
006000  2               FDS_CTRL_REG          = $4025
006000  2               FDS_STATUS            = $4030
006000  2               FDS_DRIVE_STATUS      = $4032
006000  2               
006000  2               ; GAME SPECIFIC DEFINES
006000  2               
006000  2               ObjectOffset          = $08
006000  2               
006000  2               FrameCounter          = $09
006000  2               
006000  2               SavedJoypadBits       = $06fc
006000  2               SavedJoypad1Bits      = $06fc
006000  2               SavedJoypad2Bits      = $06fd
006000  2               JoypadBitMask         = $074a
006000  2               JoypadOverride        = $0758
006000  2               
006000  2               A_B_Buttons           = $0a
006000  2               PreviousA_B_Buttons   = $0d
006000  2               Up_Down_Buttons       = $0b
006000  2               Left_Right_Buttons    = $0c
006000  2               
006000  2               GameEngineSubroutine  = $0e
006000  2               
006000  2               Mirror_PPU_CTRL       = $0778
006000  2               Mirror_PPU_MASK       = $0779
006000  2               Mirror_FDS_CTRL_REG   = $fa
006000  2               NameTableSelect       = $077a
006000  2               FileListNumber        = $07f7
006000  2               
006000  2               OperMode              = $0770
006000  2               OperMode_Task         = $0772
006000  2               ScreenRoutineTask     = $073c
006000  2               
006000  2               FDSBIOS_IRQFlag       = $0101
006000  2               IRQUpdateFlag         = $0722
006000  2               IRQAckFlag            = $077b
006000  2               DiskIOTask            = $07fc
006000  2               NotColdFlag           = $07fd
006000  2               
006000  2               GamePauseStatus       = $0776
006000  2               GamePauseTimer        = $0777
006000  2               
006000  2               DemoAction            = $0717
006000  2               DemoActionTimer       = $0718
006000  2               
006000  2               TimerControl          = $0747
006000  2               IntervalTimerControl  = $077f
006000  2               
006000  2               Timers                = $0780
006000  2               SelectTimer           = $0780
006000  2               PlayerAnimTimer       = $0781
006000  2               JumpSwimTimer         = $0782
006000  2               RunningTimer          = $0783
006000  2               BlockBounceTimer      = $0784
006000  2               SideCollisionTimer    = $0785
006000  2               JumpspringTimer       = $0786
006000  2               GameTimerCtrlTimer    = $0787
006000  2               ClimbSideTimer        = $0789
006000  2               EnemyFrameTimer       = $078a
006000  2               FrenzyEnemyTimer      = $078f
006000  2               BowserFireBreathTimer = $0790
006000  2               StompTimer            = $0791
006000  2               AirBubbleTimer        = $0792
006000  2               ScrollIntervalTimer   = $0795
006000  2               EnemyIntervalTimer    = $0796
006000  2               BrickCoinTimer        = $079d
006000  2               InjuryTimer           = $079e
006000  2               StarInvincibleTimer   = $079f
006000  2               ScreenTimer           = $07a0
006000  2               WorldEndTimer         = $07a1
006000  2               DemoTimer             = $07a2
006000  2               
006000  2               Sprite_Data           = $0200
006000  2               
006000  2               Sprite_Y_Position     = $0200
006000  2               Sprite_Tilenumber     = $0201
006000  2               Sprite_Attributes     = $0202
006000  2               Sprite_X_Position     = $0203
006000  2               
006000  2               ScreenEdge_PageLoc    = $071a
006000  2               ScreenEdge_X_Pos      = $071c
006000  2               ScreenLeft_PageLoc    = $071a
006000  2               ScreenRight_PageLoc   = $071b
006000  2               ScreenLeft_X_Pos      = $071c
006000  2               ScreenRight_X_Pos     = $071d
006000  2               
006000  2               PlayerFacingDir       = $33
006000  2               DestinationPageLoc    = $34
006000  2               VictoryWalkControl    = $35
006000  2               ScrollFractional      = $0768
006000  2               SecondaryMsgCounter   = $0749
006000  2               MsgCounter            = $0719
006000  2               MsgFractional         = $0749
006000  2               
006000  2               HorizontalScroll      = $073f
006000  2               VerticalScroll        = $0740
006000  2               ScrollLock            = $0723
006000  2               ScrollThirtyTwo       = $073d
006000  2               Player_X_Scroll       = $06ff
006000  2               Player_Pos_ForScroll  = $0755
006000  2               ScrollAmount          = $0775
006000  2               
006000  2               AreaData              = $e7
006000  2               AreaDataLow           = $e7
006000  2               AreaDataHigh          = $e8
006000  2               EnemyData             = $e9
006000  2               EnemyDataLow          = $e9
006000  2               EnemyDataHigh         = $ea
006000  2               
006000  2               AreaParserTaskNum     = $071f
006000  2               ColumnSets            = $071e
006000  2               CurrentPageLoc        = $0725
006000  2               CurrentColumnPos      = $0726
006000  2               BackloadingFlag       = $0728
006000  2               BehindAreaParserFlag  = $0729
006000  2               AreaObjectPageLoc     = $072a
006000  2               AreaObjectPageSel     = $072b
006000  2               AreaDataOffset        = $072c
006000  2               AreaObjOffsetBuffer   = $072d
006000  2               AreaObjectLength      = $0730
006000  2               StaircaseControl      = $0734
006000  2               AreaObjectHeight      = $0735
006000  2               MushroomLedgeHalfLen  = $0736
006000  2               EnemyDataOffset       = $0739
006000  2               EnemyObjectPageLoc    = $073a
006000  2               EnemyObjectPageSel    = $073b
006000  2               MetatileBuffer        = $06a1
006000  2               BlockBufferColumnPos  = $06a0
006000  2               CurrentNTAddr_Low     = $0721
006000  2               CurrentNTAddr_High    = $0720
006000  2               AttributeBuffer       = $03f9
006000  2               
006000  2               LoopCommand           = $0745
006000  2               
006000  2               DisplayDigits         = $07d7
006000  2               TopScoreDisplay       = $07d7
006000  2               ScoreAndCoinDisplay   = $07dd
006000  2               PlayerScoreDisplay    = $07dd
006000  2               GameTimerDisplay      = $07ec
006000  2               CoinDisplay           = $07e7
006000  2               DigitModifier         = $0134
006000  2               
006000  2               VerticalFlipFlag      = $0109
006000  2               FloateyNum_Control    = $0110
006000  2               ShellChainCounter     = $0125
006000  2               FloateyNum_Timer      = $012c
006000  2               FloateyNum_X_Pos      = $0117
006000  2               FloateyNum_Y_Pos      = $011e
006000  2               FlagpoleFNum_Y_Pos    = $010d
006000  2               FlagpoleFNum_YMFDummy = $010e
006000  2               FlagpoleScore         = $010f
006000  2               FlagpoleCollisionYPos = $070f
006000  2               StompChainCounter     = $0484
006000  2               FlagpoleMusicFlag     = $07f6
006000  2               
006000  2               VRAM_Buffer1_Offset   = $0300
006000  2               VRAM_Buffer1          = $0301
006000  2               VRAM_Buffer2_Offset   = $0340
006000  2               VRAM_Buffer2          = $0341
006000  2               VRAM_Buffer_AddrCtrl  = $0773
006000  2               
006000  2               DisableScreenFlag     = $0774
006000  2               DisableIntermediate   = $0769
006000  2               ColorRotateOffset     = $06d4
006000  2               
006000  2               TerrainControl        = $0727
006000  2               AreaStyle             = $0733
006000  2               ForegroundScenery     = $0741
006000  2               BackgroundScenery     = $0742
006000  2               CloudTypeOverride     = $0743
006000  2               BackgroundColorCtrl   = $0744
006000  2               AreaType              = $074e
006000  2               AreaAddrsLOffset      = $074f
006000  2               AreaPointer           = $0750
006000  2               
006000  2               PlayerEntranceCtrl    = $0710
006000  2               GameTimerSetting      = $0715
006000  2               AltEntranceControl    = $0752
006000  2               EntrancePage          = $0751
006000  2               WarpZoneControl       = $06d6
006000  2               ChangeAreaTimer       = $06de
006000  2               
006000  2               MultiLoopCorrectCntr  = $06d9
006000  2               MultiLoopPassCntr     = $06da
006000  2               
006000  2               FetchNewGameTimerFlag = $0757
006000  2               GameTimerExpiredFlag  = $0759
006000  2               
006000  2               .ifdef ANN
006000  2               PrimaryHardMode       = $077d
006000  2               .else
006000  2               PrimaryHardMode       = $076a
006000  2               .endif
006000  2               SecondaryHardMode     = $06cc
006000  2               WorldSelectNumber     = $076b
006000  2               CompletedWorlds       = $07fa
006000  2               HardWorldFlag         = $07fb
006000  2               ContinueMenuSelect    = $07f8
006000  2               
006000  2               SelectedPlayer        = $0753
006000  2               PlayerSize            = $0754
006000  2               PlayerStatus          = $0756
006000  2               
006000  2               OnscreenPlayerInfo    = $075a
006000  2               NumberofLives         = $075a ;used by current player
006000  2               HalfwayPage           = $075b
006000  2               LevelNumber           = $075c ;the actual dash number
006000  2               Hidden1UpFlag         = $075d
006000  2               CoinTally             = $075e
006000  2               WorldNumber           = $075f
006000  2               AreaNumber            = $0760 ;internal number used to find areas
006000  2               
006000  2               CoinTallyFor1Ups      = $0748
006000  2               
006000  2               BalPlatformAlignment  = $03a0
006000  2               Platform_X_Scroll     = $03a1
006000  2               PlatformCollisionFlag = $03a2
006000  2               YPlatformTopYPos      = $0401
006000  2               YPlatformCenterYPos   = $58
006000  2               
006000  2               BrickCoinTimerFlag    = $06bc
006000  2               StarFlagTaskControl   = $0746
006000  2               
006000  2               PseudoRandomBitReg    = $07a7
006000  2               WarmBootValidation    = $07ff
006000  2               
006000  2               SprShuffleAmtOffset   = $06e0
006000  2               SprShuffleAmt         = $06e1
006000  2               SprDataOffset         = $06e4
006000  2               Player_SprDataOffset  = $06e4
006000  2               Enemy_SprDataOffset   = $06e5
006000  2               Block_SprDataOffset   = $06ec
006000  2               Alt_SprDataOffset     = $06ec
006000  2               Bubble_SprDataOffset  = $06ee
006000  2               FBall_SprDataOffset   = $06f1
006000  2               Misc_SprDataOffset    = $06f3
006000  2               SprDataOffset_Ctrl    = $03ee
006000  2               
006000  2               Player_State          = $1d
006000  2               Enemy_State           = $1e
006000  2               Fireball_State        = $24
006000  2               Block_State           = $26
006000  2               Misc_State            = $2a
006000  2               
006000  2               Player_MovingDir      = $45
006000  2               Enemy_MovingDir       = $46
006000  2               
006000  2               SprObject_X_Speed     = $57
006000  2               Player_X_Speed        = $57
006000  2               Enemy_X_Speed         = $58
006000  2               Fireball_X_Speed      = $5e
006000  2               Block_X_Speed         = $60
006000  2               Misc_X_Speed          = $64
006000  2               
006000  2               Jumpspring_FixedYPos  = $58
006000  2               JumpspringAnimCtrl    = $070e
006000  2               JumpspringForce       = $06db
006000  2               
006000  2               SprObject_PageLoc     = $6d
006000  2               Player_PageLoc        = $6d
006000  2               Enemy_PageLoc         = $6e
006000  2               Fireball_PageLoc      = $74
006000  2               Block_PageLoc         = $76
006000  2               Misc_PageLoc          = $7a
006000  2               Bubble_PageLoc        = $83
006000  2               
006000  2               SprObject_X_Position  = $86
006000  2               Player_X_Position     = $86
006000  2               Enemy_X_Position      = $87
006000  2               Fireball_X_Position   = $8d
006000  2               Block_X_Position      = $8f
006000  2               Misc_X_Position       = $93
006000  2               Bubble_X_Position     = $9c
006000  2               
006000  2               SprObject_Y_Speed     = $9f
006000  2               Player_Y_Speed        = $9f
006000  2               Enemy_Y_Speed         = $a0
006000  2               Fireball_Y_Speed      = $a6
006000  2               Block_Y_Speed         = $a8
006000  2               Misc_Y_Speed          = $ac
006000  2               
006000  2               SprObject_Y_HighPos   = $b5
006000  2               Player_Y_HighPos      = $b5
006000  2               Enemy_Y_HighPos       = $b6
006000  2               Fireball_Y_HighPos    = $bc
006000  2               Block_Y_HighPos       = $be
006000  2               Misc_Y_HighPos        = $c2
006000  2               Bubble_Y_HighPos      = $cb
006000  2               
006000  2               SprObject_Y_Position  = $ce
006000  2               Player_Y_Position     = $ce
006000  2               Enemy_Y_Position      = $cf
006000  2               Fireball_Y_Position   = $d5
006000  2               Block_Y_Position      = $d7
006000  2               Misc_Y_Position       = $db
006000  2               Bubble_Y_Position     = $e4
006000  2               
006000  2               SprObject_Rel_XPos    = $03ad
006000  2               Player_Rel_XPos       = $03ad
006000  2               Enemy_Rel_XPos        = $03ae
006000  2               Fireball_Rel_XPos     = $03af
006000  2               Bubble_Rel_XPos       = $03b0
006000  2               Block_Rel_XPos        = $03b1
006000  2               Misc_Rel_XPos         = $03b3
006000  2               
006000  2               SprObject_Rel_YPos    = $03b8
006000  2               Player_Rel_YPos       = $03b8
006000  2               Enemy_Rel_YPos        = $03b9
006000  2               Fireball_Rel_YPos     = $03ba
006000  2               Bubble_Rel_YPos       = $03bb
006000  2               Block_Rel_YPos        = $03bc
006000  2               Misc_Rel_YPos         = $03be
006000  2               
006000  2               SprObject_SprAttrib   = $03c4
006000  2               Player_SprAttrib      = $03c4
006000  2               Enemy_SprAttrib       = $03c5
006000  2               
006000  2               SprObject_X_MoveForce = $0400
006000  2               Enemy_X_MoveForce     = $0401
006000  2               
006000  2               SprObject_YMF_Dummy   = $0416
006000  2               Player_YMF_Dummy      = $0416
006000  2               Enemy_YMF_Dummy       = $0417
006000  2               Bubble_YMF_Dummy      = $042c
006000  2               
006000  2               SprObject_Y_MoveForce = $0433
006000  2               Player_Y_MoveForce    = $0433
006000  2               Enemy_Y_MoveForce     = $0434
006000  2               Block_Y_MoveForce     = $043c
006000  2               
006000  2               DisableCollisionDet   = $0716
006000  2               Player_CollisionBits  = $0490
006000  2               Enemy_CollisionBits   = $0491
006000  2               
006000  2               SprObj_BoundBoxCtrl   = $0499
006000  2               Player_BoundBoxCtrl   = $0499
006000  2               Enemy_BoundBoxCtrl    = $049a
006000  2               Fireball_BoundBoxCtrl = $04a0
006000  2               Misc_BoundBoxCtrl     = $04a2
006000  2               
006000  2               EnemyFrenzyBuffer     = $06cb
006000  2               EnemyFrenzyQueue      = $06cd
006000  2               Enemy_Flag            = $0f
006000  2               Enemy_ID              = $16
006000  2               
006000  2               PlayerGfxOffset       = $06d5
006000  2               Player_XSpeedAbsolute = $0700
006000  2               FrictionAdderHigh     = $0701
006000  2               FrictionAdderLow      = $0702
006000  2               RunningSpeed          = $0703
006000  2               SwimmingFlag          = $0704
006000  2               Player_X_MoveForce    = $0705
006000  2               DiffToHaltJump        = $0706
006000  2               JumpOrigin_Y_HighPos  = $0707
006000  2               JumpOrigin_Y_Position = $0708
006000  2               VerticalForce         = $0709
006000  2               VerticalForceDown     = $070a
006000  2               PlayerChangeSizeFlag  = $070b
006000  2               PlayerAnimTimerSet    = $070c
006000  2               PlayerAnimCtrl        = $070d
006000  2               DeathMusicLoaded      = $0712
006000  2               FlagpoleSoundQueue    = $0713
006000  2               CrouchingFlag         = $0714
006000  2               MaximumLeftSpeed      = $0450
006000  2               MaximumRightSpeed     = $0456
006000  2               
006000  2               WindFlag              = $07f9
006000  2               
006000  2               SprObject_OffscrBits  = $03d0
006000  2               Player_OffscreenBits  = $03d0
006000  2               Enemy_OffscreenBits   = $03d1
006000  2               FBall_OffscreenBits   = $03d2
006000  2               Bubble_OffscreenBits  = $03d3
006000  2               Block_OffscreenBits   = $03d4
006000  2               Misc_OffscreenBits    = $03d6
006000  2               EnemyOffscrBitsMasked = $03d8
006000  2               
006000  2               Cannon_Offset         = $046a
006000  2               Cannon_PageLoc        = $046b
006000  2               Cannon_X_Position     = $0471
006000  2               Cannon_Y_Position     = $0477
006000  2               Cannon_Timer          = $047d
006000  2               
006000  2               Whirlpool_Offset      = $046a
006000  2               Whirlpool_PageLoc     = $046b
006000  2               Whirlpool_LeftExtent  = $0471
006000  2               Whirlpool_Length      = $0477
006000  2               Whirlpool_Flag        = $047d
006000  2               
006000  2               VineFlagOffset        = $0398
006000  2               VineHeight            = $0399
006000  2               VineObjOffset         = $039a
006000  2               VineStart_Y_Position  = $039d
006000  2               
006000  2               Block_Orig_YPos       = $03e4
006000  2               Block_BBuf_Low        = $03e6
006000  2               Block_Metatile        = $03e8
006000  2               Block_PageLoc2        = $03ea
006000  2               Block_RepFlag         = $03ec
006000  2               Block_ResidualCounter = $03f0
006000  2               Block_Orig_XPos       = $03f1
006000  2               
006000  2               BoundingBox_UL_XPos   = $04ac
006000  2               BoundingBox_UL_YPos   = $04ad
006000  2               BoundingBox_DR_XPos   = $04ae
006000  2               BoundingBox_DR_YPos   = $04af
006000  2               BoundingBox_UL_Corner = $04ac
006000  2               BoundingBox_LR_Corner = $04ae
006000  2               EnemyBoundingBoxCoord = $04b0
006000  2               
006000  2               PowerUpType           = $39
006000  2               
006000  2               FireballBouncingFlag  = $3a
006000  2               FireballCounter       = $06ce
006000  2               FireballThrowingTimer = $0711
006000  2               
006000  2               HammerEnemyOffset     = $06ae
006000  2               JumpCoinMiscOffset    = $06b7
006000  2               
006000  2               Block_Buffer_1        = $0500
006000  2               Block_Buffer_2        = $05d0
006000  2               
006000  2               HammerThrowingTimer   = $03a2
006000  2               HammerBroJumpTimer    = $3c
006000  2               Misc_Collision_Flag   = $06be
006000  2               
006000  2               RedPTroopaOrigXPos    = $0401
006000  2               RedPTroopaCenterYPos  = $58
006000  2               
006000  2               XMovePrimaryCounter   = $a0
006000  2               XMoveSecondaryCounter = $58
006000  2               
006000  2               CheepCheepMoveMFlag   = $58
006000  2               CheepCheepOrigYPos    = $0434
006000  2               BitMFilter            = $06dd
006000  2               
006000  2               LakituReappearTimer   = $06d1
006000  2               LakituMoveSpeed       = $58
006000  2               LakituMoveDirection   = $a0
006000  2               
006000  2               FirebarSpinState_Low  = $58
006000  2               FirebarSpinState_High = $a0
006000  2               FirebarSpinSpeed      = $0388
006000  2               FirebarSpinDirection  = $34
006000  2               
006000  2               DuplicateObj_Offset   = $06cf
006000  2               NumberofGroupEnemies  = $06d3
006000  2               
006000  2               BlooperMoveCounter    = $a0
006000  2               BlooperMoveSpeed      = $58
006000  2               
006000  2               BowserBodyControls    = $0363
006000  2               BowserFeetCounter     = $0364
006000  2               BowserMovementSpeed   = $0365
006000  2               BowserOrigXPos        = $0366
006000  2               BowserFlameTimerCtrl  = $0367
006000  2               BowserFront_Offset    = $0368
006000  2               BridgeCollapseOffset  = $0369
006000  2               BowserGfxFlag         = $036a
006000  2               BowserHitPoints       = $0483
006000  2               MaxRangeFromOrigin    = $06dc
006000  2               
006000  2               BowserFlamePRandomOfs = $0417
006000  2               
006000  2               PiranhaPlantUpYPos    = $0417
006000  2               PiranhaPlantDownYPos  = $0434
006000  2               PiranhaPlant_Y_Speed  = $58
006000  2               PiranhaPlant_MoveFlag = $a0
006000  2               
006000  2               FireworksCounter      = $06d7
006000  2               ExplosionGfxCounter   = $58
006000  2               ExplosionTimerCounter = $a0
006000  2               
006000  2               ;sound related defines
006000  2               Squ2_NoteLenBuffer    = $07b3
006000  2               Squ2_NoteLenCounter   = $07b4
006000  2               Squ2_EnvelopeDataCtrl = $07b5
006000  2               Squ1_NoteLenCounter   = $07b6
006000  2               Squ1_EnvelopeDataCtrl = $07b7
006000  2               Tri_NoteLenBuffer     = $07b8
006000  2               Tri_NoteLenCounter    = $07b9
006000  2               Noise_BeatLenCounter  = $07ba
006000  2               Squ1_SfxLenCounter    = $07bb
006000  2               Squ2_SfxLenCounter    = $07bd
006000  2               Sfx_SecondaryCounter  = $07be
006000  2               Noise_SfxLenCounter   = $07bf
006000  2               
006000  2               PauseSoundQueue       = $fa
006000  2               Square1SoundQueue     = $ff
006000  2               Square2SoundQueue     = $fe
006000  2               NoiseSoundQueue       = $fd
006000  2               AreaMusicQueue        = $fb
006000  2               EventMusicQueue       = $fc
006000  2               
006000  2               Square1SoundBuffer    = $f1
006000  2               Square2SoundBuffer    = $f2
006000  2               NoiseSoundBuffer      = $f3
006000  2               AreaMusicBuffer       = $f4
006000  2               EventMusicBuffer      = $07b1
006000  2               PauseSoundBuffer      = $07b2
006000  2               
006000  2               MusicData             = $f5
006000  2               MusicDataLow          = $f5
006000  2               MusicDataHigh         = $f6
006000  2               MusicOffset_Square2   = $f7
006000  2               MusicOffset_Square1   = $f8
006000  2               MusicOffset_Triangle  = $f9
006000  2               MusicOffset_Noise     = $07b0
006000  2               
006000  2               NoteLenLookupTblOfs   = $f0
006000  2               DAC_Counter           = $07c0
006000  2               NoiseDataLoopbackOfs  = $07c1
006000  2               NoteLengthTblAdder    = $07c4
006000  2               AreaMusicBuffer_Alt   = $07c5
006000  2               PauseModeFlag         = $07c6
006000  2               GroundMusicHeaderOfs  = $07c7
006000  2               AltRegContentFlag     = $07ca
006000  2               
006000  2               ANNMushroomRetainerGfxHandler = $77C
006000  2               
006000  2               ;SUBROUTINES IN FAMICOM DISK SYSTEM BIOS
006000  2               FDSBIOS_DELAY     = $e149
006000  2               FDSBIOS_LOADFILES = $e1f8
006000  2               FDSBIOS_WRITEFILE = $e239
006000  2               
006000  2               ;-------------------------------------------------------------------------------------
006000  2               ;CONSTANTS
006000  2               
006000  2               ;sound effects constants
006000  2               Sfx_SmallJump         = %10000000
006000  2               Sfx_Flagpole          = %01000000
006000  2               Sfx_Fireball          = %00100000
006000  2               Sfx_PipeDown_Injury   = %00010000
006000  2               Sfx_EnemySmack        = %00001000
006000  2               Sfx_EnemyStomp        = %00000100
006000  2               Sfx_Bump              = %00000010
006000  2               Sfx_BigJump           = %00000001
006000  2               
006000  2               Sfx_BowserFall        = %10000000
006000  2               Sfx_ExtraLife         = %01000000
006000  2               Sfx_PowerUpGrab       = %00100000
006000  2               Sfx_TimerTick         = %00010000
006000  2               Sfx_Blast             = %00001000
006000  2               Sfx_GrowVine          = %00000100
006000  2               Sfx_GrowPowerUp       = %00000010
006000  2               Sfx_CoinGrab          = %00000001
006000  2               
006000  2               Sfx_BowserFlame       = %00000010
006000  2               Sfx_BrickShatter      = %00000001
006000  2               
006000  2               ;music constants
006000  2               Silence               = %10000000
006000  2               
006000  2               StarPowerMusic        = %01000000
006000  2               PipeIntroMusic        = %00100000
006000  2               CloudMusic            = %00010000
006000  2               CastleMusic           = %00001000
006000  2               UndergroundMusic      = %00000100
006000  2               WaterMusic            = %00000010
006000  2               GroundMusic           = %00000001
006000  2               
006000  2               TimeRunningOutMusic   = %01000000
006000  2               EndOfLevelMusic       = %00100000
006000  2               AltGameOverMusic      = %00010000
006000  2               EndOfCastleMusic      = %00001000
006000  2               VictoryMusic          = %00000100
006000  2               GameOverMusic         = %00000010
006000  2               DeathMusic            = %00000001
006000  2               
006000  2               ;enemy object constants
006000  2               GreenKoopa            = $00
006000  2               BuzzyBeetle           = $02
006000  2               RedKoopa              = $03
006000  2               HammerBro             = $05
006000  2               Goomba                = $06
006000  2               Bloober               = $07
006000  2               BulletBill_FrenzyVar  = $08
006000  2               GreyCheepCheep        = $0a
006000  2               RedCheepCheep         = $0b
006000  2               Podoboo               = $0c
006000  2               PiranhaPlant          = $0d
006000  2               GreenParatroopaJump   = $0e
006000  2               RedParatroopa         = $0f
006000  2               GreenParatroopaFly    = $10
006000  2               Lakitu                = $11
006000  2               Spiny                 = $12
006000  2               FlyCheepCheepFrenzy   = $14
006000  2               FlyingCheepCheep      = $14
006000  2               BowserFlame           = $15
006000  2               Fireworks             = $16
006000  2               BBill_CCheep_Frenzy   = $17
006000  2               Stop_Frenzy           = $18
006000  2               Bowser                = $2d
006000  2               PowerUpObject         = $2e
006000  2               VineObject            = $2f
006000  2               FlagpoleFlagObject    = $30
006000  2               StarFlagObject        = $31
006000  2               JumpspringObject      = $32
006000  2               BulletBill_CannonVar  = $33
006000  2               RetainerObject        = $35
006000  2               TallEnemy             = $09
006000  2               UpsideDownPiranhaP    = $04
006000  2               
006000  2               ;other constants
006000  2               World1 = 0
006000  2               World2 = 1
006000  2               World3 = 2
006000  2               World4 = 3
006000  2               World5 = 4
006000  2               World6 = 5
006000  2               World7 = 6
006000  2               World8 = 7
006000  2               World9 = 8
006000  2               Level1 = 0
006000  2               Level2 = 1
006000  2               Level3 = 2
006000  2               Level4 = 3
006000  2               
006000  2               WarmBootOffset        = <$07d6
006000  2               ColdBootOffset        = <$07fe
006000  2               SoundMemory           = $07b0
006000  2               SwimTileRepOffset     = PlayerGraphicsTable + $9e
006000  2               MusicHeaderOffsetData = MusicHeaderData - 1
006000  2               MHD                   = MusicHeaderData
006000  2               
006000  2               A_Button              = %10000000
006000  2               B_Button              = %01000000
006000  2               Select_Button         = %00100000
006000  2               Start_Button          = %00010000
006000  2               Up_Dir                = %00001000
006000  2               Down_Dir              = %00000100
006000  2               Left_Dir              = %00000010
006000  2               Right_Dir             = %00000001
006000  2               
006000  2               AttractMode           = 0
006000  2               GameMode              = 1
006000  2               VictoryMode           = 2
006000  2               GameOverMode          = 3
006000  2               
006000  2               ; imports from other files
006000  2               ;SUBROUTINES IN SM2DATA2 AND SM2DATA4
006000  2               .import UpsideDownPipe_High
006000  2               .import UpsideDownPipe_Low
006000  2               .import WindOn
006000  2               .import WindOff
006000  2               .import SimulateWind
006000  2               .import BlowPlayerAround
006000  2               .import MoveUpsideDownPiranhaP
006000  2               .import ChangeHalfwayPages
006000  2               ;SUBROUTINES IN SM2DATA3
006000  2               .import EraseLivesLines
006000  2               .import RunMushroomRetainers
006000  2               .import EndingDiskRoutines
006000  2               .import AwardExtraLives
006000  2               .import PrintVictoryMsgsForWorld8
006000  2               .import FadeToBlue
006000  2               .import ScreenSubsForFinalRoom
006000  2               ;LABELS FROM SM2DATA3
006000  2               .ifdef ANN
006000  2               .import ANNEndingPalette
006000  2               .import HardWorldJumpSpringHandler
006000  2               .import HardWorldEnemyGfxHandler
006000  2               .endif
006000  2               .import WriteNameToVictoryMsg
006000  2               .import UnusedAttribData
006000  2               .import FinalRoomPalette
006000  2               .import ThankYouMessageFinal
006000  2               .import PeaceIsPavedMsg
006000  2               .import WithKingdomSavedMsg
006000  2               .import HurrahMsg
006000  2               .import OurOnlyHeroMsg
006000  2               .import ThisEndsYourTripMsg
006000  2               .import OfALongFriendshipMsg
006000  2               .import PointsAddedMsg
006000  2               .import ForEachPlayerLeftMsg
006000  2               .import PrincessPeachsRoom
006000  2               .import FantasyWorld9Msg
006000  2               .import SuperPlayerMsg
006000  2               ;from sm2data2
006000  2               .ifdef ANN
006000  2               .import E_Area06
006000  2               .import E_Area07
006000  2               .import E_Area04
006000  2               .import E_Area05
006000  2               .import E_Area09
006000  2               .import E_Area0B
006000  2               .import E_Area1E
006000  2               .import E_Area1F
006000  2               .import E_Area12
006000  2               .import E_Area21
006000  2               .import E_Area15
006000  2               .import E_Area16
006000  2               .import E_Area18
006000  2               .import E_Area19
006000  2               .import E_Area1A
006000  2               .import E_Area1B
006000  2               .import E_Area22
006000  2               .import E_Area27
006000  2               .import E_Area28
006000  2               .import E_Area2B
006000  2               .import E_Area2A
006000  2               .import L_Area06
006000  2               .import L_Area07
006000  2               .import L_Area04
006000  2               .import L_Area05
006000  2               .import L_Area09
006000  2               .import L_Area0B
006000  2               .import L_Area1E
006000  2               .import L_Area1F
006000  2               .import L_Area12
006000  2               .import L_Area21
006000  2               .import L_Area15
006000  2               .import L_Area16
006000  2               .import L_Area18
006000  2               .import L_Area19
006000  2               .import L_Area1A
006000  2               .import L_Area1B
006000  2               .import L_Area22
006000  2               .import L_Area27
006000  2               .import L_Area28
006000  2               .import L_Area2B
006000  2               .import L_Area2A
006000  2               .import MRetainerCHRWorld5
006000  2               .import MRetainerCHRWorld6
006000  2               .import MRetainerCHRWorld7
006000  2               .else
006000  2               .import E_CastleArea5
006000  2               .import E_CastleArea6
006000  2               .import E_CastleArea7
006000  2               .import E_CastleArea8
006000  2               .import E_GroundArea12
006000  2               .import E_GroundArea13
006000  2               .import E_GroundArea14
006000  2               .import E_GroundArea15
006000  2               .import E_GroundArea16
006000  2               .import E_GroundArea17
006000  2               .import E_GroundArea18
006000  2               .import E_GroundArea19
006000  2               .import E_GroundArea22
006000  2               .import E_GroundArea23
006000  2               .import E_GroundArea24
006000  2               .import E_GroundArea29
006000  2               .import E_UndergroundArea4
006000  2               .import E_UndergroundArea5
006000  2               .import E_WaterArea2
006000  2               .import E_WaterArea4
006000  2               .import E_WaterArea5
006000  2               .import L_CastleArea5
006000  2               .import L_CastleArea6
006000  2               .import L_CastleArea7
006000  2               .import L_CastleArea8
006000  2               .import L_GroundArea12
006000  2               .import L_GroundArea13
006000  2               .import L_GroundArea14
006000  2               .import L_GroundArea15
006000  2               .import L_GroundArea16
006000  2               .import L_GroundArea17
006000  2               .import L_GroundArea18
006000  2               .import L_GroundArea19
006000  2               .import L_GroundArea22
006000  2               .import L_GroundArea23
006000  2               .import L_GroundArea24
006000  2               .import L_GroundArea29
006000  2               .import L_UndergroundArea4
006000  2               .import L_UndergroundArea5
006000  2               .import L_WaterArea2
006000  2               .import L_WaterArea4
006000  2               .import L_WaterArea5
006000  2               ;from sm2data3
006000  2               .import E_CastleArea9
006000  2               .import E_CastleArea10
006000  2               .import E_GroundArea25
006000  2               .import E_GroundArea26
006000  2               .import E_GroundArea27
006000  2               .import E_WaterArea6
006000  2               .import E_WaterArea7
006000  2               .import E_WaterArea8
006000  2               .import L_CastleArea9
006000  2               .import L_CastleArea10
006000  2               .import L_GroundArea25
006000  2               .import L_GroundArea26
006000  2               .import L_GroundArea27
006000  2               .import L_WaterArea6
006000  2               .import L_WaterArea7
006000  2               .import L_WaterArea8
006000  2               .endif
006000  2               
006000  2               ; exports to other files
006000  2               .export SoundEngineJSRCode
006000  2               .export MoveSpritesOffscreen
006000  2               .export FreqRegLookupTbl
006000  2               .export NextWorld
006000  2               .export WriteTopStatusLine
006000  2               .export WriteBottomStatusLine
006000  2               .export GetAreaPalette
006000  2               .export GetBackgroundColor
006000  2               .export EndAreaPoints
006000  2               .export JumpEngine
006000  2               .export Square2SfxHandler
006000  2               .export PrintStatusBarNumbers
006000  2               .export DiskIDString
006000  2               .export EnemyGfxHandler
006000  2               .export SoundEngine
006000  2               .export DiskScreen
006000  2               .export WaitForEject
006000  2               .export WaitForReinsert
006000  2               .export ResetDiskVars
006000  2               .export DiskErrorHandler
006000  2               .export AttractModeSubs
006000  2               .export InitScreenPalette
006000  2               ; sm2data4
006000  2               .export HalfwayPageNybbles
006000  2               .export GetPipeHeight
006000  2               .export FindEmptyEnemySlot
006000  2               .export SetupPiranhaPlant
006000  2               .export VerticalPipeData
006000  2               .export RenderUnderPart
006000  2               .export MetatileBuffer
006000  2               .export GetAreaType
006000  2               .ifndef ANN
006000  2               .export E_GroundArea21
006000  2               .export E_GroundArea28
006000  2               .export L_GroundArea10
006000  2               .export L_GroundArea28
006000  2               .else
006000  2               .export E_HArea10
006000  2               .export E_HArea11
006000  2               .export L_HArea10
006000  2               .export L_HArea11
006000  2               .endif
006000  2               
006000  2               ;-------------------------------------------------------------------------------------
006000  2               
006000  2               Start:
006000  2               .ifdef ANN
006000  2  EA                       nop
006001  2  EA                       nop
006002  2  EA                       nop
006003  2  AD 5F 07                 lda WorldNumber             ;get world number and save it temporarily
006006  2  48                       pha
006007  2  A9 27                    lda #$27
006009  2  85 FA                    sta PauseSoundQueue
00600B  2  8D 25 40                 sta FDS_CTRL_REG
00600E  2               .else
00600E  2                           lda Mirror_FDS_CTRL_REG     ;get setting previously used by FDS bios
00600E  2                           and #$f7                    ;and set for vertical mirroring
00600E  2                           sta FDS_CTRL_REG
00600E  2                           lda WorldNumber             ;get world number and save it temporarily
00600E  2                           pha
00600E  2               .endif
00600E  2  A0 FE                    ldy #ColdBootOffset         ;load default cold boot pointer
006010  2  A2 05                    ldx #$05
006012  2  BD D7 07     WBootCheck: lda TopScoreDisplay,x       ;first checkpoint, check each score digit
006015  2  C9 0A                    cmp #10                     ;in the top score for a valid digit
006017  2  B0 0C                    bcs ColdBoot                ;if even one digit isn't valid (greater than 10 decimal)
006019  2  CA                       dex                         ;then branch to perform cold boot
00601A  2  10 F6                    bpl WBootCheck
00601C  2  AD FF 07                 lda WarmBootValidation      ;second checkpoint, check to see if
00601F  2  C9 A5                    cmp #$a5                    ;another location has a specific value
006021  2  D0 02                    bne ColdBoot
006023  2  A0 D6                    ldy #WarmBootOffset         ;if passed both, load warm boot pointer
006025  2  20 93 6F     ColdBoot:   jsr InitializeMemory        ;clear memory using pointer in Y
006028  2  8D 11 40                 sta SND_DELTA_REG+1
00602B  2  8D 70 07                 sta OperMode                ;now manually reset some other stuff
00602E  2  8D FC 07                 sta DiskIOTask
006031  2  68                       pla
006032  2  8D 5F 07                 sta WorldNumber
006035  2  A9 A5                    lda #$a5                    ;set warm boot flag in case the player hits reset
006037  2  8D FF 07                 sta WarmBootValidation
00603A  2  8D A7 07                 sta PseudoRandomBitReg      ;set seed for pseudorandom register
00603D  2  A9 0F                    lda #%00001111
00603F  2  8D 15 40                 sta SND_MASTERCTRL_REG      ;enable all sound channels except dmc
006042  2  A9 06                    lda #%00000110
006044  2  8D 01 20                 sta PPU_MASK                ;turn off clipping for OAM and background
006047  2  20 8A 62                 jsr MoveAllSpritesOffscreen
00604A  2  20 24 6D                 jsr InitializeNameTables
00604D  2  EE 74 07                 inc DisableScreenFlag
006050  2  A9 C0                    lda #$c0                    ;set FDS BIOS flag to use NMI vector at $dffa
006052  2  8D 01 01                 sta FDSBIOS_IRQFlag         ;enable all interrupts
006055  2  58                       cli
006056  2  AD 78 07                 lda Mirror_PPU_CTRL
006059  2  09 80                    ora #%10000000
00605B  2  20 F8 6D                 jsr WritePPUReg1
00605E  2               EndlessLoop:
00605E  2  A5 00                    lda $00                     ;endless loop
006060  2  4C 5E 60                 jmp EndlessLoop
006063  2               
006063  2               ;-------------------------------------------------------------------------------------
006063  2               
006063  2               VRAM_AddrTable:
006063  2  01 03           .word VRAM_Buffer1               ; 00
006065  2  1F 6C           .word WaterPaletteData           ; 01
006067  2  43 6C           .word GroundPaletteData          ; 02
006069  2  67 6C           .word UndergroundPaletteData     ; 03
00606B  2  8B 6C           .word CastlePaletteData          ; 04
00606D  2  E6 C5           .word TitleScreenGfxData         ; 05
00606F  2  41 03           .word VRAM_Buffer2               ; 06
006071  2  41 03           .word VRAM_Buffer2               ; 07
006073  2  C7 6C           .word BowserPaletteData          ; 08
006075  2  AF 6C           .word DaySnowPaletteData         ; 09
006077  2  B7 6C           .word NightSnowPaletteData       ; 00
006079  2  BF 6C           .word MushroomPaletteData        ; 11
00607B  2  CF 6C           .word ThankYouMessage            ; 12
00607D  2  E3 6C           .word MushroomRetainerMsg        ; 13
00607F  2  rr rr           .word UnusedAttribData           ; 14
006081  2  rr rr           .word FinalRoomPalette           ; 15
006083  2  rr rr           .word ThankYouMessageFinal       ; 16
006085  2  rr rr           .word PeaceIsPavedMsg            ; 17
006087  2  rr rr           .word WithKingdomSavedMsg        ; 18
006089  2  rr rr           .word HurrahMsg                  ; 19
00608B  2  rr rr           .word OurOnlyHeroMsg             ; 10
00608D  2  rr rr           .word ThisEndsYourTripMsg        ; 21
00608F  2  rr rr           .word OfALongFriendshipMsg       ; 22
006091  2  rr rr           .word PointsAddedMsg             ; 23
006093  2  rr rr           .word ForEachPlayerLeftMsg       ; 24
006095  2  5F C1           .word DiskErrorMainMsg           ; 25
006097  2  21 C1           .word DiskScreenPalette          ; 26
006099  2  rr rr           .word PrincessPeachsRoom         ; 27
00609B  2  CB C4           .word MenuCursorTemplate         ; 28
00609D  2               .ifdef ANN
00609D  2  6B 63           .word ANNMushroomRetainerPalette ; 29
00609F  2  rr rr           .word ANNEndingPalette           ; 30
0060A1  2               .else
0060A1  2                  .word FantasyWorld9Msg           ; 29
0060A1  2                  .word SuperPlayerMsg             ; 30
0060A1  2               .endif
0060A1  2               
0060A1  2               VRAM_Buffer_Offset:
0060A1  2  00 40           .byte <VRAM_Buffer1_Offset, <VRAM_Buffer2_Offset
0060A3  2               
0060A3  2               ;-------------------------------------------------------------------------------------
0060A3  2               
0060A3  2               NMIHandler:
0060A3  2  AD 78 07        lda Mirror_PPU_CTRL       ;alter name table address to be $2800
0060A6  2  29 7E           and #%01111110            ;(essentially $2000) and disable another NMI
0060A8  2  8D 78 07        sta Mirror_PPU_CTRL       ;from interrupting this one
0060AB  2  8D 00 20        sta PPU_CTRL
0060AE  2  78              sei
0060AF  2  AD 22 07        lda IRQUpdateFlag
0060B2  2  F0 12           beq SkipIRQ
0060B4  2  A9 58           lda #$58
0060B6  2  8D 20 40        sta FDS_IRQTIMER_LOW      ;set FDS IRQ timer to occur at the end of the status bar
0060B9  2  A9 16           lda #$16
0060BB  2  8D 21 40        sta FDS_IRQTIMER_HIGH
0060BE  2  A9 02           lda #$02
0060C0  2  8D 22 40        sta FDS_IRQTIMER_CTRL     ;enable it
0060C3  2  EE 7B 07        inc IRQAckFlag            ;reset flag to wait for next IRQ
0060C6  2               SkipIRQ:
0060C6  2  AD 79 07        lda Mirror_PPU_MASK
0060C9  2  29 E6           and #%11100110            ;disable OAM and background display by default
0060CB  2  AC 74 07        ldy DisableScreenFlag     ;if screen disabled, skip this
0060CE  2  D0 05           bne ScrnSwch
0060D0  2  AD 79 07        lda Mirror_PPU_MASK       ;otherwise reenable bits and save them
0060D3  2  09 1E           ora #%00011110
0060D5  2               ScrnSwch:
0060D5  2  8D 79 07        sta Mirror_PPU_MASK
0060D8  2  29 E7           and #%11100111            ;turn screen off regardless of mirror reg
0060DA  2  8D 01 20        sta PPU_MASK
0060DD  2  AE 02 20        ldx PPU_STATUS
0060E0  2  A9 00           lda #$00
0060E2  2  20 F1 6D        jsr InitScroll
0060E5  2  8D 03 20        sta PPU_SPR_ADDR
0060E8  2  A9 02           lda #$02                  ;dump OAM data to PPU's sprite RAM
0060EA  2  8D 14 40        sta SPR_DMA
0060ED  2  AD 73 07        lda VRAM_Buffer_AddrCtrl
0060F0  2  0A              asl
0060F1  2  AA              tax
0060F2  2  BD 63 60        lda VRAM_AddrTable,x      ;get pointer to VRAM data
0060F5  2  85 00           sta $00
0060F7  2  E8              inx
0060F8  2  BD 63 60        lda VRAM_AddrTable,x
0060FB  2  85 01           sta $01
0060FD  2  20 E8 6D        jsr UpdateScreen          ;now update the screen with it
006100  2  A0 00           ldy #$00
006102  2  AE 73 07        ldx VRAM_Buffer_AddrCtrl
006105  2  E0 06           cpx #$06                  ;if pointer number was set to 6 (for
006107  2  D0 01           bne InitVRAMVars          ;second VRAM buffer), increment Y to get
006109  2  C8              iny                       ;offset for second VRAM buffer
00610A  2               InitVRAMVars:
00610A  2  BE A1 60        ldx VRAM_Buffer_Offset,y  ;get pointer to correct buffer offset
00610D  2  A9 00           lda #$00                  ;erase the VRAM buffer offset, init first VRAM buffer
00610F  2  9D 00 03        sta VRAM_Buffer1_Offset,x ;by writing end terminator at the first byte, and
006112  2  9D 01 03        sta VRAM_Buffer1,x        ;init address control to point at first VRAM buffer
006115  2  8D 73 07        sta VRAM_Buffer_AddrCtrl
006118  2  AD 79 07        lda Mirror_PPU_MASK
00611B  2  8D 01 20        sta PPU_MASK              ;dump PPU control register 2
00611E  2  58              cli
00611F  2               SoundEngineJSRCode:
00611F  2  20 E5 D2        jsr SoundEngine           ;run subs that need to be run on every frame
006122  2  20 67 6D        jsr ReadJoypads
006125  2  20 EC 61        jsr PauseRoutine
006128  2  20 9A 6E        jsr UpdateTopScore
00612B  2  AD 76 07        lda GamePauseStatus       ;check d0 of game pause flags
00612E  2  4A              lsr                       ;if set, branch to skip
00612F  2  B0 25           bcs SeedLFSR
006131  2  AD 47 07        lda TimerControl          ;if master timer control not set, branch
006134  2  F0 05           beq CheckIntervalTC       ;to decrement frame and interval timers
006136  2  CE 47 07        dec TimerControl          ;otherwise count this timer down
006139  2  D0 19           bne IncFrameCntr
00613B  2               CheckIntervalTC:
00613B  2  A2 14           ldx #$14                  ;set offset to decrement only frame timers
00613D  2  CE 7F 07        dec IntervalTimerControl  ;if interval timer control not expired, branch
006140  2  10 07           bpl DecrTheTimers         ;to skip and thus decrement only frame timers
006142  2  A9 14           lda #$14
006144  2  8D 7F 07        sta IntervalTimerControl  ;otherwise reset interval timer control to 20 frames
006147  2  A2 23           ldx #$23                  ;and load offset to decrement frame and interval timers
006149  2               DecrTheTimers:
006149  2  BD 80 07        lda Timers,x              ;if current timer is already expired, skip it
00614C  2  F0 03           beq DTTLoop               ;otherwise decrement it
00614E  2  DE 80 07        dec Timers,x
006151  2               DTTLoop:
006151  2  CA              dex                       ;loop until all timers that need to be counted down are
006152  2  10 F5           bpl DecrTheTimers
006154  2               IncFrameCntr:
006154  2  E6 09           inc FrameCounter
006156  2               SeedLFSR:
006156  2  A2 00           ldx #$00
006158  2  A0 07           ldy #$07
00615A  2  AD A7 07        lda PseudoRandomBitReg    ;get d1 of first byte
00615D  2  29 02           and #$02
00615F  2  85 00           sta $00
006161  2  AD A8 07        lda PseudoRandomBitReg+1  ;get d1 of second byte, XOR it with the first byte
006164  2  29 02           and #$02
006166  2  45 00           eor $00
006168  2  18              clc
006169  2  F0 01           beq RotateLFSR            ;prepare to rotate the result in
00616B  2  38              sec
00616C  2               RotateLFSR:
00616C  2  7E A7 07        ror PseudoRandomBitReg,x  ;basically, rotate the operation result into d7
00616F  2  E8              inx                       ;then rotate the entire LFSR
006170  2  88              dey
006171  2  D0 F9           bne RotateLFSR
006173  2  AD 76 07        lda GamePauseStatus       ;if d0 of game pause flag is set, skip this part
006176  2  4A              lsr
006177  2  B0 18           bcs WaitForIRQ
006179  2  AD 22 07        lda IRQUpdateFlag
00617C  2  F0 06           beq CheckInvalidWorldNum
00617E  2  20 8D 62        jsr MoveSpritesOffscreen
006181  2  20 30 62        jsr SpriteShuffler
006184  2               CheckInvalidWorldNum:
006184  2  AD 5F 07        lda WorldNumber           ;if world number somehow goes past 9, just end the game
006187  2               .ifdef ANN
006187  2  C9 08           cmp #$08
006189  2               .else
006189  2                  cmp #$09
006189  2               .endif
006189  2  90 03           bcc ExecutionTree
00618B  2  20 09 71        jsr TerminateGame
00618E  2               ExecutionTree:
00618E  2  20 7C 62        jsr OperModeExecutionTree ;run one of the program's four modes
006191  2               WaitForIRQ:
006191  2  AD 7B 07        lda IRQAckFlag            ;wait for IRQ
006194  2  D0 FB           bne WaitForIRQ
006196  2  AD 02 20        lda PPU_STATUS
006199  2  AD 78 07        lda Mirror_PPU_CTRL       ;reenable NMIs
00619C  2  09 80           ora #$80
00619E  2  8D 78 07        sta Mirror_PPU_CTRL       ;then park it at endless loop until next NMI
0061A1  2  8D 00 20        sta PPU_CTRL
0061A4  2  40              rti
0061A5  2               
0061A5  2               IRQHandler:
0061A5  2  78                       sei
0061A6  2  08                       php                      ;save regs
0061A7  2  48                       pha
0061A8  2  8A                       txa
0061A9  2  48                       pha
0061AA  2  98                       tya
0061AB  2  48                       pha
0061AC  2  AD 30 40                 lda FDS_STATUS           ;get disk status register, acknowledge IRQs
0061AF  2  48                       pha
0061B0  2  29 02                    and #$02                 ;if byte transfer flag set, branch elsewhere
0061B2  2  D0 2C                    bne DelayNoScr
0061B4  2  68                       pla
0061B5  2  29 01                    and #$01                 ;if IRQ timer flag not set, branch to leave
0061B7  2  F0 2B                    beq ExitIRQ
0061B9  2  AD 78 07                 lda Mirror_PPU_CTRL
0061BC  2  29 F7                    and #$f7                 ;mask out sprite address high reg of ctrl reg mirror
0061BE  2  0D 7A 07                 ora NameTableSelect      ;mask in whatever's set here
0061C1  2  8D 78 07                 sta Mirror_PPU_CTRL      ;update the register and its mirror
0061C4  2  8D 00 20                 sta PPU_CTRL
0061C7  2  A9 00                    lda #$00
0061C9  2  8D 22 40                 sta FDS_IRQTIMER_CTRL    ;disable IRQ timer for the rest of the frame
0061CC  2  AD 3F 07                 lda HorizontalScroll
0061CF  2  8D 05 20                 sta PPU_SCROLL           ;set scroll regs for the screen under the status bar
0061D2  2  AD 40 07                 lda VerticalScroll       ;to achieve the split screen effect
0061D5  2  8D 05 20                 sta PPU_SCROLL
0061D8  2  A9 00                    lda #$00
0061DA  2  8D 7B 07                 sta IRQAckFlag           ;indicate IRQ was acknowledged
0061DD  2  4C E4 61                 jmp ExitIRQ              ;skip over the next part to end IRQ
0061E0  2  68           DelayNoScr: pla                      ;throw away disk status reg byte
0061E1  2  20 49 E1                 jsr FDSBIOS_DELAY        ;run delay subroutine in FDS bios
0061E4  2  68           ExitIRQ:    pla
0061E5  2  A8                       tay                      ;return regs, reenable IRQs and leave
0061E6  2  68                       pla
0061E7  2  AA                       tax
0061E8  2  68                       pla
0061E9  2  28                       plp
0061EA  2  58                       cli
0061EB  2  40                       rti
0061EC  2               
0061EC  2               ;-------------------------------------------------------------------------------------
0061EC  2               
0061EC  2               PauseRoutine:
0061EC  2  AD 70 07                    lda OperMode           ;are we in victory mode?
0061EF  2  C9 02                       cmp #VictoryMode       ;if so, go ahead
0061F1  2  F0 0B                       beq ChkPauseTimer
0061F3  2  C9 01                       cmp #GameMode          ;are we in game mode?
0061F5  2  D0 38                       bne ExitPause          ;if not, leave
0061F7  2  AD 72 07                    lda OperMode_Task      ;if we are in game mode, are we running game engine?
0061FA  2               .ifdef ANN
0061FA  2  C9 05                       cmp #$05
0061FC  2               .else
0061FC  2                              cmp #$04
0061FC  2               .endif
0061FC  2  D0 31                       bne ExitPause          ;if not, leave
0061FE  2  AD 77 07     ChkPauseTimer: lda GamePauseTimer     ;check if pause timer is still counting down
006201  2  F0 04                       beq ChkStart
006203  2  CE 77 07                    dec GamePauseTimer     ;if so, decrement and leave
006206  2  60                          rts
006207  2  AD FC 06     ChkStart:      lda SavedJoypad1Bits   ;check to see if start is pressed
00620A  2  29 10                       and #Start_Button
00620C  2  F0 19                       beq ClrPauseTimer
00620E  2  AD 76 07                    lda GamePauseStatus    ;check to see if timer flag is set
006211  2  29 80                       and #%10000000         ;and if so, do not reset timer (residual,
006213  2  D0 1A                       bne ExitPause          ;joypad reading routine makes this unnecessary)
006215  2  A9 2B                       lda #$2b               ;set pause timer
006217  2  8D 77 07                    sta GamePauseTimer
00621A  2  AD 76 07                    lda GamePauseStatus
00621D  2  A8                          tay
00621E  2  C8                          iny                    ;set pause sfx queue for next pause mode
00621F  2  84 FA                       sty PauseSoundQueue
006221  2  49 01                       eor #%00000001         ;invert d0 and set d7
006223  2  09 80                       ora #%10000000
006225  2  D0 05                       bne SetPause           ;unconditional branch
006227  2  AD 76 07     ClrPauseTimer: lda GamePauseStatus    ;clear timer flag if timer is at zero and start button
00622A  2  29 7F                       and #%01111111         ;is not pressed
00622C  2  8D 76 07     SetPause:      sta GamePauseStatus
00622F  2  60           ExitPause:     rts
006230  2               
006230  2               
006230  2               ;-------------------------------------------------------------------------------------
006230  2               ;$00 - used for preset value
006230  2               
006230  2               SpriteShuffler:
006230  2  AC 4E 07                    ldy AreaType                ;residual code, this value is never used
006233  2  A9 28                       lda #$28                    ;load preset value which will put it at
006235  2  85 00                       sta $00                     ;sprite #10
006237  2  A2 0E                       ldx #$0e                    ;start at the end of OAM data offsets
006239  2  BD E4 06     ShuffleLoop:   lda SprDataOffset,x         ;check for offset value against
00623C  2  C5 00                       cmp $00                     ;the preset value
00623E  2  90 0F                       bcc NextSprOffset           ;if less, skip this part
006240  2  AC E0 06                    ldy SprShuffleAmtOffset     ;get current offset to preset value we want to add
006243  2  18                          clc
006244  2  79 E1 06                    adc SprShuffleAmt,y         ;get shuffle amount, add to current sprite offset
006247  2  90 03                       bcc StrSprOffset            ;if not exceeded $ff, skip second add
006249  2  18                          clc
00624A  2  65 00                       adc $00                     ;otherwise add preset value $28 to offset
00624C  2  9D E4 06     StrSprOffset:  sta SprDataOffset,x         ;store new offset here or old one if branched to here
00624F  2  CA           NextSprOffset: dex                         ;move backwards to next one
006250  2  10 E7                       bpl ShuffleLoop
006252  2  AE E0 06                    ldx SprShuffleAmtOffset     ;load offset
006255  2  E8                          inx
006256  2  E0 03                       cpx #$03                    ;check if offset + 1 goes to 3
006258  2  D0 02                       bne SetAmtOffset            ;if offset + 1 not 3, store
00625A  2  A2 00                       ldx #$00                    ;otherwise, init to 0
00625C  2  8E E0 06     SetAmtOffset:  stx SprShuffleAmtOffset
00625F  2  A2 08                       ldx #$08                    ;load offsets for values and storage
006261  2  A0 02                       ldy #$02
006263  2  B9 E9 06     SetMiscOffset: lda SprDataOffset+5,y       ;load one of three OAM data offsets
006266  2  9D F1 06                    sta Misc_SprDataOffset-2,x  ;store first one unmodified, but
006269  2  18                          clc                         ;add eight to the second and eight
00626A  2  69 08                       adc #$08                    ;more to the third one
00626C  2  9D F2 06                    sta Misc_SprDataOffset-1,x  ;note that due to the way X is set up,
00626F  2  18                          clc                         ;this code loads into the misc sprite offsets
006270  2  69 08                       adc #$08
006272  2  9D F3 06                    sta Misc_SprDataOffset,x
006275  2  CA                          dex
006276  2  CA                          dex
006277  2  CA                          dex
006278  2  88                          dey
006279  2  10 E8                       bpl SetMiscOffset           ;do this until all misc spr offsets are loaded
00627B  2  60                          rts
00627C  2               
00627C  2               ;-------------------------------------------------------------------------------------
00627C  2               
00627C  2               OperModeExecutionTree:
00627C  2  AD 70 07           lda OperMode     ;this is the heart of the entire program,
00627F  2  20 0F 6D           jsr JumpEngine   ;most of what goes on starts here
006282  2               
006282  2  BF BF              .word AttractModeSubs
006284  2  A7 7A              .word GameModeSubs
006286  2  9B 62              .word VictoryModeMain
006288  2  E0 70              .word GameOverSubs
00628A  2               
00628A  2               ;-------------------------------------------------------------------------------------
00628A  2               
00628A  2               MoveAllSpritesOffscreen:
00628A  2  A0 00                      ldy #$00                ;this routine moves all sprites off the screen
00628C  2  2C                         .byte $2c                 ;BIT instruction opcode
00628D  2               
00628D  2               MoveSpritesOffscreen:
00628D  2  A0 04                      ldy #$04                ;this routine moves all but sprite 0
00628F  2  A9 F8                      lda #$f8                ;off the screen
006291  2  99 00 02     SprInitLoop:  sta Sprite_Y_Position,y ;write 248 into OAM data's Y coordinate
006294  2  C8                         iny                     ;which will move it off the screen
006295  2  C8                         iny
006296  2  C8                         iny
006297  2  C8                         iny
006298  2  D0 F7                      bne SprInitLoop
00629A  2  60           VMExit:       rts
00629B  2               
00629B  2               ;-------------------------------------------------------------------------------------
00629B  2               
00629B  2               VictoryModeMain:
00629B  2  20 BF 62               jsr VictoryModeSubroutines ;run victory mode subroutines in order
00629E  2  AD 72 07               lda OperMode_Task          ;if running bridge collapse subroutine
0062A1  2  F0 16                  beq BrdgSkip               ;then skip most of this
0062A3  2  AE 5F 07               ldx WorldNumber
0062A6  2  E0 07                  cpx #World8                ;if not on world 8, skip, don't bother checking
0062A8  2  D0 08                  bne NotW8                  ;to see which subroutine we're on
0062AA  2  C9 05                  cmp #$05
0062AC  2  F0 EC                  beq VMExit                 ;if running disk subroutines, branch to leave
0062AE  2  C9 0D                  cmp #$0d                   ;because the screen will be blank during this
0062B0  2  F0 E8                  beq VMExit
0062B2  2  A2 00        NotW8:    ldx #$00
0062B4  2  86 08                  stx ObjectOffset           ;run code for a single enemy object
0062B6  2  20 56 8C               jsr EnemiesAndLoopsCore    ;(either the mushroom retainer or door/princess)
0062B9  2  20 1F BE     BrdgSkip: jsr RelativePlayerPosition ;draw the player as usual
0062BC  2  4C D4 BB               jmp PlayerGfxHandler
0062BF  2               
0062BF  2               VictoryModeSubroutines:
0062BF  2  AD 5F 07         lda WorldNumber               ;run different list of subroutines if on world 8
0062C2  2  C9 07            cmp #World8
0062C4  2  F0 12            beq VictoryModeSubsForW8      ;note that world D will also run second set of subs
0062C6  2               VictoryModeSubroutines2:
0062C6  2  AD 72 07         lda OperMode_Task             ;after running the first two subs in the first set
0062C9  2  20 0F 6D         jsr JumpEngine
0062CC  2               
0062CC  2  25 9C            .word BridgeCollapse
0062CE  2  73 63            .word SetupVictoryMode
0062D0  2  C7 63            .word PlayerVictoryWalk
0062D2  2  00 64            .word PrintVictoryMessages
0062D4  2  42 64            .word EndCastleAward
0062D6  2  65 64            .word EndWorld1Thru7
0062D8  2               
0062D8  2               VictoryModeSubsForW8:
0062D8  2  AD 72 07         lda OperMode_Task
0062DB  2  20 0F 6D         jsr JumpEngine
0062DE  2               
0062DE  2  25 9C            .word BridgeCollapse
0062E0  2  73 63            .word SetupVictoryMode
0062E2  2  C7 63            .word PlayerVictoryWalk
0062E4  2  92 C0            .word StartVMDelay
0062E6  2  99 C0            .word ContinueVMDelay
0062E8  2  9F C0            .word VictoryModeDiskRoutines
0062EA  2  rr rr            .word ScreenSubsForFinalRoom    ;all these subs are in SM2DATA3
0062EC  2  rr rr            .word PrintVictoryMsgsForWorld8
0062EE  2  42 64            .word EndCastleAward            ;except this one
0062F0  2  rr rr            .word AwardExtraLives
0062F2  2  rr rr            .word FadeToBlue
0062F4  2  rr rr            .word EraseLivesLines
0062F6  2  rr rr            .word RunMushroomRetainers
0062F8  2  rr rr            .word EndingDiskRoutines
0062FA  2               
0062FA  2               ;-------------------------------------------------------------------------------------
0062FA  2               
0062FA  2               .ifdef ANN
0062FA  2               MRetainerData:
0062FA  2  3E D1        .addr MRetainerCHRWorld1
0062FC  2  9E D1        .addr MRetainerCHRWorld2
0062FE  2  FE D1        .addr MRetainerCHRWorld3
006300  2  5E D2        .addr MRetainerCHRWorld4
006302  2  rr rr        .addr MRetainerCHRWorld5
006304  2  rr rr        .addr MRetainerCHRWorld6
006306  2  rr rr        .addr MRetainerCHRWorld7
006308  2               
006308  2               ; overwrites CHR CD0-CFF, 7A0-7BF and EE0-EEF
006308  2               MRetainerPPUOffsetHi:
006308  2  0C 07 0E           .byte $0C,$07,$0E
00630B  2               MRetainerPPUOffsetLo:
00630B  2  D0 A0 E0           .byte $D0,$A0,$E0
00630E  2               MRetainerPPULen:
00630E  2  30 50 60           .byte $30,$50,$60
006311  2               
006311  2               ; Each world has it's own mushroom retainer in All Night Nippon.
006311  2               ; These are loaded in at the start of the level.
006311  2               LoadWorldMushroomRetainer:
006311  2                     @TempPtr = $00
006311  2                     @TempOffset = $06
006311  2  AD 5C 07           lda LevelNumber                ; get current level number
006314  2  C9 03              cmp #$03                       ; check if we're in a castle
006316  2  D0 39              bne @End                       ; if not - exit out
006318  2  AC FB 07           ldy HardWorldFlag              ; check if we're playing hard worlds
00631B  2  D0 34              bne @End                       ; if so - exit out
00631D  2  84 06              sty @TempOffset                ; clear offset value
00631F  2  AD 5F 07           lda WorldNumber                ; get current world
006322  2  0A                 asl a                          ; multiply by 2 to get offset
006323  2  AA                 tax                            ; and store it in X
006324  2  BD FA 62           lda MRetainerData,x            ; place pointer for world in $00
006327  2  85 00              sta @TempPtr                   ;
006329  2  E8                 inx                            ;
00632A  2  BD FA 62           lda MRetainerData,x            ;
00632D  2  85 01              sta @TempPtr+1                 ;
00632F  2               @CopyNext:
00632F  2  A6 06              ldx @TempOffset                ; load current offset
006331  2  BD 08 63           lda MRetainerPPUOffsetHi,x     ; set PPU address from table
006334  2  8D 06 20           sta PPU_ADDRESS                ;
006337  2  BD 0B 63           lda MRetainerPPUOffsetLo,x     ;
00633A  2  8D 06 20           sta PPU_ADDRESS                ;
00633D  2  B1 00        :     lda (@TempPtr),y               ; get next byte to copy to CHR
00633F  2  8D 07 20           sta PPU_DATA                   ; and write it to PPU
006342  2  C8                 iny                            ; increment loop
006343  2  98                 tya                            ;
006344  2  DD 0E 63           cmp MRetainerPPULen,x          ; check if we've reached the end of the data
006347  2  D0 F4              bne :-                         ; otherwise loop
006349  2  E6 06              inc @TempOffset                ; advance to next CHR region
00634B  2  A5 06              lda @TempOffset                ; check if we're reached the end
00634D  2  C9 03              cmp #$03                       ;
00634F  2  D0 DE              bne @CopyNext                  ; no - keep looping
006351  2               @End:
006351  2  4C B9 63           jmp IncModeTask                ; yes - move on to next task
006354  2               .endif
006354  2               
006354  2               .ifndef ANN
006354  2               WorldBits:
006354  2                   .byte $01, $02, $04, $08, $10, $20, $40, $80
006354  2               
006354  2               SetupVictoryMode:
006354  2               .else
006354  2               MushroomRetainerPalettes:
006354  2  63 63        .addr MushroomRetainerPal0
006356  2  65 63        .addr MushroomRetainerPal1
006358  2  67 63        .addr MushroomRetainerPal2
00635A  2  69 63        .addr MushroomRetainerPal3
00635C  2               
00635C  2               WMushroomRetainerOffsets:
00635C  2  04 02 00 04  .byte $04,$02,$00,$04,$02,$00,$08
006360  2  02 00 08     
006363  2               
006363  2               MushroomRetainerPal0:
006363  2  30 12        .byte $30,$12
006365  2               MushroomRetainerPal1:
006365  2  30 1A        .byte $30,$1A
006367  2               MushroomRetainerPal2:
006367  2  30 16        .byte $30,$16
006369  2               MushroomRetainerPal3:
006369  2  17 2A        .byte $17,$2A
00636B  2               
00636B  2               ANNMushroomRetainerPalette:
00636B  2  3F 18 04 0F  .byte $3F,$18,$04,$0F,$36
00636F  2  36           
006370  2               ANNMushroomPlaceholder:
006370  2  00 00 00     .byte $00,$00,$00
006373  2               
006373  2               SetupVictoryMode:
006373  2                     @TempPtr = $00
006373  2  AD FB 07           lda HardWorldFlag                 ; check if we're playing hard worlds
006376  2  D0 26              bne @VictoryMode                  ; if so - skip to 2j code
006378  2  AE 5F 07           ldx WorldNumber                   ; get current world
00637B  2  E0 07              cpx #World8                       ; are we in world 8?
00637D  2  F0 1F              beq @VictoryMode                  ; yes - skip to 2j code
00637F  2  BC 5C 63           ldy WMushroomRetainerOffsets,x    ; no - get palette offset based on world
006382  2  B9 54 63           lda MushroomRetainerPalettes,y    ; then load palette location into pointer
006385  2  85 00              sta @TempPtr                      ; store in a temporary pointer
006387  2  C8                 iny                               ;
006388  2  B9 54 63           lda MushroomRetainerPalettes,y    ;
00638B  2  85 01              sta @TempPtr+1                    ;
00638D  2  A0 00              ldy #0                            ;
00638F  2  B1 00        :     lda (@TempPtr),y                  ; load byte from pointer
006391  2  99 70 63           sta ANNMushroomPlaceholder,y      ; and write it to the palette placeholder
006394  2  C8                 iny                               ;
006395  2  C0 02              cpy #2                            ; check if we've reached the end
006397  2  D0 F6              bne :-                            ; no - continue loop
006399  2  A9 1D              lda #$1D                          ; yes - set vram buffer to mushroom palette
00639B  2  8D 73 07           sta VRAM_Buffer_AddrCtrl          ; what a bad way to copy two bytes... oh well.
00639E  2               @VictoryMode:
00639E  2               .endif
00639E  2  AE 1B 07              ldx ScreenRight_PageLoc ;get page location of right side of screen
0063A1  2  E8                    inx                     ;increment to next page
0063A2  2  86 34                 stx DestinationPageLoc
0063A4  2               .ifndef ANN
0063A4  2                        ldy WorldNumber
0063A4  2                        lda WorldBits,y
0063A4  2                        ora CompletedWorlds     ;set bit according to the world the player was in
0063A4  2                        sta CompletedWorlds
0063A4  2               .endif
0063A4  2  AD FB 07              lda HardWorldFlag       ;if not playing worlds A-D, branch to skip this
0063A7  2  F0 0C                 beq W1Thru8
0063A9  2  AD 5F 07              lda WorldNumber         ;otherwise, if not on world D, branch to skip this
0063AC  2  C9 03                 cmp #World4             ;(note worlds A-D use values 0-3 in this variable)
0063AE  2  90 05                 bcc W1Thru8
0063B0  2  A9 07                 lda #World8             ;if on world D, set world number to 8 to satisfy
0063B2  2  8D 5F 07              sta WorldNumber         ;end of game condition in later victory mode subs
0063B5  2  A9 08        W1Thru8: lda #EndOfCastleMusic
0063B7  2  85 FC                 sta EventMusicQueue     ;play win castle music
0063B9  2               
0063B9  2               IncModeTask:
0063B9  2  EE 72 07         inc OperMode_Task
0063BC  2  60               rts
0063BD  2               
0063BD  2               ;-------------------------------------------------------------------------------------
0063BD  2               
0063BD  2               DrawTitleScreen:
0063BD  2  AD 70 07         lda OperMode       ;if not in attract mode, do not draw title screen
0063C0  2  D0 F7            bne IncModeTask    ;yes, this routine is run in other modes
0063C2  2  A9 05            lda #$05
0063C4  2  4C 28 66         jmp SetVRAMAddr_B  ;otherwise set up VRAM address controller accordingly
0063C7  2               
0063C7  2               ;-------------------------------------------------------------------------------------
0063C7  2               
0063C7  2               PlayerVictoryWalk:
0063C7  2  A0 00                     ldy #$00                ;set value here to not walk player by default
0063C9  2  84 35                     sty VictoryWalkControl
0063CB  2  A5 6D                     lda Player_PageLoc      ;get player's page location
0063CD  2  C5 34                     cmp DestinationPageLoc  ;compare with destination page location
0063CF  2  D0 06                     bne PerformWalk         ;if page locations don't match, branch
0063D1  2  A5 86                     lda Player_X_Position   ;otherwise get player's horizontal position
0063D3  2  C9 60                     cmp #$60                ;compare with preset horizontal position
0063D5  2  B0 03                     bcs DontWalk            ;if still on other page, branch ahead
0063D7  2  E6 35        PerformWalk: inc VictoryWalkControl  ;otherwise increment value and Y
0063D9  2  C8                        iny                     ;note Y will be used to walk the player
0063DA  2  98           DontWalk:    tya                     ;put contents of Y in A and
0063DB  2  20 A8 7C                  jsr AutoControlPlayer   ;use A to move player to the right or not
0063DE  2  AD 1A 07                  lda ScreenLeft_PageLoc  ;check page location of left side of screen
0063E1  2  C5 34                     cmp DestinationPageLoc  ;against set value here
0063E3  2  F0 16                     beq ExitVWalk           ;branch if equal to change modes if necessary
0063E5  2  AD 68 07                  lda ScrollFractional
0063E8  2  18                        clc                     ;do fixed point math on fractional part of scroll
0063E9  2  69 80                     adc #$80
0063EB  2  8D 68 07                  sta ScrollFractional    ;save fractional movement amount
0063EE  2  A9 01                     lda #$01                ;set 1 pixel per frame
0063F0  2  69 00                     adc #$00                ;add carry from previous addition
0063F2  2  A8                        tay                     ;use as scroll amount
0063F3  2  20 8A 7B                  jsr ScrollScreen        ;do sub to scroll the screen
0063F6  2  20 35 7B                  jsr UpdScrollVar        ;do another sub to update screen and scroll variables
0063F9  2  E6 35                     inc VictoryWalkControl  ;increment value to stay in this routine
0063FB  2  A5 35        ExitVWalk:   lda VictoryWalkControl  ;load value set here
0063FD  2  F0 3F                     beq IncModeTask_A       ;if zero, branch to change modes
0063FF  2  60                        rts                     ;otherwise leave
006400  2               
006400  2               PrintVictoryMessages:
006400  2  AD 49 07                    lda MsgFractional        ;load message counter fractional
006403  2  D0 1F                       bne IncMsgCounter        ;if not yet wrapped, branch to increment it
006405  2  AD 19 07                    lda MsgCounter           ;otherwise load message counter
006408  2  F0 08                       beq ThankPlayer          ;if set to zero, branch to print first message
00640A  2  C9 08                       cmp #$08                 ;if at 8 or above, branch elsewhere
00640C  2  B0 16                       bcs IncMsgCounter
00640E  2  C9 01                       cmp #$01                 ;if at zero, branch (note, this branch is never
006410  2  90 12                       bcc IncMsgCounter        ;taken because we already branched at zero earlier)
006412  2  A8           ThankPlayer:   tay
006413  2  F0 08                       beq PrintMsgs
006415  2  C0 03                       cpy #$03
006417  2  B0 1E                       bcs SetEndTimer          ;wait until a specific point to set the timer
006419  2  C0 02                       cpy #$02
00641B  2  B0 07                       bcs IncMsgCounter        ;skip printing of messages after the first two
00641D  2  98           PrintMsgs:     tya                      ;put primary message counter in A
00641E  2  18                          clc                      ;add 12 to counter, thus giving an appropriate value
00641F  2  69 0C                       adc #$0c
006421  2  8D 73 07                    sta VRAM_Buffer_AddrCtrl ;write message counter to vram address controller
006424  2  AD 49 07     IncMsgCounter: lda MsgFractional
006427  2  18                          clc
006428  2  69 04                       adc #$04                 ;add four to fractional
00642A  2  8D 49 07                    sta MsgFractional
00642D  2  AD 19 07                    lda MsgCounter
006430  2  69 00                       adc #$00                 ;carry the one if fractional wraps
006432  2  8D 19 07                    sta MsgCounter
006435  2  C9 06                       cmp #$06                 ;check message counter one more time
006437  2  90 08        SetEndTimer:   bcc ExitMsgs             ;if not reached 6 yet, branch to leave
006439  2  A9 08                       lda #$08
00643B  2  8D A1 07                    sta WorldEndTimer        ;otherwise set world end timer
00643E  2  EE 72 07     IncModeTask_A: inc OperMode_Task        ;move onto next task in mode
006441  2  60           ExitMsgs:      rts
006442  2               
006442  2               EndCastleAward:
006442  2  AD A1 07        lda WorldEndTimer      ;if world end timer has not yet reached a certain point
006445  2  C9 06           cmp #$06               ;then go ahead and skip all of this
006447  2  B0 1B           bcs ExEWA
006449  2               .ifndef ANN
006449  2                  jsr AwardTimerCastle
006449  2               .endif
006449  2  AD EC 07        lda GameTimerDisplay   ;if game timer points not all awarded, skip this part
00644C  2  0D ED 07        ora GameTimerDisplay+1
00644F  2  0D EE 07        ora GameTimerDisplay+2
006452  2               .ifdef ANN
006452  2  F0 03           beq @Continue          ; bugfix for castle countdown, skip ahead if timer is zero
006454  2  4C 5B 9F        jmp AwardTimerCastle   ; otherwise run timer countdown
006457  2                  @Continue:
006457  2               .else
006457  2                  bne ExEWA
006457  2               .endif
006457  2  A9 30           lda #$30
006459  2  8D 80 07        sta SelectTimer        ;set select timer (used for world 8 ending only)
00645C  2  A9 06           lda #$06
00645E  2  8D A1 07        sta WorldEndTimer      ;another short delay, then on to the next task
006461  2  EE 72 07        inc OperMode_Task
006464  2               ExEWA:
006464  2  60              rts
006465  2               
006465  2               EndWorld1Thru7:
006465  2  AD A1 07                lda WorldEndTimer         ;skip this until world end timer expires
006468  2  D0 19                   bne EndExit
00646A  2  A9 00        NextWorld: lda #$00
00646C  2  8D 60 07                sta AreaNumber            ;reset area/level numbers to start the next world
00646F  2  8D 5C 07                sta LevelNumber
006472  2  8D 72 07                sta OperMode_Task
006475  2               .ifdef ANN
006475  2  EE 5F 07                inc WorldNumber           ; advance to next world
006478  2               .else
006478  2                          lda WorldNumber
006478  2                          clc
006478  2                          adc #$01                  ;add one, but only up to world 9
006478  2                          cmp #World9
006478  2                          bcc NoPast9
006478  2                          lda #World9               ;make world 9 loop forever (or until game is over)
006478  2               NoPast9:   sta WorldNumber           ;update the world number
006478  2               .endif
006478  2  20 86 C2                jsr LoadAreaPointer       ;get pointer for the next area
00647B  2  EE 57 07                inc FetchNewGameTimerFlag ;and get a new game timer
00647E  2  A9 01                   lda #$01
006480  2  8D 70 07                sta OperMode              ;and oh yeah, go back to game mode also
006483  2  60           EndExit:   rts
006484  2               
006484  2               ;-------------------------------------------------------------------------------------
006484  2               
006484  2               ;data is used as tiles for numbers
006484  2               ;that appear when you defeat enemies
006484  2               FloateyNumTileData:
006484  2  FF FF              .byte $ff, $ff ;dummy
006486  2  F6 FB              .byte $f6, $fb ; "100"
006488  2  F7 FB              .byte $f7, $fb ; "200"
00648A  2  F8 FB              .byte $f8, $fb ; "400"
00648C  2  F9 FB              .byte $f9, $fb ; "500"
00648E  2  FA FB              .byte $fa, $fb ; "800"
006490  2  F6 50              .byte $f6, $50 ; "1000"
006492  2  F7 50              .byte $f7, $50 ; "2000"
006494  2  F8 50              .byte $f8, $50 ; "4000"
006496  2  F9 50              .byte $f9, $50 ; "5000"
006498  2  FA 50              .byte $fa, $50 ; "8000"
00649A  2  FD FE              .byte $fd, $fe ; "1-UP"
00649C  2               
00649C  2               ;high nybble is digit number, low nybble is number to
00649C  2               ;add to the digit of the player's score
00649C  2               ScoreUpdateData:
00649C  2  FF                 .byte $ff ;dummy
00649D  2  41 42 44 45        .byte $41, $42, $44, $45, $48
0064A1  2  48           
0064A2  2  31 32 34 35        .byte $31, $32, $34, $35, $38, $00
0064A6  2  38 00        
0064A8  2               
0064A8  2               FloateyNumbersRoutine:
0064A8  2  BD 10 01                   lda FloateyNum_Control,x     ;load control for floatey number
0064AB  2  F0 D6                      beq EndExit                  ;if zero, branch to leave
0064AD  2  C9 0B                      cmp #$0b                     ;if less than $0b, branch
0064AF  2  90 05                      bcc ChkNumTimer
0064B1  2  A9 0B                      lda #$0b                     ;otherwise set to $0b, thus keeping
0064B3  2  9D 10 01                   sta FloateyNum_Control,x     ;it in range
0064B6  2  A8           ChkNumTimer:  tay                          ;use as Y
0064B7  2  BD 2C 01                   lda FloateyNum_Timer,x       ;check value here
0064BA  2  D0 04                      bne DecNumTimer              ;if nonzero, branch ahead
0064BC  2  9D 10 01                   sta FloateyNum_Control,x     ;initialize floatey number control and leave
0064BF  2  60                         rts
0064C0  2  DE 2C 01     DecNumTimer:  dec FloateyNum_Timer,x       ;decrement value here
0064C3  2  C9 2B                      cmp #$2b                     ;if not reached a certain point, branch
0064C5  2  D0 1E                      bne ChkTallEnemy
0064C7  2  C0 0B                      cpy #$0b                     ;check offset for $0b
0064C9  2  D0 07                      bne LoadNumTiles             ;branch ahead if not found
0064CB  2  EE 5A 07                   inc NumberofLives            ;give player one extra life (1-up)
0064CE  2  A9 40                      lda #Sfx_ExtraLife
0064D0  2  85 FE                      sta Square2SoundQueue        ;and play the 1-up sound
0064D2  2  B9 9C 64     LoadNumTiles: lda ScoreUpdateData,y        ;load point value here
0064D5  2  4A                         lsr                          ;move high nybble to low
0064D6  2  4A                         lsr
0064D7  2  4A                         lsr
0064D8  2  4A                         lsr
0064D9  2  AA                         tax                          ;use as X offset, essentially the digit
0064DA  2  B9 9C 64                   lda ScoreUpdateData,y        ;load again and this time
0064DD  2  29 0F                      and #%00001111               ;mask out the high nybble
0064DF  2  9D 34 01                   sta DigitModifier,x          ;store as amount to add to the digit
0064E2  2  20 33 88                   jsr AddToScore               ;update the score accordingly
0064E5  2  BC E5 06     ChkTallEnemy: ldy Enemy_SprDataOffset,x    ;get OAM data offset for enemy object
0064E8  2  B5 16                      lda Enemy_ID,x               ;get enemy object identifier
0064EA  2  C9 12                      cmp #Spiny
0064EC  2  F0 22                      beq FloateyPart              ;branch if spiny
0064EE  2  C9 0D                      cmp #PiranhaPlant
0064F0  2  F0 1E                      beq FloateyPart              ;branch if piranha plant
0064F2  2  C9 05                      cmp #HammerBro
0064F4  2  F0 12                      beq GetAltOffset             ;branch elsewhere if hammer bro
0064F6  2  C9 0A                      cmp #GreyCheepCheep
0064F8  2  F0 16                      beq FloateyPart              ;branch if cheep-cheep of either color
0064FA  2  C9 0B                      cmp #RedCheepCheep
0064FC  2  F0 12                      beq FloateyPart
0064FE  2  C9 09                      cmp #TallEnemy
006500  2  B0 06                      bcs GetAltOffset             ;branch elsewhere if enemy object => $09
006502  2  B5 1E                      lda Enemy_State,x
006504  2  C9 02                      cmp #$02                     ;if enemy state defeated or otherwise
006506  2  B0 08                      bcs FloateyPart              ;$02 or greater, branch beyond this part
006508  2  AE EE 03     GetAltOffset: ldx SprDataOffset_Ctrl       ;load some kind of control bit
00650B  2  BC EC 06                   ldy Alt_SprDataOffset,x      ;get alternate OAM data offset
00650E  2  A6 08                      ldx ObjectOffset             ;get enemy object offset again
006510  2  BD 1E 01     FloateyPart:  lda FloateyNum_Y_Pos,x       ;get vertical coordinate for
006513  2  C9 18                      cmp #$18                     ;floatey number, if coordinate in the
006515  2  90 05                      bcc SetupNumSpr              ;status bar, branch
006517  2  E9 01                      sbc #$01
006519  2  9D 1E 01                   sta FloateyNum_Y_Pos,x       ;otherwise subtract one and store as new
00651C  2  BD 1E 01     SetupNumSpr:  lda FloateyNum_Y_Pos,x       ;get vertical coordinate
00651F  2  E9 08                      sbc #$08                     ;subtract eight and dump into the
006521  2  20 72 B2                   jsr DumpTwoSpr               ;left and right sprite's Y coordinates
006524  2  BD 17 01                   lda FloateyNum_X_Pos,x       ;get horizontal coordinate
006527  2  99 03 02                   sta Sprite_X_Position,y      ;store into X coordinate of left sprite
00652A  2  18                         clc
00652B  2  69 08                      adc #$08                     ;add eight pixels and store into X
00652D  2  99 07 02                   sta Sprite_X_Position+4,y    ;coordinate of right sprite
006530  2  A9 02                      lda #$02
006532  2  99 02 02                   sta Sprite_Attributes,y      ;set palette control in attribute bytes
006535  2  99 06 02                   sta Sprite_Attributes+4,y    ;of left and right sprites
006538  2  BD 10 01                   lda FloateyNum_Control,x
00653B  2  0A                         asl                          ;multiply our floatey number control by 2
00653C  2  AA                         tax                          ;and use as offset for look-up table
00653D  2  BD 84 64                   lda FloateyNumTileData,x
006540  2  99 01 02                   sta Sprite_Tilenumber,y      ;display first half of number of points
006543  2  BD 85 64                   lda FloateyNumTileData+1,x
006546  2  99 05 02                   sta Sprite_Tilenumber+4,y    ;display the second half
006549  2  A6 08                      ldx ObjectOffset             ;get enemy object offset and leave
00654B  2               .ifdef ANN
00654B  2               ANNDoNothing:
00654B  2               .endif
00654B  2  60                         rts
00654C  2               
00654C  2               ;-------------------------------------------------------------------------------------
00654C  2               
00654C  2               ScreenRoutines:
00654C  2  AD 3C 07        lda ScreenRoutineTask
00654F  2  20 0F 6D        jsr JumpEngine
006552  2               
006552  2  72 65           .word InitScreen
006554  2  82 65           .word SetupIntermediate
006556  2  2E 66           .word WriteTopStatusLine
006558  2  36 66           .word WriteBottomStatusLine
00655A  2  7F 66           .word DisplayTimeUp
00655C  2  14 68           .word ResetSpritesAndScreenTimer
00655E  2  9E 66           .word DisplayIntermediate
006560  2               .ifdef ANN
006560  2  4B 65           .word ANNDoNothing
006562  2               .else
006562  2                  .word DemoReset
006562  2               .endif
006562  2  14 68           .word ResetSpritesAndScreenTimer
006564  2  D1 66           .word AreaParserTaskControl
006566  2  A6 65           .word GetAreaPalette
006568  2  C6 65           .word GetBackgroundColor
00656A  2  1F 66           .word GetAlternatePalette1
00656C  2  BD 63           .word DrawTitleScreen
00656E  2  31 C5           .word ClearBuffersDrawIcon
006570  2  48 C5           .word WriteTopScore
006572  2               
006572  2               InitScreen:
006572  2  20 8A 62           jsr MoveAllSpritesOffscreen ;initialize all sprites including sprite #0
006575  2  20 24 6D           jsr InitializeNameTables    ;and erase both name and attribute tables
006578  2  AD 70 07           lda OperMode
00657B  2  F0 32              beq NextSubtask             ;if in attact mode, do not set pointer control
00657D  2               InitScreenPalette:
00657D  2  A2 03              ldx #$03                    ;otherwise set for underground palette
00657F  2  4C AC 65           jmp SetVRAMAddr_A
006582  2               
006582  2               SetupIntermediate:
006582  2  AD 44 07           lda BackgroundColorCtrl  ;save current background color control
006585  2  48                 pha                      ;and player status to stack
006586  2  AD 56 07           lda PlayerStatus
006589  2  48                 pha
00658A  2  A9 00              lda #$00                 ;set background color to black
00658C  2  8D 56 07           sta PlayerStatus         ;and player status to not fiery
00658F  2  A9 02              lda #$02                 ;this is the ONLY time background color control
006591  2  8D 44 07           sta BackgroundColorCtrl  ;is set to less than 4
006594  2  20 D4 65           jsr GetPlayerColors
006597  2  68                 pla                      ;set up colors for intermediate lives display
006598  2  8D 56 07           sta PlayerStatus
00659B  2  68                 pla                      ;return bg color control and player status
00659C  2  8D 44 07           sta BackgroundColorCtrl
00659F  2  4C 9A 66           jmp IncSubtask           ;then move onto the next task
0065A2  2               
0065A2  2               AreaPalette:
0065A2  2  01 02 03 04        .byte $01, $02, $03, $04
0065A6  2               
0065A6  2               GetAreaPalette:
0065A6  2  AC 4E 07                    ldy AreaType             ;select appropriate palette to load
0065A9  2  BE A2 65                    ldx AreaPalette,y        ;based on area type
0065AC  2  8E 73 07     SetVRAMAddr_A: stx VRAM_Buffer_AddrCtrl ;store offset into buffer control
0065AF  2  4C 9A 66     NextSubtask:   jmp IncSubtask           ;move onto next task
0065B2  2               
0065B2  2               ;-------------------------------------------------------------------------------------
0065B2  2               ;$00 - used as temp counter in GetPlayerColors
0065B2  2               
0065B2  2               BGColorCtrl_Addr:
0065B2  2  00 09 0A 04        .byte $00, $09, $0a, $04
0065B6  2               
0065B6  2               BackgroundColors:
0065B6  2  22 22 0F 0F        .byte $22, $22, $0f, $0f ;used by area type if bg color ctrl not set
0065BA  2  0F 22 0F 0F        .byte $0f, $22, $0f, $0f ;used by background color control if set
0065BE  2               
0065BE  2               PlayerColors:
0065BE  2  22 16 27 18        .byte $22, $16, $27, $18 ;player's normal colors, may be overwritten
0065C2  2  22 37 27 16        .byte $22, $37, $27, $16 ;player's colors after grabbing fire flower
0065C6  2               
0065C6  2               GetBackgroundColor:
0065C6  2  AC 44 07                ldy BackgroundColorCtrl   ;check background color control
0065C9  2  F0 06                   beq NoBGColor             ;if not set, increment task and fetch palette
0065CB  2  B9 AE 65                lda BGColorCtrl_Addr-4,y  ;put appropriate palette into vram
0065CE  2  8D 73 07                sta VRAM_Buffer_AddrCtrl  ;note that if set to 5-7, first VRAM buffer will not be read
0065D1  2  EE 3C 07     NoBGColor: inc ScreenRoutineTask     ;increment to next subtask and plod on through
0065D4  2               
0065D4  2               GetPlayerColors:
0065D4  2  AE 00 03                    ldx VRAM_Buffer1_Offset  ;get current buffer offset
0065D7  2  A0 00                       ldy #$00
0065D9  2  AD 56 07     ChkFiery:      lda PlayerStatus         ;check player status
0065DC  2  C9 02                       cmp #$02
0065DE  2  D0 02                       bne StartClrGet          ;if fiery, load alternate offset for fiery player
0065E0  2  A0 04                       ldy #$04
0065E2  2  A9 03        StartClrGet:   lda #$03                 ;do four colors
0065E4  2  85 00                       sta $00
0065E6  2  B9 BE 65     ClrGetLoop:    lda PlayerColors,y       ;fetch player colors and store them
0065E9  2  9D 04 03                    sta VRAM_Buffer1+3,x     ;in the buffer
0065EC  2  C8                          iny
0065ED  2  E8                          inx
0065EE  2  C6 00                       dec $00
0065F0  2  10 F4                       bpl ClrGetLoop
0065F2  2  AE 00 03                    ldx VRAM_Buffer1_Offset  ;load original offset from before
0065F5  2  AC 44 07                    ldy BackgroundColorCtrl  ;if this value is four or greater, it will be set
0065F8  2  D0 03                       bne SetBGColor           ;therefore use it as offset to background color
0065FA  2  AC 4E 07                    ldy AreaType             ;otherwise use area type bits from area offset as offset
0065FD  2  B9 B6 65     SetBGColor:    lda BackgroundColors,y   ;to background color instead
006600  2  9D 04 03                    sta VRAM_Buffer1+3,x
006603  2  A9 3F                       lda #$3f                 ;set for sprite palette address
006605  2  9D 01 03                    sta VRAM_Buffer1,x       ;save to buffer
006608  2  A9 10                       lda #$10
00660A  2  9D 02 03                    sta VRAM_Buffer1+1,x
00660D  2  A9 04                       lda #$04                 ;write length byte to buffer
00660F  2  9D 03 03                    sta VRAM_Buffer1+2,x
006612  2  A9 00                       lda #$00                 ;now the null terminator
006614  2  9D 08 03                    sta VRAM_Buffer1+7,x
006617  2  8A                          txa                      ;move the buffer pointer ahead 7 bytes
006618  2  18                          clc                      ;in case we want to write anything else later
006619  2  69 07                       adc #$07
00661B  2  8D 00 03     SetVRAMOffset: sta VRAM_Buffer1_Offset  ;store as new vram buffer offset
00661E  2  60                          rts
00661F  2               
00661F  2               GetAlternatePalette1:
00661F  2  AD 33 07                    lda AreaStyle            ;check for mushroom level style
006622  2  C9 01                       cmp #$01
006624  2  D0 05                       bne NoAltPal
006626  2  A9 0B                       lda #$0b                 ;if found, load appropriate palette
006628  2  8D 73 07     SetVRAMAddr_B: sta VRAM_Buffer_AddrCtrl
00662B  2  4C 9A 66     NoAltPal:      jmp IncSubtask           ;now onto the next task
00662E  2               
00662E  2               WriteTopStatusLine:
00662E  2  A9 00              lda #$00          ;select main status bar
006630  2  20 A8 67           jsr WriteGameText ;output it
006633  2  4C 9A 66           jmp IncSubtask    ;onto the next task
006636  2               
006636  2               WriteBottomStatusLine:
006636  2  20 38 88           jsr WriteScoreAndCoinTally ;write player's score and coin tally to screen
006639  2  AE 00 03           ldx VRAM_Buffer1_Offset
00663C  2  A9 20              lda #$20                   ;write address for world-area number on screen
00663E  2  9D 01 03           sta VRAM_Buffer1,x
006641  2  A9 73              lda #$73
006643  2  9D 02 03           sta VRAM_Buffer1+1,x
006646  2  A9 03              lda #$03                   ;write length for it
006648  2  9D 03 03           sta VRAM_Buffer1+2,x
00664B  2  20 6D 66           jsr GetWorldNumForDisplay  ;first the world number
00664E  2  9D 04 03           sta VRAM_Buffer1+3,x
006651  2  A9 28              lda #$28                   ;next the dash
006653  2  9D 05 03           sta VRAM_Buffer1+4,x
006656  2  AC 5C 07           ldy LevelNumber            ;next the level number
006659  2  C8                 iny                        ;increment for proper number display
00665A  2  98                 tya
00665B  2  9D 06 03           sta VRAM_Buffer1+5,x
00665E  2  A9 00              lda #$00                   ;put null terminator at the end
006660  2  9D 07 03           sta VRAM_Buffer1+6,x
006663  2  8A                 txa                        ;move the buffer offset up by 6 bytes
006664  2  18                 clc
006665  2  69 06              adc #$06
006667  2  8D 00 03           sta VRAM_Buffer1_Offset
00666A  2  4C 9A 66           jmp IncSubtask
00666D  2               
00666D  2               GetWorldNumForDisplay:
00666D  2  AC 5F 07            ldy WorldNumber
006670  2  AD FB 07            lda HardWorldFlag  ;if not in worlds A-D, branch to use digits 1-8
006673  2  F0 07               beq WNumD
006675  2  98                  tya
006676  2  29 03               and #$03           ;otherwise mask out any world numbers higher than 4
006678  2  18                  clc                ;and add 9 to get the proper letter A thru D
006679  2  69 09               adc #$09
00667B  2  A8                  tay
00667C  2  C8           WNumD: iny                ;increment the world number/letter because
00667D  2  98                  tya                ;the internal world number counts from 0, not 1
00667E  2  60                  rts
00667F  2               
00667F  2               DisplayTimeUp:
00667F  2  AD 59 07               lda GameTimerExpiredFlag  ;if game timer not expired, increment task
006682  2  F0 13                  beq IncSubtaskby2         ;control 2 tasks forward, otherwise, stay here
006684  2  A9 00                  lda #$00
006686  2  8D 59 07               sta GameTimerExpiredFlag  ;reset timer expiration flag
006689  2  A9 02                  lda #$02                  ;output time-up screen to buffer
00668B  2               OtherInter:
00668B  2  20 A8 67               jsr WriteGameText
00668E  2  20 1C 68               jsr ResetScreenTimer
006691  2  A9 00                  lda #$00
006693  2  8D 74 07               sta DisableScreenFlag
006696  2  60                     rts
006697  2               
006697  2               IncSubtaskby2:
006697  2  EE 3C 07           inc ScreenRoutineTask
00669A  2               IncSubtask:
00669A  2  EE 3C 07           inc ScreenRoutineTask
00669D  2  60                 rts
00669E  2               
00669E  2               DisplayIntermediate:
00669E  2  AD 70 07                    lda OperMode                 ;check primary mode of operation
0066A1  2  F0 28                       beq NoInter                  ;if in attract mode, do not display intermediate screens
0066A3  2  C9 03                       cmp #GameOverMode            ;are we in game over mode?
0066A5  2  F0 1C                       beq GameOverInter            ;if so, proceed to display game over screen
0066A7  2  AD 52 07                    lda AltEntranceControl       ;otherwise check for mode of alternate entry
0066AA  2  D0 1F                       bne NoInter                  ;and branch if found
0066AC  2  AC 4E 07                    ldy AreaType                 ;check if we are on castle level
0066AF  2  C0 03                       cpy #$03                     ;and if so, branch (possibly residual)
0066B1  2  F0 05                       beq PlayerInter
0066B3  2  AD 69 07                    lda DisableIntermediate      ;if this flag is set, skip intermediate lives display
0066B6  2  D0 13                       bne NoInter                  ;and jump to specific task, otherwise
0066B8  2  20 8F BC     PlayerInter:   jsr DrawPlayer_Intermediate  ;put player in appropriate place for
0066BB  2  A9 01                       lda #$01                     ;lives display, then output lives display to buffer
0066BD  2  20 8B 66     OutputInter:   jsr OtherInter
0066C0  2               .ifdef ANN
0066C0  2  4C 9A 66                    jmp IncSubtask
0066C3  2               .else
0066C3  2                              lda WorldNumber              ;if on any world besides 9, do next task
0066C3  2                              cmp #World9
0066C3  2                              bne IncSubtask
0066C3  2                              inc DisableScreenFlag        ;disable screen output
0066C3  2                              rts
0066C3  2               .endif
0066C3  2               
0066C3  2  A9 03        GameOverInter: lda #$03                     ;output game over screen to buffer
0066C5  2  20 A8 67                    jsr WriteGameText
0066C8  2               .ifndef ANN
0066C8  2                              lda WorldNumber
0066C8  2                              cmp #World9
0066C8  2                              beq IncSubtask
0066C8  2               .endif
0066C8  2  4C B9 63                    jmp IncModeTask
0066CB  2               
0066CB  2  A9 09        NoInter:       lda #$09                     ;skip ahead in screen routine list
0066CD  2  8D 3C 07                    sta ScreenRoutineTask        ;to execute area parser
0066D0  2  60                          rts
0066D1  2               
0066D1  2               AreaParserTaskControl:
0066D1  2  EE 74 07                inc DisableScreenFlag     ;turn off screen
0066D4  2  20 3D 71     TaskLoop:  jsr AreaParserTaskHandler ;render column set of current area
0066D7  2  AD 1F 07                lda AreaParserTaskNum     ;check number of tasks
0066DA  2  D0 F8                   bne TaskLoop              ;if tasks still not all done, do another one
0066DC  2  CE 1E 07                dec ColumnSets            ;do we need to render more column sets?
0066DF  2  10 03                   bpl OutputCol
0066E1  2  EE 3C 07                inc ScreenRoutineTask     ;if not, move on to the next task
0066E4  2  A9 06        OutputCol: lda #$06                  ;set vram buffer to output rendered column set
0066E6  2  8D 73 07                sta VRAM_Buffer_AddrCtrl  ;on next NMI
0066E9  2  60                      rts
0066EA  2               
0066EA  2               GameText:
0066EA  2               TopStatusBarLine:
0066EA  2  20 43 05 16    .byte $20, $43, $05, $16, $0a, $1b, $12, $18 ;"MARIO"
0066EE  2  0A 1B 12 18  
0066F2  2  20 52 0B 20    .byte $20, $52, $0b, $20, $18, $1b, $15, $0d ;"WORLD  TIME"
0066F6  2  18 1B 15 0D  
0066FA  2  24 24 1D 12    .byte $24, $24, $1d, $12, $16, $0e
0066FE  2  16 0E        
006700  2  20 68 05 00    .byte $20, $68, $05, $00, $24, $24, $2e, $29 ;score trailing digit and coin display
006704  2  24 24 2E 29  
006708  2  23 C0 7F AA    .byte $23, $c0, $7f, $aa ;attribute table data, clears name table 0 to palette 2
00670C  2  23 C2 01 EA    .byte $23, $c2, $01, $ea ;attribute table data, used for coin icon in status bar
006710  2  FF             .byte $ff ;end of data block
006711  2               
006711  2               WorldLivesDisplay:
006711  2  21 CD 07 24    .byte $21, $cd, $07, $24, $24 ;cross with spaces used on
006715  2  24           
006716  2  29 24 24 24    .byte $29, $24, $24, $24, $24 ;lives display
00671A  2  24           
00671B  2  21 4B 09 20    .byte $21, $4b, $09, $20, $18 ;"WORLD  - " used on lives display
00671F  2  18           
006720  2  1B 15 0D 24    .byte $1b, $15, $0d, $24, $24, $28, $24
006724  2  24 28 24     
006727  2  22 0C 47 24    .byte $22, $0c, $47, $24 ;possibly used to clear time up
00672B  2  23 DC 01 BA    .byte $23, $dc, $01, $ba ;attribute table data for crown if more than 9 lives
00672F  2  FF             .byte $ff
006730  2               
006730  2               TimeUp:
006730  2  22 0C 07 1D    .byte $22, $0c, $07, $1d, $12, $16, $0e, $24, $1e, $19 ; "TIME UP"
006734  2  12 16 0E 24  
006738  2  1E 19        
00673A  2  FF             .byte $ff
00673B  2               
00673B  2               GameOver:
00673B  2  21 6B 09 10    .byte $21, $6b, $09, $10, $0a, $16, $0e, $24 ;"GAME OVER"
00673F  2  0A 16 0E 24  
006743  2  18 1F 0E 1B    .byte $18, $1f, $0e, $1b
006747  2  21 EB 08 0C    .byte $21, $eb, $08, $0c, $18, $17, $1d, $12, $17, $1e, $0e ;"CONTINUE"
00674B  2  18 17 1D 12  
00674F  2  17 1E 0E     
006752  2  22 0C 47 24    .byte $22, $0c, $47, $24
006756  2  22 4B 05 1B    .byte $22, $4b, $05, $1b, $0e, $1d, $1b, $22 ;"RETRY"
00675A  2  0E 1D 1B 22  
00675E  2  FF             .byte $ff
00675F  2               
00675F  2               .ifdef ANN ; Use SMB1 style Warpzones
00675F  2               WarpZone:
00675F  2  25 84 15       .byte $25, $84, $15
006762  2  20 0E 15 0C    .byte $20, $0e, $15, $0c, $18, $16, $0e, $24, $1d, $18 ; "WELCOME TO WARP ZONE!"
006766  2  18 16 0E 24  
00676A  2  1D 18        
00676C  2  24 20 0A 1B    .byte $24, $20, $0a, $1b, $19, $24, $23, $18, $17, $0e
006770  2  19 24 23 18  
006774  2  17 0E        
006776  2  2B             .byte $2b
006777  2  26 25 01 24    .byte $26, $25, $01, $24         ; placeholder for left pipe
00677B  2  26 2D 01 24    .byte $26, $2d, $01, $24         ; placeholder for middle pipe
00677F  2  26 35 01 24    .byte $26, $35, $01, $24         ; placeholder for right pipe
006783  2  27 D9 46 AA    .byte $27, $d9, $46, $aa         ; attribute data
006787  2  27 E1 45 AA    .byte $27, $e1, $45, $aa
00678B  2  00             .byte $00
00678C  2               
00678C  2               WarpZoneNumbers:
00678C  2  04 03 02 00    .byte $04, $03, $02, $00         ; warp zone numbers, note spaces on middle
006790  2  24 05 24 00    .byte $24, $05, $24, $00         ; zone, partly responsible for
006794  2  08 07 06 00    .byte $08, $07, $06, $00         ; the minus world
006798  2  24 0B 24 00    .byte $24, $0B, $24, $00         ; 2j-style ANN warpzones
00679C  2  24 0C 24 00    .byte $24, $0C, $24, $00         ; 2j-style ANN warpzones
0067A0  2  24 0D 24 00    .byte $24, $0D, $24, $00         ; 2j-style ANN warpzones
0067A4  2               .else
0067A4  2               WarpZone:
0067A4  2                 .byte $25, $84, $15
0067A4  2                 .byte $20, $0e, $15, $0c, $18, $16, $0e, $24, $1d, $18 ; "WELCOME TO WARP ZONE!"
0067A4  2                 .byte $24, $20, $0a, $1b, $19, $24, $23, $18, $17, $0e
0067A4  2                 .byte $2b
0067A4  2                 .byte $26, $2d, $01, $24 ;blank filler for world number
0067A4  2                 .byte $27, $d9, $46, $aa ;attribute data
0067A4  2                 .byte $27, $e1, $45, $aa
0067A4  2                 .byte $00
0067A4  2               
0067A4  2               WarpZoneNumbers:
0067A4  2                 .byte $02, $03, $04, $01, $06, $07, $08, $05, $0b, $0c, $0d
0067A4  2               .endif
0067A4  2               
0067A4  2               GameTextOffsets:
0067A4  2  00              .byte <(TopStatusBarLine-GameText)
0067A5  2  27              .byte <(WorldLivesDisplay-GameText)
0067A6  2  46              .byte <(TimeUp-GameText)
0067A7  2  51              .byte <(GameOver-GameText)
0067A8  2               
0067A8  2               WriteGameText:
0067A8  2  48                          pha                       ;save text number to stack and use as offset
0067A9  2  A8                          tay
0067AA  2  BE A4 67                    ldx GameTextOffsets,y     ;get offset to game text we want to print
0067AD  2  A0 00                       ldy #$00
0067AF  2  BD EA 66     GameTextLoop:  lda GameText,x            ;load game text data
0067B2  2  C9 FF                       cmp #$ff                  ;check for terminator
0067B4  2  F0 07                       beq EndGameText           ;branch to end text if found
0067B6  2  99 01 03                    sta VRAM_Buffer1,y        ;otherwise write data to buffer
0067B9  2  E8                          inx                       ;and increment increment
0067BA  2  C8                          iny
0067BB  2  D0 F2                       bne GameTextLoop          ;do this for 256 bytes if no terminator found
0067BD  2  A9 00        EndGameText:   lda #$00                  ;put null terminator at end
0067BF  2  99 01 03                    sta VRAM_Buffer1,y
0067C2  2  68                          pla                       ;pull original text number from stack
0067C3  2  F0 25                       beq ExWGT                 ;if printing top status bar, branch to leave
0067C5  2  AA                          tax
0067C6  2  CA                          dex                       ;if printing anything else besides world/lives display
0067C7  2  D0 21                       bne ExWGT                 ;then branch to leave
0067C9  2  AD 5A 07                    lda NumberofLives         ;otherwise, check number of lives
0067CC  2  18                          clc                       ;and increment by one for display
0067CD  2  69 01                       adc #$01
0067CF  2  C9 0A                       cmp #10                   ;more than 9 lives?
0067D1  2  90 07                       bcc PutLives
0067D3  2  E9 0A                       sbc #10                   ;if so, subtract 10 and put a crown tile
0067D5  2  A0 9F                       ldy #$9f                  ;next to the difference...strange things happen if
0067D7  2  8C 08 03                    sty VRAM_Buffer1+7        ;the number of lives exceeds 19
0067DA  2  8D 09 03     PutLives:      sta VRAM_Buffer1+8
0067DD  2  20 6D 66                    jsr GetWorldNumForDisplay ;get world number or letter
0067E0  2  8D 14 03                    sta VRAM_Buffer1+19
0067E3  2  AC 5C 07                    ldy LevelNumber
0067E6  2  C8                          iny
0067E7  2  8C 16 03                    sty VRAM_Buffer1+21       ;we're done here
0067EA  2  60           ExWGT:         rts
0067EB  2               
0067EB  2               WriteWarpZoneMessage:
0067EB  2  48                    pha                   ;save warp zone control temporarily
0067EC  2  A0 FF                 ldy #$ff
0067EE  2  C8           WZMLoop: iny
0067EF  2  B9 5F 67              lda WarpZone,y        ;write warp zone message to VRAM buffer
0067F2  2  99 01 03              sta VRAM_Buffer1,y
0067F5  2  D0 F7                 bne WZMLoop
0067F7  2  68                    pla
0067F8  2  38                    sec
0067F9  2  E9 80                 sbc #$80              ;clear d7 of warp zone control, use as offset
0067FB  2               .ifdef ANN
0067FB  2  0A                    asl                    ;twice to get proper warp zone number
0067FC  2  0A                    asl                    ;offset
0067FD  2  AA                    tax
0067FE  2  A0 00                 ldy #$00
006800  2  BD 8C 67     :        lda WarpZoneNumbers,x  ;print warp zone numbers into the
006803  2  99 1C 03              sta VRAM_Buffer1+27,y  ;placeholders from earlier
006806  2  E8                    inx
006807  2  C8                    iny                    ;put a number in every fourth space
006808  2  C8                    iny
006809  2  C8                    iny
00680A  2  C8                    iny
00680B  2  C0 0C                 cpy #$0c
00680D  2  90 F1                 bcc :-
00680F  2  A9 2C                 lda #$2c               ;load new buffer pointer at end of message
006811  2               .else
006811  2                        tax
006811  2                        lda WarpZoneNumbers,x ;replace blank tile with world number
006811  2                        sta VRAM_Buffer1+27   ;that the warp zone leads to
006811  2                        lda #$24              ;set VRAM offset after the contents
006811  2               .endif
006811  2  4C 1B 66              jmp SetVRAMOffset     ;in case anything else needs to go in there
006814  2               
006814  2               ResetSpritesAndScreenTimer:
006814  2  AD A0 07              lda ScreenTimer             ;check if screen timer has expired
006817  2  D0 0B                 bne NoReset                 ;if not, branch to leave
006819  2  20 8A 62              jsr MoveAllSpritesOffscreen ;otherwise reset sprites now
00681C  2               
00681C  2               ResetScreenTimer:
00681C  2  A9 07                 lda #$07                    ;reset timer again
00681E  2  8D A0 07              sta ScreenTimer
006821  2  EE 3C 07              inc ScreenRoutineTask       ;move onto next task
006824  2  60           NoReset: rts
006825  2               
006825  2               ;-------------------------------------------------------------------------------------
006825  2               ;$00 - temp vram buffer offset
006825  2               ;$01 - temp metatile buffer offset
006825  2               ;$02 - temp metatile graphics table offset
006825  2               ;$03 - used to store attribute bits
006825  2               ;$04 - used to determine attribute table row
006825  2               ;$05 - used to determine attribute table column
006825  2               ;$06 - metatile graphics table address low
006825  2               ;$07 - metatile graphics table address high
006825  2               
006825  2               RenderAreaGraphics:
006825  2  AD 26 07                 lda CurrentColumnPos         ;store LSB of where we're at
006828  2  29 01                    and #$01
00682A  2  85 05                    sta $05
00682C  2  AC 40 03                 ldy VRAM_Buffer2_Offset      ;store vram buffer offset
00682F  2  84 00                    sty $00
006831  2  AD 21 07                 lda CurrentNTAddr_Low        ;get current name table address we're supposed to render
006834  2  99 42 03                 sta VRAM_Buffer2+1,y
006837  2  AD 20 07                 lda CurrentNTAddr_High
00683A  2  99 41 03                 sta VRAM_Buffer2,y
00683D  2  A9 9A                    lda #$9a                     ;store length byte of 26 here with d7 set
00683F  2  99 43 03                 sta VRAM_Buffer2+2,y         ;to increment by 32 (in columns)
006842  2  A9 00                    lda #$00                     ;init attribute row
006844  2  85 04                    sta $04
006846  2  AA                       tax
006847  2  86 01        DrawMTLoop: stx $01                      ;store init value of 0 or incremented offset for buffer
006849  2  BD A1 06                 lda MetatileBuffer,x         ;get first metatile number, and mask out all but 2 MSB
00684C  2  29 C0                    and #%11000000
00684E  2  85 03                    sta $03                      ;store attribute table bits here
006850  2  0A                       asl                          ;note that metatile format is:
006851  2  2A                       rol                          ;%xx000000 - attribute table bits,
006852  2  2A                       rol                          ;%00xxxxxx - metatile number
006853  2  A8                       tay                          ;rotate bits to d1-d0 and use as offset here
006854  2  B9 7F 6A                 lda MetatileGraphics_Low,y   ;get address to graphics table from here
006857  2  85 06                    sta $06
006859  2  B9 83 6A                 lda MetatileGraphics_High,y
00685C  2  85 07                    sta $07
00685E  2  BD A1 06                 lda MetatileBuffer,x         ;get metatile number again
006861  2  0A                       asl                          ;multiply by 4 and use as tile offset
006862  2  0A                       asl
006863  2  85 02                    sta $02
006865  2  AD 1F 07                 lda AreaParserTaskNum        ;get current task number for level processing and
006868  2  29 01                    and #%00000001               ;mask out all but LSB, then invert LSB, multiply by 2
00686A  2  49 01                    eor #%00000001               ;to get the correct column position in the metatile,
00686C  2  0A                       asl                          ;then add to the tile offset so we can draw either side
00686D  2  65 02                    adc $02                      ;of the metatiles
00686F  2  A8                       tay
006870  2  A6 00                    ldx $00                      ;use vram buffer offset from before as X
006872  2  B1 06                    lda ($06),y
006874  2  9D 44 03                 sta VRAM_Buffer2+3,x         ;get first tile number (top left or top right) and store
006877  2  C8                       iny
006878  2  B1 06                    lda ($06),y                  ;now get the second (bottom left or bottom right) and store
00687A  2  9D 45 03                 sta VRAM_Buffer2+4,x
00687D  2  A4 04                    ldy $04                      ;get current attribute row
00687F  2  A5 05                    lda $05                      ;get LSB of current column where we're at, and
006881  2  D0 0E                    bne RightCheck               ;branch if set (clear = left attrib, set = right)
006883  2  A5 01                    lda $01                      ;get current row we're rendering
006885  2  4A                       lsr                          ;branch if LSB set (clear = top left, set = bottom left)
006886  2  B0 19                    bcs LLeft
006888  2  26 03                    rol $03                      ;rotate attribute bits 3 to the left
00688A  2  26 03                    rol $03                      ;thus in d1-d0, for upper left square
00688C  2  26 03                    rol $03
00688E  2  4C A7 68                 jmp SetAttrib
006891  2  A5 01        RightCheck: lda $01                      ;get LSB of current row we're rendering
006893  2  4A                       lsr                          ;branch if set (clear = top right, set = bottom right)
006894  2  B0 0F                    bcs NextMTRow
006896  2  46 03                    lsr $03                      ;shift attribute bits 4 to the right
006898  2  46 03                    lsr $03                      ;thus in d3-d2, for upper right square
00689A  2  46 03                    lsr $03
00689C  2  46 03                    lsr $03
00689E  2  4C A7 68                 jmp SetAttrib
0068A1  2  46 03        LLeft:      lsr $03                      ;shift attribute bits 2 to the right
0068A3  2  46 03                    lsr $03                      ;thus in d5-d4 for lower left square
0068A5  2  E6 04        NextMTRow:  inc $04                      ;move onto next attribute row
0068A7  2  B9 F9 03     SetAttrib:  lda AttributeBuffer,y        ;get previously saved bits from before
0068AA  2  05 03                    ora $03                      ;if any, and put new bits, if any, onto
0068AC  2  99 F9 03                 sta AttributeBuffer,y        ;the old, and store
0068AF  2  E6 00                    inc $00                      ;increment vram buffer offset by 2
0068B1  2  E6 00                    inc $00
0068B3  2  A6 01                    ldx $01                      ;get current gfx buffer row, and check for
0068B5  2  E8                       inx                          ;the bottom of the screen
0068B6  2  E0 0D                    cpx #$0d
0068B8  2  90 8D                    bcc DrawMTLoop               ;if not there yet, loop back
0068BA  2  A4 00                    ldy $00                      ;get current vram buffer offset, increment by 3
0068BC  2  C8                       iny                          ;(for name table address and length bytes)
0068BD  2  C8                       iny
0068BE  2  C8                       iny
0068BF  2  A9 00                    lda #$00
0068C1  2  99 41 03                 sta VRAM_Buffer2,y           ;put null terminator at end of data for name table
0068C4  2  8C 40 03                 sty VRAM_Buffer2_Offset      ;store new buffer offset
0068C7  2  EE 21 07                 inc CurrentNTAddr_Low        ;increment name table address low
0068CA  2  AD 21 07                 lda CurrentNTAddr_Low        ;check current low byte
0068CD  2  29 1F                    and #%00011111               ;if no wraparound, just skip this part
0068CF  2  D0 0D                    bne ExitDrawM
0068D1  2  A9 80                    lda #$80                     ;if wraparound occurs, make sure low byte stays
0068D3  2  8D 21 07                 sta CurrentNTAddr_Low        ;just under the status bar
0068D6  2  AD 20 07                 lda CurrentNTAddr_High       ;and then invert d2 of the name table address high
0068D9  2  49 04                    eor #%00000100               ;to move onto the next appropriate name table
0068DB  2  8D 20 07                 sta CurrentNTAddr_High
0068DE  2  4C 34 69     ExitDrawM:  jmp SetVRAMCtrl              ;jump to set VRAM address controller
0068E1  2               
0068E1  2               RenderAttributeTables:
0068E1  2  AD 21 07                  lda CurrentNTAddr_Low    ;get low byte of next name table address
0068E4  2  29 1F                     and #%00011111           ;to be written to, mask out all but 5 LSB,
0068E6  2  38                        sec                      ;subtract four
0068E7  2  E9 04                     sbc #$04
0068E9  2  29 1F                     and #%00011111           ;mask out bits again and store
0068EB  2  85 01                     sta $01
0068ED  2  AD 20 07                  lda CurrentNTAddr_High   ;get high byte and branch if borrow not set
0068F0  2  B0 02                     bcs SetATHigh
0068F2  2  49 04                     eor #%00000100           ;otherwise invert d2
0068F4  2  29 04        SetATHigh:   and #%00000100           ;mask out all other bits
0068F6  2  09 23                     ora #$23                 ;add $2300 (for attribute table) to the high byte
0068F8  2  85 00                     sta $00
0068FA  2  A5 01                     lda $01                  ;get low byte - 4, divide by 4, add offset for
0068FC  2  4A                        lsr                      ;attribute table and store
0068FD  2  4A                        lsr
0068FE  2  69 C0                     adc #$c0                 ;we should now have the appropriate block of
006900  2  85 01                     sta $01                  ;attribute table in our temp address
006902  2  A2 00                     ldx #$00
006904  2  AC 40 03                  ldy VRAM_Buffer2_Offset  ;get buffer offset
006907  2  A5 00        AttribLoop:  lda $00
006909  2  99 41 03                  sta VRAM_Buffer2,y       ;store high byte of attribute table address
00690C  2  A5 01                     lda $01
00690E  2  18                        clc                      ;get low byte, add 8 because we want to start
00690F  2  69 08                     adc #$08                 ;below the status bar, and store
006911  2  99 42 03                  sta VRAM_Buffer2+1,y
006914  2  85 01                     sta $01                  ;also store in temp again
006916  2  BD F9 03                  lda AttributeBuffer,x    ;fetch current attribute table byte and store
006919  2  99 44 03                  sta VRAM_Buffer2+3,y     ;in the buffer
00691C  2  A9 01                     lda #$01
00691E  2  99 43 03                  sta VRAM_Buffer2+2,y     ;store length of 1 in buffer
006921  2  4A                        lsr
006922  2  9D F9 03                  sta AttributeBuffer,x    ;clear current byte in attribute buffer
006925  2  C8                        iny                      ;increment buffer offset by 4 bytes
006926  2  C8                        iny
006927  2  C8                        iny
006928  2  C8                        iny
006929  2  E8                        inx                      ;increment attribute offset and check to see
00692A  2  E0 07                     cpx #$07                 ;if we're at the end yet
00692C  2  90 D9                     bcc AttribLoop
00692E  2  99 41 03                  sta VRAM_Buffer2,y       ;put null terminator at the end
006931  2  8C 40 03                  sty VRAM_Buffer2_Offset  ;store offset in case we want to do any more
006934  2  A9 06        SetVRAMCtrl: lda #$06
006936  2  8D 73 07                  sta VRAM_Buffer_AddrCtrl ;set VRAM address controller to second VRAM buffer
006939  2  60                        rts
00693A  2               
00693A  2               ;-------------------------------------------------------------------------------------
00693A  2               ;$00 - used as temporary counter in ColorRotation
00693A  2               
00693A  2               ColorRotatePalette:
00693A  2  27 27 27 17         .byte $27, $27, $27, $17, $07, $17
00693E  2  07 17        
006940  2               
006940  2               BlankPalette:
006940  2  3F 0C 04 FF         .byte $3f, $0c, $04, $ff, $ff, $ff, $ff, $00
006944  2  FF FF FF 00  
006948  2               
006948  2               ;used based on area type
006948  2               Palette3Data:
006948  2  0F 07 12 0F         .byte $0f, $07, $12, $0f
00694C  2  0F 07 17 0F         .byte $0f, $07, $17, $0f
006950  2  0F 07 17 1C         .byte $0f, $07, $17, $1c
006954  2  0F 07 17 00         .byte $0f, $07, $17, $00
006958  2               
006958  2               ColorRotation:
006958  2  A5 09                      lda FrameCounter         ;get frame counter
00695A  2  29 07                      and #$07                 ;mask out all but three LSB
00695C  2  D0 51                      bne ExitColorRot         ;branch if not set to zero to do this every eighth frame
00695E  2  AE 00 03                   ldx VRAM_Buffer1_Offset  ;check vram buffer offset
006961  2  E0 31                      cpx #$31
006963  2  B0 4A                      bcs ExitColorRot         ;if offset over 48 bytes, branch to leave
006965  2  A8                         tay                      ;otherwise use frame counter's 3 LSB as offset here
006966  2  B9 40 69     GetBlankPal:  lda BlankPalette,y       ;get blank palette for palette 3
006969  2  9D 01 03                   sta VRAM_Buffer1,x       ;store it in the vram buffer
00696C  2  E8                         inx                      ;increment offsets
00696D  2  C8                         iny
00696E  2  C0 08                      cpy #$08
006970  2  90 F4                      bcc GetBlankPal          ;do this until all bytes are copied
006972  2  AE 00 03                   ldx VRAM_Buffer1_Offset  ;get current vram buffer offset
006975  2  A9 03                      lda #$03
006977  2  85 00                      sta $00                  ;set counter here
006979  2  AD 4E 07                   lda AreaType             ;get area type
00697C  2  0A                         asl                      ;multiply by 4 to get proper offset
00697D  2  0A                         asl
00697E  2  A8                         tay                      ;save as offset here
00697F  2  B9 48 69     GetAreaPal:   lda Palette3Data,y       ;fetch palette to be written based on area type
006982  2  9D 04 03                   sta VRAM_Buffer1+3,x     ;store it to overwrite blank palette in vram buffer
006985  2  C8                         iny
006986  2  E8                         inx
006987  2  C6 00                      dec $00                  ;decrement counter
006989  2  10 F4                      bpl GetAreaPal           ;do this until the palette is all copied
00698B  2  AE 00 03                   ldx VRAM_Buffer1_Offset  ;get current vram buffer offset
00698E  2  AC D4 06                   ldy ColorRotateOffset    ;get color cycling offset
006991  2  B9 3A 69                   lda ColorRotatePalette,y
006994  2  9D 05 03                   sta VRAM_Buffer1+4,x     ;get and store current color in second slot of palette
006997  2  AD 00 03                   lda VRAM_Buffer1_Offset
00699A  2  18                         clc                      ;add seven bytes to vram buffer offset
00699B  2  69 07                      adc #$07
00699D  2  8D 00 03                   sta VRAM_Buffer1_Offset
0069A0  2  EE D4 06                   inc ColorRotateOffset    ;increment color cycling offset
0069A3  2  AD D4 06                   lda ColorRotateOffset
0069A6  2  C9 06                      cmp #$06                 ;check to see if it's still in range
0069A8  2  90 05                      bcc ExitColorRot         ;if so, branch to leave
0069AA  2  A9 00                      lda #$00
0069AC  2  8D D4 06                   sta ColorRotateOffset    ;otherwise, init to keep it in range
0069AF  2  60           ExitColorRot: rts                      ;leave
0069B0  2               
0069B0  2               ;-------------------------------------------------------------------------------------
0069B0  2               ;$00 - temp store for offset control bit
0069B0  2               ;$01 - temp vram buffer offset
0069B0  2               ;$02 - temp store for vertical high nybble in block buffer routine
0069B0  2               ;$03 - temp adder for high byte of name table address
0069B0  2               ;$04, $05 - name table address low/high
0069B0  2               ;$06, $07 - block buffer address low/high
0069B0  2               
0069B0  2               BlockGfxData:
0069B0  2  45 45 47 47         .byte $45, $45, $47, $47
0069B4  2  47 47 47 47         .byte $47, $47, $47, $47
0069B8  2  57 58 59 5A         .byte $57, $58, $59, $5a
0069BC  2  24 24 24 24         .byte $24, $24, $24, $24
0069C0  2  26 26 26 26         .byte $26, $26, $26, $26
0069C4  2               
0069C4  2               RemoveCoin_Axe:
0069C4  2  A0 41                      ldy #$41                 ;set low byte so offset points to second vram buffer
0069C6  2  A9 03                      lda #$03                 ;load offset for default blank metatile
0069C8  2  AE 4E 07                   ldx AreaType             ;check area type
0069CB  2  D0 02                      bne WriteBlankMT         ;if not water type, use offset
0069CD  2  A9 04                      lda #$04                 ;otherwise load offset for blank metatile used in water
0069CF  2  20 0E 6A     WriteBlankMT: jsr PutBlockMetatile     ;do a sub to write blank metatile to vram buffer
0069D2  2  A9 06                      lda #$06
0069D4  2  8D 73 07                   sta VRAM_Buffer_AddrCtrl ;set vram address controller to second vram buffer and leave
0069D7  2  60                         rts
0069D8  2               
0069D8  2               ReplaceBlockMetatile:
0069D8  2  20 E4 69            jsr WriteBlockMetatile    ;write metatile to vram buffer to replace block object
0069DB  2  EE F0 03            inc Block_ResidualCounter ;increment unused counter (residual code)
0069DE  2  DE EC 03            dec Block_RepFlag,x       ;decrement flag (residual code)
0069E1  2  60                  rts                       ;leave
0069E2  2               
0069E2  2               DestroyBlockMetatile:
0069E2  2  A9 00               lda #$00       ;force blank metatile if branched/jumped to this point
0069E4  2               
0069E4  2               WriteBlockMetatile:
0069E4  2  A0 03                     ldy #$03                ;load offset for blank metatile
0069E6  2  C9 00                     cmp #$00                ;check contents of A for blank metatile
0069E8  2  F0 14                     beq UseBOffset          ;branch if found (unconditional if destroying metatile)
0069EA  2  A0 00                     ldy #$00                ;load offset for brick metatile w/ line
0069EC  2               .ifdef ANN
0069EC  2  C9 57                     cmp #$57
0069EE  2               .else
0069EE  2                            cmp #$56
0069EE  2               .endif
0069EE  2  F0 0E                     beq UseBOffset          ;use offset if metatile is brick with coins (w/ line)
0069F0  2               .ifdef ANN
0069F0  2  C9 51                     cmp #$51
0069F2  2               .else
0069F2  2                            cmp #$4f
0069F2  2               .endif
0069F2  2  F0 0A                     beq UseBOffset          ;use offset if metatile is breakable brick w/ line
0069F4  2  C8                        iny                     ;increment offset for brick metatile w/o line
0069F5  2  C9 5C                     cmp #$5c
0069F7  2  F0 05                     beq UseBOffset          ;use offset if metatile is brick with coins (w/o line)
0069F9  2               .ifdef ANN
0069F9  2  C9 52                     cmp #$52
0069FB  2               .else
0069FB  2                            cmp #$50
0069FB  2               .endif
0069FB  2  F0 01                     beq UseBOffset          ;use offset if metatile is breakable brick w/o line
0069FD  2  C8                        iny                     ;if any other metatile, increment offset for empty block
0069FE  2  98           UseBOffset:  tya                     ;put Y in A
0069FF  2  AC 00 03                  ldy VRAM_Buffer1_Offset ;get vram buffer offset
006A02  2  C8                        iny                     ;move onto next byte
006A03  2  20 0E 6A                  jsr PutBlockMetatile    ;get appropriate block data and write to vram buffer
006A06  2  88           MoveVOffset: dey                     ;decrement vram buffer offset
006A07  2  98                        tya                     ;add 10 bytes to it
006A08  2  18                        clc
006A09  2  69 0A                     adc #10
006A0B  2  4C 1B 66                  jmp SetVRAMOffset       ;branch to store as new vram buffer offset
006A0E  2               
006A0E  2               PutBlockMetatile:
006A0E  2  86 00                    stx $00               ;store control bit from SprDataOffset_Ctrl
006A10  2  84 01                    sty $01               ;store vram buffer offset for next byte
006A12  2  0A                       asl
006A13  2  0A                       asl                   ;multiply A by four and use as X
006A14  2  AA                       tax
006A15  2  A0 20                    ldy #$20              ;load high byte for name table 0
006A17  2  A5 06                    lda $06               ;get low byte of block buffer pointer
006A19  2  C9 D0                    cmp #$d0              ;check to see if we're on odd-page block buffer
006A1B  2  90 02                    bcc SaveHAdder        ;if not, use current high byte
006A1D  2  A0 24                    ldy #$24              ;otherwise load high byte for name table 1
006A1F  2  84 03        SaveHAdder: sty $03               ;save high byte here
006A21  2  29 0F                    and #$0f              ;mask out high nybble of block buffer pointer
006A23  2  0A                       asl                   ;multiply by 2 to get appropriate name table low byte
006A24  2  85 04                    sta $04               ;and then store it here
006A26  2  A9 00                    lda #$00
006A28  2  85 05                    sta $05               ;initialize temp high byte
006A2A  2  A5 02                    lda $02               ;get vertical high nybble offset used in block buffer routine
006A2C  2  18                       clc
006A2D  2  69 20                    adc #$20              ;add 32 pixels for the status bar
006A2F  2  0A                       asl
006A30  2  26 05                    rol $05               ;shift and rotate d7 onto d0 and d6 into carry
006A32  2  0A                       asl
006A33  2  26 05                    rol $05               ;shift and rotate d6 onto d0 and d5 into carry
006A35  2  65 04                    adc $04               ;add low byte of name table and carry to vertical high nybble
006A37  2  85 04                    sta $04               ;and store here
006A39  2  A5 05                    lda $05               ;get whatever was in d7 and d6 of vertical high nybble
006A3B  2  69 00                    adc #$00              ;add carry
006A3D  2  18                       clc
006A3E  2  65 03                    adc $03               ;then add high byte of name table
006A40  2  85 05                    sta $05               ;store here
006A42  2  A4 01                    ldy $01               ;get vram buffer offset to be used
006A44  2  BD B0 69     RemBridge:  lda BlockGfxData,x    ;write top left and top right
006A47  2  99 03 03                 sta VRAM_Buffer1+2,y  ;tile numbers into first spot
006A4A  2  BD B1 69                 lda BlockGfxData+1,x
006A4D  2  99 04 03                 sta VRAM_Buffer1+3,y
006A50  2  BD B2 69                 lda BlockGfxData+2,x  ;write bottom left and bottom
006A53  2  99 08 03                 sta VRAM_Buffer1+7,y  ;right tiles numbers into
006A56  2  BD B3 69                 lda BlockGfxData+3,x  ;second spot
006A59  2  99 09 03                 sta VRAM_Buffer1+8,y
006A5C  2  A5 04                    lda $04
006A5E  2  99 01 03                 sta VRAM_Buffer1,y    ;write low byte of name table
006A61  2  18                       clc                   ;into first slot as read
006A62  2  69 20                    adc #$20              ;add 32 bytes to value
006A64  2  99 06 03                 sta VRAM_Buffer1+5,y  ;write low byte of name table
006A67  2  A5 05                    lda $05               ;plus 32 bytes into second slot
006A69  2  99 00 03                 sta VRAM_Buffer1-1,y  ;write high byte of name
006A6C  2  99 05 03                 sta VRAM_Buffer1+4,y  ;table address to both slots
006A6F  2  A9 02                    lda #$02
006A71  2  99 02 03                 sta VRAM_Buffer1+1,y  ;put length of 2 in
006A74  2  99 07 03                 sta VRAM_Buffer1+6,y  ;both slots
006A77  2  A9 00                    lda #$00
006A79  2  99 0A 03                 sta VRAM_Buffer1+9,y  ;put null terminator at end
006A7C  2  A6 00                    ldx $00               ;get offset control bit here
006A7E  2  60                       rts                   ;and leave
006A7F  2               
006A7F  2               ;-------------------------------------------------------------------------------------
006A7F  2               ;METATILE GRAPHICS TABLE
006A7F  2               
006A7F  2               MetatileGraphics_Low:
006A7F  2  87 23 DF 07    .byte <Palette0_MTiles, <Palette1_MTiles, <Palette2_MTiles, <Palette3_MTiles
006A83  2               
006A83  2               MetatileGraphics_High:
006A83  2  6A 6B 6B 6C    .byte >Palette0_MTiles, >Palette1_MTiles, >Palette2_MTiles, >Palette3_MTiles
006A87  2               
006A87  2               .ifdef ANN
006A87  2               ; ann metatiles are mostly copied from smb1, not completely
006A87  2               Palette0_MTiles:
006A87  2  24 24 24 24    .byte $24, $24, $24, $24 ;blank
006A8B  2  27 27 27 27    .byte $27, $27, $27, $27 ;black metatile
006A8F  2  24 24 24 35    .byte $24, $24, $24, $35 ;bush left
006A93  2  36 25 37 25    .byte $36, $25, $37, $25 ;bush middle
006A97  2  24 38 24 24    .byte $24, $38, $24, $24 ;bush right
006A9B  2  24 30 30 26    .byte $24, $30, $30, $26 ;mountain left
006A9F  2  26 26 34 26    .byte $26, $26, $34, $26 ;mountain left bottom/middle center
006AA3  2  24 31 24 32    .byte $24, $31, $24, $32 ;mountain middle top
006AA7  2  33 26 24 33    .byte $33, $26, $24, $33 ;mountain right
006AAB  2  34 26 26 26    .byte $34, $26, $26, $26 ;mountain right bottom
006AAF  2  26 26 26 26    .byte $26, $26, $26, $26 ;mountain middle bottom
006AB3  2  24 C0 24 C0    .byte $24, $c0, $24, $c0 ;bridge guardrail
006AB7  2  24 7F 7F 24    .byte $24, $7f, $7f, $24 ;chain
006ABB  2  B8 BA B9 BB    .byte $b8, $ba, $b9, $bb ;tall tree top, top half
006ABF  2  B8 BC B9 BD    .byte $b8, $bc, $b9, $bd ;short tree top
006AC3  2  BA BC BB BD    .byte $ba, $bc, $bb, $bd ;tall tree top, bottom half
006AC7  2  60 64 61 65    .byte $60, $64, $61, $65 ;warp pipe end left, points up
006ACB  2  62 66 63 67    .byte $62, $66, $63, $67 ;warp pipe end right, points up
006ACF  2  60 64 61 65    .byte $60, $64, $61, $65 ;decoration pipe end left, points up
006AD3  2  62 66 63 67    .byte $62, $66, $63, $67 ;decoration pipe end right, points up
006AD7  2  68 68 69 69    .byte $68, $68, $69, $69 ;pipe shaft left
006ADB  2  26 26 6A 6A    .byte $26, $26, $6a, $6a ;pipe shaft right
006ADF  2  4B 4C 4D 4E    .byte $4b, $4c, $4d, $4e ;tree ledge left edge
006AE3  2  4D 4F 4D 4F    .byte $4d, $4f, $4d, $4f ;tree ledge middle
006AE7  2  4D 4E 50 51    .byte $4d, $4e, $50, $51 ;tree ledge right edge
006AEB  2  6B 70 2C 2D    .byte $6b, $70, $2c, $2d ;mushroom left edge
006AEF  2  6C 71 6D 72    .byte $6c, $71, $6d, $72 ;mushroom middle
006AF3  2  6E 73 6F 74    .byte $6e, $73, $6f, $74 ;mushroom right edge
006AF7  2  86 8A 87 8B    .byte $86, $8a, $87, $8b ;sideways pipe end top
006AFB  2  88 8C 88 8C    .byte $88, $8c, $88, $8c ;sideways pipe shaft top
006AFF  2  89 8D 69 69    .byte $89, $8d, $69, $69 ;sideways pipe joint top
006B03  2  8E 91 8F 92    .byte $8e, $91, $8f, $92 ;sideways pipe end bottom
006B07  2  26 93 26 93    .byte $26, $93, $26, $93 ;sideways pipe shaft bottom
006B0B  2  90 94 69 69    .byte $90, $94, $69, $69 ;sideways pipe joint bottom
006B0F  2  A4 E9 EA EB    .byte $a4, $e9, $ea, $eb ;seaplant
006B13  2  24 24 24 24    .byte $24, $24, $24, $24 ;blank, used on bricks or blocks that are hit
006B17  2  24 2F 24 3D    .byte $24, $2f, $24, $3d ;flagpole ball
006B1B  2  A2 A2 A3 A3    .byte $a2, $a2, $a3, $a3 ;flagpole shaft
006B1F  2  24 24 24 24    .byte $24, $24, $24, $24 ;blank, used in conjunction with vines
006B23  2               
006B23  2               Palette1_MTiles:
006B23  2  A2 A2 A3 A3    .byte $a2, $a2, $a3, $a3 ;vertical rope
006B27  2  99 24 99 24    .byte $99, $24, $99, $24 ;horizontal rope
006B2B  2  24 A2 3E 3F    .byte $24, $a2, $3e, $3f ;left pulley
006B2F  2  5B 5C 24 A3    .byte $5b, $5c, $24, $a3 ;right pulley
006B33  2  24 24 24 24    .byte $24, $24, $24, $24 ;blank used for balance rope
006B37  2  9D 47 9E 47    .byte $9d, $47, $9e, $47 ;castle top
006B3B  2  47 47 27 27    .byte $47, $47, $27, $27 ;castle window left
006B3F  2  47 47 47 47    .byte $47, $47, $47, $47 ;castle brick wall
006B43  2  27 27 47 47    .byte $27, $27, $47, $47 ;castle window right
006B47  2  A9 47 AA 47    .byte $a9, $47, $aa, $47 ;castle top w/ brick
006B4B  2  9B 27 9C 27    .byte $9b, $27, $9c, $27 ;entrance top
006B4F  2  27 27 27 27    .byte $27, $27, $27, $27 ;entrance bottom
006B53  2  52 52 52 52    .byte $52, $52, $52, $52 ;green ledge stump
006B57  2  80 A0 81 A1    .byte $80, $a0, $81, $a1 ;fence
006B5B  2  BE BE BF BF    .byte $be, $be, $bf, $bf ;tree trunk
006B5F  2  75 BA 76 BB    .byte $75, $ba, $76, $bb ;mushroom stump top
006B63  2  BA BA BB BB    .byte $ba, $ba, $bb, $bb ;mushroom stump bottom
006B67  2  45 47 45 47    .byte $45, $47, $45, $47 ;breakable brick w/ line
006B6B  2  47 47 47 47    .byte $47, $47, $47, $47 ;breakable brick
006B6F  2  45 47 45 47    .byte $45, $47, $45, $47 ;breakable brick (not used)
006B73  2  45 47 45 47    .byte $45, $47, $45, $47 ;brick with line (power-up)
006B77  2  45 47 45 47    .byte $45, $47, $45, $47 ;brick with line (vine)
006B7B  2  45 47 45 47    .byte $45, $47, $45, $47 ;brick with line (star)
006B7F  2  45 47 45 47    .byte $45, $47, $45, $47 ;brick with line (coins)
006B83  2  45 47 45 47    .byte $45, $47, $45, $47 ;brick with line (1-up)
006B87  2  47 47 47 47    .byte $47, $47, $47, $47 ;brick (power-up)
006B8B  2  47 47 47 47    .byte $47, $47, $47, $47 ;brick (vine)
006B8F  2  47 47 47 47    .byte $47, $47, $47, $47 ;brick (star)
006B93  2  47 47 47 47    .byte $47, $47, $47, $47 ;brick (coins)
006B97  2  47 47 47 47    .byte $47, $47, $47, $47 ;brick (1-up)
006B9B  2  24 24 24 24    .byte $24, $24, $24, $24 ;hidden block (1 coin)
006B9F  2  24 24 24 24    .byte $24, $24, $24, $24 ;hidden block (1-up)
006BA3  2  24 24 24 24    .byte $24, $24, $24, $24 ;hidden block (power-up)
006BA7  2  AB AC AD AE    .byte $ab, $ac, $ad, $ae ;solid block (3-d block)
006BAB  2  5D 5E 5D 5E    .byte $5d, $5e, $5d, $5e ;solid block (white wall)
006BAF  2  C1 24 C1 24    .byte $c1, $24, $c1, $24 ;bridge
006BB3  2  C6 C8 C7 C9    .byte $c6, $c8, $c7, $c9 ;bullet bill cannon barrel
006BB7  2  CA CC CB CD    .byte $ca, $cc, $cb, $cd ;bullet bill cannon top
006BBB  2  2A 2A 40 40    .byte $2a, $2a, $40, $40 ;bullet bill cannon bottom
006BBF  2  24 24 24 24    .byte $24, $24, $24, $24 ;blank used for jumpspring
006BC3  2  24 47 24 47    .byte $24, $47, $24, $47 ;half brick used for jumpspring
006BC7  2  82 83 84 85    .byte $82, $83, $84, $85 ;solid block (water level, green rock)
006BCB  2  B4 B6 B5 B7    .byte $b4, $b6, $b5, $b7 ;cracked rock terrain
006BCF  2  24 47 24 47    .byte $24, $47, $24, $47 ;half brick (not used)
006BD3  2  86 8A 87 8B    .byte $86, $8a, $87, $8b ;water pipe top
006BD7  2  8E 91 8F 92    .byte $8e, $91, $8f, $92 ;water pipe bottom
006BDB  2  24 2F 24 3D    .byte $24, $2f, $24, $3d ;flag ball (residual object)
006BDF  2               
006BDF  2               Palette2_MTiles:
006BDF  2  24 24 24 35    .byte $24, $24, $24, $35 ;cloud left
006BE3  2  36 25 37 25    .byte $36, $25, $37, $25 ;cloud middle
006BE7  2  24 38 24 24    .byte $24, $38, $24, $24 ;cloud right
006BEB  2  24 24 39 24    .byte $24, $24, $39, $24 ;cloud bottom left
006BEF  2  3A 24 3B 24    .byte $3a, $24, $3b, $24 ;cloud bottom middle
006BF3  2  3C 24 24 24    .byte $3c, $24, $24, $24 ;cloud bottom right
006BF7  2  41 26 41 26    .byte $41, $26, $41, $26 ;water/lava top
006BFB  2  26 26 26 26    .byte $26, $26, $26, $26 ;water/lava
006BFF  2  B0 B1 B2 B3    .byte $b0, $b1, $b2, $b3 ;cloud level terrain
006C03  2  77 79 77 79    .byte $77, $79, $77, $79 ;bowser's bridge
006C07  2               
006C07  2               Palette3_MTiles:
006C07  2  53 55 54 56    .byte $53, $55, $54, $56 ;question block (coin)
006C0B  2  53 55 54 56    .byte $53, $55, $54, $56 ;question block (power-up)
006C0F  2  A5 A7 A6 A8    .byte $a5, $a7, $a6, $a8 ;coin
006C13  2  C2 C4 C3 C5    .byte $c2, $c4, $c3, $c5 ;underwater coin
006C17  2  57 59 58 5A    .byte $57, $59, $58, $5a ;empty block
006C1B  2  7B 7D 7C 7E    .byte $7b, $7d, $7c, $7e ;axe
006C1F  2               .else
006C1F  2               
006C1F  2               Palette0_MTiles:
006C1F  2                 .byte $24, $24, $24, $24 ;blank
006C1F  2                 .byte $27, $27, $27, $27 ;black metatile
006C1F  2                 .byte $24, $24, $24, $35 ;bush left
006C1F  2                 .byte $36, $25, $37, $25 ;bush middle
006C1F  2                 .byte $24, $38, $24, $24 ;bush right
006C1F  2                 .byte $24, $30, $30, $26 ;mountain left
006C1F  2                 .byte $26, $26, $34, $26 ;mountain left bottom/middle center
006C1F  2                 .byte $24, $31, $24, $32 ;mountain middle top
006C1F  2                 .byte $33, $26, $24, $33 ;mountain right
006C1F  2                 .byte $34, $26, $26, $26 ;mountain right bottom
006C1F  2                 .byte $26, $26, $26, $26 ;mountain middle bottom
006C1F  2                 .byte $24, $c0, $24, $c0 ;bridge guardrail
006C1F  2                 .byte $24, $7f, $7f, $24 ;chain
006C1F  2                 .byte $b8, $ba, $b9, $bb ;tall tree top, top half
006C1F  2                 .byte $b8, $bc, $b9, $bd ;short tree top
006C1F  2                 .byte $ba, $bc, $bb, $bd ;tall tree top, bottom half
006C1F  2                 .byte $60, $64, $61, $65 ;warp pipe end left, points up
006C1F  2                 .byte $62, $66, $63, $67 ;warp pipe end right, points up
006C1F  2                 .byte $60, $64, $61, $65 ;decoration pipe end left, points up
006C1F  2                 .byte $62, $66, $63, $67 ;decoration pipe end right, points up
006C1F  2                 .byte $68, $68, $69, $69 ;pipe shaft left
006C1F  2                 .byte $26, $26, $6a, $6a ;pipe shaft right
006C1F  2                 .byte $4b, $4c, $4d, $4e ;tree ledge left edge
006C1F  2                 .byte $4d, $4f, $4d, $4f ;tree ledge middle
006C1F  2                 .byte $4d, $4e, $50, $51 ;tree ledge right edge
006C1F  2                 .byte $86, $8a, $87, $8b ;sideways pipe end top
006C1F  2                 .byte $88, $8c, $88, $8c ;sideways pipe shaft top
006C1F  2                 .byte $89, $8d, $69, $69 ;sideways pipe joint top
006C1F  2                 .byte $8e, $91, $8f, $92 ;sideways pipe end bottom
006C1F  2                 .byte $26, $93, $26, $93 ;sideways pipe shaft bottom
006C1F  2                 .byte $90, $94, $69, $69 ;sideways pipe joint bottom
006C1F  2                 .byte $a4, $e9, $ea, $eb ;seaplant
006C1F  2                 .byte $24, $24, $24, $24 ;blank, used on bricks or blocks that are hit
006C1F  2                 .byte $24, $2f, $24, $3d ;flagpole ball
006C1F  2                 .byte $a2, $a2, $a3, $a3 ;flagpole shaft
006C1F  2                 .byte $24, $24, $24, $24 ;blank, used in conjunction with vines
006C1F  2               
006C1F  2               Palette1_MTiles:
006C1F  2                 .byte $a2, $a2, $a3, $a3 ;vertical rope
006C1F  2                 .byte $99, $24, $99, $24 ;horizontal rope
006C1F  2                 .byte $24, $a2, $3e, $3f ;left pulley
006C1F  2                 .byte $5b, $5c, $24, $a3 ;right pulley
006C1F  2                 .byte $24, $24, $24, $24 ;blank used for balance rope
006C1F  2                 .byte $9d, $47, $9e, $47 ;castle top
006C1F  2                 .byte $47, $47, $27, $27 ;castle window left
006C1F  2                 .byte $47, $47, $47, $47 ;castle brick wall
006C1F  2                 .byte $27, $27, $47, $47 ;castle window right
006C1F  2                 .byte $a9, $47, $aa, $47 ;castle top w/ brick
006C1F  2                 .byte $9b, $27, $9c, $27 ;entrance top
006C1F  2                 .byte $27, $27, $27, $27 ;entrance bottom
006C1F  2                 .byte $52, $52, $52, $52 ;green ledge stump
006C1F  2                 .byte $80, $a0, $81, $a1 ;fence
006C1F  2                 .byte $be, $be, $bf, $bf ;tree trunk
006C1F  2                 .byte $45, $47, $45, $47 ;breakable brick w/ line
006C1F  2                 .byte $47, $47, $47, $47 ;breakable brick
006C1F  2                 .byte $45, $47, $45, $47 ;breakable brick (not used)
006C1F  2                 .byte $45, $47, $45, $47 ;brick with line (power-up)
006C1F  2                 .byte $45, $47, $45, $47 ;brick with line (poison shroom)
006C1F  2                 .byte $45, $47, $45, $47 ;brick with line (vine)
006C1F  2                 .byte $45, $47, $45, $47 ;brick with line (star)
006C1F  2                 .byte $45, $47, $45, $47 ;brick with line (coins)
006C1F  2                 .byte $45, $47, $45, $47 ;brick with line (1-up)
006C1F  2                 .byte $47, $47, $47, $47 ;brick (power-up)
006C1F  2                 .byte $47, $47, $47, $47 ;brick (poison shroom)
006C1F  2                 .byte $47, $47, $47, $47 ;brick (vine)
006C1F  2                 .byte $47, $47, $47, $47 ;brick (star)
006C1F  2                 .byte $47, $47, $47, $47 ;brick (coins)
006C1F  2                 .byte $47, $47, $47, $47 ;brick (1-up)
006C1F  2                 .byte $24, $24, $24, $24 ;hidden block (1 coin)
006C1F  2                 .byte $24, $24, $24, $24 ;hidden block (1-up)
006C1F  2                 .byte $24, $24, $24, $24 ;hidden block (poison shroom)
006C1F  2                 .byte $24, $24, $24, $24 ;hidden block (power-up)
006C1F  2                 .byte $ab, $ac, $ad, $ae ;solid block (3-d block)
006C1F  2                 .byte $5d, $5e, $5d, $5e ;solid block (white wall)
006C1F  2                 .byte $c1, $24, $c1, $24 ;bridge
006C1F  2                 .byte $c6, $c8, $c7, $c9 ;bullet bill cannon barrel
006C1F  2                 .byte $ca, $cc, $cb, $cd ;bullet bill cannon top
006C1F  2                 .byte $2a, $2a, $40, $40 ;bullet bill cannon bottom
006C1F  2                 .byte $24, $24, $24, $24 ;blank used for jumpspring
006C1F  2                 .byte $24, $47, $24, $47 ;half brick used for jumpspring
006C1F  2                 .byte $82, $83, $84, $85 ;solid block (water level, green rock)
006C1F  2                 .byte $b4, $b6, $b5, $b7 ;cracked rock terrain
006C1F  2                 .byte $24, $47, $24, $47 ;half brick (not used)
006C1F  2                 .byte $86, $8a, $87, $8b ;water pipe top
006C1F  2                 .byte $8e, $91, $8f, $92 ;water pipe bottom
006C1F  2                 .byte $24, $2f, $24, $3d ;flag ball (residual object)
006C1F  2               
006C1F  2               Palette2_MTiles:
006C1F  2                 .byte $24, $24, $24, $35 ;cloud left
006C1F  2                 .byte $36, $25, $37, $25 ;cloud middle
006C1F  2                 .byte $24, $38, $24, $24 ;cloud right
006C1F  2                 .byte $24, $24, $39, $24 ;cloud bottom left
006C1F  2                 .byte $3a, $24, $3b, $24 ;cloud bottom middle
006C1F  2                 .byte $3c, $24, $24, $24 ;cloud bottom right
006C1F  2                 .byte $41, $26, $41, $26 ;water/lava top
006C1F  2                 .byte $26, $26, $26, $26 ;water/lava
006C1F  2                 .byte $b0, $b1, $b2, $b3 ;cloud level terrain
006C1F  2                 .byte $77, $79, $77, $79 ;bowser's bridge
006C1F  2                 .byte $6b, $70, $2c, $2d ;cloud ledge left edge
006C1F  2                 .byte $6c, $71, $6d, $72 ;cloud ledge middle
006C1F  2                 .byte $6e, $73, $6f, $74 ;cloud ledge right edge
006C1F  2               
006C1F  2               Palette3_MTiles:
006C1F  2                 .byte $53, $55, $54, $56 ;question block (coin)
006C1F  2                 .byte $53, $55, $54, $56 ;question block (power-up)
006C1F  2                 .byte $53, $55, $54, $56 ;question block (poison shroom)
006C1F  2                 .byte $a5, $a7, $a6, $a8 ;coin
006C1F  2                 .byte $c2, $c4, $c3, $c5 ;underwater coin
006C1F  2                 .byte $57, $59, $58, $5a ;empty block
006C1F  2                 .byte $7b, $7d, $7c, $7e ;axe
006C1F  2               .endif
006C1F  2               
006C1F  2               ;------------------------------------------------------------------------------------
006C1F  2               
006C1F  2               WaterPaletteData:
006C1F  2  3F 00 20       .byte $3f, $00, $20
006C22  2  0F 15 12 25    .byte $0f, $15, $12, $25
006C26  2  0F 3A 1A 0F    .byte $0f, $3a, $1a, $0f
006C2A  2  0F 30 12 0F    .byte $0f, $30, $12, $0f
006C2E  2  0F 27 12 0F    .byte $0f, $27, $12, $0f
006C32  2  22 16 27 18    .byte $22, $16, $27, $18
006C36  2  0F 10 30 27    .byte $0f, $10, $30, $27
006C3A  2  0F 16 30 27    .byte $0f, $16, $30, $27
006C3E  2  0F 0F 30 10    .byte $0f, $0f, $30, $10
006C42  2  00             .byte $00
006C43  2               
006C43  2               GroundPaletteData:
006C43  2  3F 00 20       .byte $3f, $00, $20
006C46  2  0F 29 1A 0F    .byte $0f, $29, $1a, $0f
006C4A  2  0F 36 17 0F    .byte $0f, $36, $17, $0f
006C4E  2  0F 30 21 0F    .byte $0f, $30, $21, $0f
006C52  2  0F 27 17 0F    .byte $0f, $27, $17, $0f
006C56  2  0F 16 27 18    .byte $0f, $16, $27, $18
006C5A  2  0F 1A 30 27    .byte $0f, $1a, $30, $27
006C5E  2  0F 16 30 27    .byte $0f, $16, $30, $27
006C62  2  0F 0F 36 17    .byte $0f, $0f, $36, $17
006C66  2  00             .byte $00
006C67  2               
006C67  2               UndergroundPaletteData:
006C67  2  3F 00 20       .byte $3f, $00, $20
006C6A  2  0F 29 1A 09    .byte $0f, $29, $1a, $09
006C6E  2  0F 3C 1C 0F    .byte $0f, $3c, $1c, $0f
006C72  2  0F 30 21 1C    .byte $0f, $30, $21, $1c
006C76  2  0F 27 17 1C    .byte $0f, $27, $17, $1c
006C7A  2  0F 16 27 18    .byte $0f, $16, $27, $18
006C7E  2  0F 1C 36 17    .byte $0f, $1c, $36, $17
006C82  2  0F 16 30 27    .byte $0f, $16, $30, $27
006C86  2  0F 0C 3C 1C    .byte $0f, $0c, $3c, $1c
006C8A  2  00             .byte $00
006C8B  2               
006C8B  2               CastlePaletteData:
006C8B  2  3F 00 20       .byte $3f, $00, $20
006C8E  2  0F 30 10 00    .byte $0f, $30, $10, $00
006C92  2  0F 30 10 00    .byte $0f, $30, $10, $00
006C96  2  0F 30 16 00    .byte $0f, $30, $16, $00
006C9A  2  0F 27 17 00    .byte $0f, $27, $17, $00
006C9E  2  0F 16 27 18    .byte $0f, $16, $27, $18
006CA2  2  0F 1C 36 17    .byte $0f, $1c, $36, $17
006CA6  2  0F 16 30 27    .byte $0f, $16, $30, $27
006CAA  2  0F 00 30 10    .byte $0f, $00, $30, $10
006CAE  2  00             .byte $00
006CAF  2               
006CAF  2               DaySnowPaletteData:
006CAF  2  3F 00 04       .byte $3f, $00, $04
006CB2  2  22 30 00 10    .byte $22, $30, $00, $10
006CB6  2  00             .byte $00
006CB7  2               
006CB7  2               NightSnowPaletteData:
006CB7  2  3F 00 04       .byte $3f, $00, $04
006CBA  2  0F 30 00 10    .byte $0f, $30, $00, $10
006CBE  2  00             .byte $00
006CBF  2               
006CBF  2               MushroomPaletteData:
006CBF  2  3F 00 04       .byte $3f, $00, $04
006CC2  2  22 27 16 0F    .byte $22, $27, $16, $0f
006CC6  2  00             .byte $00
006CC7  2               
006CC7  2               BowserPaletteData:
006CC7  2  3F 14 04       .byte $3f, $14, $04
006CCA  2  0F 1A 30 27    .byte $0f, $1a, $30, $27
006CCE  2  00             .byte $00
006CCF  2               
006CCF  2               ThankYouMessage:
006CCF  2  25 48 10       .byte $25, $48, $10
006CD2  2  1D 11 0A 17    .byte $1d, $11, $0a, $17, $14, $24, $22, $18
006CD6  2  14 24 22 18  
006CDA  2  1E 24 16 0A    .byte $1e, $24, $16, $0a, $1b, $12, $18, $2b
006CDE  2  1B 12 18 2B  
006CE2  2  00             .byte $00
006CE3  2               
006CE3  2               MushroomRetainerMsg:
006CE3  2  25 C5 16       .byte $25, $c5, $16
006CE6  2  0B 1E 1D 24    .byte $0b, $1e, $1d, $24, $18, $1e, $1b, $24
006CEA  2  18 1E 1B 24  
006CEE  2  19 1B 12 17    .byte $19, $1b, $12, $17, $0c, $0e, $1c, $1c
006CF2  2  0C 0E 1C 1C  
006CF6  2  24 12 1C 24    .byte $24, $12, $1c, $24, $12, $17
006CFA  2  12 17        
006CFC  2  26 05 0F       .byte $26, $05, $0f
006CFF  2  0A 17 18 1D    .byte $0a, $17, $18, $1d, $11, $0e, $1b, $24
006D03  2  11 0E 1B 24  
006D07  2  0C 0A 1C 1D    .byte $0c, $0a, $1c, $1d, $15, $0e, $2b
006D0B  2  15 0E 2B     
006D0E  2  00             .byte $00
006D0F  2               
006D0F  2               ;------------------------------------------------------------------------------------
006D0F  2               
006D0F  2               JumpEngine:
006D0F  2  0A                  asl          ;shift bit from contents of A
006D10  2  A8                  tay
006D11  2  68                  pla          ;pull saved return address from stack
006D12  2  85 04               sta $04      ;save to indirect
006D14  2  68                  pla
006D15  2  85 05               sta $05
006D17  2  C8                  iny
006D18  2  B1 04               lda ($04),y  ;load pointer from indirect
006D1A  2  85 06               sta $06      ;note that if an RTS is performed in next routine
006D1C  2  C8                  iny          ;it will return to the execution before the sub
006D1D  2  B1 04               lda ($04),y  ;that called this routine
006D1F  2  85 07               sta $07
006D21  2  6C 06 00            jmp ($0006)  ;jump to the address we loaded
006D24  2               
006D24  2               ;------------------------------------------------------------------------------------
006D24  2               
006D24  2               InitializeNameTables:
006D24  2  AD 02 20                   lda PPU_STATUS            ;reset flip-flop
006D27  2  AD 78 07                   lda Mirror_PPU_CTRL       ;load mirror of first ppu control reg
006D2A  2  09 10                      ora #%00010000            ;set sprites for first 4k and background for second 4k
006D2C  2  29 F0                      and #%11110000            ;clear rest of lower nybble, leave higher alone
006D2E  2  20 F8 6D                   jsr WritePPUReg1
006D31  2  A9 24                      lda #$24                  ;set vram address to start of name table 1
006D33  2  20 38 6D                   jsr WriteNTAddr
006D36  2  A9 20                      lda #$20                  ;and then set it to name table 0
006D38  2  8D 06 20     WriteNTAddr:  sta PPU_ADDRESS
006D3B  2  A9 00                      lda #$00
006D3D  2  8D 06 20                   sta PPU_ADDRESS
006D40  2  A2 04                      ldx #$04                  ;clear name table with blank tile $24
006D42  2  A0 C0                      ldy #$c0
006D44  2  A9 24                      lda #$24
006D46  2  8D 07 20     InitNTLoop:   sta PPU_DATA              ;count out exactly 768 tiles
006D49  2  88                         dey
006D4A  2  D0 FA                      bne InitNTLoop
006D4C  2  CA                         dex
006D4D  2  D0 F7                      bne InitNTLoop
006D4F  2  A0 40                      ldy #64                   ;now to clear the attribute table (with zero this time)
006D51  2  8A                         txa
006D52  2  8D 00 03                   sta VRAM_Buffer1_Offset   ;init vram buffer 1 offset
006D55  2  8D 01 03                   sta VRAM_Buffer1          ;init vram buffer 1
006D58  2  8D 07 20     InitATLoop:   sta PPU_DATA
006D5B  2  88                         dey
006D5C  2  D0 FA                      bne InitATLoop
006D5E  2  8D 3F 07                   sta HorizontalScroll      ;reset scroll variables
006D61  2  8D 40 07                   sta VerticalScroll
006D64  2  4C F1 6D                   jmp InitScroll            ;initialize scroll registers to zero
006D67  2               
006D67  2               ;------------------------------------------------------------------------------------
006D67  2               
006D67  2               ReadJoypads:
006D67  2  A9 01                      lda #$01               ;reset and clear strobe of joypad ports
006D69  2  8D 16 40                   sta JOYPAD_PORT
006D6C  2  4A                         lsr
006D6D  2  AA                         tax                    ;start with joypad 1's port
006D6E  2  8D 16 40                   sta JOYPAD_PORT
006D71  2  20 75 6D                   jsr ReadPortBits
006D74  2  E8                         inx                    ;increment for joypad 2's port
006D75  2  A0 08        ReadPortBits: ldy #$08
006D77  2  48           PortLoop:     pha                    ;push previous bit onto stack
006D78  2  BD 16 40                   lda JOYPAD_PORT,x      ;read current bit on joypad port
006D7B  2  85 00                      sta $00                ;check d1 and d0 of port output
006D7D  2  4A                         lsr                    ;this is necessary on the old
006D7E  2  05 00                      ora $00                ;famicom systems in japan
006D80  2  4A                         lsr
006D81  2  68                         pla                    ;read bits from stack
006D82  2  2A                         rol                    ;rotate bit from carry flag
006D83  2  88                         dey
006D84  2  D0 F1                      bne PortLoop           ;count down bits left
006D86  2  9D FC 06                   sta SavedJoypadBits,x  ;save controller status here always
006D89  2  48                         pha
006D8A  2  29 30                      and #%00110000         ;check for select or start
006D8C  2  3D 4A 07                   and JoypadBitMask,x    ;if neither saved state nor current state
006D8F  2  F0 07                      beq Save8Bits          ;have any of these two set, branch
006D91  2  68                         pla
006D92  2  29 CF                      and #%11001111         ;otherwise store without select
006D94  2  9D FC 06                   sta SavedJoypadBits,x  ;or start bits and leave
006D97  2  60                         rts
006D98  2  68           Save8Bits:    pla
006D99  2  9D 4A 07                   sta JoypadBitMask,x    ;save with all bits in another place and leave
006D9C  2  60                         rts
006D9D  2               
006D9D  2               ;------------------------------------------------------------------------------------
006D9D  2               
006D9D  2               WriteBufferToScreen:
006D9D  2  8D 06 20                    sta PPU_ADDRESS           ;store high byte of vram address
006DA0  2  C8                          iny
006DA1  2  B1 00                       lda ($00),y               ;load next byte (second)
006DA3  2  8D 06 20                    sta PPU_ADDRESS           ;store low byte of vram address
006DA6  2  C8                          iny
006DA7  2  B1 00                       lda ($00),y               ;load next byte (third)
006DA9  2  0A                          asl                       ;shift to left and save in stack
006DAA  2  48                          pha
006DAB  2  AD 78 07                    lda Mirror_PPU_CTRL
006DAE  2  09 04                       ora #%00000100            ;set ppu to increment by 32 by default
006DB0  2  B0 02                       bcs SetupWrites           ;if d7 of third byte was clear, ppu will
006DB2  2  29 FB                       and #%11111011            ;only increment by 1
006DB4  2  20 F8 6D     SetupWrites:   jsr WritePPUReg1          ;write to register
006DB7  2  68                          pla                       ;pull from stack and shift to left again
006DB8  2  0A                          asl
006DB9  2  90 03                       bcc GetLength             ;if d6 of third byte was clear, do not repeat byte
006DBB  2  09 02                       ora #%00000010            ;otherwise set d1 and increment Y
006DBD  2  C8                          iny
006DBE  2  4A           GetLength:     lsr                       ;shift back to the right to get proper length
006DBF  2  4A                          lsr                       ;note that d1 will now be in carry
006DC0  2  AA                          tax
006DC1  2  B0 01        OutputToVRAM:  bcs RepeatByte            ;if carry set, repeat loading the same byte
006DC3  2  C8                          iny                       ;otherwise increment Y to load next byte
006DC4  2  B1 00        RepeatByte:    lda ($00),y               ;load more data from buffer and write to vram
006DC6  2  8D 07 20                    sta PPU_DATA
006DC9  2  CA                          dex                       ;done writing?
006DCA  2  D0 F5                       bne OutputToVRAM
006DCC  2  38                          sec
006DCD  2  98                          tya
006DCE  2  65 00                       adc $00                   ;add end length plus one to the indirect at $00
006DD0  2  85 00                       sta $00                   ;to allow this routine to read another set of updates
006DD2  2  A9 00                       lda #$00
006DD4  2  65 01                       adc $01
006DD6  2  85 01                       sta $01
006DD8  2  A9 3F                       lda #$3f                  ;sets vram address to palette memory
006DDA  2  8D 06 20                    sta PPU_ADDRESS
006DDD  2  A9 00                       lda #$00
006DDF  2  8D 06 20                    sta PPU_ADDRESS
006DE2  2  8D 06 20                    sta PPU_ADDRESS           ;then reinitializes it for some reason
006DE5  2  8D 06 20                    sta PPU_ADDRESS
006DE8  2  AE 02 20     UpdateScreen:  ldx PPU_STATUS            ;reset flip-flop
006DEB  2  A0 00                       ldy #$00                  ;load first byte from indirect as a pointer
006DED  2  B1 00                       lda ($00),y
006DEF  2  D0 AC                       bne WriteBufferToScreen   ;if byte is zero we have no further updates to make here
006DF1  2  8D 05 20     InitScroll:    sta PPU_SCROLL            ;store contents of A into scroll registers
006DF4  2  8D 05 20                    sta PPU_SCROLL            ;and end whatever subroutine led us here
006DF7  2  60                          rts
006DF8  2               
006DF8  2               ;------------------------------------------------------------------------------------
006DF8  2               
006DF8  2               WritePPUReg1:
006DF8  2  8D 00 20                   sta PPU_CTRL              ;write contents of A to PPU register 1
006DFB  2  8D 78 07                   sta Mirror_PPU_CTRL       ;and its mirror
006DFE  2  60                         rts
006DFF  2               
006DFF  2               ;------------------------------------------------------------------------------------
006DFF  2               ;$00 - used to store status bar nybbles
006DFF  2               ;$02 - used as temp vram offset
006DFF  2               ;$03 - used to store length of status bar number
006DFF  2               
006DFF  2               ;status bar name table offset and length data
006DFF  2               StatusBarData:
006DFF  2               .ifdef ANN
006DFF  2  F1 06              .byte $f1, $06 ; top score display on title screen
006E01  2               .else
006E01  2                     .byte $ef, $06 ; top score display on title screen
006E01  2               .endif
006E01  2  62 06              .byte $62, $06 ; player score
006E03  2  6D 02              .byte $6d, $02 ; coin tally
006E05  2  7A 03              .byte $7a, $03 ; game timer
006E07  2               
006E07  2               StatusBarOffset:
006E07  2  06 0C 12 18        .byte $06, $0c, $12, $18
006E0B  2               
006E0B  2               PrintStatusBarNumbers:
006E0B  2  85 00              sta $00            ;store player-specific offset
006E0D  2  20 16 6E           jsr OutputNumbers  ;use first nybble to print the coin display
006E10  2  A5 00              lda $00            ;move high nybble to low
006E12  2  4A                 lsr                ;and print the score display
006E13  2  4A                 lsr
006E14  2  4A                 lsr
006E15  2  4A                 lsr
006E16  2               
006E16  2               OutputNumbers:
006E16  2  18                        clc                      ;add 1 to low nybble
006E17  2  69 01                     adc #$01
006E19  2  29 0F                     and #%00001111           ;mask out high nybble
006E1B  2  C9 06                     cmp #$06
006E1D  2  B0 44                     bcs ExitOutputN
006E1F  2  48                        pha                      ;save incremented value to stack for now and
006E20  2  0A                        asl                      ;multiply by 2 to use as offset
006E21  2  A8                        tay
006E22  2  AE 00 03                  ldx VRAM_Buffer1_Offset  ;get current buffer pointer
006E25  2  A9 20                     lda #$20                 ;put at top of screen by default
006E27  2  C0 00                     cpy #$00                 ;are we writing top score on title screen?
006E29  2  D0 02                     bne SetupNums
006E2B  2  A9 22                     lda #$22                 ;if so, put further down on the screen
006E2D  2  9D 01 03     SetupNums:   sta VRAM_Buffer1,x
006E30  2  B9 FF 6D                  lda StatusBarData,y      ;write vram address low and length of thing
006E33  2  9D 02 03                  sta VRAM_Buffer1+1,x     ;we're printing to the buffer
006E36  2  B9 00 6E                  lda StatusBarData+1,y
006E39  2  9D 03 03                  sta VRAM_Buffer1+2,x
006E3C  2  85 03                     sta $03                  ;save length byte in counter
006E3E  2  86 02                     stx $02                  ;and buffer pointer elsewhere for now
006E40  2  68                        pla                      ;pull original incremented value from stack
006E41  2  AA                        tax
006E42  2  BD 07 6E                  lda StatusBarOffset,x    ;load offset to value we want to write
006E45  2  38                        sec
006E46  2  F9 00 6E                  sbc StatusBarData+1,y    ;subtract from length byte we read before
006E49  2  A8                        tay                      ;use value as offset to display digits
006E4A  2  A6 02                     ldx $02
006E4C  2  B9 D7 07     DigitPLoop:  lda DisplayDigits,y      ;write digits to the buffer
006E4F  2  9D 04 03                  sta VRAM_Buffer1+3,x
006E52  2  E8                        inx
006E53  2  C8                        iny
006E54  2  C6 03                     dec $03                  ;do this until all the digits are written
006E56  2  D0 F4                     bne DigitPLoop
006E58  2  A9 00                     lda #$00                 ;put null terminator at end
006E5A  2  9D 04 03                  sta VRAM_Buffer1+3,x
006E5D  2  E8                        inx                      ;increment buffer pointer by 3
006E5E  2  E8                        inx
006E5F  2  E8                        inx
006E60  2  8E 00 03                  stx VRAM_Buffer1_Offset  ;store it in case we want to use it again
006E63  2  60           ExitOutputN: rts
006E64  2               
006E64  2               DigitsMathRoutine:
006E64  2  AD 70 07                 lda OperMode              ;check mode of operation
006E67  2  F0 16                    beq EraseDMods            ;if in attract mode, branch to lock score
006E69  2  A2 05                    ldx #$05
006E6B  2  BD 34 01     AddModLoop: lda DigitModifier,x       ;load digit amount to increment
006E6E  2  18                       clc
006E6F  2  79 D7 07                 adc DisplayDigits,y       ;add to current digit
006E72  2  30 16                    bmi BorrowOne             ;if result is a negative number, branch to subtract
006E74  2  C9 0A                    cmp #10
006E76  2  B0 19                    bcs CarryOne              ;if digit greater than $09, branch to add
006E78  2  99 D7 07     StoreNewD:  sta DisplayDigits,y       ;store as new score or game timer digit
006E7B  2  88                       dey                       ;move onto next digits in score or game timer
006E7C  2  CA                       dex                       ;and digit amounts to increment
006E7D  2  10 EC                    bpl AddModLoop            ;loop back if we're not done yet
006E7F  2  A9 00        EraseDMods: lda #$00                  ;now we need to erase the digit modifiers
006E81  2  A2 06                    ldx #$06                  ;start with the last digit
006E83  2  9D 33 01     EraseMLoop: sta DigitModifier-1,x     ;initialize the digit amounts to increment
006E86  2  CA                       dex
006E87  2  10 FA                    bpl EraseMLoop            ;do this until they're all reset, then leave
006E89  2  60                       rts
006E8A  2               
006E8A  2  DE 33 01     BorrowOne:  dec DigitModifier-1,x     ;decrement the previous digit, then put $09 in
006E8D  2  A9 09                    lda #$09                  ;the game timer digit we're currently on to "borrow
006E8F  2  D0 E7                    bne StoreNewD             ;the one", then do an unconditional branch back
006E91  2  38           CarryOne:   sec                       ;subtract ten from our digit to make it a
006E92  2  E9 0A                    sbc #10                   ;proper BCD number, then increment the digit
006E94  2  FE 33 01                 inc DigitModifier-1,x     ;preceding current digit to "carry the one" properly
006E97  2  4C 78 6E                 jmp StoreNewD             ;go back to just after we branched here
006E9A  2               
006E9A  2               UpdateTopScore:
006E9A  2  A2 05                      ldx #$05                 ;start with the lowest digit
006E9C  2  A0 05                      ldy #$05
006E9E  2  38                         sec
006E9F  2  BD DD 07     GetScoreDiff: lda PlayerScoreDisplay,x ;subtract the regular score digit from each high score digit
006EA2  2  F9 D7 07                   sbc TopScoreDisplay,y    ;from lowest to highest, if any top score digit exceeds
006EA5  2  CA                         dex                      ;the player score digit, borrow will be set until a subsequent
006EA6  2  88                         dey                      ;subtraction clears it (player digit is higher than top)
006EA7  2  10 F6                      bpl GetScoreDiff
006EA9  2  90 0E                      bcc NoTopSc              ;check to see if borrow is still set, if so, no new high score
006EAB  2  E8                         inx                      ;increment X and Y once to the start of the score
006EAC  2  C8                         iny
006EAD  2  BD DD 07     CopyScore:    lda PlayerScoreDisplay,x ;store player's score digits into high score memory area
006EB0  2  99 D7 07                   sta TopScoreDisplay,y
006EB3  2  E8                         inx
006EB4  2  C8                         iny
006EB5  2  C0 06                      cpy #$06                 ;do this until we have stored them all
006EB7  2  90 F4                      bcc CopyScore
006EB9  2  60           NoTopSc:      rts
006EBA  2               
006EBA  2               ;-------------------------------------------------------------------------------------
006EBA  2               
006EBA  2               .ifndef ANN
006EBA  2               ;unused memory
006EBA  2                     .byte $ff, $ff
006EBA  2               .endif
006EBA  2               
006EBA  2               DefaultSprOffsets:
006EBA  2  04 30 48 60        .byte $04, $30, $48, $60, $78, $90, $a8, $c0
006EBE  2  78 90 A8 C0  
006EC2  2  D8 E8 24 F8        .byte $d8, $e8, $24, $f8, $fc, $28, $2c
006EC6  2  FC 28 2C     
006EC9  2               
006EC9  2               ;-------------------------------------------------------------------------------------
006EC9  2               
006EC9  2               InitializeArea:
006EC9  2  A0 4B                       ldy #$4b                 ;clear all memory again, only as far as $074b
006ECB  2  20 93 6F                    jsr InitializeMemory     ;this is only necessary in game mode
006ECE  2  A2 21                       ldx #$21
006ED0  2  A9 00                       lda #$00
006ED2  2  9D 80 07     ClrTimersLoop: sta Timers,x             ;clear out timer memory
006ED5  2  CA                          dex
006ED6  2  10 FA                       bpl ClrTimersLoop
006ED8  2  AD 5B 07                    lda HalfwayPage
006EDB  2  AC 52 07                    ldy AltEntranceControl   ;if AltEntranceControl not set, use halfway page, if any found
006EDE  2  F0 03                       beq StartPage
006EE0  2  AD 51 07                    lda EntrancePage         ;otherwise use saved entry page number here
006EE3  2  8D 1A 07     StartPage:     sta ScreenLeft_PageLoc   ;set as value here
006EE6  2  8D 25 07                    sta CurrentPageLoc       ;also set as current page
006EE9  2  8D 28 07                    sta BackloadingFlag      ;set flag here if halfway page or saved entry page number found
006EEC  2  20 FA 7B                    jsr GetScreenPosition    ;get pixel coordinates for screen borders
006EEF  2  A0 20                       ldy #$20                 ;if on odd numbered page, use $2480 as start of rendering
006EF1  2  29 01                       and #%00000001           ;otherwise use $2080, this address used later as name table
006EF3  2  F0 02                       beq SetInitNTHigh        ;address for rendering of game area
006EF5  2  A0 24                       ldy #$24
006EF7  2  8C 20 07     SetInitNTHigh: sty CurrentNTAddr_High   ;store name table address
006EFA  2  A0 80                       ldy #$80
006EFC  2  8C 21 07                    sty CurrentNTAddr_Low
006EFF  2  0A                          asl                      ;store LSB of page number in high nybble
006F00  2  0A                          asl                      ;of block buffer column position
006F01  2  0A                          asl
006F02  2  0A                          asl
006F03  2  8D A0 06                    sta BlockBufferColumnPos
006F06  2  CE 30 07                    dec AreaObjectLength     ;set area object lengths for all empty
006F09  2  CE 31 07                    dec AreaObjectLength+1
006F0C  2  CE 32 07                    dec AreaObjectLength+2
006F0F  2  A9 0B                       lda #$0b                 ;set value for renderer to update 12 column sets
006F11  2  8D 1E 07                    sta ColumnSets           ;12 column sets = 24 metatile columns = 1 1/2 screens
006F14  2  20 A5 C2                    jsr GetAreaDataAddrs     ;get enemy and level addresses and load header
006F17  2  AD FB 07                    lda HardWorldFlag        ;check to see if we're in worlds A-D
006F1A  2  D0 10                       bne SetSecHard           ;if so, activate the secondary no matter where we're at
006F1C  2  AD 5F 07                    lda WorldNumber          ;otherwise check world number
006F1F  2  C9 03                       cmp #World4              ;if less than 4, do not activate secondary
006F21  2  90 0C                       bcc CheckHalfway
006F23  2  D0 07                       bne SetSecHard           ;if not equal to, then world > 4, thus activate
006F25  2  AD 5C 07                    lda LevelNumber          ;otherwise, world 4, so check level number
006F28  2  C9 03                       cmp #Level4              ;if not 4, do not set secondary hard mode flag
006F2A  2  90 03                       bcc CheckHalfway
006F2C  2  EE CC 06     SetSecHard:    inc SecondaryHardMode    ;set secondary hard mode flag for areas 4-4 and beyond
006F2F  2  AD 5B 07     CheckHalfway:  lda HalfwayPage
006F32  2  F0 05                       beq DoneInitArea
006F34  2  A9 02                       lda #$02                 ;if halfway page set, overwrite start position from header
006F36  2  8D 10 07                    sta PlayerEntranceCtrl
006F39  2  A9 80        DoneInitArea:  lda #Silence             ;silence music
006F3B  2  85 FB                       sta AreaMusicQueue
006F3D  2  A9 01                       lda #$01                 ;disable screen output
006F3F  2  8D 74 07                    sta DisableScreenFlag
006F42  2  20 52 C2                    jsr LoadPhysicsData
006F45  2               .ifdef ANN
006F45  2  4C B9 63                    jmp IncModeTask
006F48  2               .else
006F48  2                              inc OperMode_Task        ;increment task for this mode
006F48  2                              rts
006F48  2               .endif
006F48  2               
006F48  2               ;-------------------------------------------------------------------------------------
006F48  2               
006F48  2               SecondaryGameSetup:
006F48  2  A9 00               lda #$00
006F4A  2  8D 74 07            sta DisableScreenFlag    ;reenable screen, reset some flags
006F4D  2               .ifndef ANN
006F4D  2                      sta WindFlag
006F4D  2               .endif
006F4D  2  8D F6 07            sta FlagpoleMusicFlag
006F50  2  A8                  tay
006F51  2  99 00 03     ClearVRLoop: sta VRAM_Buffer1-1,y      ;clear buffer at $0300-$03ff
006F54  2  C8                        iny
006F55  2  D0 FA                     bne ClearVRLoop
006F57  2  8D 59 07                  sta GameTimerExpiredFlag  ;clear game timer exp flag
006F5A  2  8D 69 07                  sta DisableIntermediate   ;clear skip lives display flag
006F5D  2  8D 28 07                  sta BackloadingFlag       ;clear value here
006F60  2  A9 FF                     lda #$ff
006F62  2  8D A0 03                  sta BalPlatformAlignment  ;initialize balance platform assignment flag
006F65  2  AD 1A 07                  lda ScreenLeft_PageLoc    ;get left side page location
006F68  2  29 01                     and #$01
006F6A  2  8D 7A 07                  sta NameTableSelect
006F6D  2  20 B8 6F                  jsr GetAreaMusic
006F70  2  A9 38                     lda #$38                  ;load sprite shuffle amounts to be used later
006F72  2  8D E3 06                  sta SprShuffleAmt+2
006F75  2  A9 48                     lda #$48
006F77  2  8D E2 06                  sta SprShuffleAmt+1
006F7A  2  A9 58                     lda #$58
006F7C  2  8D E1 06                  sta SprShuffleAmt
006F7F  2  A2 0E                     ldx #$0e                  ;load default OAM offsets
006F81  2  BD BA 6E     ShufAmtLoop: lda DefaultSprOffsets,x
006F84  2  9D E4 06                  sta SprDataOffset,x
006F87  2  CA                        dex                       ;do this until they're all set
006F88  2  10 F7                     bpl ShufAmtLoop
006F8A  2  20 37 71                  jsr DoNothing             ;do slightly less of nothing than in super mario bros 1
006F8D  2  EE 22 07                  inc IRQUpdateFlag
006F90  2               .ifdef ANN
006F90  2  4C B9 63                  jmp IncModeTask
006F93  2               .else
006F93  2                            inc OperMode_Task
006F93  2                            rts
006F93  2               .endif
006F93  2               
006F93  2               ;-------------------------------------------------------------------------------------
006F93  2               
006F93  2               InitializeMemory:
006F93  2  A2 07                      ldx #$07          ;set initial high byte to $0700-$07ff
006F95  2  A9 00                      lda #$00          ;set initial low byte to start of page (at $00 of page)
006F97  2  85 06                      sta $06
006F99  2  86 07        InitPageLoop: stx $07
006F9B  2  E0 01        InitByteLoop: cpx #$01          ;check to see if we're on the stack ($0100-$01ff)
006F9D  2  D0 08                      bne InitByte      ;if not, go ahead anyway
006F9F  2  C0 60                      cpy #$60          ;otherwise, check to see if we're at $0160-$01ff
006FA1  2  B0 06                      bcs SkipByte      ;if so, skip write
006FA3  2  C0 09                      cpy #$09          ;otherwise, check to see if we're at $0100-$0108
006FA5  2  90 02                      bcc SkipByte      ;if so, skip write
006FA7  2  91 06        InitByte:     sta ($06),y       ;otherwise, initialize memory
006FA9  2  88           SkipByte:     dey
006FAA  2  C0 FF                      cpy #$ff          ;do this until all bytes in page have been erased
006FAC  2  D0 ED                      bne InitByteLoop
006FAE  2  CA                         dex               ;go onto the next page
006FAF  2  10 E8                      bpl InitPageLoop  ;do this until all desired pages of memory have been erased
006FB1  2  60                         rts
006FB2  2               
006FB2  2               ;-------------------------------------------------------------------------------------
006FB2  2               
006FB2  2               MusicSelectData:
006FB2  2  02 01 04 08        .byte WaterMusic, GroundMusic, UndergroundMusic, CastleMusic
006FB6  2  10 20              .byte CloudMusic, PipeIntroMusic
006FB8  2               
006FB8  2               GetAreaMusic:
006FB8  2  AD 70 07                  lda OperMode           ;if in attract mode, leave
006FBB  2  F0 23                     beq ExitGetM
006FBD  2  AD 52 07                  lda AltEntranceControl ;check for specific alternate mode of entry
006FC0  2  C9 02                     cmp #$02               ;if found, branch without checking starting position
006FC2  2  F0 0D                     beq ChkAreaType        ;from area object data header
006FC4  2  A0 05                     ldy #$05               ;select music for pipe intro scene by default
006FC6  2  AD 10 07                  lda PlayerEntranceCtrl ;check value from level header for certain values
006FC9  2  C9 06                     cmp #$06
006FCB  2  F0 0E                     beq StoreMusic         ;load music for pipe intro scene if header
006FCD  2  C9 07                     cmp #$07               ;start position either value $06 or $07
006FCF  2  F0 0A                     beq StoreMusic
006FD1  2  AC 4E 07     ChkAreaType: ldy AreaType           ;load area type as offset for music bit
006FD4  2  AD 43 07                  lda CloudTypeOverride
006FD7  2  F0 02                     beq StoreMusic         ;check for cloud type override
006FD9  2  A0 04                     ldy #$04               ;select music for cloud type level if found
006FDB  2  B9 B2 6F     StoreMusic:  lda MusicSelectData,y  ;otherwise select appropriate music for level type
006FDE  2  85 FB                     sta AreaMusicQueue     ;store in queue and leave
006FE0  2  60           ExitGetM:    rts
006FE1  2               
006FE1  2               ;-------------------------------------------------------------------------------------
006FE1  2               
006FE1  2               PlayerStarting_X_Pos:
006FE1  2  28 18              .byte $28, $18
006FE3  2  38 28              .byte $38, $28
006FE5  2               
006FE5  2               AltYPosOffset:
006FE5  2  08 00              .byte $08, $00
006FE7  2               
006FE7  2               PlayerStarting_Y_Pos:
006FE7  2  00 20 B0 50        .byte $00, $20, $b0, $50, $00, $00, $b0, $b0
006FEB  2  00 00 B0 B0  
006FEF  2  F0                 .byte $f0
006FF0  2               
006FF0  2               PlayerBGPriorityData:
006FF0  2  00 20 00 00        .byte $00, $20, $00, $00, $00, $00, $00, $00
006FF4  2  00 00 00 00  
006FF8  2               
006FF8  2               GameTimerData:
006FF8  2  20                 .byte $20 ;dummy byte, used as part of bg priority data
006FF9  2  04 03 02           .byte $04, $03, $02
006FFC  2               
006FFC  2               Entrance_GameTimerSetup:
006FFC  2  AD 1A 07               lda ScreenLeft_PageLoc      ;set current page for area objects
006FFF  2  85 6D                  sta Player_PageLoc          ;as page location for player
007001  2  A9 28                  lda #$28                    ;store value here
007003  2  8D 0A 07               sta VerticalForceDown       ;for fractional movement downwards if necessary
007006  2  A9 01                  lda #$01                    ;set high byte of player position and
007008  2  85 33                  sta PlayerFacingDir         ;set facing direction so that player faces right
00700A  2  85 B5                  sta Player_Y_HighPos
00700C  2  A9 00                  lda #$00                    ;set player state to on the ground by default
00700E  2  85 1D                  sta Player_State
007010  2  CE 90 04               dec Player_CollisionBits    ;initialize player's collision bits
007013  2  A0 00                  ldy #$00                    ;initialize halfway page
007015  2  8C 5B 07               sty HalfwayPage
007018  2  AD 4E 07               lda AreaType                ;check area type
00701B  2  D0 01                  bne ChkStPos                ;if water type, set swimming flag, otherwise do not set
00701D  2  C8                     iny
00701E  2  8C 04 07     ChkStPos: sty SwimmingFlag
007021  2  AE 10 07               ldx PlayerEntranceCtrl      ;get starting position loaded from header
007024  2  AC 52 07               ldy AltEntranceControl      ;check alternate mode of entry flag for 0 or 1
007027  2  F0 07                  beq SetStPos
007029  2  C0 01                  cpy #$01
00702B  2  F0 03                  beq SetStPos
00702D  2  BE E3 6F               ldx AltYPosOffset-2,y       ;if not 0 or 1, override start pos from header with alt offset
007030  2  B9 E1 6F     SetStPos: lda PlayerStarting_X_Pos,y  ;load appropriate horizontal position
007033  2  85 86                  sta Player_X_Position       ;and vertical positions for the player, using
007035  2  BD E7 6F               lda PlayerStarting_Y_Pos,x  ;AltEntranceControl as offset for horizontal and either
007038  2  85 CE                  sta Player_Y_Position       ;the original offset from the header or alt offset for vertical
00703A  2  BD F0 6F               lda PlayerBGPriorityData,x
00703D  2  8D C4 03               sta Player_SprAttrib        ;set player sprite attributes using offset in X
007040  2  20 D4 65               jsr GetPlayerColors         ;get appropriate player palette
007043  2  AC 15 07               ldy GameTimerSetting        ;get timer control value from header
007046  2  F0 1A                  beq ChkOverR                ;if set to zero, branch (do not use dummy byte for this)
007048  2  AD 57 07               lda FetchNewGameTimerFlag   ;do we need to set the game timer? if not, use
00704B  2  F0 15                  beq ChkOverR                ;old game timer setting
00704D  2  B9 F8 6F               lda GameTimerData,y         ;if game timer is set and game timer flag is also set,
007050  2  8D EC 07               sta GameTimerDisplay        ;use value of game timer control for first digit of game timer
007053  2  A9 01                  lda #$01
007055  2  8D EE 07               sta GameTimerDisplay+2      ;set last digit of game timer to 1
007058  2  4A                     lsr
007059  2  8D ED 07               sta GameTimerDisplay+1      ;set second digit of game timer
00705C  2  8D 57 07               sta FetchNewGameTimerFlag   ;clear flag for game timer reset
00705F  2  8D 9F 07               sta StarInvincibleTimer     ;clear star mario timer
007062  2  AC 58 07     ChkOverR: ldy JoypadOverride          ;if controller bits not set, branch to skip this part
007065  2  F0 14                  beq ChkSwimE
007067  2  A9 03                  lda #$03                    ;set player state to climbing
007069  2  85 1D                  sta Player_State
00706B  2  A2 00                  ldx #$00                    ;set offset for first slot, for block object
00706D  2  20 90 89               jsr InitBlock_XY_Pos
007070  2  A9 F0                  lda #$f0                    ;set vertical coordinate for block object
007072  2  85 D7                  sta Block_Y_Position
007074  2  A2 05                  ldx #$05                    ;set offset in X for last enemy object buffer slot
007076  2  A0 00                  ldy #$00                    ;set offset in Y for object coordinates used earlier
007078  2  20 F5 84               jsr Setup_Vine              ;do a sub to grow vine
00707B  2  AC 4E 07     ChkSwimE: ldy AreaType                ;if level not water-type,
00707E  2  D0 03                  bne SetPESub                ;skip this subroutine
007080  2  20 CB 82               jsr SetupBubble             ;otherwise, execute sub to set up air bubbles
007083  2  A9 07        SetPESub: lda #$07                    ;set to run player entrance subroutine
007085  2  85 0E                  sta GameEngineSubroutine    ;on the next frame of game engine
007087  2  60                     rts
007088  2               
007088  2               ;-------------------------------------------------------------------------------------
007088  2               
007088  2               ;page numbers are in order from level numbers 1 to 4
007088  2               HalfwayPageNybbles:
007088  2               .ifdef ANN
007088  2  56 40              .byte $56, $40
00708A  2  65 70              .byte $65, $70
00708C  2  66 40              .byte $66, $40
00708E  2  66 40              .byte $66, $40
007090  2  66 60              .byte $66, $60
007092  2  66 60              .byte $66, $60
007094  2  67 80              .byte $67, $80
007096  2  00 00              .byte $00, $00
007098  2               .else
007098  2                     .byte $66, $60
007098  2                     .byte $88, $60
007098  2                     .byte $66, $70
007098  2                     .byte $77, $60
007098  2                     .byte $d6, $00
007098  2                     .byte $77, $80
007098  2                     .byte $70, $b0
007098  2                     .byte $00, $00
007098  2                     .byte $00, $00
007098  2               .endif
007098  2               
007098  2               PlayerLoseLife:
007098  2  EE 74 07                  inc DisableScreenFlag    ;disable screen and IRQ updates
00709B  2  A9 00                     lda #$00
00709D  2  8D 22 07                  sta IRQUpdateFlag
0070A0  2  A9 80                     lda #Silence             ;silence music
0070A2  2  85 FC                     sta EventMusicQueue
0070A4  2  CE 5A 07                  dec NumberofLives        ;take one life from player
0070A7  2  10 0B                     bpl StillInGame          ;if player still has lives, branch
0070A9  2  A9 00                     lda #$00
0070AB  2  8D 72 07                  sta OperMode_Task        ;initialize mode task,
0070AE  2  A9 03                     lda #GameOverMode        ;switch to game over mode
0070B0  2  8D 70 07                  sta OperMode             ;and leave
0070B3  2  60                        rts
0070B4  2  AD 5F 07     StillInGame: lda WorldNumber          ;multiply world number by 2 and use
0070B7  2  0A                        asl                      ;as offset
0070B8  2  AA                        tax
0070B9  2  AD 5C 07                  lda LevelNumber          ;if in level 3 or 4, increment
0070BC  2  29 02                     and #$02                 ;offset by one byte, otherwise
0070BE  2  F0 01                     beq GetHalfway           ;leave offset alone
0070C0  2  E8                        inx
0070C1  2  BC 88 70     GetHalfway:  ldy HalfwayPageNybbles,x ;get halfway page number with offset
0070C4  2  AD 5C 07                  lda LevelNumber          ;check area number's LSB
0070C7  2  4A                        lsr
0070C8  2  98                        tya                      ;if in level 2 or 4, use lower nybble
0070C9  2  B0 04                     bcs MaskHPNyb
0070CB  2  4A                        lsr                      ;move higher nybble to lower if
0070CC  2  4A                        lsr                      ;level number is 1 or 3
0070CD  2  4A                        lsr
0070CE  2  4A                        lsr
0070CF  2  29 0F        MaskHPNyb:   and #%00001111           ;mask out all but lower nybble
0070D1  2  CD 1A 07                  cmp ScreenLeft_PageLoc
0070D4  2  F0 04                     beq SetHalfway           ;left side of screen must be at the halfway page,
0070D6  2  90 02                     bcc SetHalfway           ;otherwise player must start at the
0070D8  2  A9 00                     lda #$00                 ;beginning of the level
0070DA  2  8D 5B 07     SetHalfway:  sta HalfwayPage          ;store as halfway page for player
0070DD  2  4C 19 71                  jmp ContinueGame         ;continue the game
0070E0  2               
0070E0  2               ;-------------------------------------------------------------------------------------
0070E0  2               
0070E0  2               GameOverSubs:
0070E0  2  AD 72 07           lda OperMode_Task
0070E3  2  20 0F 6D           jsr JumpEngine
0070E6  2               
0070E6  2  EC 70              .word SetupGameOver
0070E8  2  4C 65              .word ScreenRoutines
0070EA  2  01 71              .word RunGameOver
0070EC  2               
0070EC  2               ;-------------------------------------------------------------------------------------
0070EC  2               
0070EC  2               SetupGameOver:
0070EC  2  A9 00              lda #$00
0070EE  2  8D 3C 07           sta ScreenRoutineTask
0070F1  2  8D 22 07           sta IRQUpdateFlag
0070F4  2  8D F8 07           sta ContinueMenuSelect ;set continue as default choice
0070F7  2  A9 02              lda #$02
0070F9  2  85 FC              sta EventMusicQueue    ;play game over music
0070FB  2  EE 74 07           inc DisableScreenFlag
0070FE  2               .ifdef ANN
0070FE  2  4C B9 63           jmp IncModeTask
007101  2               .else
007101  2                     inc OperMode_Task
007101  2                     rts
007101  2               .endif
007101  2               
007101  2               RunGameOver:
007101  2  A9 00               lda #$00
007103  2  8D 74 07            sta DisableScreenFlag
007106  2               .ifdef ANN
007106  2  4C D8 C1            jmp GameOverMenu
007109  2               .else
007109  2                      lda WorldNumber       ;if on world 9, branch on to end the game
007109  2                      cmp #World9
007109  2                      beq W9End
007109  2                      jmp GameOverMenu      ;otherwise run game over menu
007109  2               W9End: lda ScreenTimer
007109  2                      bne ExRGO
007109  2               .endif
007109  2               
007109  2               TerminateGame:
007109  2  A9 80               lda #Silence          ;silence music
00710B  2  85 FC               sta EventMusicQueue
00710D  2  A9 00               lda #$00
00710F  2  8D 72 07            sta OperMode_Task     ;reset to attract mode and leave
007112  2  8D A0 07            sta ScreenTimer
007115  2  8D 70 07            sta OperMode
007118  2  60           ExRGO: rts
007119  2               
007119  2               ContinueGame:
007119  2  20 86 C2                jsr LoadAreaPointer       ;update level pointer with
00711C  2  A9 01                   lda #$01                  ;actual world and area numbers, then
00711E  2  8D 54 07                sta PlayerSize            ;reset player's size, status, and
007121  2  EE 57 07                inc FetchNewGameTimerFlag ;set game timer flag to reload
007124  2  A9 00                   lda #$00                  ;game timer from header
007126  2  8D 47 07                sta TimerControl          ;also set flag for timers to count again
007129  2  8D 56 07                sta PlayerStatus
00712C  2  85 0E                   sta GameEngineSubroutine  ;reset task for game core
00712E  2  8D 72 07                sta OperMode_Task         ;set modes and leave
007131  2  A9 01                   lda #$01                  ;if in game over mode, switch back to
007133  2  8D 70 07                sta OperMode              ;game mode, because game is still on
007136  2  60           GameIsOn:  rts
007137  2               
007137  2               ;-------------------------------------------------------------------------------------
007137  2               
007137  2               DoNothing:
007137  2  A9 FF              lda #$ff       ;this is residual code, this value is
007139  2  8D C9 06           sta $06c9      ;not used anywhere in the program
00713C  2  60                 rts
00713D  2               
00713D  2               ;-------------------------------------------------------------------------------------
00713D  2               
00713D  2               AreaParserTaskHandler:
00713D  2  AC 1F 07                   ldy AreaParserTaskNum     ;check number of tasks here
007140  2  D0 05                      bne DoAPTasks             ;if already set, go ahead
007142  2  A0 08                      ldy #$08
007144  2  8C 1F 07                   sty AreaParserTaskNum     ;otherwise, set eight by default
007147  2  88           DoAPTasks:    dey
007148  2  98                         tya
007149  2  20 55 71                   jsr AreaParserTasks
00714C  2  CE 1F 07                   dec AreaParserTaskNum     ;if all tasks not complete do not
00714F  2  D0 03                      bne SkipATRender          ;render attribute table yet
007151  2  20 E1 68                   jsr RenderAttributeTables
007154  2  60           SkipATRender: rts
007155  2               
007155  2               AreaParserTasks:
007155  2  20 0F 6D           jsr JumpEngine
007158  2               
007158  2  68 71              .word IncrementColumnPos
00715A  2  25 68              .word RenderAreaGraphics
00715C  2  25 68              .word RenderAreaGraphics
00715E  2  89 72              .word AreaParserCore
007160  2  68 71              .word IncrementColumnPos
007162  2  25 68              .word RenderAreaGraphics
007164  2  25 68              .word RenderAreaGraphics
007166  2  89 72              .word AreaParserCore
007168  2               
007168  2               ;-------------------------------------------------------------------------------------
007168  2               
007168  2               IncrementColumnPos:
007168  2  EE 26 07                inc CurrentColumnPos     ;increment column where we're at
00716B  2  AD 26 07                lda CurrentColumnPos
00716E  2  29 0F                   and #%00001111           ;mask out higher nybble
007170  2  D0 06                   bne NoColWrap
007172  2  8D 26 07                sta CurrentColumnPos     ;if no bits left set, wrap back to zero (0-f)
007175  2  EE 25 07                inc CurrentPageLoc       ;and increment page number where we're at
007178  2  EE A0 06     NoColWrap: inc BlockBufferColumnPos ;increment column offset where we're at
00717B  2  AD A0 06                lda BlockBufferColumnPos
00717E  2  29 1F                   and #%00011111           ;mask out all but 5 LSB (0-1f)
007180  2  8D A0 06                sta BlockBufferColumnPos ;and save
007183  2  60                      rts
007184  2               
007184  2               ;-------------------------------------------------------------------------------------
007184  2               ;$00 - used as counter, store for low nybble for background, ceiling byte for terrain
007184  2               ;$01 - used to store floor byte for terrain
007184  2               ;$07 - used to store terrain metatile
007184  2               ;$06-$07 - used to store block buffer address
007184  2               
007184  2               BSceneDataOffsets:
007184  2  00 30 60           .byte $00, $30, $60
007187  2               
007187  2               BackSceneryData:
007187  2  93 00 00 11     .byte $93, $00, $00, $11, $12, $12, $13, $00 ;clouds
00718B  2  12 12 13 00  
00718F  2  00 51 52 53     .byte $00, $51, $52, $53, $00, $00, $00, $00
007193  2  00 00 00 00  
007197  2  00 00 01 02     .byte $00, $00, $01, $02, $02, $03, $00, $00
00719B  2  02 03 00 00  
00719F  2  00 00 00 00     .byte $00, $00, $00, $00, $91, $92, $93, $00
0071A3  2  91 92 93 00  
0071A7  2  00 00 00 51     .byte $00, $00, $00, $51, $52, $53, $41, $42
0071AB  2  52 53 41 42  
0071AF  2  43 00 00 00     .byte $43, $00, $00, $00, $00, $00, $91, $92
0071B3  2  00 00 91 92  
0071B7  2               
0071B7  2  97 87 88 89     .byte $97, $87, $88, $89, $99, $00, $00, $00 ;mountains and bushes
0071BB  2  99 00 00 00  
0071BF  2  11 12 13 A4     .byte $11, $12, $13, $a4, $a5, $a5, $a5, $a6
0071C3  2  A5 A5 A5 A6  
0071C7  2  97 98 99 01     .byte $97, $98, $99, $01, $02, $03, $00, $a4
0071CB  2  02 03 00 A4  
0071CF  2  A5 A6 00 11     .byte $a5, $a6, $00, $11, $12, $12, $12, $13
0071D3  2  12 12 12 13  
0071D7  2  00 00 00 00     .byte $00, $00, $00, $00, $01, $02, $02, $03
0071DB  2  01 02 02 03  
0071DF  2  00 A4 A5 A5     .byte $00, $a4, $a5, $a5, $a6, $00, $00, $00
0071E3  2  A6 00 00 00  
0071E7  2               
0071E7  2  11 12 12 13     .byte $11, $12, $12, $13, $00, $00, $00, $00 ;trees and fences
0071EB  2  00 00 00 00  
0071EF  2  00 00 00 9C     .byte $00, $00, $00, $9c, $00, $8b, $aa, $aa
0071F3  2  00 8B AA AA  
0071F7  2  AA AA 11 12     .byte $aa, $aa, $11, $12, $13, $8b, $00, $9c
0071FB  2  13 8B 00 9C  
0071FF  2  9C 00 00 01     .byte $9c, $00, $00, $01, $02, $03, $11, $12
007203  2  02 03 11 12  
007207  2  12 13 00 00     .byte $12, $13, $00, $00, $00, $00, $aa, $aa
00720B  2  00 00 AA AA  
00720F  2  9C AA 00 8B     .byte $9c, $aa, $00, $8b, $00, $01, $02, $03
007213  2  00 01 02 03  
007217  2               
007217  2               BackSceneryMetatiles:
007217  2  80 83 00        .byte $80, $83, $00 ;cloud left
00721A  2  81 84 00        .byte $81, $84, $00 ;cloud middle
00721D  2  82 85 00        .byte $82, $85, $00 ;cloud right
007220  2  02 00 00        .byte $02, $00, $00 ;bush left
007223  2  03 00 00        .byte $03, $00, $00 ;bush middle
007226  2  04 00 00        .byte $04, $00, $00 ;bush right
007229  2  00 05 06        .byte $00, $05, $06 ;mountain left
00722C  2  07 06 0A        .byte $07, $06, $0a ;mountain middle
00722F  2  00 08 09        .byte $00, $08, $09 ;mountain right
007232  2  4D 00 00        .byte $4d, $00, $00 ;fence
007235  2  0D 0F 4E        .byte $0d, $0f, $4e ;tall tree
007238  2  0E 4E 4E        .byte $0e, $4e, $4e ;short tree
00723B  2               
00723B  2               FSceneDataOffsets:
00723B  2  00 0D 1A           .byte $00, $0d, $1a
00723E  2               
00723E  2               ForeSceneryData:
00723E  2  86 87 87 87     .byte $86, $87, $87, $87, $87, $87, $87   ;in water
007242  2  87 87 87     
007245  2  87 87 87 87     .byte $87, $87, $87, $87
007249  2               .ifdef ANN
007249  2  69 69           .byte $69, $69
00724B  2               .else
00724B  2                  .byte $6a, $6a
00724B  2               .endif
00724B  2               
00724B  2  00 00 00 00     .byte $00, $00, $00, $00, $00, $45, $47   ;wall
00724F  2  00 45 47     
007252  2  47 47 47 47     .byte $47, $47, $47, $47, $00, $00
007256  2  00 00        
007258  2               
007258  2  00 00 00 00     .byte $00, $00, $00, $00, $00, $00, $00   ;over water
00725C  2  00 00 00     
00725F  2  00 00 00 00     .byte $00, $00, $00, $00, $86, $87
007263  2  86 87        
007265  2               
007265  2               TerrainMetatiles:
007265  2               .ifdef ANN
007265  2  69 6A 52 62        .byte $69, $6a, $52, $62
007269  2               .else
007269  2                     .byte $6a, $6b, $50, $63
007269  2               .endif
007269  2               
007269  2               TerrainRenderBits:
007269  2  00 00              .byte %00000000, %00000000 ;no ceiling or floor
00726B  2  00 18              .byte %00000000, %00011000 ;no ceiling, floor 2
00726D  2  01 18              .byte %00000001, %00011000 ;ceiling 1, floor 2
00726F  2  07 18              .byte %00000111, %00011000 ;ceiling 3, floor 2
007271  2  0F 18              .byte %00001111, %00011000 ;ceiling 4, floor 2
007273  2  FF 18              .byte %11111111, %00011000 ;ceiling 8, floor 2
007275  2  01 1F              .byte %00000001, %00011111 ;ceiling 1, floor 5
007277  2  07 1F              .byte %00000111, %00011111 ;ceiling 3, floor 5
007279  2  0F 1F              .byte %00001111, %00011111 ;ceiling 4, floor 5
00727B  2  81 1F              .byte %10000001, %00011111 ;ceiling 1, floor 6
00727D  2  01 00              .byte %00000001, %00000000 ;ceiling 1, no floor
00727F  2  8F 1F              .byte %10001111, %00011111 ;ceiling 4, floor 6
007281  2  F1 1F              .byte %11110001, %00011111 ;ceiling 1, floor 9
007283  2  F9 18              .byte %11111001, %00011000 ;ceiling 1, middle 5, floor 2
007285  2  F1 18              .byte %11110001, %00011000 ;ceiling 1, middle 4, floor 2
007287  2  FF 1F              .byte %11111111, %00011111 ;completely solid top to bottom
007289  2               
007289  2               AreaParserCore:
007289  2  AD 28 07           lda BackloadingFlag       ;check to see if we are starting right of start
00728C  2  F0 03              beq RenderSceneryTerrain  ;if not, go ahead and render background, foreground and terrain
00728E  2  20 95 73           jsr ProcessAreaData       ;otherwise skip ahead and load level data
007291  2               
007291  2               RenderSceneryTerrain:
007291  2  A2 0C                  ldx #$0c
007293  2  A9 00                  lda #$00
007295  2  9D A1 06     ClrMTBuf: sta MetatileBuffer,x       ;clear out metatile buffer
007298  2  CA                     dex
007299  2  10 FA                  bpl ClrMTBuf
00729B  2  AC 42 07               ldy BackgroundScenery      ;do we need to render the background scenery?
00729E  2  F0 42                  beq RendFore               ;if not, skip to check the foreground
0072A0  2  AD 25 07               lda CurrentPageLoc         ;otherwise check for every third page
0072A3  2  C9 03        ThirdP:   cmp #$03
0072A5  2  30 05                  bmi RendBack               ;if less than three we're there
0072A7  2  38                     sec
0072A8  2  E9 03                  sbc #$03                   ;if 3 or more, subtract 3 and
0072AA  2  10 F7                  bpl ThirdP                 ;do an unconditional branch
0072AC  2  0A           RendBack: asl                        ;move results to higher nybble
0072AD  2  0A                     asl
0072AE  2  0A                     asl
0072AF  2  0A                     asl
0072B0  2  79 83 71               adc BSceneDataOffsets-1,y  ;add to it offset loaded from here
0072B3  2  6D 26 07               adc CurrentColumnPos       ;add to the result our current column position
0072B6  2  AA                     tax
0072B7  2  BD 87 71               lda BackSceneryData,x      ;load data from sum of offsets
0072BA  2  F0 26                  beq RendFore               ;if zero, no scenery for that part
0072BC  2  48                     pha
0072BD  2  29 0F                  and #$0f                   ;save to stack and clear high nybble
0072BF  2  38                     sec
0072C0  2  E9 01                  sbc #$01                   ;subtract one (because low nybble is $01-$0c)
0072C2  2  85 00                  sta $00                    ;save low nybble
0072C4  2  0A                     asl                        ;multiply by three (shift to left and add result to old one)
0072C5  2  65 00                  adc $00                    ;note that since d7 was nulled, the carry flag is always clear
0072C7  2  AA                     tax                        ;save as offset for background scenery metatile data
0072C8  2  68                     pla                        ;get high nybble from stack, move low
0072C9  2  4A                     lsr
0072CA  2  4A                     lsr
0072CB  2  4A                     lsr
0072CC  2  4A                     lsr
0072CD  2  A8                     tay                        ;use as second offset (used to determine height)
0072CE  2  A9 03                  lda #$03                   ;use previously saved memory location for counter
0072D0  2  85 00                  sta $00
0072D2  2  BD 17 72     SceLoop1: lda BackSceneryMetatiles,x ;load metatile data from offset of (lsb - 1) * 3
0072D5  2  99 A1 06               sta MetatileBuffer,y       ;store into buffer from offset of (msb / 16)
0072D8  2  E8                     inx
0072D9  2  C8                     iny
0072DA  2  C0 0B                  cpy #$0b                   ;if at this location, leave loop
0072DC  2  F0 04                  beq RendFore
0072DE  2  C6 00                  dec $00                    ;decrement until counter expires, barring exception
0072E0  2  D0 F0                  bne SceLoop1
0072E2  2  AE 41 07     RendFore: ldx ForegroundScenery      ;check for foreground data needed or not
0072E5  2  F0 13                  beq RendTerr               ;if not, skip this part
0072E7  2  BC 3A 72               ldy FSceneDataOffsets-1,x  ;load offset from location offset by header value, then
0072EA  2  A2 00                  ldx #$00                   ;reinit X
0072EC  2  B9 3E 72     SceLoop2: lda ForeSceneryData,y      ;load data until counter expires
0072EF  2  F0 03                  beq NoFore                 ;do not store if zero found
0072F1  2  9D A1 06               sta MetatileBuffer,x
0072F4  2  C8           NoFore:   iny
0072F5  2  E8                     inx
0072F6  2  E0 0D                  cpx #$0d                   ;store up to end of metatile buffer
0072F8  2  D0 F2                  bne SceLoop2
0072FA  2  AC 4E 07     RendTerr: ldy AreaType               ;check world type for water level
0072FD  2  D0 0C                  bne TerMTile               ;if not water level, skip this part
0072FF  2  AD 5F 07               lda WorldNumber            ;check world number, if not world number eight
007302  2  C9 07                  cmp #World8                ;then skip this part
007304  2  D0 05                  bne TerMTile
007306  2               .ifdef ANN
007306  2  A9 62                  lda #$62
007308  2               .else
007308  2                         lda #$63                   ;if set as water level and world number eight,
007308  2               .endif
007308  2  4C 15 73               jmp StoreMT                ;use castle wall metatile as terrain type
00730B  2  B9 65 72     TerMTile: lda TerrainMetatiles,y     ;otherwise get appropriate metatile for area type
00730E  2  AC 43 07               ldy CloudTypeOverride      ;check for cloud type override
007311  2  F0 02                  beq StoreMT                ;if not set, keep value otherwise
007313  2  A9 88                  lda #$88                   ;use cloud block terrain
007315  2  85 07        StoreMT:  sta $07                    ;store value here
007317  2  A2 00                  ldx #$00                   ;initialize X, use as metatile buffer offset
007319  2  AD 27 07               lda TerrainControl         ;use yet another value from the header
00731C  2  0A                     asl                        ;multiply by 2 and use as yet another offset
00731D  2  A8                     tay
00731E  2  B9 69 72     TerrLoop: lda TerrainRenderBits,y    ;get one of the terrain rendering bit data
007321  2  85 00                  sta $00
007323  2  C8                     iny                        ;increment Y and use as offset next time around
007324  2  84 01                  sty $01
007326  2  AD 43 07               lda CloudTypeOverride      ;skip if value here is zero
007329  2  F0 0A                  beq NoCloud2
00732B  2  E0 00                  cpx #$00                   ;otherwise, check if we're doing the ceiling byte
00732D  2  F0 06                  beq NoCloud2
00732F  2  A5 00                  lda $00                    ;if not, mask out all but d3
007331  2  29 08                  and #%00001000
007333  2  85 00                  sta $00
007335  2  A0 00        NoCloud2: ldy #$00                   ;start at beginning of bitmasks
007337  2  B9 BD 92     TerrBChk: lda Bitmasks,y             ;load bitmask, then perform AND on contents of first byte
00733A  2  24 00                  bit $00
00733C  2  F0 05                  beq NextTBit               ;if not set, skip this part (do not write terrain to buffer)
00733E  2  A5 07                  lda $07
007340  2  9D A1 06               sta MetatileBuffer,x       ;load terrain type metatile number and store into buffer here
007343  2  E8           NextTBit: inx                        ;continue until end of buffer
007344  2  E0 0D                  cpx #$0d
007346  2  F0 18                  beq RendBBuf               ;if we're at the end, break out of this loop
007348  2  AD 4E 07               lda AreaType               ;check world type for underground area
00734B  2  C9 02                  cmp #$02
00734D  2  D0 08                  bne EndUChk                ;if not underground, skip this part
00734F  2  E0 0B                  cpx #$0b
007351  2  D0 04                  bne EndUChk                ;if we're at the bottom of the screen, override
007353  2               .ifdef ANN
007353  2  A9 6A                  lda #$6A
007355  2               .else
007355  2                         lda #$6b                   ;old terrain type with ground level terrain type
007355  2               .endif
007355  2  85 07                  sta $07
007357  2  C8           EndUChk:  iny                        ;increment bitmasks offset in Y
007358  2  C0 08                  cpy #$08
00735A  2  D0 DB                  bne TerrBChk               ;if not all bits checked, loop back
00735C  2  A4 01                  ldy $01
00735E  2  D0 BE                  bne TerrLoop               ;unconditional branch, use Y to load next byte
007360  2  20 95 73     RendBBuf: jsr ProcessAreaData        ;do the area data loading routine now
007363  2  AD A0 06               lda BlockBufferColumnPos
007366  2  20 92 7A               jsr GetBlockBufferAddr     ;get block buffer address from where we're at
007369  2  A2 00                  ldx #$00
00736B  2  A0 00                  ldy #$00                   ;init index regs and start at beginning of smaller buffer
00736D  2  84 00        ChkMTLow: sty $00
00736F  2  BD A1 06               lda MetatileBuffer,x       ;load stored metatile number
007372  2  29 C0                  and #%11000000             ;mask out all but 2 MSB
007374  2  0A                     asl
007375  2  2A                     rol                        ;make %xx000000 into %000000xx
007376  2  2A                     rol
007377  2  A8                     tay                        ;use as offset in Y
007378  2  BD A1 06               lda MetatileBuffer,x       ;reload original unmasked value here
00737B  2  D9 91 73               cmp BlockBuffLowBounds,y   ;check for certain values depending on bits set
00737E  2  B0 02                  bcs StrBlock               ;if equal or greater, branch
007380  2  A9 00                  lda #$00                   ;if less, init value before storing
007382  2  A4 00        StrBlock: ldy $00                    ;get offset for block buffer
007384  2  91 06                  sta ($06),y                ;store value into block buffer
007386  2  98                     tya
007387  2  18                     clc                        ;add 16 (move down one row) to offset
007388  2  69 10                  adc #$10
00738A  2  A8                     tay
00738B  2  E8                     inx                        ;increment column value
00738C  2  E0 0D                  cpx #$0d
00738E  2  90 DD                  bcc ChkMTLow               ;continue until we pass last row, then leave
007390  2  60                     rts
007391  2               
007391  2               ;numbers lower than these with the same attribute bits
007391  2               ;will not be stored in the block buffer
007391  2               BlockBuffLowBounds:
007391  2               .ifdef ANN
007391  2  10 51 88 C0        .byte $10, $51, $88, $c0
007395  2               .else
007395  2                     .byte $10, $4f, $88, $c0
007395  2               .endif
007395  2               
007395  2               ;-------------------------------------------------------------------------------------
007395  2               ;$00 - used to store area object identifier
007395  2               ;$07 - used as adder to find proper area object code
007395  2               
007395  2               ProcessAreaData:
007395  2  A2 02                    ldx #$02                 ;start at the end of area object buffer
007397  2  86 08        ProcADLoop: stx ObjectOffset
007399  2  A9 00                    lda #$00                 ;reset flag
00739B  2  8D 29 07                 sta BehindAreaParserFlag
00739E  2  AC 2C 07                 ldy AreaDataOffset       ;get offset of area data pointer
0073A1  2  B1 E7                    lda (AreaData),y         ;get first byte of area object
0073A3  2  C9 FD                    cmp #$fd                 ;if end-of-area, skip all this crap
0073A5  2  F0 4B                    beq RdyDecode
0073A7  2  BD 30 07                 lda AreaObjectLength,x   ;check area object buffer flag
0073AA  2  10 46                    bpl RdyDecode            ;if buffer not negative, branch, otherwise
0073AC  2  C8                       iny
0073AD  2  B1 E7                    lda (AreaData),y         ;get second byte of area object
0073AF  2  0A                       asl                      ;check for page select bit (d7), branch if not set
0073B0  2  90 0B                    bcc Chk1Row13
0073B2  2  AD 2B 07                 lda AreaObjectPageSel    ;check page select
0073B5  2  D0 06                    bne Chk1Row13
0073B7  2  EE 2B 07                 inc AreaObjectPageSel    ;if not already set, set it now
0073BA  2  EE 2A 07                 inc AreaObjectPageLoc    ;and increment page location
0073BD  2  88           Chk1Row13:  dey
0073BE  2  B1 E7                    lda (AreaData),y         ;reread first byte of level object
0073C0  2  29 0F                    and #$0f                 ;mask out high nybble
0073C2  2  C9 0D                    cmp #$0d                 ;row 13?
0073C4  2  D0 1B                    bne Chk1Row14
0073C6  2  C8                       iny                      ;if so, reread second byte of level object
0073C7  2  B1 E7                    lda (AreaData),y
0073C9  2  88                       dey                      ;decrement to get ready to read first byte
0073CA  2  29 40                    and #%01000000           ;check for d6 set (if not, object is page control)
0073CC  2  D0 1C                    bne CheckRear
0073CE  2  AD 2B 07                 lda AreaObjectPageSel    ;if page select is set, do not reread
0073D1  2  D0 17                    bne CheckRear
0073D3  2  C8                       iny                      ;if d6 not set, reread second byte
0073D4  2  B1 E7                    lda (AreaData),y
0073D6  2  29 1F                    and #%00011111           ;mask out all but 5 LSB and store in page control
0073D8  2  8D 2A 07                 sta AreaObjectPageLoc
0073DB  2  EE 2B 07                 inc AreaObjectPageSel    ;increment page select
0073DE  2  4C FB 73                 jmp NextAObj
0073E1  2  C9 0E        Chk1Row14:  cmp #$0e                 ;row 14?
0073E3  2  D0 05                    bne CheckRear
0073E5  2  AD 28 07                 lda BackloadingFlag      ;check flag for saved page number and branch if set
0073E8  2  D0 08                    bne RdyDecode            ;to render the object (otherwise bg might not look right)
0073EA  2  AD 2A 07     CheckRear:  lda AreaObjectPageLoc    ;check to see if current page of level object is
0073ED  2  CD 25 07                 cmp CurrentPageLoc       ;behind current page of renderer
0073F0  2  90 06                    bcc SetBehind            ;if so branch
0073F2  2  20 22 74     RdyDecode:  jsr DecodeAreaData       ;do sub and do not turn on flag
0073F5  2  4C FE 73                 jmp ChkLength
0073F8  2  EE 29 07     SetBehind:  inc BehindAreaParserFlag ;turn on flag if object is behind renderer
0073FB  2  20 16 74     NextAObj:   jsr IncAreaObjOffset     ;increment buffer offset and move on
0073FE  2  A6 08        ChkLength:  ldx ObjectOffset         ;get buffer offset
007400  2  BD 30 07                 lda AreaObjectLength,x   ;check object length for anything stored here
007403  2  30 03                    bmi ProcLoopb            ;if not, branch to handle loopback
007405  2  DE 30 07                 dec AreaObjectLength,x   ;otherwise decrement length or get rid of it
007408  2  CA           ProcLoopb:  dex                      ;decrement buffer offset
007409  2  10 8C                    bpl ProcADLoop           ;and loopback unless exceeded buffer
00740B  2  AD 29 07                 lda BehindAreaParserFlag ;check for flag set if objects were behind renderer
00740E  2  D0 85                    bne ProcessAreaData      ;branch if true to load more level data, otherwise
007410  2  AD 28 07                 lda BackloadingFlag      ;check for flag set if starting right of page $00
007413  2  D0 80                    bne ProcessAreaData      ;branch if true to load more level data, otherwise leave
007415  2  60           EndAParse:  rts
007416  2               
007416  2               IncAreaObjOffset:
007416  2  EE 2C 07           inc AreaDataOffset    ;increment offset of level pointer
007419  2  EE 2C 07           inc AreaDataOffset
00741C  2  A9 00              lda #$00              ;reset page select
00741E  2  8D 2B 07           sta AreaObjectPageSel
007421  2  60                 rts
007422  2               
007422  2               DecodeAreaData:
007422  2  BD 30 07               lda AreaObjectLength,x     ;check current buffer flag
007425  2  30 03                  bmi Chk1stB
007427  2  BC 2D 07               ldy AreaObjOffsetBuffer,x  ;if not, get offset from buffer
00742A  2  A2 10        Chk1stB:  ldx #$10                   ;load offset of 16 for special row 15
00742C  2  B1 E7                  lda (AreaData),y           ;get first byte of level object again
00742E  2  C9 FD                  cmp #$fd
007430  2  F0 E3                  beq EndAParse              ;if end of level, leave this routine
007432  2  29 0F                  and #$0f                   ;otherwise, mask out low nybble
007434  2  C9 0F                  cmp #$0f                   ;row 15?
007436  2  F0 08                  beq ChkRow14               ;if so, keep the offset of 16
007438  2  A2 08                  ldx #$08                   ;otherwise load offset of 8 for special row 12
00743A  2  C9 0C                  cmp #$0c                   ;row 12?
00743C  2  F0 02                  beq ChkRow14               ;if so, keep the offset value of 8
00743E  2  A2 00                  ldx #$00                   ;otherwise nullify value by default
007440  2  86 07        ChkRow14: stx $07                    ;store whatever value we just loaded here
007442  2  A6 08                  ldx ObjectOffset           ;get object offset again
007444  2  C9 0E                  cmp #$0e                   ;row 14?
007446  2  D0 08                  bne ChkRow13
007448  2  A9 00                  lda #$00                   ;if so, load offset with $00
00744A  2  85 07                  sta $07
00744C  2               .ifdef ANN
00744C  2  A9 31                  lda #$31
00744E  2               .else
00744E  2                         lda #$36                   ;and load A with another value
00744E  2               .endif
00744E  2  D0 53                  bne NormObj                ;unconditional branch
007450  2  C9 0D        ChkRow13: cmp #$0d                   ;row 13?
007452  2  D0 1B                  bne ChkSRows
007454  2               .ifdef ANN
007454  2  A9 25                  lda #$25
007456  2               .else
007456  2                         lda #$28                   ;if so, load offset with 40
007456  2               .endif
007456  2  85 07                  sta $07
007458  2  C8                     iny                        ;get next byte
007459  2  B1 E7                  lda (AreaData),y
00745B  2  29 40                  and #%01000000             ;mask out all but d6 (page control obj bit)
00745D  2  F0 63                  beq LeavePar               ;if d6 clear, branch to leave (we handled this earlier)
00745F  2  B1 E7                  lda (AreaData),y           ;otherwise, get byte again
007461  2  29 7F                  and #%01111111             ;mask out d7
007463  2  C9 4B                  cmp #$4b                   ;check for loop command in low nybble
007465  2  D0 03                  bne Mask2MSB               ;(plus d6 set for object other than page control)
007467  2  EE 45 07               inc LoopCommand            ;if loop command, set loop command flag
00746A  2  29 3F        Mask2MSB: and #%00111111             ;mask out d7 and d6
00746C  2  4C A3 74               jmp NormObj                ;and jump
00746F  2  C9 0C        ChkSRows: cmp #$0c                   ;row 12-15?
007471  2  B0 27                  bcs SpecObj
007473  2  C8                     iny                        ;if not, get second byte of level object
007474  2  B1 E7                  lda (AreaData),y
007476  2  29 70                  and #%01110000             ;mask out all but d6-d4
007478  2  D0 0B                  bne LrgObj                 ;if any bits set, branch to handle large object
00747A  2  A9 18                  lda #$18
00747C  2  85 07                  sta $07                    ;otherwise set offset of 24 for small object
00747E  2  B1 E7                  lda (AreaData),y           ;reload second byte of level object
007480  2  29 0F                  and #%00001111             ;mask out higher nybble and jump
007482  2  4C A3 74               jmp NormObj
007485  2  85 00        LrgObj:   sta $00                    ;store value here (branch for large objects)
007487  2  C9 70                  cmp #$70                   ;check for vertical pipe object
007489  2  D0 0A                  bne NotWPipe
00748B  2  B1 E7                  lda (AreaData),y           ;if not, reload second byte
00748D  2  29 08                  and #%00001000             ;mask out all but d3 (usage control bit)
00748F  2  F0 04                  beq NotWPipe               ;if d3 clear, branch to get original value
007491  2  A9 00                  lda #$00                   ;otherwise, nullify value for warp pipe
007493  2  85 00                  sta $00
007495  2  A5 00        NotWPipe: lda $00                    ;get value and jump ahead
007497  2  4C 9F 74               jmp MoveAOId
00749A  2  C8           SpecObj:  iny                        ;branch here for rows 12-15
00749B  2  B1 E7                  lda (AreaData),y
00749D  2  29 70                  and #%01110000             ;get next byte and mask out all but d6-d4
00749F  2  4A           MoveAOId: lsr                        ;move d6-d4 to lower nybble
0074A0  2  4A                     lsr
0074A1  2  4A                     lsr
0074A2  2  4A                     lsr
0074A3  2  85 00        NormObj:  sta $00                    ;store value here (branch for small objects and rows 13 and 14)
0074A5  2  BD 30 07               lda AreaObjectLength,x     ;is there something stored here already?
0074A8  2  10 42                  bpl RunAObj                ;if so, branch to do its particular sub
0074AA  2  AD 2A 07               lda AreaObjectPageLoc      ;otherwise check to see if the object we've loaded is on the
0074AD  2  CD 25 07               cmp CurrentPageLoc         ;same page as the renderer, and if so, branch
0074B0  2  F0 11                  beq InitRear
0074B2  2  AC 2C 07               ldy AreaDataOffset         ;if not, get old offset of level pointer
0074B5  2  B1 E7                  lda (AreaData),y           ;and reload first byte
0074B7  2  29 0F                  and #%00001111
0074B9  2  C9 0E                  cmp #$0e                   ;row 14?
0074BB  2  D0 05                  bne LeavePar
0074BD  2  AD 28 07               lda BackloadingFlag        ;if so, check backloading flag
0074C0  2  D0 21                  bne StrAObj                ;if set, branch to render object, else leave
0074C2  2  60           LeavePar: rts
0074C3  2  AD 28 07     InitRear: lda BackloadingFlag        ;check backloading flag to see if it's been initialized
0074C6  2  F0 0B                  beq BackColC               ;branch to column-wise check
0074C8  2  A9 00                  lda #$00                   ;if not, initialize both backloading and
0074CA  2  8D 28 07               sta BackloadingFlag        ;behind-renderer flags and leave
0074CD  2  8D 29 07               sta BehindAreaParserFlag
0074D0  2  85 08                  sta ObjectOffset
0074D2  2  60           LoopCmdE: rts
0074D3  2  AC 2C 07     BackColC: ldy AreaDataOffset         ;get first byte again
0074D6  2  B1 E7                  lda (AreaData),y
0074D8  2  29 F0                  and #%11110000             ;mask out low nybble and move high to low
0074DA  2  4A                     lsr
0074DB  2  4A                     lsr
0074DC  2  4A                     lsr
0074DD  2  4A                     lsr
0074DE  2  CD 26 07               cmp CurrentColumnPos       ;is this where we're at?
0074E1  2  D0 DF                  bne LeavePar               ;if not, branch to leave
0074E3  2  AD 2C 07     StrAObj:  lda AreaDataOffset         ;if so, load area obj offset and store in buffer
0074E6  2  9D 2D 07               sta AreaObjOffsetBuffer,x
0074E9  2  20 16 74               jsr IncAreaObjOffset       ;do sub to increment to next object data
0074EC  2  A5 00        RunAObj:  lda $00                    ;get stored value and add offset to it
0074EE  2  18                     clc                        ;then use the jump engine with current contents of A
0074EF  2  65 07                  adc $07
0074F1  2  20 0F 6D               jsr JumpEngine
0074F4  2               
0074F4  2  8E 77         .word VerticalPipe
0074F6  2  E9 75         .word AreaStyleObject
0074F8  2  DD 78         .word RowOfBricks
0074FA  2  ED 78         .word RowOfSolidBlocks
0074FC  2  A1 78         .word RowOfCoins
0074FE  2  FF 78         .word ColumnOfBricks
007500  2  08 79         .word ColumnOfSolidBlocks
007502  2  8E 77         .word VerticalPipe
007504  2               
007504  2  F2 79         .word Hole_Empty
007506  2  63 76         .word PulleyRopeObject
007508  2  28 78         .word Bridge_High
00750A  2  2B 78         .word Bridge_Middle
00750C  2  2E 78         .word Bridge_Low
00750E  2  06 78         .word Hole_Water
007510  2  17 78         .word QuestionBlockRow_High
007512  2  1A 78         .word QuestionBlockRow_Low
007514  2               
007514  2  7F 78         .word EndlessRope
007516  2  86 78         .word BalancePlatRope
007518  2  AF 76         .word CastleObject
00751A  2  66 79         .word StaircaseObject
00751C  2  54 77         .word ExitPipe
00751E  2  43 78         .word FlagBalls_Residual
007520  2  rr rr         .word UpsideDownPipe_High
007522  2  rr rr         .word UpsideDownPipe_Low
007524  2               
007524  2  BF 79         .word QuestionBlock
007526  2  BF 79         .word QuestionBlock
007528  2  BF 79         .word QuestionBlock
00752A  2                .ifndef ANN
00752A  2                .word QuestionBlock
00752A  2                .endif
00752A  2  B2 79         .word Hidden1UpBlock
00752C  2  BF 79         .word QuestionBlock
00752E  2                .ifndef ANN
00752E  2                .word QuestionBlock
00752E  2                .endif
00752E  2  CA 79         .word BrickWithItem
007530  2  CA 79         .word BrickWithItem
007532  2  CA 79         .word BrickWithItem
007534  2                .ifndef ANN
007534  2                .word BrickWithItem
007534  2                .endif
007534  2  C5 79         .word BrickWithCoins
007536  2  CA 79         .word BrickWithItem
007538  2  18 77         .word WaterPipe
00753A  2  C8 78         .word EmptyBlock
00753C  2  82 79         .word Jumpspring
00753E  2               
00753E  2  2B 77         .word IntroPipe
007540  2  4D 78         .word FlagpoleObject
007542  2  B8 78         .word AxeObj
007544  2  BD 78         .word ChainObj
007546  2  B0 78         .word CastleBridgeObj
007548  2  85 75         .word ScrollLockObject_Warp
00754A  2  B6 75         .word ScrollLockObject
00754C  2  B6 75         .word ScrollLockObject
00754E  2  D4 75         .word AreaFrenzy
007550  2  D4 75         .word AreaFrenzy
007552  2  D4 75         .word AreaFrenzy
007554  2  D2 74         .word LoopCmdE
007556  2                .ifndef ANN
007556  2                .word WindOn                ;these two are in SM2DATA2 and SM2DATA4
007556  2                .word WindOff
007556  2               .endif
007556  2               
007556  2  58 75         .word AlterAreaAttributes
007558  2               
007558  2               ;-------------------------------------------------------------------------------------
007558  2               ;(these apply to all area object subroutines in this section unless otherwise stated)
007558  2               ;$00 - used to store offset used to find object code
007558  2               ;$07 - starts with adder from area parser, used to store row offset
007558  2               
007558  2               AlterAreaAttributes:
007558  2  BC 2D 07              ldy AreaObjOffsetBuffer,x ;load offset for level object data saved in buffer
00755B  2  C8                    iny                       ;load second byte
00755C  2  B1 E7                 lda (AreaData),y
00755E  2  48                    pha                       ;save in stack for now
00755F  2  29 40                 and #%01000000
007561  2  D0 12                 bne Alter2                ;branch if d6 is set
007563  2  68                    pla
007564  2  48                    pha                       ;pull and push offset to copy to A
007565  2  29 0F                 and #%00001111            ;mask out high nybble and store as
007567  2  8D 27 07              sta TerrainControl        ;new terrain height type bits
00756A  2  68                    pla
00756B  2  29 30                 and #%00110000            ;pull and mask out all but d5 and d4
00756D  2  4A                    lsr                       ;move bits to lower nybble and store
00756E  2  4A                    lsr                       ;as new background scenery bits
00756F  2  4A                    lsr
007570  2  4A                    lsr
007571  2  8D 42 07              sta BackgroundScenery     ;then leave
007574  2  60                    rts
007575  2  68           Alter2:  pla
007576  2  29 07                 and #%00000111            ;mask out all but 3 LSB
007578  2  C9 04                 cmp #$04                  ;if four or greater, set color control bits
00757A  2  90 05                 bcc SetFore               ;and nullify foreground scenery bits
00757C  2  8D 44 07              sta BackgroundColorCtrl
00757F  2  A9 00                 lda #$00
007581  2  8D 41 07     SetFore: sta ForegroundScenery     ;otherwise set new foreground scenery bits
007584  2  60                    rts
007585  2               
007585  2               ;--------------------------------
007585  2               
007585  2               ScrollLockObject_Warp:
007585  2               .ifdef ANN
007585  2  A2 80              ldx #$80                 ;use base number for warp to world 2
007587  2  AD FB 07           lda HardWorldFlag        ;if on worlds A-D, skip ahead to next part
00758A  2  D0 0F              bne WarpWorldsAThruD     ;note d7 is set in all entries to prevent zero condition
00758C  2  AD 5F 07           lda WorldNumber          ;from happening in warp zone code elsewhere
00758F  2  F0 19              beq BaseW                ;if not on world 1, branch to handle a different way
007591  2  E8                 inx
007592  2  AC 4E 07           ldy AreaType
007595  2  88                 dey
007596  2  D0 12              bne BaseW
007598  2  4C A9 75           jmp Warp2
00759B  2               
00759B  2               WarpWorldsAThruD:
00759B  2  A2 84              ldx #$84
00759D  2  AD 5F 07           lda WorldNumber
0075A0  2  D0 07              bne Warp2
0075A2  2  CA                 dex
0075A3  2  AC 5C 07           ldy LevelNumber
0075A6  2  88                 dey
0075A7  2  F0 01              beq BaseW
0075A9  2               
0075A9  2               Warp2:
0075A9  2  E8                 inx
0075AA  2               BaseW:
0075AA  2  8A                 txa
0075AB  2               .else
0075AB  2                        ldx #$80                 ;use base number for warp to world 2
0075AB  2                        lda HardWorldFlag        ;if on worlds A-D, skip ahead to next part
0075AB  2                        bne WarpWorldsAThruD     ;note d7 is set in all entries to prevent zero condition
0075AB  2                        lda WorldNumber          ;from happening in warp zone code elsewhere
0075AB  2                        bne WarpWorlds2Thru8     ;if not on world 1, branch to handle a different way
0075AB  2                        ldy AreaType             ;check to see if on ground level type
0075AB  2                        dey                      ;branch if so to add one to the number
0075AB  2                        beq W1Warp2
0075AB  2                        lda AreaAddrsLOffset     ;if on first underground level, branch to use base number
0075AB  2                        beq W1Warp1
0075AB  2                        inx                      ;otherwise add two to the number and use it
0075AB  2               W1Warp2: inx
0075AB  2               W1Warp1: jmp BaseW
0075AB  2               
0075AB  2               WarpWorldsAThruD:
0075AB  2                     lda #$87                 ;use base number for worlds A-D
0075AB  2                     clc
0075AB  2                     adc LevelNumber          ;add level number itself to it
0075AB  2                     bne DumpWarpCtrl         ;then branch to use it
0075AB  2               
0075AB  2               WarpWorlds2Thru8:
0075AB  2                     ldx #$83                 ;use base number for worlds 2-8
0075AB  2                     lda WorldNumber
0075AB  2                     cmp #World3              ;branch if on world 3 to use
0075AB  2                     beq BaseW
0075AB  2                     inx                      ;otherwise add one to the number
0075AB  2                     cmp #World5              ;if not on world 5, branch to add 3 more
0075AB  2                     bne W678Warp
0075AB  2                     lda AreaAddrsLOffset
0075AB  2                     cmp #$0b                 ;if on the 12th ground area, branch to use
0075AB  2                     beq BaseW                ;(in normal map data this corresponds to world 5-1)
0075AB  2                     ldy AreaType             ;check to see if on ground level type
0075AB  2                     dey                      ;branch if so to add 2 more to the number
0075AB  2                     beq W5Warp3
0075AB  2                     jmp W5Warp2              ;otherwise add 1 more
0075AB  2               
0075AB  2               W678Warp: inx                  ;add 1, 2, or 3 to base number or use as-is
0075AB  2               W5Warp3:  inx                  ;depending on where branched
0075AB  2               W5Warp2:  inx
0075AB  2               BaseW:    txa
0075AB  2               .endif
0075AB  2               
0075AB  2               DumpWarpCtrl:
0075AB  2  8D D6 06           sta WarpZoneControl      ;set warp zone control
0075AE  2  20 EB 67           jsr WriteWarpZoneMessage
0075B1  2  A9 0D              lda #$0d                 ;kill piranha plants
0075B3  2  20 BF 75           jsr KillEnemies
0075B6  2               
0075B6  2               ScrollLockObject:
0075B6  2  AD 23 07           lda ScrollLock      ;invert scroll lock to turn it on
0075B9  2  49 01              eor #%00000001
0075BB  2  8D 23 07           sta ScrollLock
0075BE  2  60                 rts
0075BF  2               
0075BF  2               ;--------------------------------
0075BF  2               ;$00 - used to store enemy identifier in KillEnemies
0075BF  2               
0075BF  2               KillEnemies:
0075BF  2  85 00                   sta $00           ;store identifier here
0075C1  2  A9 00                   lda #$00
0075C3  2  A2 04                   ldx #$04          ;check for identifier in enemy object buffer
0075C5  2  B4 16        KillELoop: ldy Enemy_ID,x
0075C7  2  C4 00                   cpy $00           ;if not found, branch
0075C9  2  D0 02                   bne NoKillE
0075CB  2  95 0F                   sta Enemy_Flag,x  ;if found, deactivate enemy object flag
0075CD  2  CA           NoKillE:   dex               ;do this until all slots are checked
0075CE  2  10 F5                   bpl KillELoop
0075D0  2  60                      rts
0075D1  2               
0075D1  2               ;--------------------------------
0075D1  2               
0075D1  2               FrenzyIDData:
0075D1  2  14 17 18           .byte FlyCheepCheepFrenzy, BBill_CCheep_Frenzy, Stop_Frenzy
0075D4  2               
0075D4  2  A6 00        AreaFrenzy:  ldx $00               ;use area object identifier bit as offset
0075D6  2  BD C9 75                  lda FrenzyIDData-8,x  ;note that it starts at 8, thus weird address here
0075D9  2  A0 05                     ldy #$05
0075DB  2  88           FreCompLoop: dey                   ;check regular slots of enemy object buffer
0075DC  2  30 07                     bmi ExitAFrenzy       ;if all slots checked and enemy object not found, branch to store
0075DE  2  D9 16 00                  cmp Enemy_ID,y    ;check for enemy object in buffer versus frenzy object
0075E1  2  D0 F8                     bne FreCompLoop
0075E3  2  A9 00                     lda #$00              ;if enemy object already present, nullify queue and leave
0075E5  2  8D CD 06     ExitAFrenzy: sta EnemyFrenzyQueue  ;store enemy into frenzy queue
0075E8  2  60                        rts
0075E9  2               
0075E9  2               
0075E9  2               ;--------------------------------
0075E9  2               ;$06 - used by CloudLedge to store length
0075E9  2               
0075E9  2               AreaStyleObject:
0075E9  2  AD 33 07           lda AreaStyle        ;load level object style and jump to the right sub
0075EC  2  20 0F 6D           jsr JumpEngine
0075EF  2  F5 75              .word TreeLedge        ;also used for cloud bonus levels
0075F1  2               .ifdef ANN
0075F1  2  21 76              .word MushroomLedge
0075F3  2               .else
0075F3  2                     .word CloudLedge
0075F3  2               .endif
0075F3  2  18 79              .word BulletBillCannon
0075F5  2               
0075F5  2               TreeLedge:
0075F5  2  20 6C 7A               jsr GetLrgObjAttrib     ;get row and length of green ledge
0075F8  2  BD 30 07               lda AreaObjectLength,x  ;check length counter for expiration
0075FB  2  F0 1F                  beq EndTreeL
0075FD  2  10 11                  bpl MidTreeL
0075FF  2  98                     tya
007600  2  9D 30 07               sta AreaObjectLength,x  ;store lower nybble into buffer flag as length of ledge
007603  2  AD 25 07               lda CurrentPageLoc
007606  2  0D 26 07               ora CurrentColumnPos    ;are we at the start of the level?
007609  2  F0 05                  beq MidTreeL
00760B  2  A9 16                  lda #$16                ;render start of tree ledge
00760D  2  4C 59 76               jmp NoUnder
007610  2  A6 07        MidTreeL: ldx $07
007612  2  A9 17                  lda #$17                ;render middle of tree ledge
007614  2  9D A1 06               sta MetatileBuffer,x    ;note that this is also used if ledge position is
007617  2  A9 4C                  lda #$4c                ;at the start of level for continuous effect
007619  2  4C 53 76               jmp AllUnder            ;now render the part underneath
00761C  2  A9 18        EndTreeL: lda #$18                ;render end of tree ledge
00761E  2  4C 59 76               jmp NoUnder
007621  2               
007621  2               .ifdef ANN
007621  2               MushroomLedge:
007621  2  20 5D 7A               jsr ChkLrgObjLength        ;get shroom dimensions
007624  2  84 06                  sty $06                    ;store length here for now
007626  2  90 0C                  bcc EndMushL
007628  2  BD 30 07               lda AreaObjectLength,x     ;divide length by 2 and store elsewhere
00762B  2  4A                     lsr
00762C  2  9D 36 07               sta MushroomLedgeHalfLen,x
00762F  2  A9 19                  lda #$19                   ;render start of mushroom
007631  2  4C 59 76               jmp NoUnder
007634  2  A9 1B        EndMushL: lda #$1b                   ;if at the end, render end of mushroom
007636  2  BC 30 07               ldy AreaObjectLength,x
007639  2  F0 1E                  beq NoUnder
00763B  2  BD 36 07               lda MushroomLedgeHalfLen,x ;get divided length and store where length
00763E  2  85 06                  sta $06                    ;was stored originally
007640  2  A6 07                  ldx $07
007642  2  A9 1A                  lda #$1a
007644  2  9D A1 06               sta MetatileBuffer,x       ;render middle of mushroom
007647  2  C4 06                  cpy $06                    ;are we smack dab in the center?
007649  2  D0 2C                  bne MushLExit              ;if not, branch to leave
00764B  2  E8                     inx
00764C  2  A9 4F                  lda #$4f
00764E  2  9D A1 06               sta MetatileBuffer,x       ;render stem top of mushroom underneath the middle
007651  2  A9 50                  lda #$50
007653  2               .else
007653  2               ;note: This is the style utilized by world 8-3 and part of world 8-2, and not to
007653  2               ;be confused with the cloud-type bonus levels full of coins found throughout the game.
007653  2               CloudLedge:
007653  2                         jsr ChkLrgObjLength        ;get cloud dimensions
007653  2                         sty $06                    ;store length here for now
007653  2                         bcc EndCloud
007653  2                         lda AreaObjectLength,x     ;divide length by 2 and store elsewhere
007653  2                         lsr
007653  2                         sta MushroomLedgeHalfLen,x
007653  2                         lda #$8a                   ;render start of cloud
007653  2                         jmp NoUnder
007653  2               EndCloud: lda #$8c                   ;if at the end, render end of cloud
007653  2                         ldy AreaObjectLength,x
007653  2                         beq NoUnder
007653  2                         lda MushroomLedgeHalfLen,x ;get divided length and store where length
007653  2                         sta $06                    ;was stored originally
007653  2                         ldx $07
007653  2                         lda #$8b
007653  2                         sta MetatileBuffer,x       ;render middle of cloud
007653  2                         rts
007653  2               .endif
007653  2               
007653  2  E8           AllUnder: inx
007654  2  A0 0F                  ldy #$0f                   ;set $0f to render all way down
007656  2  4C 2E 7A               jmp RenderUnderPart        ;now render the support of the tree ledge
007659  2  A6 07        NoUnder:  ldx $07                    ;load row of ledge
00765B  2  A0 00                  ldy #$00                   ;set 0 for no bottom on this part
00765D  2  4C 2E 7A               jmp RenderUnderPart
007660  2               
007660  2               ;--------------------------------
007660  2               
007660  2               ;tiles used by pulleys and rope object
007660  2               PulleyRopeMetatiles:
007660  2  42 41 43           .byte $42, $41, $43
007663  2               
007663  2               PulleyRopeObject:
007663  2  20 5D 7A                jsr ChkLrgObjLength       ;get length of pulley/rope object
007666  2  A0 00                   ldy #$00                  ;initialize metatile offset
007668  2  B0 07                   bcs RenderPul             ;if starting, render left pulley
00766A  2  C8                      iny
00766B  2  BD 30 07                lda AreaObjectLength,x    ;if not at the end, render rope
00766E  2  D0 01                   bne RenderPul
007670  2  C8                      iny                       ;otherwise render right pulley
007671  2  B9 60 76     RenderPul: lda PulleyRopeMetatiles,y
007674  2  8D A1 06                sta MetatileBuffer        ;render at the top of the screen
007677  2  60           MushLExit: rts                       ;and leave
007678  2               
007678  2               ;--------------------------------
007678  2               ;$06 - used to store upper limit of rows for CastleObject
007678  2               
007678  2               CastleMetatiles:
007678  2  00 45 45 45        .byte $00, $45, $45, $45, $00
00767C  2  00           
00767D  2  00 48 47 46        .byte $00, $48, $47, $46, $00
007681  2  00           
007682  2  45 49 49 49        .byte $45, $49, $49, $49, $45
007686  2  45           
007687  2  47 47 4A 47        .byte $47, $47, $4a, $47, $47
00768B  2  47           
00768C  2  47 47 4B 47        .byte $47, $47, $4b, $47, $47
007690  2  47           
007691  2  49 49 49 49        .byte $49, $49, $49, $49, $49
007695  2  49           
007696  2  47 4A 47 4A        .byte $47, $4a, $47, $4a, $47
00769A  2  47           
00769B  2  47 4B 47 4B        .byte $47, $4b, $47, $4b, $47
00769F  2  47           
0076A0  2  47 47 47 47        .byte $47, $47, $47, $47, $47
0076A4  2  47           
0076A5  2  4A 47 4A 47        .byte $4a, $47, $4a, $47, $4a
0076A9  2  4A           
0076AA  2  4B 47 4B 47        .byte $4b, $47, $4b, $47, $4b
0076AE  2  4B           
0076AF  2               
0076AF  2               CastleObject:
0076AF  2  20 6C 7A                 jsr GetLrgObjAttrib      ;save lower nybble as starting row
0076B2  2  84 07                    sty $07                  ;if starting row is above $0a, game will crash!!!
0076B4  2  A0 04                    ldy #$04
0076B6  2  20 60 7A                 jsr ChkLrgObjFixedLength ;load length of castle if not already loaded
0076B9  2  8A                       txa
0076BA  2  48                       pha                      ;save obj buffer offset to stack
0076BB  2  BC 30 07                 ldy AreaObjectLength,x   ;use current length as offset for castle data
0076BE  2  A6 07                    ldx $07                  ;begin at starting row
0076C0  2  A9 0B                    lda #$0b
0076C2  2  85 06                    sta $06                  ;load upper limit of number of rows to print
0076C4  2  B9 78 76     CRendLoop:  lda CastleMetatiles,y    ;load current byte using offset
0076C7  2  9D A1 06                 sta MetatileBuffer,x
0076CA  2  E8                       inx                      ;store in buffer and increment buffer offset
0076CB  2  A5 06                    lda $06
0076CD  2  F0 07                    beq ChkCFloor            ;have we reached upper limit yet?
0076CF  2  C8                       iny                      ;if not, increment column-wise
0076D0  2  C8                       iny                      ;to byte in next row
0076D1  2  C8                       iny
0076D2  2  C8                       iny
0076D3  2  C8                       iny
0076D4  2  C6 06                    dec $06                  ;move closer to upper limit
0076D6  2  E0 0B        ChkCFloor:  cpx #$0b                 ;have we reached the row just before floor?
0076D8  2  D0 EA                    bne CRendLoop            ;if not, go back and do another row
0076DA  2  68                       pla
0076DB  2  AA                       tax                      ;get obj buffer offset from before
0076DC  2  AD 25 07                 lda CurrentPageLoc
0076DF  2  F0 36                    beq ExitCastle           ;if we're at page 0, we do not need to do anything else
0076E1  2  BD 30 07                 lda AreaObjectLength,x   ;check length
0076E4  2  C9 01                    cmp #$01                 ;if length almost about to expire, put brick at floor
0076E6  2  F0 2A                    beq PlayerStop
0076E8  2  A4 07                    ldy $07                  ;check starting row for tall castle ($00)
0076EA  2  D0 04                    bne NotTall
0076EC  2  C9 03                    cmp #$03                 ;if found, then check to see if we're at the second column
0076EE  2  F0 22                    beq PlayerStop
0076F0  2  C9 02        NotTall:    cmp #$02                 ;if not tall castle, check to see if we're at the third column
0076F2  2  D0 23                    bne ExitCastle           ;if we aren't and the castle is tall, don't create flag yet
0076F4  2  20 7C 7A                 jsr GetAreaObjXPosition  ;otherwise, obtain and save horizontal pixel coordinate
0076F7  2  48                       pha
0076F8  2  20 F9 77                 jsr FindEmptyEnemySlot   ;find an empty place on the enemy object buffer
0076FB  2  68                       pla
0076FC  2  95 87                    sta Enemy_X_Position,x   ;then write horizontal coordinate for star flag
0076FE  2  AD 25 07                 lda CurrentPageLoc
007701  2  95 6E                    sta Enemy_PageLoc,x      ;set page location for star flag
007703  2  A9 01                    lda #$01
007705  2  95 B6                    sta Enemy_Y_HighPos,x    ;set vertical high byte
007707  2  95 0F                    sta Enemy_Flag,x         ;set flag for buffer
007709  2  A9 90                    lda #$90
00770B  2  95 CF                    sta Enemy_Y_Position,x   ;set vertical coordinate
00770D  2  A9 31                    lda #StarFlagObject      ;set star flag value in buffer itself
00770F  2  95 16                    sta Enemy_ID,x
007711  2  60                       rts
007712  2               PlayerStop:
007712  2               .ifdef ANN
007712  2  A0 52                    ldy #$52                 ;put brick at floor to stop player at end of level
007714  2               .else
007714  2                           ldy #$50                 ;put brick at floor to stop player at end of level
007714  2               .endif
007714  2  8C AB 06                 sty MetatileBuffer+10    ;this is only done if we're on the second column
007717  2  60           ExitCastle: rts
007718  2               
007718  2               ;--------------------------------
007718  2               
007718  2               WaterPipe:
007718  2  20 6C 7A           jsr GetLrgObjAttrib     ;get row and lower nybble
00771B  2  BC 30 07           ldy AreaObjectLength,x  ;get length (residual code, water pipe is 1 col thick)
00771E  2  A6 07              ldx $07                 ;get row
007720  2               .ifdef ANN
007720  2  A9 6C              lda #$6c
007722  2  9D A1 06           sta MetatileBuffer,x    ;draw something here and below it
007725  2  A9 6D              lda #$6d
007727  2  9D A2 06           sta MetatileBuffer+1,x
00772A  2               .else
00772A  2                     lda #$6d
00772A  2                     sta MetatileBuffer,x    ;draw something here and below it
00772A  2                     lda #$6e
00772A  2                     sta MetatileBuffer+1,x
00772A  2               .endif
00772A  2  60                 rts
00772B  2               
00772B  2               ;--------------------------------
00772B  2               ;$05 - used to store length of vertical shaft in RenderSidewaysPipe
00772B  2               ;$06 - used to store leftover horizontal length in RenderSidewaysPipe
00772B  2               ; and vertical length in VerticalPipe and GetPipeHeight
00772B  2               
00772B  2               IntroPipe:
00772B  2  A0 03                       ldy #$03                 ;check if length set, if not set, set it
00772D  2  20 60 7A                    jsr ChkLrgObjFixedLength
007730  2  A0 0A                       ldy #$0a                 ;set fixed value and render the sideways part
007732  2  20 5C 77                    jsr RenderSidewaysPipe
007735  2  B0 10                       bcs NoBlankP             ;if carry flag set, not time to draw vertical pipe part
007737  2  A2 06                       ldx #$06                 ;blank everything above the vertical pipe part
007739  2  A9 00        VPipeSectLoop: lda #$00                 ;all the way to the top of the screen
00773B  2  9D A1 06                    sta MetatileBuffer,x     ;because otherwise it will look like exit pipe
00773E  2  CA                          dex
00773F  2  10 F8                       bpl VPipeSectLoop
007741  2  B9 86 77                    lda VerticalPipeData,y   ;draw the end of the vertical pipe part
007744  2  8D A8 06                    sta MetatileBuffer+7
007747  2  60           NoBlankP:      rts
007748  2               
007748  2               SidePipeShaftData:
007748  2  15 14              .byte $15, $14  ;used to control whether or not vertical pipe shaft
00774A  2  00 00              .byte $00, $00  ;is drawn, and if so, controls the metatile number
00774C  2               .ifdef ANN
00774C  2               SidePipeTopPart:
00774C  2  15 1E              .byte $15, $1e  ;top part of sideways part of pipe
00774E  2  1D 1C              .byte $1d, $1c
007750  2               SidePipeBottomPart:
007750  2  15 21              .byte $15, $21  ;bottom part of sideways part of pipe
007752  2  20 1F              .byte $20, $1f
007754  2               .else
007754  2               SidePipeTopPart:
007754  2                     .byte $15, $1b  ;top part of sideways part of pipe
007754  2                     .byte $1a, $19
007754  2               SidePipeBottomPart:
007754  2                     .byte $15, $1e  ;bottom part of sideways part of pipe
007754  2                     .byte $1d, $1c
007754  2               .endif
007754  2               
007754  2               ExitPipe:
007754  2  A0 03              ldy #$03                 ;check if length set, if not set, set it
007756  2  20 60 7A           jsr ChkLrgObjFixedLength
007759  2  20 6C 7A           jsr GetLrgObjAttrib      ;get vertical length, then plow on through RenderSidewaysPipe
00775C  2               
00775C  2               RenderSidewaysPipe:
00775C  2  88                         dey                       ;decrement twice to make room for shaft at bottom
00775D  2  88                         dey                       ;and store here for now as vertical length
00775E  2  84 05                      sty $05
007760  2  BC 30 07                   ldy AreaObjectLength,x    ;get length left over and store here
007763  2  84 06                      sty $06
007765  2  A6 05                      ldx $05                   ;get vertical length plus one, use as buffer offset
007767  2  E8                         inx
007768  2  B9 48 77                   lda SidePipeShaftData,y   ;check for value $00 based on horizontal offset
00776B  2  C9 00                      cmp #$00
00776D  2  F0 08                      beq DrawSidePart          ;if found, do not draw the vertical pipe shaft
00776F  2  A2 00                      ldx #$00
007771  2  A4 05                      ldy $05                   ;init buffer offset and get vertical length
007773  2  20 2E 7A                   jsr RenderUnderPart       ;and render vertical shaft using tile number in A
007776  2  18                         clc                       ;clear carry flag to be used by IntroPipe
007777  2  A4 06        DrawSidePart: ldy $06                   ;render side pipe part at the bottom
007779  2  B9 4C 77                   lda SidePipeTopPart,y
00777C  2  9D A1 06                   sta MetatileBuffer,x      ;note that the pipe parts are stored
00777F  2  B9 50 77                   lda SidePipeBottomPart,y  ;backwards horizontally
007782  2  9D A2 06                   sta MetatileBuffer+1,x
007785  2  60                         rts
007786  2               
007786  2               VerticalPipeData:
007786  2  11 10              .byte $11, $10 ;used by pipes that lead somewhere
007788  2  15 14              .byte $15, $14
00778A  2  13 12              .byte $13, $12 ;used by decoration pipes
00778C  2  15 14              .byte $15, $14
00778E  2               
00778E  2               VerticalPipe:
00778E  2  20 C9 77               jsr GetPipeHeight
007791  2  A5 00                  lda $00                  ;check to see if value was nullified earlier
007793  2  F0 04                  beq WarpPipe             ;(if d3, the usage control bit of second byte, was set)
007795  2  C8                     iny
007796  2  C8                     iny
007797  2  C8                     iny
007798  2  C8                     iny                      ;add four if usage control bit was not set
007799  2  98           WarpPipe: tya                      ;save value in stack
00779A  2  48                     pha
00779B  2  BC 30 07               ldy AreaObjectLength,x   ;if on second column of pipe, branch
00779E  2  F0 15                  beq DrawPipe             ;(because we only need to do this once)
0077A0  2  20 F9 77               jsr FindEmptyEnemySlot   ;check for an empty moving data buffer space
0077A3  2  B0 10                  bcs DrawPipe             ;if not found, too many enemies, thus skip
0077A5  2               .ifdef ANN
0077A5  2  AD 5F 07               lda WorldNumber          ;skip adding piranha plant in 1-1
0077A8  2  0D 60 07               ora AreaNumber
0077AB  2  0D FB 07               ora HardWorldFlag
0077AE  2  F0 05                  beq DrawPipe
0077B0  2               .endif
0077B0  2  A9 0D                  lda #PiranhaPlant
0077B2  2  20 DA 77               jsr SetupPiranhaPlant
0077B5  2               
0077B5  2  68           DrawPipe: pla                      ;get value saved earlier and use as Y
0077B6  2  A8                     tay
0077B7  2  A6 07                  ldx $07                  ;get buffer offset
0077B9  2  B9 86 77               lda VerticalPipeData,y   ;draw the appropriate pipe with the Y we loaded earlier
0077BC  2  9D A1 06               sta MetatileBuffer,x     ;render the top of the pipe
0077BF  2  E8                     inx
0077C0  2  B9 88 77               lda VerticalPipeData+2,y ;render the rest of the pipe
0077C3  2  A4 06                  ldy $06                  ;subtract one from length and render the part underneath
0077C5  2  88                     dey
0077C6  2  4C 2E 7A               jmp RenderUnderPart
0077C9  2               
0077C9  2               GetPipeHeight:
0077C9  2  A0 01              ldy #$01       ;check for length loaded, if not, load
0077CB  2  20 60 7A           jsr ChkLrgObjFixedLength ;pipe length of 2 (horizontal)
0077CE  2  20 6C 7A           jsr GetLrgObjAttrib
0077D1  2  98                 tya            ;get saved lower nybble as height
0077D2  2  29 07              and #$07       ;save only the three lower bits as
0077D4  2  85 06              sta $06        ;vertical length, then load Y with
0077D6  2  BC 30 07           ldy AreaObjectLength,x    ;length left over
0077D9  2  60                 rts
0077DA  2               
0077DA  2               SetupPiranhaPlant:
0077DA  2  95 16                  sta Enemy_ID,x
0077DC  2  20 7C 7A               jsr GetAreaObjXPosition  ;get horizontal pixel coordinate
0077DF  2  18                     clc
0077E0  2  69 08                  adc #$08                 ;add eight to put the piranha plant in the center
0077E2  2  95 87                  sta Enemy_X_Position,x   ;store as enemy's horizontal coordinate
0077E4  2  AD 25 07               lda CurrentPageLoc       ;add carry to current page number
0077E7  2  69 00                  adc #$00
0077E9  2  95 6E                  sta Enemy_PageLoc,x      ;store as enemy's page coordinate
0077EB  2  A9 01                  lda #$01
0077ED  2  95 B6                  sta Enemy_Y_HighPos,x
0077EF  2  95 0F                  sta Enemy_Flag,x         ;activate enemy flag
0077F1  2  20 84 7A               jsr GetAreaObjYPosition  ;get piranha plant's vertical coordinate and store here
0077F4  2  95 CF                  sta Enemy_Y_Position,x
0077F6  2  4C BF 93               jmp InitPiranhaPlant
0077F9  2               
0077F9  2               FindEmptyEnemySlot:
0077F9  2  A2 00                      ldx #$00          ;start at first enemy slot
0077FB  2  18           EmptyChkLoop: clc               ;clear carry flag by default
0077FC  2  B5 0F                      lda Enemy_Flag,x  ;check enemy buffer for nonzero
0077FE  2  F0 05                      beq ExitEmptyChk  ;if zero, leave
007800  2  E8                         inx
007801  2  E0 05                      cpx #$05          ;if nonzero, check next value
007803  2  D0 F6                      bne EmptyChkLoop
007805  2  60           ExitEmptyChk: rts               ;if all values nonzero, carry flag is set
007806  2               
007806  2               ;--------------------------------
007806  2               
007806  2               Hole_Water:
007806  2  20 5D 7A           jsr ChkLrgObjLength   ;get low nybble and save as length
007809  2  A9 86              lda #$86              ;render waves
00780B  2  8D AB 06           sta MetatileBuffer+10
00780E  2  A2 0B              ldx #$0b
007810  2  A0 01              ldy #$01              ;now render the water underneath
007812  2  A9 87              lda #$87
007814  2  4C 2E 7A           jmp RenderUnderPart
007817  2               
007817  2               QuestionBlockRow_High:
007817  2  A9 03              lda #$03              ;start on the fourth row
007819  2  2C                 .byte $2c               ;BIT instruction opcode
00781A  2               
00781A  2               QuestionBlockRow_Low:
00781A  2  A9 07              lda #$07             ;start on the eighth row
00781C  2  48                 pha                  ;save whatever row to the stack for now
00781D  2  20 5D 7A           jsr ChkLrgObjLength  ;get low nybble and save as length
007820  2  68                 pla
007821  2  AA                 tax                  ;render question boxes with coins
007822  2  A9 C0              lda #$c0
007824  2  9D A1 06           sta MetatileBuffer,x
007827  2  60                 rts
007828  2               
007828  2               ;--------------------------------
007828  2               
007828  2               Bridge_High:
007828  2  A9 06              lda #$06  ;start on the seventh row from top of screen
00782A  2  2C                 .byte $2c   ;BIT instruction opcode
00782B  2               
00782B  2               Bridge_Middle:
00782B  2  A9 07              lda #$07  ;start on the eighth row
00782D  2  2C                 .byte $2c   ;BIT instruction opcode
00782E  2               
00782E  2               Bridge_Low:
00782E  2  A9 09              lda #$09             ;start on the tenth row
007830  2  48                 pha                  ;save whatever row to the stack for now
007831  2  20 5D 7A           jsr ChkLrgObjLength  ;get low nybble and save as length
007834  2  68                 pla
007835  2  AA                 tax                  ;render bridge railing
007836  2  A9 0B              lda #$0b
007838  2  9D A1 06           sta MetatileBuffer,x
00783B  2  E8                 inx
00783C  2  A0 00              ldy #$00             ;now render the bridge itself
00783E  2               .ifdef ANN
00783E  2  A9 63              lda #$63
007840  2               .else
007840  2                     lda #$64
007840  2               .endif
007840  2  4C 2E 7A           jmp RenderUnderPart
007843  2               
007843  2               ;--------------------------------
007843  2               
007843  2               FlagBalls_Residual:
007843  2  20 6C 7A           jsr GetLrgObjAttrib  ;get low nybble from object byte
007846  2  A2 02              ldx #$02             ;render flag balls on third row from top
007848  2               .ifdef ANN
007848  2  A9 6E              lda #$6e             ;of screen downwards based on low nybble
00784A  2               .else
00784A  2                     lda #$6f             ;of screen downwards based on low nybble
00784A  2               .endif
00784A  2  4C 2E 7A           jmp RenderUnderPart
00784D  2               
00784D  2               ;--------------------------------
00784D  2               
00784D  2               FlagpoleObject:
00784D  2               .ifdef ANN
00784D  2  A9 24              lda #$24                 ;render flagpole ball on top
00784F  2               .else
00784F  2                     lda #$21                 ;render flagpole ball on top
00784F  2               .endif
00784F  2  8D A1 06           sta MetatileBuffer
007852  2  A2 01              ldx #$01                 ;now render the flagpole shaft
007854  2  A0 08              ldy #$08
007856  2               .ifdef ANN
007856  2  A9 25              lda #$25
007858  2               .else
007858  2                     lda #$22
007858  2               .endif
007858  2  20 2E 7A           jsr RenderUnderPart
00785B  2               .ifdef ANN
00785B  2  A9 61              lda #$61
00785D  2               .else
00785D  2                     lda #$62                 ;render solid block at the bottom
00785D  2               .endif
00785D  2  8D AB 06           sta MetatileBuffer+10
007860  2  20 7C 7A           jsr GetAreaObjXPosition
007863  2  38                 sec                      ;get pixel coordinate of where the flagpole is,
007864  2  E9 08              sbc #$08                 ;subtract eight pixels and use as horizontal
007866  2  85 8C              sta Enemy_X_Position+5   ;coordinate for the flag
007868  2  AD 25 07           lda CurrentPageLoc
00786B  2  E9 00              sbc #$00                 ;subtract borrow from page location and use as
00786D  2  85 73              sta Enemy_PageLoc+5      ;page location for the flag
00786F  2  A9 30              lda #$30
007871  2  85 D4              sta Enemy_Y_Position+5   ;set vertical coordinate for flag
007873  2  A9 B0              lda #$b0
007875  2  8D 0D 01           sta FlagpoleFNum_Y_Pos   ;set initial vertical coordinate for flagpole's floatey number
007878  2  A9 30              lda #FlagpoleFlagObject
00787A  2  85 1B              sta Enemy_ID+5           ;set flag identifier, note that identifier and coordinates
00787C  2  E6 14              inc Enemy_Flag+5         ;use last space in enemy object buffer
00787E  2  60                 rts
00787F  2               
00787F  2               ;--------------------------------
00787F  2               
00787F  2               EndlessRope:
00787F  2  A2 00              ldx #$00       ;render rope from the top to the bottom of screen
007881  2  A0 0F              ldy #$0f
007883  2  4C 98 78           jmp DrawRope
007886  2               
007886  2               BalancePlatRope:
007886  2  8A                     txa                 ;save object buffer offset for now
007887  2  48                     pha
007888  2  A2 01                  ldx #$01            ;blank out all from second row to the bottom
00788A  2  A0 0F                  ldy #$0f            ;with blank used for balance platform rope
00788C  2  A9 44                  lda #$44
00788E  2  20 2E 7A               jsr RenderUnderPart
007891  2  68                     pla                 ;get back object buffer offset
007892  2  AA                     tax
007893  2  20 6C 7A               jsr GetLrgObjAttrib ;get vertical length from lower nybble
007896  2  A2 01                  ldx #$01
007898  2  A9 40        DrawRope: lda #$40            ;render the actual rope
00789A  2  4C 2E 7A               jmp RenderUnderPart
00789D  2               
00789D  2               ;--------------------------------
00789D  2               
00789D  2               CoinMetatileData:
00789D  2               .ifdef ANN
00789D  2  C3 C2 C2 C2        .byte $c3, $c2, $c2, $c2
0078A1  2               .else
0078A1  2                     .byte $c4, $c3, $c3, $c3
0078A1  2               .endif
0078A1  2               
0078A1  2               RowOfCoins:
0078A1  2  AC 4E 07           ldy AreaType            ;get area type
0078A4  2  B9 9D 78           lda CoinMetatileData,y  ;load appropriate coin metatile
0078A7  2  4C F3 78           jmp GetRow
0078AA  2               
0078AA  2               ;--------------------------------
0078AA  2               
0078AA  2               C_ObjectRow:
0078AA  2  06 07 08           .byte $06, $07, $08
0078AD  2               
0078AD  2               C_ObjectMetatile:
0078AD  2               .ifdef ANN
0078AD  2  C5                 .byte $c5
0078AE  2               .else
0078AE  2                     .byte $c6
0078AE  2               .endif
0078AE  2  0C 89              .byte $0c, $89
0078B0  2               
0078B0  2               CastleBridgeObj:
0078B0  2  A0 0C              ldy #$0c                  ;load length of 13 columns
0078B2  2  20 60 7A           jsr ChkLrgObjFixedLength
0078B5  2  4C BD 78           jmp ChainObj
0078B8  2               
0078B8  2               AxeObj:
0078B8  2  A9 08              lda #$08                  ;load bowser's palette into sprite portion of palette
0078BA  2  8D 73 07           sta VRAM_Buffer_AddrCtrl
0078BD  2               
0078BD  2               ChainObj:
0078BD  2  A4 00              ldy $00                   ;get value loaded earlier from decoder
0078BF  2  BE A8 78           ldx C_ObjectRow-2,y       ;get appropriate row and metatile for object
0078C2  2  B9 AB 78           lda C_ObjectMetatile-2,y
0078C5  2  4C CF 78           jmp ColObj
0078C8  2               
0078C8  2               EmptyBlock:
0078C8  2  20 6C 7A             jsr GetLrgObjAttrib  ;get row location
0078CB  2  A6 07                ldx $07
0078CD  2               .ifdef ANN
0078CD  2  A9 C4                lda #$c4
0078CF  2               .else
0078CF  2                       lda #$c5
0078CF  2               .endif
0078CF  2  A0 00        ColObj: ldy #$00             ;column length of 1
0078D1  2  4C 2E 7A             jmp RenderUnderPart
0078D4  2               
0078D4  2               ;--------------------------------
0078D4  2               
0078D4  2               SolidBlockMetatiles:
0078D4  2               .ifdef ANN
0078D4  2  69 61 61 62        .byte $69, $61, $61, $62
0078D8  2               .else
0078D8  2                     .byte $6a, $62, $62, $63
0078D8  2               .endif
0078D8  2               
0078D8  2               BrickMetatiles:
0078D8  2               .ifdef ANN
0078D8  2  22 51 52 52        .byte $22, $51, $52, $52
0078DC  2               .else
0078DC  2                     .byte $1f, $4f, $50, $50
0078DC  2               .endif
0078DC  2  88                 .byte $88 ;used only by row of bricks object
0078DD  2               
0078DD  2               RowOfBricks:
0078DD  2  AC 4E 07                 ldy AreaType           ;load area type obtained from area offset pointer
0078E0  2  AD 43 07                 lda CloudTypeOverride  ;check for cloud type override
0078E3  2  F0 02                    beq DrawBricks
0078E5  2  A0 04                    ldy #$04               ;if cloud type, override area type
0078E7  2  B9 D8 78     DrawBricks: lda BrickMetatiles,y   ;get appropriate metatile
0078EA  2  4C F3 78                 jmp GetRow             ;and go render it
0078ED  2               
0078ED  2               RowOfSolidBlocks:
0078ED  2  AC 4E 07              ldy AreaType               ;load area type obtained from area offset pointer
0078F0  2  B9 D4 78              lda SolidBlockMetatiles,y  ;get metatile
0078F3  2  48           GetRow:  pha                        ;store metatile here
0078F4  2  20 5D 7A              jsr ChkLrgObjLength        ;get row number, load length
0078F7  2  A6 07        DrawRow: ldx $07
0078F9  2  A0 00                 ldy #$00                   ;set vertical height of 1
0078FB  2  68                    pla
0078FC  2  4C 2E 7A              jmp RenderUnderPart        ;render object
0078FF  2               
0078FF  2               ColumnOfBricks:
0078FF  2  AC 4E 07           ldy AreaType          ;load area type obtained from area offset
007902  2  B9 D8 78           lda BrickMetatiles,y  ;get metatile (no cloud override as for row)
007905  2  4C 0E 79           jmp GetRow2
007908  2               
007908  2               ColumnOfSolidBlocks:
007908  2  AC 4E 07              ldy AreaType               ;load area type obtained from area offset
00790B  2  B9 D4 78              lda SolidBlockMetatiles,y  ;get metatile
00790E  2  48           GetRow2: pha                        ;save metatile to stack for now
00790F  2  20 6C 7A              jsr GetLrgObjAttrib        ;get length and row
007912  2  68                    pla                        ;restore metatile
007913  2  A6 07                 ldx $07                    ;get starting row
007915  2  4C 2E 7A              jmp RenderUnderPart        ;now render the column
007918  2               
007918  2               ;--------------------------------
007918  2               
007918  2               BulletBillCannon:
007918  2  20 6C 7A                  jsr GetLrgObjAttrib      ;get row and length of bullet bill cannon
00791B  2  A6 07                     ldx $07                  ;start at first row
00791D  2               .ifdef ANN
00791D  2  A9 64                     lda #$64                 ;render bullet bill cannon
00791F  2               .else
00791F  2                            lda #$65                 ;render bullet bill cannon
00791F  2               .endif
00791F  2  9D A1 06                  sta MetatileBuffer,x
007922  2  E8                        inx
007923  2  88                        dey                      ;done yet?
007924  2  30 0E                     bmi SetupCannon
007926  2               .ifdef ANN
007926  2  A9 65                     lda #$65                 ;if not, render middle part
007928  2               .else
007928  2                            lda #$66                 ;if not, render middle part
007928  2               .endif
007928  2  9D A1 06                  sta MetatileBuffer,x
00792B  2  E8                        inx
00792C  2  88                        dey                      ;done yet?
00792D  2  30 05                     bmi SetupCannon
00792F  2               .ifdef ANN
00792F  2  A9 66                     lda #$66                 ;if not, render bottom until length expires
007931  2               .else
007931  2                            lda #$67                 ;if not, render bottom until length expires
007931  2               .endif
007931  2  20 2E 7A                  jsr RenderUnderPart
007934  2  AE 6A 04     SetupCannon: ldx Cannon_Offset        ;get offset for data used by cannons and whirlpools
007937  2  20 84 7A                  jsr GetAreaObjYPosition  ;get proper vertical coordinate for cannon
00793A  2  9D 77 04                  sta Cannon_Y_Position,x  ;and store it here
00793D  2  AD 25 07                  lda CurrentPageLoc
007940  2  9D 6B 04                  sta Cannon_PageLoc,x     ;store page number for cannon here
007943  2  20 7C 7A                  jsr GetAreaObjXPosition  ;get proper horizontal coordinate for cannon
007946  2  9D 71 04                  sta Cannon_X_Position,x  ;and store it here
007949  2  E8                        inx
00794A  2  E0 06                     cpx #$06                 ;increment and check offset
00794C  2  90 02                     bcc StrCOffset           ;if not yet reached sixth cannon, branch to save offset
00794E  2  A2 00                     ldx #$00                 ;otherwise initialize it
007950  2  8E 6A 04     StrCOffset:  stx Cannon_Offset        ;save new offset and leave
007953  2  60                        rts
007954  2               
007954  2               ;--------------------------------
007954  2               
007954  2               StaircaseHeightData:
007954  2  07 07 06 05        .byte $07, $07, $06, $05, $04, $03, $02, $01, $00
007958  2  04 03 02 01  
00795C  2  00           
00795D  2               
00795D  2               StaircaseRowData:
00795D  2  03 03 04 05        .byte $03, $03, $04, $05, $06, $07, $08, $09, $0a
007961  2  06 07 08 09  
007965  2  0A           
007966  2               
007966  2               StaircaseObject:
007966  2  20 5D 7A                jsr ChkLrgObjLength       ;check and load length
007969  2  90 05                   bcc NextStair             ;if length already loaded, skip init part
00796B  2  A9 09                   lda #$09                  ;start past the end for the bottom
00796D  2  8D 34 07                sta StaircaseControl      ;of the staircase
007970  2  CE 34 07     NextStair: dec StaircaseControl      ;move onto next step (or first if starting)
007973  2  AC 34 07                ldy StaircaseControl
007976  2  BE 5D 79                ldx StaircaseRowData,y    ;get starting row and height to render
007979  2  B9 54 79                lda StaircaseHeightData,y
00797C  2  A8                      tay
00797D  2               .ifdef ANN
00797D  2  A9 61                   lda #$61                  ;now render solid block staircase
00797F  2               .else
00797F  2                          lda #$62                  ;now render solid block staircase
00797F  2               .endif
00797F  2  4C 2E 7A                jmp RenderUnderPart
007982  2               
007982  2               ;--------------------------------
007982  2               
007982  2               Jumpspring:
007982  2  20 6C 7A           jsr GetLrgObjAttrib
007985  2  20 F9 77           jsr FindEmptyEnemySlot      ;find empty space in enemy object buffer
007988  2  B0 27              bcs NoJs                    ;if none, cancel (potentially problematic!)
00798A  2  20 7C 7A           jsr GetAreaObjXPosition     ;get horizontal coordinate for jumpspring
00798D  2  95 87              sta Enemy_X_Position,x      ;and store
00798F  2  AD 25 07           lda CurrentPageLoc          ;store page location of jumpspring
007992  2  95 6E              sta Enemy_PageLoc,x
007994  2  20 84 7A           jsr GetAreaObjYPosition     ;get vertical coordinate for jumpspring
007997  2  95 CF              sta Enemy_Y_Position,x      ;and store
007999  2  95 58              sta Jumpspring_FixedYPos,x  ;store as permanent coordinate here
00799B  2  A9 32              lda #JumpspringObject
00799D  2  95 16              sta Enemy_ID,x              ;write jumpspring object to enemy object buffer
00799F  2  A0 01              ldy #$01
0079A1  2  94 B6              sty Enemy_Y_HighPos,x       ;store vertical high byte
0079A3  2  F6 0F              inc Enemy_Flag,x            ;set flag for enemy object buffer
0079A5  2  A6 07              ldx $07
0079A7  2               .ifdef ANN
0079A7  2  A9 67              lda #$67                    ;draw metatiles in two rows where jumpspring is
0079A9  2  9D A1 06           sta MetatileBuffer,x
0079AC  2  A9 68              lda #$68
0079AE  2  9D A2 06           sta MetatileBuffer+1,x
0079B1  2               .else
0079B1  2                     lda #$68                    ;draw metatiles in two rows where jumpspring is
0079B1  2                     sta MetatileBuffer,x
0079B1  2                     lda #$69
0079B1  2                     sta MetatileBuffer+1,x
0079B1  2               .endif
0079B1  2  60           NoJs: rts
0079B2  2               
0079B2  2               ;--------------------------------
0079B2  2               ;$07 - used to save ID of brick object
0079B2  2               
0079B2  2               Hidden1UpBlock:
0079B2  2  AD 5D 07           lda Hidden1UpFlag  ;if flag not set, do not render object
0079B5  2  F0 36              beq ExitDecBlock
0079B7  2  A9 00              lda #$00           ;if set, init for the next one
0079B9  2  8D 5D 07           sta Hidden1UpFlag
0079BC  2  4C CA 79           jmp BrickWithItem  ;jump to code shared with unbreakable bricks
0079BF  2               
0079BF  2               QuestionBlock:
0079BF  2  20 E7 79           jsr GetAreaObjectID ;get value from level decoder routine
0079C2  2  4C DD 79           jmp DrawQBlk        ;go to render it
0079C5  2               
0079C5  2               BrickWithCoins:
0079C5  2  A9 00              lda #$00                 ;initialize multi-coin timer flag
0079C7  2  8D BC 06           sta BrickCoinTimerFlag
0079CA  2               
0079CA  2               BrickWithItem:
0079CA  2  20 E7 79               jsr GetAreaObjectID         ;save area object ID
0079CD  2  84 07                  sty $07
0079CF  2  A9 00                  lda #$00                    ;load default adder for bricks with lines
0079D1  2  AC 4E 07               ldy AreaType                ;check level type for ground level
0079D4  2  88                     dey
0079D5  2  F0 02                  beq BWithL                  ;if ground type, do not start with 6
0079D7  2               .ifdef ANN
0079D7  2  A9 05                  lda #$05                    ;otherwise use adder for bricks without lines
0079D9  2               .else
0079D9  2                         lda #$06                    ;otherwise use adder for bricks without lines
0079D9  2               .endif
0079D9  2  18           BWithL:   clc                         ;add object ID to adder
0079DA  2  65 07                  adc $07
0079DC  2  A8                     tay                         ;use as offset for metatile
0079DD  2  B9 F6 89     DrawQBlk: lda BrickQBlockMetatiles,y  ;get appropriate metatile for brick (question block
0079E0  2  48                     pha                         ;if branched to here from question block routine)
0079E1  2  20 6C 7A               jsr GetLrgObjAttrib         ;get row from location byte
0079E4  2  4C F7 78               jmp DrawRow                 ;now render the object
0079E7  2               
0079E7  2               GetAreaObjectID:
0079E7  2  A5 00                      lda $00    ;get value saved from area parser routine
0079E9  2  38                         sec
0079EA  2  E9 00                      sbc #$00   ;possibly residual code
0079EC  2  A8                         tay        ;save to Y
0079ED  2  60           ExitDecBlock: rts
0079EE  2               
0079EE  2               ;--------------------------------
0079EE  2               
0079EE  2               HoleMetatiles:
0079EE  2  87 00 00 00        .byte $87, $00, $00, $00
0079F2  2               
0079F2  2               Hole_Empty:
0079F2  2  20 5D 7A                 jsr ChkLrgObjLength          ;get lower nybble and save as length
0079F5  2  90 2D                    bcc NoWhirlP                 ;skip this part if length already loaded
0079F7  2  AD 4E 07                 lda AreaType                 ;check for water type level
0079FA  2  D0 28                    bne NoWhirlP                 ;if not water type, skip this part
0079FC  2  AE 6A 04                 ldx Whirlpool_Offset         ;get offset for data used by cannons and whirlpools
0079FF  2  20 7C 7A                 jsr GetAreaObjXPosition      ;get proper vertical coordinate of where we're at
007A02  2  38                       sec
007A03  2  E9 10                    sbc #$10                     ;subtract 16 pixels
007A05  2  9D 71 04                 sta Whirlpool_LeftExtent,x   ;store as left extent of whirlpool
007A08  2  AD 25 07                 lda CurrentPageLoc           ;get page location of where we're at
007A0B  2  E9 00                    sbc #$00                     ;subtract borrow
007A0D  2  9D 6B 04                 sta Whirlpool_PageLoc,x      ;save as page location of whirlpool
007A10  2  C8                       iny
007A11  2  C8                       iny                          ;increment length by 2
007A12  2  98                       tya
007A13  2  0A                       asl                          ;multiply by 16 to get size of whirlpool
007A14  2  0A                       asl                          ;note that whirlpool will always be
007A15  2  0A                       asl                          ;two blocks bigger than actual size of hole
007A16  2  0A                       asl                          ;and extend one block beyond each edge
007A17  2  9D 77 04                 sta Whirlpool_Length,x       ;save size of whirlpool here
007A1A  2  E8                       inx
007A1B  2  E0 05                    cpx #$05                     ;increment and check offset
007A1D  2  90 02                    bcc StrWOffset               ;if not yet reached fifth whirlpool, branch to save offset
007A1F  2  A2 00                    ldx #$00                     ;otherwise initialize it
007A21  2  8E 6A 04     StrWOffset: stx Whirlpool_Offset         ;save new offset here
007A24  2  AE 4E 07     NoWhirlP:   ldx AreaType                 ;get appropriate metatile, then
007A27  2  BD EE 79                 lda HoleMetatiles,x          ;render the hole proper
007A2A  2  A2 08                    ldx #$08
007A2C  2  A0 0F                    ldy #$0f                     ;start at ninth row and go to bottom, run RenderUnderPart
007A2E  2               
007A2E  2               ;--------------------------------
007A2E  2               
007A2E  2               RenderUnderPart:
007A2E  2  8C 35 07                  sty AreaObjectHeight  ;store vertical length to render
007A31  2  BC A1 06                  ldy MetatileBuffer,x  ;check current spot to see if there's something
007A34  2  F0 18                     beq DrawThisRow       ;we need to keep, if nothing, go ahead
007A36  2  C0 17                     cpy #$17
007A38  2  F0 17                     beq WaitOneRow        ;if middle part (tree ledge), wait until next row
007A3A  2               .ifdef ANN
007A3A  2  C0 1A                     cpy #$1a
007A3C  2               .else
007A3C  2                            cpy #$8b
007A3C  2               .endif
007A3C  2  F0 13                     beq WaitOneRow        ;if middle part (cloud ledge), wait until next row
007A3E  2  C0 C0                     cpy #$c0
007A40  2  F0 0C                     beq DrawThisRow       ;if question block w/ coin, overwrite
007A42  2  C0 C0                     cpy #$c0
007A44  2  B0 0B                     bcs WaitOneRow        ;if any other metatile with palette 3, wait until next row
007A46  2               .ifdef ANN
007A46  2  C0 6A                     cpy #$6a
007A48  2  D0 04                     bne DrawThisRow
007A4A  2  C9 50                     cmp #$50
007A4C  2  F0 03                     beq WaitOneRow
007A4E  2               .endif
007A4E  2  9D A1 06     DrawThisRow: sta MetatileBuffer,x  ;render contents of A from routine that called this
007A51  2  E8           WaitOneRow:  inx
007A52  2  E0 0D                     cpx #$0d              ;stop rendering if we're at the bottom of the screen
007A54  2  B0 06                     bcs ExitUPartR
007A56  2  AC 35 07                  ldy AreaObjectHeight  ;decrement, and stop rendering if there is no more length
007A59  2  88                        dey
007A5A  2  10 D2                     bpl RenderUnderPart
007A5C  2  60           ExitUPartR:  rts
007A5D  2               
007A5D  2               
007A5D  2               ChkLrgObjLength:
007A5D  2  20 6C 7A             jsr GetLrgObjAttrib     ;get row location and size (length if branched to from here)
007A60  2               
007A60  2               ChkLrgObjFixedLength:
007A60  2  BD 30 07             lda AreaObjectLength,x  ;check for set length counter
007A63  2  18                   clc                     ;clear carry flag for not just starting
007A64  2  10 05                bpl LenSet              ;if counter not set, load it, otherwise leave alone
007A66  2  98                   tya                     ;save length into length counter
007A67  2  9D 30 07             sta AreaObjectLength,x
007A6A  2  38                   sec                     ;set carry flag if just starting
007A6B  2  60           LenSet: rts
007A6C  2               
007A6C  2               GetLrgObjAttrib:
007A6C  2  BC 2D 07           ldy AreaObjOffsetBuffer,x ;get offset saved from area obj decoding routine
007A6F  2  B1 E7              lda (AreaData),y          ;get first byte of level object
007A71  2  29 0F              and #%00001111
007A73  2  85 07              sta $07                   ;save row location
007A75  2  C8                 iny
007A76  2  B1 E7              lda (AreaData),y          ;get next byte, save lower nybble (length or height)
007A78  2  29 0F              and #%00001111            ;as Y, then leave
007A7A  2  A8                 tay
007A7B  2  60                 rts
007A7C  2               
007A7C  2               ;--------------------------------
007A7C  2               
007A7C  2               GetAreaObjXPosition:
007A7C  2  AD 26 07           lda CurrentColumnPos    ;multiply current offset where we're at by 16
007A7F  2  0A                 asl                     ;to obtain horizontal pixel coordinate
007A80  2  0A                 asl
007A81  2  0A                 asl
007A82  2  0A                 asl
007A83  2  60                 rts
007A84  2               
007A84  2               ;--------------------------------
007A84  2               
007A84  2               GetAreaObjYPosition:
007A84  2  A5 07              lda $07  ;multiply value by 16
007A86  2  0A                 asl
007A87  2  0A                 asl      ;this will give us the proper vertical pixel coordinate
007A88  2  0A                 asl
007A89  2  0A                 asl
007A8A  2  18                 clc
007A8B  2  69 20              adc #32  ;add 32 pixels for the status bar
007A8D  2  60                 rts
007A8E  2               
007A8E  2               ;-------------------------------------------------------------------------------------
007A8E  2               ;$06-$07 - used to store block buffer address used as indirect
007A8E  2               
007A8E  2               BlockBufferAddr:
007A8E  2  00 D0              .byte <Block_Buffer_1, <Block_Buffer_2
007A90  2  05 05              .byte >Block_Buffer_1, >Block_Buffer_2
007A92  2               
007A92  2               GetBlockBufferAddr:
007A92  2  48                 pha                      ;take value of A, save
007A93  2  4A                 lsr                      ;move high nybble to low
007A94  2  4A                 lsr
007A95  2  4A                 lsr
007A96  2  4A                 lsr
007A97  2  A8                 tay                      ;use nybble as pointer to high byte
007A98  2  B9 90 7A           lda BlockBufferAddr+2,y  ;of indirect here
007A9B  2  85 07              sta $07
007A9D  2  68                 pla
007A9E  2  29 0F              and #%00001111           ;pull from stack, mask out high nybble
007AA0  2  18                 clc
007AA1  2  79 8E 7A           adc BlockBufferAddr,y    ;add to low byte
007AA4  2  85 06              sta $06                  ;store here and leave
007AA6  2  60                 rts
007AA7  2               
007AA7  2               ;-------------------------------------------------------------------------------------
007AA7  2               
007AA7  2               GameModeSubs:
007AA7  2  AD 72 07           lda OperMode_Task
007AAA  2  20 0F 6D           jsr JumpEngine
007AAD  2               
007AAD  2  5E C0              .word GameModeDiskRoutines
007AAF  2  C9 6E              .word InitializeArea
007AB1  2               .ifdef ANN
007AB1  2  11 63              .word LoadWorldMushroomRetainer
007AB3  2               .endif
007AB3  2  4C 65              .word ScreenRoutines
007AB5  2  48 6F              .word SecondaryGameSetup
007AB7  2  B9 7A              .word GameCoreRoutine
007AB9  2               
007AB9  2               GameCoreRoutine:
007AB9  2  20 0C 7C           jsr GameRoutines           ;execute one of many possible subs
007ABC  2  AD 72 07           lda OperMode_Task          ;check major task of operating mode
007ABF  2               .ifdef ANN
007ABF  2  C9 05              cmp #$05                   ;if we are supposed to be here,
007AC1  2               .else
007AC1  2                     cmp #$04                   ;if we are supposed to be here,
007AC1  2               .endif
007AC1  2  B0 01              bcs GameEngine             ;branch to the game engine itself
007AC3  2  60                 rts
007AC4  2               
007AC4  2               GameEngine:
007AC4  2  20 E4 81                   jsr ProcFireball_Bubble    ;process fireballs and air bubbles
007AC7  2  A2 00                      ldx #$00
007AC9  2  86 08        ProcELoop:    stx ObjectOffset           ;put incremented offset in X as enemy object offset
007ACB  2  20 56 8C                   jsr EnemiesAndLoopsCore    ;process enemy objects
007ACE  2  20 A8 64                   jsr FloateyNumbersRoutine  ;process floatey numbers
007AD1  2  E8                         inx
007AD2  2  E0 06                      cpx #$06                   ;do these two subroutines until the whole buffer is done
007AD4  2  D0 F3                      bne ProcELoop
007AD6  2  20 75 BE                   jsr GetPlayerOffscreenBits ;get offscreen bits for player object
007AD9  2  20 1F BE                   jsr RelativePlayerPosition ;get relative coordinates for player object
007ADC  2  20 D4 BB                   jsr PlayerGfxHandler       ;draw the player
007ADF  2  20 E3 8A                   jsr BlockObjMT_Updater     ;replace block objects with metatiles if necessary
007AE2  2  A2 01                      ldx #$01
007AE4  2  86 08                      stx ObjectOffset           ;set offset for second
007AE6  2  20 7F 8A                   jsr BlockObjectsCore       ;process second block object
007AE9  2  CA                         dex
007AEA  2  86 08                      stx ObjectOffset           ;set offset for first
007AEC  2  20 7F 8A                   jsr BlockObjectsCore       ;process first block object
007AEF  2  20 AC 87                   jsr MiscObjectsCore        ;process misc objects (hammer, jumping coins)
007AF2  2  20 D2 85                   jsr ProcessCannons         ;process bullet bill cannons
007AF5  2  20 75 83                   jsr ProcessWhirlpools      ;process whirlpools
007AF8  2  20 12 84                   jsr FlagpoleRoutine        ;process the flagpole
007AFB  2  20 0F 83                   jsr RunGameTimer           ;count down the game timer
007AFE  2  20 58 69                   jsr ColorRotation          ;cycle one of the background colors
007B01  2               .ifndef ANN
007B01  2                             lda FileListNumber
007B01  2                             beq NoWind                 ;if in worlds 1-4, skip ahead
007B01  2                             jsr SimulateWind           ;otherwise, simulate wind where needed
007B01  2               .endif
007B01  2  A5 B5        NoWind:       lda Player_Y_HighPos
007B03  2  C9 02                      cmp #$02                   ;if player is below the screen, don't bother with the music
007B05  2  10 11                      bpl NoChgMus
007B07  2  AD 9F 07                   lda StarInvincibleTimer    ;if star mario invincibility timer at zero,
007B0A  2  F0 1E                      beq ClrPlrPal              ;skip this part
007B0C  2  C9 04                      cmp #$04
007B0E  2  D0 08                      bne NoChgMus               ;if not yet at a certain point, continue
007B10  2  AD 7F 07                   lda IntervalTimerControl   ;if interval timer not yet expired,
007B13  2  D0 03                      bne NoChgMus               ;branch ahead, don't bother with the music
007B15  2  20 B8 6F                   jsr GetAreaMusic           ;to re-attain appropriate level music
007B18  2  AC 9F 07     NoChgMus:     ldy StarInvincibleTimer    ;get invincibility timer
007B1B  2  A5 09                      lda FrameCounter           ;get frame counter
007B1D  2  C0 08                      cpy #$08                   ;if timer still above certain point,
007B1F  2  B0 02                      bcs CycleTwo               ;branch to cycle player's palette quickly
007B21  2  4A                         lsr                        ;otherwise, divide by 8 to cycle every eighth frame
007B22  2  4A                         lsr
007B23  2  4A           CycleTwo:     lsr                        ;if branched here, divide by 2 to cycle every other frame
007B24  2  20 49 7E                   jsr CyclePlayerPalette     ;do sub to cycle the palette (note: shares fire flower code)
007B27  2  4C 2D 7B                   jmp SaveAB                 ;then skip this sub to finish up the game engine
007B2A  2  20 5B 7E     ClrPlrPal:    jsr ResetPalStar           ;do sub to clear player's palette bits in attributes
007B2D  2  A5 0A        SaveAB:       lda A_B_Buttons            ;save current A and B button
007B2F  2  85 0D                      sta PreviousA_B_Buttons    ;into temp variable to be used on next frame
007B31  2  A9 00                      lda #$00
007B33  2  85 0C                      sta Left_Right_Buttons     ;nullify left and right buttons temp variable
007B35  2  AD 73 07     UpdScrollVar: lda VRAM_Buffer_AddrCtrl
007B38  2  C9 06                      cmp #$06                   ;if vram address controller set to 6
007B3A  2  F0 1C                      beq ExitEng                ;then branch to leave
007B3C  2  AD 1F 07                   lda AreaParserTaskNum      ;otherwise check number of tasks
007B3F  2  D0 14                      bne RunParser
007B41  2  AD 3D 07                   lda ScrollThirtyTwo        ;get horizontal scroll in 0-31 or $00-$20 range
007B44  2  C9 20                      cmp #$20                   ;check to see if exceeded $21
007B46  2  30 10                      bmi ExitEng                ;branch to leave if not
007B48  2  AD 3D 07                   lda ScrollThirtyTwo
007B4B  2  E9 20                      sbc #$20                   ;otherwise subtract $20 to set appropriately
007B4D  2  8D 3D 07                   sta ScrollThirtyTwo        ;and store
007B50  2  A9 00                      lda #$00                   ;reset vram buffer offset used in conjunction with
007B52  2  8D 40 03                   sta VRAM_Buffer2_Offset    ;level graphics buffer in second VRAM buffer
007B55  2  20 3D 71     RunParser:    jsr AreaParserTaskHandler  ;update the name table with more level graphics
007B58  2  60           ExitEng:      rts                        ;and after all that, we're finally done!
007B59  2               
007B59  2               ScrollHandler:
007B59  2  AD FF 06                 lda Player_X_Scroll       ;load value saved here
007B5C  2  18                       clc
007B5D  2  6D A1 03                 adc Platform_X_Scroll     ;add value used by left/right platforms
007B60  2  8D FF 06                 sta Player_X_Scroll       ;save as new value here to impose force on scroll
007B63  2  AD 23 07                 lda ScrollLock            ;check scroll lock flag
007B66  2  D0 55                    bne InitScrlAmt           ;skip a bunch of code here if set
007B68  2  AD 55 07                 lda Player_Pos_ForScroll
007B6B  2  C9 50                    cmp #$50                  ;check player's horizontal screen position
007B6D  2  90 4E                    bcc InitScrlAmt           ;if less than 80 pixels to the right, branch
007B6F  2  AD 85 07                 lda SideCollisionTimer    ;if timer related to player's side collision
007B72  2  D0 49                    bne InitScrlAmt           ;not expired, branch
007B74  2  AC FF 06                 ldy Player_X_Scroll       ;get value and decrement by one
007B77  2  88                       dey                       ;if value originally set to zero or otherwise
007B78  2  30 43                    bmi InitScrlAmt           ;negative for left movement, branch
007B7A  2  C8                       iny
007B7B  2  C0 02                    cpy #$02                  ;if value $01, branch and do not decrement
007B7D  2  90 01                    bcc ChkNearMid
007B7F  2  88                       dey                       ;otherwise decrement by one
007B80  2  AD 55 07     ChkNearMid: lda Player_Pos_ForScroll
007B83  2  C9 70                    cmp #$70                  ;check player's horizontal screen position
007B85  2  90 03                    bcc ScrollScreen          ;if less than 112 pixels to the right, branch
007B87  2  AC FF 06                 ldy Player_X_Scroll       ;otherwise get original value undecremented
007B8A  2               
007B8A  2               ScrollScreen:
007B8A  2  AD 7B 07                   lda IRQAckFlag
007B8D  2  D0 FB                      bne ScrollScreen           ;loop if IRQ has not yet happened
007B8F  2  98                         tya
007B90  2  8D 75 07                   sta ScrollAmount           ;save value here
007B93  2  18                         clc
007B94  2  6D 3D 07                   adc ScrollThirtyTwo        ;add to value already set here
007B97  2  8D 3D 07                   sta ScrollThirtyTwo        ;save as new value here
007B9A  2  98                         tya
007B9B  2  18                         clc
007B9C  2  6D 1C 07                   adc ScreenLeft_X_Pos       ;add to left side coordinate
007B9F  2  8D 1C 07                   sta ScreenLeft_X_Pos       ;save as new left side coordinate
007BA2  2  8D 3F 07                   sta HorizontalScroll       ;save here also
007BA5  2  AD 1A 07                   lda ScreenLeft_PageLoc
007BA8  2  69 00                      adc #$00                   ;add carry to page location for left
007BAA  2  8D 1A 07                   sta ScreenLeft_PageLoc     ;side of the screen
007BAD  2  29 01                      and #$01                   ;get LSB of page location
007BAF  2  8D 7A 07                   sta NameTableSelect        ;save as name table select for later use
007BB2  2  20 FA 7B                   jsr GetScreenPosition
007BB5  2  A9 08                      lda #$08
007BB7  2  8D 95 07                   sta ScrollIntervalTimer    ;set scroll timer (residual, not used elsewhere)
007BBA  2  4C C2 7B                   jmp ChkPOffscr             ;skip this part
007BBD  2  A9 00        InitScrlAmt:  lda #$00
007BBF  2  8D 75 07                   sta ScrollAmount           ;initialize value here
007BC2  2  A2 00        ChkPOffscr:   ldx #$00                   ;set X for player offset
007BC4  2  20 EB BE                   jsr GetXOffscreenBits      ;get horizontal offscreen bits for player
007BC7  2  85 00                      sta $00                    ;save them here
007BC9  2  A0 00                      ldy #$00                   ;load default offset (left side)
007BCB  2  0A                         asl                        ;if d7 of offscreen bits are set,
007BCC  2  B0 07                      bcs KeepOnscr              ;branch with default offset
007BCE  2  C8                         iny                        ;otherwise use different offset (right side)
007BCF  2  A5 00                      lda $00
007BD1  2  29 20                      and #%00100000             ;check offscreen bits for d5 set
007BD3  2  F0 1B                      beq InitPlatScrl           ;if not set, branch ahead of this part
007BD5  2  B9 1C 07     KeepOnscr:    lda ScreenEdge_X_Pos,y     ;get left or right side coordinate based on offset
007BD8  2  38                         sec
007BD9  2  F9 F6 7B                   sbc X_SubtracterData,y     ;subtract amount based on offset
007BDC  2  85 86                      sta Player_X_Position      ;store as player position to prevent movement further
007BDE  2  B9 1A 07                   lda ScreenEdge_PageLoc,y   ;get left or right page location based on offset
007BE1  2  E9 00                      sbc #$00                   ;subtract borrow
007BE3  2  85 6D                      sta Player_PageLoc         ;save as player's page location
007BE5  2  A5 0C                      lda Left_Right_Buttons     ;check saved controller bits
007BE7  2  D9 F8 7B                   cmp OffscrJoypadBitsData,y ;against bits based on offset
007BEA  2  F0 04                      beq InitPlatScrl           ;if not equal, branch
007BEC  2  A9 00                      lda #$00
007BEE  2  85 57                      sta Player_X_Speed         ;otherwise nullify horizontal speed of player
007BF0  2  A9 00        InitPlatScrl: lda #$00                   ;nullify platform force imposed on scroll
007BF2  2  8D A1 03                   sta Platform_X_Scroll
007BF5  2  60                         rts
007BF6  2               
007BF6  2               X_SubtracterData:
007BF6  2  00 10              .byte $00, $10
007BF8  2               
007BF8  2               OffscrJoypadBitsData:
007BF8  2  01 02              .byte $01, $02
007BFA  2               
007BFA  2               ;-------------------------------------------------------------------------------------
007BFA  2               
007BFA  2               GetScreenPosition:
007BFA  2  AD 1C 07           lda ScreenLeft_X_Pos    ;get coordinate of screen's left boundary
007BFD  2  18                 clc
007BFE  2  69 FF              adc #$ff                ;add 255 pixels
007C00  2  8D 1D 07           sta ScreenRight_X_Pos   ;store as coordinate of screen's right boundary
007C03  2  AD 1A 07           lda ScreenLeft_PageLoc  ;get page number where left boundary is
007C06  2  69 00              adc #$00                ;add carry from before
007C08  2  8D 1B 07           sta ScreenRight_PageLoc ;store as page number where right boundary is
007C0B  2  60                 rts
007C0C  2               
007C0C  2               ;-------------------------------------------------------------------------------------
007C0C  2               
007C0C  2               GameRoutines:
007C0C  2  A5 0E              lda GameEngineSubroutine  ;run routine based on number (a few of these routines are
007C0E  2  20 0F 6D           jsr JumpEngine            ;merely placeholders as conditions for other routines)
007C11  2               
007C11  2  FC 6F              .word Entrance_GameTimerSetup
007C13  2  89 7D              .word Vine_AutoClimb
007C15  2  C8 7D              .word SideExitPipeEntry
007C17  2  A7 7D              .word VerticalPipeEntry
007C19  2  64 7E              .word FlagpoleSlide
007C1B  2  8A 7E              .word PlayerEndLevel
007C1D  2  98 70              .word PlayerLoseLife
007C1F  2  2B 7C              .word PlayerEntrance
007C21  2  AB 7C              .word PlayerCtrlRoutine
007C23  2  F4 7D              .word PlayerChangeSize
007C25  2  06 7E              .word PlayerInjuryBlink
007C27  2  2A 7E              .word PlayerDeath
007C29  2  3E 7E              .word PlayerFireFlower
007C2B  2               
007C2B  2               PlayerEntrance:
007C2B  2  AD 52 07                 lda AltEntranceControl    ;check for mode of alternate entry
007C2E  2  C9 02                    cmp #$02
007C30  2  F0 2B                    beq EntrMode2             ;if found, branch to enter from pipe or with vine
007C32  2  A9 00                    lda #$00
007C34  2  A4 CE                    ldy Player_Y_Position     ;if vertical position above a certain
007C36  2  C0 30                    cpy #$30                  ;point, nullify controller bits and continue
007C38  2  90 6E                    bcc AutoControlPlayer     ;with player movement code, do not return
007C3A  2  AD 10 07                 lda PlayerEntranceCtrl    ;check player entry bits from header
007C3D  2  C9 06                    cmp #$06
007C3F  2  F0 04                    beq ChkBehPipe            ;if set to 6 or 7, execute pipe intro code
007C41  2  C9 07                    cmp #$07                  ;otherwise branch to normal entry
007C43  2  D0 50                    bne PlayerRdy
007C45  2  AD C4 03     ChkBehPipe: lda Player_SprAttrib      ;check for sprite attributes
007C48  2  D0 05                    bne IntroEntr             ;branch if found
007C4A  2  A9 01                    lda #$01
007C4C  2  4C A8 7C                 jmp AutoControlPlayer     ;force player to walk to the right
007C4F  2  20 E1 7D     IntroEntr:  jsr EnterSidePipe         ;execute sub to move player to the right
007C52  2  CE DE 06                 dec ChangeAreaTimer       ;decrement timer for change of area
007C55  2  D0 50                    bne ExitEntr              ;branch to exit if not yet expired
007C57  2  EE 69 07                 inc DisableIntermediate   ;set flag to skip world and lives display
007C5A  2  4C D8 7E                 jmp NextArea              ;jump to increment to next area and set modes
007C5D  2  AD 58 07     EntrMode2:  lda JoypadOverride        ;if controller override bits set here,
007C60  2  D0 0C                    bne VineEntr              ;branch to enter with vine
007C62  2  A9 FF                    lda #$ff                  ;otherwise, set value here then execute sub
007C64  2  20 C2 7D                 jsr MovePlayerYAxis       ;to move player upwards
007C67  2  A5 CE                    lda Player_Y_Position     ;check to see if player is at a specific coordinate
007C69  2  C9 91                    cmp #$91                  ;if player risen to a certain point (this requires pipes
007C6B  2  90 28                    bcc PlayerRdy             ;to be at specific height to look/function right) branch
007C6D  2  60                       rts                       ;to the last part, otherwise leave
007C6E  2  AD 99 03     VineEntr:   lda VineHeight
007C71  2  C9 60                    cmp #$60                  ;check vine height
007C73  2  D0 32                    bne ExitEntr              ;if vine not yet reached maximum height, branch to leave
007C75  2  A5 CE                    lda Player_Y_Position     ;get player's vertical coordinate
007C77  2  C9 99                    cmp #$99                  ;check player's vertical coordinate against preset value
007C79  2  A0 00                    ldy #$00                  ;load default values to be written to
007C7B  2  A9 01                    lda #$01                  ;this value moves player to the right off the vine
007C7D  2  90 0A                    bcc OffVine               ;if vertical coordinate < preset value, use defaults
007C7F  2  A9 03                    lda #$03
007C81  2  85 1D                    sta Player_State          ;otherwise set player state to climbing
007C83  2  C8                       iny                       ;increment value in Y
007C84  2  A9 08                    lda #$08                  ;set block in block buffer to cover hole, then
007C86  2  8D B4 05                 sta Block_Buffer_1+$b4    ;use same value to force player to climb
007C89  2  8C 16 07     OffVine:    sty DisableCollisionDet   ;set collision detection disable flag
007C8C  2  20 A8 7C                 jsr AutoControlPlayer     ;use contents of A to move player up or right, execute sub
007C8F  2  A5 86                    lda Player_X_Position
007C91  2  C9 48                    cmp #$48                  ;check player's horizontal position
007C93  2  90 12                    bcc ExitEntr              ;if not far enough to the right, branch to leave
007C95  2  A9 08        PlayerRdy:  lda #$08                  ;set routine to be executed by game engine next frame
007C97  2  85 0E                    sta GameEngineSubroutine
007C99  2  A9 01                    lda #$01                  ;set to face player to the right
007C9B  2  85 33                    sta PlayerFacingDir
007C9D  2  4A                       lsr                       ;init A
007C9E  2  8D 52 07                 sta AltEntranceControl    ;init mode of entry
007CA1  2  8D 16 07                 sta DisableCollisionDet   ;init collision detection disable flag
007CA4  2  8D 58 07                 sta JoypadOverride        ;nullify controller override bits
007CA7  2  60           ExitEntr:   rts                       ;leave!
007CA8  2               
007CA8  2               ;-------------------------------------------------------------------------------------
007CA8  2               ;$07 - used to hold upper limit of high byte when player falls down hole
007CA8  2               
007CA8  2               AutoControlPlayer:
007CA8  2  8D FC 06           sta SavedJoypadBits         ;override controller bits with contents of A if executing here
007CAB  2               
007CAB  2               PlayerCtrlRoutine:
007CAB  2  A5 0E                    lda GameEngineSubroutine    ;check task here
007CAD  2  C9 0B                    cmp #$0b                    ;if certain value is set, branch to skip controller bit loading
007CAF  2  F0 3C                    beq SizeChk
007CB1  2  AD 4E 07                 lda AreaType                ;are we in a water type area?
007CB4  2  D0 10                    bne SaveJoyp                ;if not, branch
007CB6  2  A4 B5                    ldy Player_Y_HighPos
007CB8  2  88                       dey                         ;if not in vertical area between
007CB9  2  D0 06                    bne DisJoyp                 ;status bar and bottom, branch
007CBB  2  A5 CE                    lda Player_Y_Position
007CBD  2  C9 D0                    cmp #$d0                    ;if nearing the bottom of the screen or
007CBF  2  90 05                    bcc SaveJoyp                ;not in the vertical area between status bar or bottom,
007CC1  2  A9 00        DisJoyp:    lda #$00                    ;disable controller bits
007CC3  2  8D FC 06                 sta SavedJoypadBits
007CC6  2  AD FC 06     SaveJoyp:   lda SavedJoypadBits         ;otherwise store A and B buttons in $0a
007CC9  2  29 C0                    and #%11000000
007CCB  2  85 0A                    sta A_B_Buttons
007CCD  2  AD FC 06                 lda SavedJoypadBits         ;store left and right buttons in $0c
007CD0  2  29 03                    and #%00000011
007CD2  2  85 0C                    sta Left_Right_Buttons
007CD4  2  AD FC 06                 lda SavedJoypadBits         ;store up and down buttons in $0b
007CD7  2  29 0C                    and #%00001100
007CD9  2  85 0B                    sta Up_Down_Buttons
007CDB  2  29 04                    and #%00000100              ;check for pressing down
007CDD  2  F0 0E                    beq SizeChk                 ;if not, branch
007CDF  2  A5 1D                    lda Player_State            ;check player's state
007CE1  2  D0 0A                    bne SizeChk                 ;if not on the ground, branch
007CE3  2  A4 0C                    ldy Left_Right_Buttons      ;check left and right
007CE5  2  F0 06                    beq SizeChk                 ;if neither pressed, branch
007CE7  2  A9 00                    lda #$00
007CE9  2  85 0C                    sta Left_Right_Buttons      ;if pressing down while on the ground,
007CEB  2  85 0B                    sta Up_Down_Buttons         ;nullify directional bits
007CED  2  20 EC 7E     SizeChk:    jsr PlayerMovementSubs      ;run movement subroutines
007CF0  2  A0 01                    ldy #$01                    ;is player small?
007CF2  2  AD 54 07                 lda PlayerSize
007CF5  2  D0 09                    bne ChkMoveDir
007CF7  2  A0 00                    ldy #$00                    ;check for if crouching
007CF9  2  AD 14 07                 lda CrouchingFlag
007CFC  2  F0 02                    beq ChkMoveDir              ;if not, branch ahead
007CFE  2  A0 02                    ldy #$02                    ;if big and crouching, load y with 2
007D00  2  8C 99 04     ChkMoveDir: sty Player_BoundBoxCtrl     ;set contents of Y as player's bounding box size control
007D03  2  A9 01                    lda #$01                    ;set moving direction to right by default
007D05  2  A4 57                    ldy Player_X_Speed          ;check player's horizontal speed
007D07  2  F0 05                    beq PlayerSubs              ;if not moving at all horizontally, skip this part
007D09  2  10 01                    bpl SetMoveDir              ;if moving to the right, use default moving direction
007D0B  2  0A                       asl                         ;otherwise change to move to the left
007D0C  2  85 45        SetMoveDir: sta Player_MovingDir        ;set moving direction
007D0E  2  20 59 7B     PlayerSubs: jsr ScrollHandler           ;move the screen if necessary
007D11  2  20 75 BE                 jsr GetPlayerOffscreenBits  ;get player's offscreen bits
007D14  2  20 1F BE                 jsr RelativePlayerPosition  ;get coordinates relative to the screen
007D17  2  A2 00                    ldx #$00                    ;set offset for player object
007D19  2  20 4C AF                 jsr BoundingBoxCore         ;get player's bounding box coordinates
007D1C  2  20 DE A8                 jsr PlayerBGCollision       ;do collision detection and process
007D1F  2  A5 CE                    lda Player_Y_Position
007D21  2  C9 40                    cmp #$40                    ;check to see if player is higher than 64th pixel
007D23  2  90 16                    bcc PlayerHole              ;if so, branch ahead
007D25  2  A5 0E                    lda GameEngineSubroutine
007D27  2  C9 05                    cmp #$05                    ;if running end-of-level routine, branch ahead
007D29  2  F0 10                    beq PlayerHole
007D2B  2  C9 07                    cmp #$07                    ;if running player entrance routine, branch ahead
007D2D  2  F0 0C                    beq PlayerHole
007D2F  2  C9 04                    cmp #$04                    ;if running routines $00-$03, branch ahead
007D31  2  90 08                    bcc PlayerHole
007D33  2  AD C4 03                 lda Player_SprAttrib
007D36  2  29 DF                    and #%11011111              ;otherwise nullify player's
007D38  2  8D C4 03                 sta Player_SprAttrib        ;background priority flag
007D3B  2  A5 B5        PlayerHole: lda Player_Y_HighPos        ;check player's vertical high byte
007D3D  2  C9 02                    cmp #$02                    ;for below the screen
007D3F  2  30 3B                    bmi ExitCtrl                ;branch to leave if not that far down
007D41  2  A2 01                    ldx #$01
007D43  2  8E 23 07                 stx ScrollLock              ;set scroll lock
007D46  2  A0 04                    ldy #$04
007D48  2  84 07                    sty $07                     ;set value here
007D4A  2  A2 00                    ldx #$00                    ;use X as flag, and clear for cloud level
007D4C  2  AC 59 07                 ldy GameTimerExpiredFlag    ;check game timer expiration flag
007D4F  2  D0 05                    bne HoleDie                 ;if set, branch
007D51  2  AC 43 07                 ldy CloudTypeOverride       ;check for cloud type override
007D54  2  D0 16                    bne ChkHoleX                ;skip to last part if found
007D56  2  E8           HoleDie:    inx                         ;set flag in X for player death
007D57  2  A4 0E                    ldy GameEngineSubroutine
007D59  2  C0 0B                    cpy #$0b                    ;check for some other routine running
007D5B  2  F0 0F                    beq ChkHoleX                ;if so, branch ahead
007D5D  2  AC 12 07                 ldy DeathMusicLoaded        ;check value here
007D60  2  D0 06                    bne HoleBottom              ;if already set, branch to next part
007D62  2  C8                       iny
007D63  2  84 FC                    sty EventMusicQueue         ;otherwise play death music
007D65  2  8C 12 07                 sty DeathMusicLoaded        ;and set value here
007D68  2  A0 06        HoleBottom: ldy #$06
007D6A  2  84 07                    sty $07                     ;change value here
007D6C  2  C5 07        ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
007D6E  2  30 0C                    bmi ExitCtrl                ;if less, branch to leave
007D70  2  CA                       dex                         ;otherwise decrement flag in X
007D71  2  30 0A                    bmi CloudExit               ;if flag was clear, branch to set modes and other values
007D73  2  AC B1 07                 ldy EventMusicBuffer        ;check to see if music is still playing
007D76  2  D0 04                    bne ExitCtrl                ;branch to leave if so
007D78  2  A9 06                    lda #$06                    ;otherwise set to run lose life routine
007D7A  2  85 0E                    sta GameEngineSubroutine    ;on next frame
007D7C  2  60           ExitCtrl:   rts                         ;leave
007D7D  2               
007D7D  2               CloudExit:
007D7D  2  A9 00              lda #$00
007D7F  2  8D 58 07           sta JoypadOverride      ;clear controller override bits if any are set
007D82  2  20 9F 7D           jsr SetEntr             ;do sub to set secondary mode
007D85  2  EE 52 07           inc AltEntranceControl  ;set mode of entry to 3
007D88  2  60                 rts
007D89  2               
007D89  2               ;-------------------------------------------------------------------------------------
007D89  2               
007D89  2               Vine_AutoClimb:
007D89  2  A5 B5                   lda Player_Y_HighPos   ;check to see whether player reached position
007D8B  2  D0 06                   bne AutoClimb          ;above the status bar yet and if so, set modes
007D8D  2  A5 CE                   lda Player_Y_Position
007D8F  2  C9 E4                   cmp #$e4
007D91  2  90 0C                   bcc SetEntr
007D93  2  A9 08        AutoClimb: lda #%00001000         ;set controller bits override to up
007D95  2  8D 58 07                sta JoypadOverride
007D98  2  A0 03                   ldy #$03               ;set player state to climbing
007D9A  2  84 1D                   sty Player_State
007D9C  2  4C A8 7C                jmp AutoControlPlayer
007D9F  2  A9 02        SetEntr:   lda #$02               ;set starting position to override
007DA1  2  8D 52 07                sta AltEntranceControl
007DA4  2  4C D5 7D                jmp ChgAreaMode        ;set modes
007DA7  2               
007DA7  2               ;-------------------------------------------------------------------------------------
007DA7  2               
007DA7  2               VerticalPipeEntry:
007DA7  2  A9 01              lda #$01             ;set 1 as movement amount
007DA9  2  20 C2 7D           jsr MovePlayerYAxis  ;do sub to move player downwards
007DAC  2  20 59 7B           jsr ScrollHandler    ;do sub to scroll screen with saved force if necessary
007DAF  2  A0 00              ldy #$00             ;load default mode of entry
007DB1  2  AD D6 06           lda WarpZoneControl  ;check warp zone control variable/flag
007DB4  2  D0 17              bne ChgAreaPipe      ;if set, branch to use mode 0
007DB6  2  C8                 iny
007DB7  2  AD 4E 07           lda AreaType         ;check for castle level type
007DBA  2  C9 03              cmp #$03
007DBC  2  D0 0F              bne ChgAreaPipe      ;if not castle type level, use mode 1
007DBE  2  C8                 iny
007DBF  2  4C CD 7D           jmp ChgAreaPipe      ;otherwise use mode 2
007DC2  2               
007DC2  2               MovePlayerYAxis:
007DC2  2  18                 clc
007DC3  2  65 CE              adc Player_Y_Position ;add contents of A to player position
007DC5  2  85 CE              sta Player_Y_Position
007DC7  2  60                 rts
007DC8  2               
007DC8  2               ;-------------------------------------------------------------------------------------
007DC8  2               
007DC8  2               SideExitPipeEntry:
007DC8  2  20 E1 7D                  jsr EnterSidePipe         ;execute sub to move player to the right
007DCB  2  A0 02                     ldy #$02
007DCD  2  CE DE 06     ChgAreaPipe: dec ChangeAreaTimer       ;decrement timer for change of area
007DD0  2  D0 0E                     bne ExitCAPipe
007DD2  2  8C 52 07                  sty AltEntranceControl    ;when timer expires set mode of alternate entry
007DD5  2  EE 74 07     ChgAreaMode: inc DisableScreenFlag     ;set flag to disable screen output
007DD8  2  A9 00                     lda #$00
007DDA  2  8D 72 07                  sta OperMode_Task         ;set secondary mode of operation
007DDD  2  8D 22 07                  sta IRQUpdateFlag         ;disable sprite 0 check
007DE0  2  60           ExitCAPipe:  rts                       ;leave
007DE1  2               
007DE1  2               EnterSidePipe:
007DE1  2  A9 08                   lda #$08               ;set player's horizontal speed
007DE3  2  85 57                   sta Player_X_Speed
007DE5  2  A0 01                   ldy #$01               ;set controller right button by default
007DE7  2  A5 86                   lda Player_X_Position  ;mask out higher nybble of player's
007DE9  2  29 0F                   and #%00001111         ;horizontal position
007DEB  2  D0 03                   bne RightPipe
007DED  2  85 57                   sta Player_X_Speed     ;if lower nybble = 0, set as horizontal speed
007DEF  2  A8                      tay                    ;and nullify controller bit override here
007DF0  2  98           RightPipe: tya                    ;use contents of Y to
007DF1  2               .ifdef ANN
007DF1  2  4C A8 7C                jmp AutoControlPlayer  ;execute player control routine with ctrl bits nulled
007DF4  2               .else
007DF4  2                          jsr AutoControlPlayer  ;execute player control routine with ctrl bits nulled
007DF4  2                          rts
007DF4  2               .endif
007DF4  2               
007DF4  2               ;-------------------------------------------------------------------------------------
007DF4  2               
007DF4  2               PlayerChangeSize:
007DF4  2  AD 47 07                  lda TimerControl    ;check master timer control
007DF7  2  C9 F8                     cmp #$f8            ;for specific moment in time
007DF9  2  D0 03                     bne EndChgSize      ;branch if before or after that point
007DFB  2  4C 16 7E                  jmp InitChangeSize  ;otherwise run code to get growing/shrinking going
007DFE  2  C9 C4        EndChgSize:  cmp #$c4            ;check again for another specific moment
007E00  2  D0 03                     bne ExitChgSize     ;and branch to leave if before or after that point
007E02  2  20 34 7E                  jsr DonePlayerTask  ;otherwise do sub to init timer control and set routine
007E05  2  60           ExitChgSize: rts                 ;and then leave
007E06  2               
007E06  2               ;-------------------------------------------------------------------------------------
007E06  2               
007E06  2               PlayerInjuryBlink:
007E06  2  AD 47 07                lda TimerControl       ;check master timer control
007E09  2  C9 F0                   cmp #$f0               ;for specific moment in time
007E0B  2  B0 07                   bcs ExitBlink          ;branch if before that point
007E0D  2  C9 C8                   cmp #$c8               ;check again for another specific point
007E0F  2  F0 23                   beq DonePlayerTask     ;branch if at that point, and not before or after
007E11  2  4C AB 7C                jmp PlayerCtrlRoutine  ;otherwise run player control routine
007E14  2  D0 13        ExitBlink: bne ExitBoth           ;do unconditional branch to leave
007E16  2               
007E16  2               InitChangeSize:
007E16  2  AC 0B 07               ldy PlayerChangeSizeFlag  ;if growing/shrinking flag already set
007E19  2  D0 0E                  bne ExitBoth              ;then branch to leave
007E1B  2  8C 0D 07               sty PlayerAnimCtrl        ;otherwise initialize player's animation frame control
007E1E  2  EE 0B 07               inc PlayerChangeSizeFlag  ;set growing/shrinking flag
007E21  2  AD 54 07               lda PlayerSize
007E24  2  49 01                  eor #$01                  ;invert player's size
007E26  2  8D 54 07               sta PlayerSize
007E29  2  60           ExitBoth: rts                       ;leave
007E2A  2               
007E2A  2               ;-------------------------------------------------------------------------------------
007E2A  2               ;$00 - used in CyclePlayerPalette to store current palette to cycle
007E2A  2               
007E2A  2               PlayerDeath:
007E2A  2  AD 47 07           lda TimerControl       ;check master timer control
007E2D  2  C9 F0              cmp #$f0               ;for specific moment in time
007E2F  2  B0 32              bcs ExitDeath          ;branch to leave if before that point
007E31  2  4C AB 7C           jmp PlayerCtrlRoutine  ;otherwise run player control routine
007E34  2               
007E34  2               DonePlayerTask:
007E34  2  A9 00              lda #$00
007E36  2  8D 47 07           sta TimerControl          ;initialize master timer control to continue timers
007E39  2  A9 08              lda #$08
007E3B  2  85 0E              sta GameEngineSubroutine  ;set player control routine to run next frame
007E3D  2  60                 rts                       ;leave
007E3E  2               
007E3E  2               PlayerFireFlower:
007E3E  2  AD 47 07           lda TimerControl       ;check master timer control
007E41  2  C9 C0              cmp #$c0               ;for specific moment in time
007E43  2  F0 13              beq ResetPalFireFlower ;branch if at moment, not before or after
007E45  2  A5 09              lda FrameCounter       ;get frame counter
007E47  2  4A                 lsr
007E48  2  4A                 lsr                    ;divide by four to change every four frames
007E49  2               
007E49  2               CyclePlayerPalette:
007E49  2  29 03              and #$03              ;mask out all but d1-d0 (previously d3-d2)
007E4B  2  85 00              sta $00               ;store result here to use as palette bits
007E4D  2  AD C4 03           lda Player_SprAttrib  ;get player attributes
007E50  2  29 FC              and #%11111100        ;save any other bits but palette bits
007E52  2  05 00              ora $00               ;add palette bits
007E54  2  8D C4 03           sta Player_SprAttrib  ;store as new player attributes
007E57  2  60                 rts                   ;and leave
007E58  2               
007E58  2               ResetPalFireFlower:
007E58  2  20 34 7E           jsr DonePlayerTask    ;do sub to init timer control and run player control routine
007E5B  2               
007E5B  2               ResetPalStar:
007E5B  2  AD C4 03           lda Player_SprAttrib  ;get player attributes
007E5E  2  29 FC              and #%11111100        ;mask out palette bits to force palette 0
007E60  2  8D C4 03           sta Player_SprAttrib  ;store as new player attributes
007E63  2               ExitDeath:
007E63  2  60                 rts                   ;and leave
007E64  2               
007E64  2               ;-------------------------------------------------------------------------------------
007E64  2               
007E64  2               FlagpoleSlide:
007E64  2  A5 1B                     lda Enemy_ID+5           ;check special use enemy slot
007E66  2  C9 30                     cmp #FlagpoleFlagObject  ;for flagpole flag object
007E68  2  D0 15                     bne NoFPObj              ;if not found, branch to something residual
007E6A  2  AD 13 07                  lda FlagpoleSoundQueue   ;load flagpole sound
007E6D  2  85 FF                     sta Square1SoundQueue    ;into square 1's sfx queue
007E6F  2  A9 00                     lda #$00
007E71  2  8D 13 07                  sta FlagpoleSoundQueue   ;init flagpole sound queue
007E74  2  A4 CE                     ldy Player_Y_Position
007E76  2  C0 9E                     cpy #$9e                 ;check to see if player has slid down
007E78  2  B0 02                     bcs SlidePlayer          ;far enough, and if so, branch with no controller bits set
007E7A  2  A9 04                     lda #$04                 ;otherwise force player to climb down (to slide)
007E7C  2  4C A8 7C     SlidePlayer: jmp AutoControlPlayer    ;jump to player control routine
007E7F  2  E6 0E        NoFPObj:     inc GameEngineSubroutine ;increment to next routine (this may
007E81  2  60                        rts                      ;be residual code)
007E82  2               
007E82  2               ;-------------------------------------------------------------------------------------
007E82  2               
007E82  2               .ifdef ANN
007E82  2               Hidden1UpCoinAmts:
007E82  2  14 1E 14 1B        .byte $14, $1E, $14, $1B, $13, $18, $13, $63
007E86  2  13 18 13 63  
007E8A  2               .endif
007E8A  2               
007E8A  2               PlayerEndLevel:
007E8A  2  A9 01                  lda #$01                  ;force player to walk to the right
007E8C  2  20 A8 7C               jsr AutoControlPlayer
007E8F  2  A5 CE                  lda Player_Y_Position     ;check player's vertical position
007E91  2  C9 AE                  cmp #$ae
007E93  2  90 11                  bcc ChkStop               ;if player is not yet off the flagpole, skip this part
007E95  2  A9 00                  lda #$00
007E97  2  8D 23 07               sta ScrollLock            ;reactivate scroll
007E9A  2  AD F6 07               lda FlagpoleMusicFlag     ;check flag to see if music was already queued
007E9D  2  D0 07                  bne ChkStop               ;if so, skip this
007E9F  2  A9 20                  lda #EndOfLevelMusic
007EA1  2  85 FC                  sta EventMusicQueue       ;load win level music in event music queue
007EA3  2  EE F6 07               inc FlagpoleMusicFlag     ;set flag to keep music from getting queued more than once
007EA6  2  AD 90 04     ChkStop:  lda Player_CollisionBits  ;get player collision bits
007EA9  2  4A                     lsr                       ;check for d0 set
007EAA  2  B0 0D                  bcs RdyNextA              ;if d0 set, skip to next part
007EAC  2  AD 46 07               lda StarFlagTaskControl   ;if star flag task control already set,
007EAF  2  D0 03                  bne InCastle              ;go ahead with the rest of the code
007EB1  2  EE 46 07               inc StarFlagTaskControl   ;otherwise set task control now (this gets ball rolling!)
007EB4  2  A9 20        InCastle: lda #%00100000            ;set player's background priority bit to
007EB6  2  8D C4 03               sta Player_SprAttrib      ;give illusion of being inside the castle
007EB9  2  AD 46 07     RdyNextA: lda StarFlagTaskControl
007EBC  2  C9 05                  cmp #$05                  ;if star flag task control not yet set
007EBE  2  D0 2B                  bne ExitNA                ;beyond last valid task number, branch to leave
007EC0  2  EE 5C 07               inc LevelNumber           ;increment level number used for game logic
007EC3  2  AD 5C 07               lda LevelNumber
007EC6  2  C9 03                  cmp #$03                  ;check to see if we have yet reached level -4
007EC8  2  D0 0E                  bne NextArea              ;and skip this last part here if not
007ECA  2  AC 5F 07               ldy WorldNumber           ;get world number as offset
007ECD  2  AD 48 07               lda CoinTallyFor1Ups      ;check third area coin tally for bonus 1-ups
007ED0  2               .ifdef ANN
007ED0  2  D9 82 7E               cmp Hidden1UpCoinAmts,y   ;against minimum value, if player has not collected
007ED3  2               .else
007ED3  2                         cmp #$0a                  ;against minimum value, if player has not collected
007ED3  2               .endif
007ED3  2  90 03                  bcc NextArea              ;at least this number of coins, leave flag clear
007ED5  2  EE 5D 07               inc Hidden1UpFlag         ;otherwise set hidden 1-up box control flag
007ED8  2  EE 60 07     NextArea: inc AreaNumber            ;increment area number used for address loader
007EDB  2               .ifndef ANN
007EDB  2                         lda WorldNumber
007EDB  2                         cmp #$08
007EDB  2                         bne NotW9                 ;if not at end of world 9-4, branch
007EDB  2                         lda LevelNumber           ;otherwise reset level and area numbers properly
007EDB  2                         cmp #$04
007EDB  2                         bne NotW9
007EDB  2                         lda #$00
007EDB  2                         sta LevelNumber
007EDB  2                         sta AreaNumber
007EDB  2               .endif
007EDB  2  20 86 C2     NotW9:    jsr LoadAreaPointer       ;get new level pointer
007EDE  2  EE 57 07               inc FetchNewGameTimerFlag ;set flag to load new game timer
007EE1  2  20 D5 7D               jsr ChgAreaMode           ;do sub to set secondary mode, disable screen and sprite 0
007EE4  2  8D 5B 07               sta HalfwayPage           ;reset halfway page to 0 (beginning)
007EE7  2  A9 80                  lda #Silence
007EE9  2  85 FC                  sta EventMusicQueue       ;silence music and leave
007EEB  2  60           ExitNA:   rts
007EEC  2               
007EEC  2               ;-------------------------------------------------------------------------------------
007EEC  2               
007EEC  2               PlayerMovementSubs:
007EEC  2  A9 00                   lda #$00                  ;set A to init crouch flag by default
007EEE  2  AC 54 07                ldy PlayerSize            ;is player small?
007EF1  2  D0 08                   bne SetCrouch             ;if so, branch
007EF3  2  A5 1D                   lda Player_State          ;check state of player
007EF5  2  D0 07                   bne ProcMove              ;if not on the ground, branch
007EF7  2  A5 0B                   lda Up_Down_Buttons       ;load controller bits for up and down
007EF9  2  29 04                   and #%00000100            ;single out bit for down button
007EFB  2  8D 14 07     SetCrouch: sta CrouchingFlag         ;store value in crouch flag
007EFE  2  20 10 80     ProcMove:  jsr PlayerPhysicsSub      ;run sub related to jumping and swimming
007F01  2  AD 0B 07                lda PlayerChangeSizeFlag  ;if growing/shrinking flag set,
007F04  2  D0 16                   bne NoMoveSub             ;branch to leave
007F06  2  A5 1D                   lda Player_State
007F08  2  C9 03                   cmp #$03                  ;get player state
007F0A  2  F0 05                   beq MoveSubs              ;if climbing, branch ahead, leave timer unset
007F0C  2  A0 18                   ldy #$18
007F0E  2  8C 89 07                sty ClimbSideTimer        ;otherwise reset timer now
007F11  2  20 0F 6D     MoveSubs:  jsr JumpEngine
007F14  2               
007F14  2  1D 7F              .word OnGroundStateSub
007F16  2  39 7F              .word JumpSwimSub
007F18  2  30 7F              .word FallingSub
007F1A  2  8F 7F              .word ClimbingSub
007F1C  2               
007F1C  2  60           NoMoveSub: rts
007F1D  2               
007F1D  2               ;-------------------------------------------------------------------------------------
007F1D  2               ;$00 - used by ClimbingSub to store high vertical adder
007F1D  2               
007F1D  2               OnGroundStateSub:
007F1D  2  20 4F 81              jsr GetPlayerAnimSpeed     ;do a sub to set animation frame timing
007F20  2  A5 0C                 lda Left_Right_Buttons
007F22  2  F0 02                 beq GndMove                ;if left/right controller bits not set, skip instruction
007F24  2  85 33                 sta PlayerFacingDir        ;otherwise set new facing direction
007F26  2  20 8C 81     GndMove: jsr ImposeFriction         ;do a sub to impose friction on player's walk/run
007F29  2  20 18 8B     JmpMove: jsr MovePlayerHorizontally ;do another sub to move player horizontally
007F2C  2  8D FF 06              sta Player_X_Scroll        ;set returned value as player's movement speed for scroll
007F2F  2               .ifndef ANN
007F2F  2                        lda FileListNumber         ;if in worlds 1-4 don't bother checking for wind
007F2F  2                        beq ExOGSS
007F2F  2                        jsr BlowPlayerAround
007F2F  2               ExOGSS:
007F2F  2               .endif
007F2F  2  60                    rts
007F30  2               
007F30  2               ;--------------------------------
007F30  2               
007F30  2               FallingSub:
007F30  2  AD 0A 07           lda VerticalForceDown
007F33  2  8D 09 07           sta VerticalForce      ;dump vertical movement force for falling into main one
007F36  2  4C 6F 7F           jmp LRAir              ;movement force, then skip ahead to process left/right movement
007F39  2               
007F39  2               ;--------------------------------
007F39  2               
007F39  2               JumpSwimSub:
007F39  2  A4 9F                  ldy Player_Y_Speed         ;if player's vertical speed zero
007F3B  2  10 13                  bpl DumpFall               ;or moving downwards, branch to falling
007F3D  2  A5 0A                  lda A_B_Buttons
007F3F  2  29 80                  and #A_Button              ;check to see if A button is being pressed
007F41  2  25 0D                  and PreviousA_B_Buttons    ;and was pressed in previous frame
007F43  2  D0 11                  bne ProcSwim               ;if so, branch elsewhere
007F45  2  AD 08 07               lda JumpOrigin_Y_Position  ;get vertical position player jumped from
007F48  2  38                     sec
007F49  2  E5 CE                  sbc Player_Y_Position      ;subtract current from original vertical coordinate
007F4B  2  CD 06 07               cmp DiffToHaltJump         ;compare to value set here to see if player is in mid-jump
007F4E  2  90 06                  bcc ProcSwim               ;or just starting to jump, if just starting, skip ahead
007F50  2  AD 0A 07     DumpFall: lda VerticalForceDown      ;otherwise dump falling into main fractional
007F53  2  8D 09 07               sta VerticalForce
007F56  2  AD 04 07     ProcSwim: lda SwimmingFlag           ;if swimming flag not set,
007F59  2  F0 14                  beq LRAir                  ;branch ahead to last part
007F5B  2  20 4F 81               jsr GetPlayerAnimSpeed     ;do a sub to get animation frame timing
007F5E  2  A5 CE                  lda Player_Y_Position
007F60  2  C9 14                  cmp #$14                   ;check vertical position against preset value
007F62  2  B0 05                  bcs LRWater                ;if not yet reached a certain position, branch ahead
007F64  2  A9 18                  lda #$18
007F66  2  8D 09 07               sta VerticalForce          ;otherwise set fractional
007F69  2  A5 0C        LRWater:  lda Left_Right_Buttons     ;check left/right controller bits (check for swimming)
007F6B  2  F0 02                  beq LRAir                  ;if not pressing any, skip
007F6D  2  85 33                  sta PlayerFacingDir        ;otherwise set facing direction accordingly
007F6F  2  A5 0C        LRAir:    lda Left_Right_Buttons     ;check left/right controller bits (check for jumping/falling)
007F71  2  F0 03                  beq JSMove                 ;if not pressing any, skip
007F73  2  20 8C 81               jsr ImposeFriction         ;otherwise process horizontal movement
007F76  2  20 29 7F     JSMove:   jsr JmpMove
007F79  2  A5 0E                  lda GameEngineSubroutine
007F7B  2  C9 0B                  cmp #$0b                   ;check for specific routine selected
007F7D  2  D0 05                  bne ExitMov1               ;branch if not set to run
007F7F  2  A9 28                  lda #$28
007F81  2  8D 09 07               sta VerticalForce          ;otherwise set fractional
007F84  2  4C 5C 8B     ExitMov1: jmp MovePlayerVertically   ;jump to move player vertically, then leave
007F87  2               
007F87  2               ;--------------------------------
007F87  2               
007F87  2               ClimbAdderLow:
007F87  2  0E 04 FC F2        .byte $0e, $04, $fc, $f2
007F8B  2               ClimbAdderHigh:
007F8B  2  00 00 FF FF        .byte $00, $00, $ff, $ff
007F8F  2               
007F8F  2               ClimbingSub:
007F8F  2  AD 16 04                  lda Player_YMF_Dummy
007F92  2  18                        clc                      ;add movement force to dummy variable
007F93  2  6D 33 04                  adc Player_Y_MoveForce   ;save with carry
007F96  2  8D 16 04                  sta Player_YMF_Dummy
007F99  2  A0 00                     ldy #$00                 ;set default adder here
007F9B  2  A5 9F                     lda Player_Y_Speed       ;get player's vertical speed
007F9D  2  10 01                     bpl MoveOnVine           ;if not moving upwards, branch
007F9F  2  88                        dey                      ;otherwise set adder to $ff
007FA0  2  84 00        MoveOnVine:  sty $00                  ;store adder here
007FA2  2  65 CE                     adc Player_Y_Position    ;add carry to player's vertical position
007FA4  2  85 CE                     sta Player_Y_Position    ;and store to move player up or down
007FA6  2  A5 B5                     lda Player_Y_HighPos
007FA8  2  65 00                     adc $00                  ;add carry to player's page location
007FAA  2  85 B5                     sta Player_Y_HighPos     ;and store
007FAC  2  A5 0C                     lda Left_Right_Buttons   ;compare left/right controller bits
007FAE  2  2D 90 04                  and Player_CollisionBits ;to collision flag
007FB1  2  F0 2D                     beq InitCSTimer          ;if not set, skip to end
007FB3  2  AC 89 07                  ldy ClimbSideTimer       ;otherwise check timer
007FB6  2  D0 27                     bne ExitCSub             ;if timer not expired, branch to leave
007FB8  2  A0 18                     ldy #$18
007FBA  2  8C 89 07                  sty ClimbSideTimer       ;otherwise set timer now
007FBD  2  A2 00                     ldx #$00                 ;set default offset here
007FBF  2  A4 33                     ldy PlayerFacingDir      ;get facing direction
007FC1  2  4A                        lsr                      ;move right button controller bit to carry
007FC2  2  B0 02                     bcs ClimbFD              ;if controller right pressed, branch ahead
007FC4  2  E8                        inx
007FC5  2  E8                        inx                      ;otherwise increment offset by 2 bytes
007FC6  2  88           ClimbFD:     dey                      ;check to see if facing right
007FC7  2  F0 01                     beq CSetFDir             ;if so, branch, do not increment
007FC9  2  E8                        inx                      ;otherwise increment by 1 byte
007FCA  2  A5 86        CSetFDir:    lda Player_X_Position
007FCC  2  18                        clc                      ;add or subtract from player's horizontal position
007FCD  2  7D 87 7F                  adc ClimbAdderLow,x      ;using value here as adder and X as offset
007FD0  2  85 86                     sta Player_X_Position
007FD2  2  A5 6D                     lda Player_PageLoc       ;add or subtract carry or borrow using value here
007FD4  2  7D 8B 7F                  adc ClimbAdderHigh,x     ;from the player's page location
007FD7  2  85 6D                     sta Player_PageLoc
007FD9  2  A5 0C                     lda Left_Right_Buttons   ;get left/right controller bits again
007FDB  2  49 03                     eor #%00000011           ;invert them and store them while player
007FDD  2  85 33                     sta PlayerFacingDir      ;is on vine to face player in opposite direction
007FDF  2  60           ExitCSub:    rts                      ;then leave
007FE0  2  8D 89 07     InitCSTimer: sta ClimbSideTimer       ;initialize timer here
007FE3  2  60                        rts
007FE4  2               
007FE4  2               ;-------------------------------------------------------------------------------------
007FE4  2               ;$00 - used to store offset to friction data
007FE4  2               
007FE4  2               JumpMForceData:
007FE4  2  20 20 1E 28        .byte $20, $20, $1e, $28, $28, $0d, $04
007FE8  2  28 0D 04     
007FEB  2               
007FEB  2               FallMForceData:
007FEB  2  70 70 60 90        .byte $70, $70, $60, $90, $90, $0a, $09
007FEF  2  90 0A 09     
007FF2  2               
007FF2  2               FrictionData:
007FF2  2  E4 98 D0           .byte $e4, $98, $d0
007FF5  2               
007FF5  2               PlayerYSpdData:
007FF5  2  FC FC FC FB        .byte $fc, $fc, $fc, $fb, $fb, $fe, $ff
007FF9  2  FB FE FF     
007FFC  2               
007FFC  2               InitMForceData:
007FFC  2  00 00 00 00        .byte $00, $00, $00, $00, $00, $80, $00
008000  2  00 80 00     
008003  2               
008003  2               MaxLeftXSpdData:
008003  2  D8 E8 F0           .byte $d8, $e8, $f0
008006  2               
008006  2               MaxRightXSpdData:
008006  2  28 18 10           .byte $28, $18, $10
008009  2  0C                 .byte $0c ;used for pipe intros
00800A  2               
00800A  2               Climb_Y_SpeedData:
00800A  2  00 FF 01           .byte $00, $ff, $01
00800D  2               
00800D  2               Climb_Y_MForceData:
00800D  2  00 20 FF           .byte $00, $20, $ff
008010  2               
008010  2               PlayerPhysicsSub:
008010  2  A5 1D                   lda Player_State          ;check player state
008012  2  C9 03                   cmp #$03
008014  2  D0 23                   bne CheckForJumping       ;if not climbing, branch
008016  2  A0 00                   ldy #$00
008018  2  A5 0B                   lda Up_Down_Buttons       ;get controller bits for up/down
00801A  2  2D 90 04                and Player_CollisionBits  ;check against player's collision detection bits
00801D  2  F0 06                   beq ProcClimb             ;if not pressing up or down, branch
00801F  2  C8                      iny
008020  2  29 08                   and #%00001000            ;check for pressing up
008022  2  D0 01                   bne ProcClimb
008024  2  C8                      iny
008025  2  BE 0D 80     ProcClimb: ldx Climb_Y_MForceData,y  ;load value here
008028  2  8E 33 04                stx Player_Y_MoveForce    ;store as vertical movement force
00802B  2  A9 08                   lda #$08                  ;load default animation timing
00802D  2  BE 0A 80                ldx Climb_Y_SpeedData,y   ;load some other value here
008030  2  86 9F                   stx Player_Y_Speed        ;store as vertical speed
008032  2  30 01                   bmi SetCAnim              ;if climbing down, use default animation timing value
008034  2  4A                      lsr                       ;otherwise divide timer setting by 2
008035  2  8D 0C 07     SetCAnim:  sta PlayerAnimTimerSet    ;store animation timer setting and leave
008038  2  60                      rts
008039  2               
008039  2               CheckForJumping:
008039  2  AD 0E 07             lda JumpspringAnimCtrl    ;if jumpspring animating,
00803C  2  D0 0A                bne NoJump                ;skip ahead to something else
00803E  2  A5 0A                lda A_B_Buttons           ;check for A button press
008040  2  29 80                and #A_Button
008042  2  F0 04                beq NoJump                ;if not, branch to something else
008044  2  25 0D                and PreviousA_B_Buttons   ;if button not pressed in previous frame, branch
008046  2  F0 03                beq ProcJumping
008048  2  4C DC 80     NoJump: jmp X_Physics             ;otherwise, jump to something else
00804B  2               
00804B  2               ProcJumping:
00804B  2  A5 1D                   lda Player_State           ;check player state
00804D  2  F0 11                   beq InitJS                 ;if on the ground, branch
00804F  2  AD 04 07                lda SwimmingFlag           ;if swimming flag not set, jump to do something else
008052  2  F0 F4                   beq NoJump                 ;to prevent midair jumping, otherwise continue
008054  2  AD 82 07                lda JumpSwimTimer          ;if jump/swim timer nonzero, branch
008057  2  D0 07                   bne InitJS
008059  2  A5 9F                   lda Player_Y_Speed         ;check player's vertical speed
00805B  2  10 03                   bpl InitJS                 ;if player's vertical speed motionless or down, branch
00805D  2  4C DC 80                jmp X_Physics              ;if timer at zero and player still rising, do not swim
008060  2  A9 20        InitJS:    lda #$20                   ;set jump/swim timer
008062  2  8D 82 07                sta JumpSwimTimer
008065  2  A0 00                   ldy #$00                   ;initialize vertical force and dummy variable
008067  2  8C 16 04                sty Player_YMF_Dummy
00806A  2  8C 33 04                sty Player_Y_MoveForce
00806D  2  A5 B5                   lda Player_Y_HighPos       ;get vertical high and low bytes of jump origin
00806F  2  8D 07 07                sta JumpOrigin_Y_HighPos   ;and store them next to each other here
008072  2  A5 CE                   lda Player_Y_Position
008074  2  8D 08 07                sta JumpOrigin_Y_Position
008077  2  A9 01                   lda #$01                   ;set player state to jumping/swimming
008079  2  85 1D                   sta Player_State
00807B  2  AD 00 07                lda Player_XSpeedAbsolute  ;check value related to walking/running speed
00807E  2  C9 09                   cmp #$09
008080  2  90 10                   bcc ChkWtr                 ;branch if below certain values, increment Y
008082  2  C8                      iny                        ;for each amount equal or exceeded
008083  2  C9 10                   cmp #$10
008085  2  90 0B                   bcc ChkWtr
008087  2  C8                      iny
008088  2  C9 19                   cmp #$19
00808A  2  90 06                   bcc ChkWtr
00808C  2  C8                      iny
00808D  2  C9 1C                   cmp #$1c
00808F  2  90 01                   bcc ChkWtr                 ;note that for jumping, range is 0-4 for Y
008091  2  C8                      iny
008092  2  A9 01        ChkWtr:    lda #$01                   ;set value here (apparently always set to 1)
008094  2  8D 06 07                sta DiffToHaltJump
008097  2  AD 04 07                lda SwimmingFlag           ;if swimming flag disabled, branch
00809A  2  F0 08                   beq GetYPhy
00809C  2  A0 05                   ldy #$05                   ;otherwise set Y to 5, range is 5-6
00809E  2  AD 7D 04                lda Whirlpool_Flag         ;if whirlpool flag not set, branch
0080A1  2  F0 01                   beq GetYPhy
0080A3  2  C8                      iny                        ;otherwise increment to 6
0080A4  2  B9 E4 7F     GetYPhy:   lda JumpMForceData,y       ;store appropriate jump/swim
0080A7  2  8D 09 07                sta VerticalForce          ;data here
0080AA  2  B9 EB 7F                lda FallMForceData,y
0080AD  2  8D 0A 07                sta VerticalForceDown
0080B0  2  B9 FC 7F                lda InitMForceData,y
0080B3  2  8D 33 04                sta Player_Y_MoveForce
0080B6  2  B9 F5 7F                lda PlayerYSpdData,y
0080B9  2  85 9F                   sta Player_Y_Speed
0080BB  2  AD 04 07                lda SwimmingFlag           ;if swimming flag disabled, branch
0080BE  2  F0 11                   beq PJumpSnd
0080C0  2  A9 04                   lda #Sfx_EnemyStomp        ;load swim/goomba stomp sound into
0080C2  2  85 FF                   sta Square1SoundQueue      ;square 1's sfx queue
0080C4  2  A5 CE                   lda Player_Y_Position
0080C6  2  C9 14                   cmp #$14                   ;check vertical low byte of player position
0080C8  2  B0 12                   bcs X_Physics              ;if below a certain point, branch
0080CA  2  A9 00                   lda #$00                   ;otherwise reset player's vertical speed
0080CC  2  85 9F                   sta Player_Y_Speed         ;and jump to something else to keep player
0080CE  2  4C DC 80                jmp X_Physics              ;from swimming above water level
0080D1  2  A9 01        PJumpSnd:  lda #Sfx_BigJump           ;load big mario's jump sound by default
0080D3  2  AC 54 07                ldy PlayerSize             ;is mario big?
0080D6  2  F0 02                   beq SJumpSnd
0080D8  2  A9 80                   lda #Sfx_SmallJump         ;if not, load small mario's jump sound
0080DA  2  85 FF        SJumpSnd:  sta Square1SoundQueue      ;store appropriate jump sound in square 1 sfx queue
0080DC  2  A0 00        X_Physics: ldy #$00
0080DE  2  84 00                   sty $00                    ;init value here
0080E0  2  A5 1D                   lda Player_State           ;if mario is on the ground, branch
0080E2  2  F0 09                   beq ProcPRun
0080E4  2  AD 00 07                lda Player_XSpeedAbsolute  ;check something that seems to be related
0080E7  2  C9 19                   cmp #$19                   ;to mario's speed
0080E9  2  B0 33                   bcs GetXPhy                ;if =>$19 branch here
0080EB  2  90 18                   bcc ChkRFast               ;if not branch elsewhere
0080ED  2  C8           ProcPRun:  iny                        ;if mario on the ground, increment Y
0080EE  2  AD 4E 07                lda AreaType               ;check area type
0080F1  2  F0 12                   beq ChkRFast               ;if water type, branch
0080F3  2  88                      dey                        ;decrement Y by default for non-water type area
0080F4  2  A5 0C                   lda Left_Right_Buttons     ;get left/right controller bits
0080F6  2  C5 45                   cmp Player_MovingDir       ;check against moving direction
0080F8  2  D0 0B                   bne ChkRFast               ;if controller bits <> moving direction, skip this part
0080FA  2  A5 0A                   lda A_B_Buttons            ;check for b button pressed
0080FC  2  29 40                   and #B_Button
0080FE  2  D0 19                   bne SetRTmr                ;if pressed, skip ahead to set timer
008100  2  AD 83 07                lda RunningTimer           ;check for running timer set
008103  2  D0 19                   bne GetXPhy                ;if set, branch
008105  2  C8           ChkRFast:  iny                        ;if running timer not set or level type is water,
008106  2  E6 00                   inc $00                    ;increment Y again and temp variable in memory
008108  2  AD 03 07                lda RunningSpeed
00810B  2  D0 07                   bne FastXSp                ;if running speed set here, branch
00810D  2  AD 00 07                lda Player_XSpeedAbsolute
008110  2  C9 21                   cmp #$21                   ;otherwise check player's walking/running speed
008112  2  90 0A                   bcc GetXPhy                ;if less than a certain amount, branch ahead
008114  2  E6 00        FastXSp:   inc $00                    ;if running speed set or speed => $21 increment $00
008116  2  4C 1E 81                jmp GetXPhy                ;and jump ahead
008119  2  A9 0A        SetRTmr:   lda #$0a                   ;if b button pressed, set running timer
00811B  2  8D 83 07                sta RunningTimer
00811E  2  B9 03 80     GetXPhy:   lda MaxLeftXSpdData,y      ;get maximum speed to the left
008121  2  8D 50 04                sta MaximumLeftSpeed
008124  2  A5 0E                   lda GameEngineSubroutine   ;check for specific routine running
008126  2  C9 07                   cmp #$07                   ;(player entrance)
008128  2  D0 02                   bne GetXPhy2               ;if not running, skip and use old value of Y
00812A  2  A0 03                   ldy #$03                   ;otherwise set Y to 3
00812C  2  B9 06 80     GetXPhy2:  lda MaxRightXSpdData,y     ;get maximum speed to the right
00812F  2  8D 56 04                sta MaximumRightSpeed
008132  2  A4 00                   ldy $00                    ;get other value in memory
008134  2  B9 F2 7F                lda FrictionData,y         ;get value using value in memory as offset
008137  2  8D 02 07                sta FrictionAdderLow
00813A  2  A9 00                   lda #$00
00813C  2  8D 01 07                sta FrictionAdderHigh      ;init something here
00813F  2  A5 33                   lda PlayerFacingDir
008141  2  C5 45                   cmp Player_MovingDir       ;check facing direction against moving direction
008143  2  F0 06                   beq ExitPhy                ;if the same, branch to leave
008145  2  0E 02 07     PhyOpcode: asl FrictionAdderLow       ;otherwise multiply friction by 2
008148  2  2E 01 07                rol FrictionAdderHigh      ;then leave (or just leave, if code was modified earlier
00814B  2  60           ExitPhy:   rts
00814C  2               
00814C  2               ;-------------------------------------------------------------------------------------
00814C  2               
00814C  2               PlayerAnimTmrData:
00814C  2  02 04 07           .byte $02, $04, $07
00814F  2               
00814F  2               GetPlayerAnimSpeed:
00814F  2  A0 00                    ldy #$00                   ;initialize offset in Y
008151  2  AD 00 07                 lda Player_XSpeedAbsolute  ;check player's walking/running speed
008154  2  C9 1C                    cmp #$1c                   ;against preset amount
008156  2  B0 15                    bcs SetRunSpd              ;if greater than a certain amount, branch ahead
008158  2  C8                       iny                        ;otherwise increment Y
008159  2  C9 0E                    cmp #$0e                   ;compare against lower amount
00815B  2  B0 01                    bcs ChkSkid                ;if greater than this but not greater than first, skip increment
00815D  2  C8                       iny                        ;otherwise increment Y again
00815E  2  AD FC 06     ChkSkid:    lda SavedJoypadBits        ;get controller bits
008161  2  29 7F                    and #%01111111             ;mask out A button
008163  2  F0 20                    beq SetAnimSpd             ;if no other buttons pressed, branch ahead of all this
008165  2  29 03                    and #$03                   ;mask out all others except left and right
008167  2  C5 45                    cmp Player_MovingDir       ;check against moving direction
008169  2  D0 08                    bne ProcSkid               ;if left/right controller bits <> moving direction, branch
00816B  2  A9 00                    lda #$00                   ;otherwise set zero value here
00816D  2  8D 03 07     SetRunSpd:  sta RunningSpeed           ;store zero or running speed here
008170  2  4C 85 81                 jmp SetAnimSpd
008173  2  AD 00 07     ProcSkid:   lda Player_XSpeedAbsolute  ;check player's walking/running speed
008176  2  C9 0B                    cmp #$0b                   ;against one last amount
008178  2  B0 0B                    bcs SetAnimSpd             ;if greater than this amount, branch
00817A  2  A5 33                    lda PlayerFacingDir
00817C  2  85 45                    sta Player_MovingDir       ;otherwise use facing direction to set moving direction
00817E  2  A9 00                    lda #$00
008180  2  85 57                    sta Player_X_Speed         ;nullify player's horizontal speed
008182  2  8D 05 07                 sta Player_X_MoveForce     ;and dummy variable for player
008185  2  B9 4C 81     SetAnimSpd: lda PlayerAnimTmrData,y    ;get animation timer setting using Y as offset
008188  2  8D 0C 07                 sta PlayerAnimTimerSet
00818B  2  60                       rts
00818C  2               
00818C  2               ;-------------------------------------------------------------------------------------
00818C  2               
00818C  2               ImposeFriction:
00818C  2  2D 90 04                and Player_CollisionBits  ;perform AND between left/right controller bits and collision flag
00818F  2  C9 00                   cmp #$00                  ;then compare to zero (this instruction is redundant)
008191  2  D0 08                   bne JoypFrict             ;if any bits set, branch to next part
008193  2  A5 57                   lda Player_X_Speed
008195  2  F0 49                   beq SetAbsSpd             ;if player has no horizontal speed, branch ahead to last part
008197  2  10 23                   bpl RghtFrict             ;if player moving to the right, branch to slow
008199  2  30 03                   bmi LeftFrict             ;otherwise logic dictates player moving left, branch to slow
00819B  2  4A           JoypFrict: lsr                       ;put right controller bit into carry
00819C  2  90 1E                   bcc RghtFrict             ;if left button pressed, carry = 0, thus branch
00819E  2  AD 05 07     LeftFrict: lda Player_X_MoveForce    ;load value set here
0081A1  2  18                      clc
0081A2  2  6D 02 07                adc FrictionAdderLow      ;add to it another value set here
0081A5  2  8D 05 07                sta Player_X_MoveForce    ;store here
0081A8  2  A5 57                   lda Player_X_Speed
0081AA  2  6D 01 07                adc FrictionAdderHigh     ;add value plus carry to horizontal speed
0081AD  2  85 57                   sta Player_X_Speed        ;set as new horizontal speed
0081AF  2  CD 56 04                cmp MaximumRightSpeed     ;compare against maximum value for right movement
0081B2  2  30 23                   bmi XSpdSign              ;if horizontal speed greater negatively, branch
0081B4  2  AD 56 04                lda MaximumRightSpeed     ;otherwise set preset value as horizontal speed
0081B7  2  85 57                   sta Player_X_Speed        ;thus slowing the player's left movement down
0081B9  2  4C E0 81                jmp SetAbsSpd             ;skip to the end
0081BC  2  AD 05 07     RghtFrict: lda Player_X_MoveForce    ;load value set here
0081BF  2  38                      sec
0081C0  2  ED 02 07                sbc FrictionAdderLow      ;subtract from it another value set here
0081C3  2  8D 05 07                sta Player_X_MoveForce    ;store here
0081C6  2  A5 57                   lda Player_X_Speed
0081C8  2  ED 01 07                sbc FrictionAdderHigh     ;subtract value plus borrow from horizontal speed
0081CB  2  85 57                   sta Player_X_Speed        ;set as new horizontal speed
0081CD  2  CD 50 04                cmp MaximumLeftSpeed      ;compare against maximum value for left movement
0081D0  2  10 05                   bpl XSpdSign              ;if horizontal speed greater positively, branch
0081D2  2  AD 50 04                lda MaximumLeftSpeed      ;otherwise set preset value as horizontal speed
0081D5  2  85 57                   sta Player_X_Speed        ;thus slowing the player's right movement down
0081D7  2  C9 00        XSpdSign:  cmp #$00                  ;if player not moving or moving to the right,
0081D9  2  10 05                   bpl SetAbsSpd             ;branch and leave horizontal speed value unmodified
0081DB  2  49 FF                   eor #$ff
0081DD  2  18                      clc                       ;otherwise get two's compliment to get absolute
0081DE  2  69 01                   adc #$01                  ;unsigned walking/running speed
0081E0  2  8D 00 07     SetAbsSpd: sta Player_XSpeedAbsolute ;store walking/running speed here and leave
0081E3  2  60                      rts
0081E4  2               
0081E4  2               ;-------------------------------------------------------------------------------------
0081E4  2               ;$00 - used to store downward movement force in FireballObjCore
0081E4  2               ;$02 - used to store maximum vertical speed in FireballObjCore
0081E4  2               ;$07 - used to store pseudorandom bit in BubbleCheck
0081E4  2               
0081E4  2               ProcFireball_Bubble:
0081E4  2  AD 56 07           lda PlayerStatus           ;check player's status
0081E7  2  C9 02              cmp #$02
0081E9  2  90 43              bcc ProcAirBubbles         ;if not fiery, branch
0081EB  2  A5 0A              lda A_B_Buttons
0081ED  2  29 40              and #B_Button              ;check for b button pressed
0081EF  2  F0 33              beq ProcFireballs          ;branch if not pressed
0081F1  2  25 0D              and PreviousA_B_Buttons
0081F3  2  D0 2F              bne ProcFireballs          ;if button pressed in previous frame, branch
0081F5  2  AD CE 06           lda FireballCounter        ;load fireball counter
0081F8  2  29 01              and #%00000001             ;get LSB and use as offset for buffer
0081FA  2  AA                 tax
0081FB  2  B5 24              lda Fireball_State,x       ;load fireball state
0081FD  2  D0 25              bne ProcFireballs          ;if not inactive, branch
0081FF  2  A4 B5              ldy Player_Y_HighPos       ;if player too high or too low, branch
008201  2  88                 dey
008202  2  D0 20              bne ProcFireballs
008204  2  AD 14 07           lda CrouchingFlag          ;if player crouching, branch
008207  2  D0 1B              bne ProcFireballs
008209  2  A5 1D              lda Player_State           ;if player's state = climbing, branch
00820B  2  C9 03              cmp #$03
00820D  2  F0 15              beq ProcFireballs
00820F  2  A9 20              lda #Sfx_Fireball          ;play fireball sound effect
008211  2  85 FF              sta Square1SoundQueue
008213  2  A9 02              lda #$02                   ;load state
008215  2  95 24              sta Fireball_State,x
008217  2  AC 0C 07           ldy PlayerAnimTimerSet     ;copy animation frame timer setting
00821A  2  8C 11 07           sty FireballThrowingTimer  ;into fireball throwing timer
00821D  2  88                 dey
00821E  2  8C 81 07           sty PlayerAnimTimer        ;decrement and store in player's animation timer
008221  2  EE CE 06           inc FireballCounter        ;increment fireball counter
008224  2               
008224  2               ProcFireballs:
008224  2  A2 00              ldx #$00
008226  2  20 49 82           jsr FireballObjCore  ;process first fireball object
008229  2  A2 01              ldx #$01
00822B  2  20 49 82           jsr FireballObjCore  ;process second fireball object, then do air bubbles
00822E  2               
00822E  2               ProcAirBubbles:
00822E  2  AD 4E 07               lda AreaType                ;if not water type level, skip the rest of this
008231  2  D0 13                  bne BublExit
008233  2  A2 02                  ldx #$02                    ;otherwise load counter and use as offset
008235  2  86 08        BublLoop: stx ObjectOffset            ;store offset
008237  2  20 B9 82               jsr BubbleCheck             ;check timers and coordinates, create air bubble
00823A  2  20 26 BE               jsr RelativeBubblePosition  ;get relative coordinates
00823D  2  20 86 BE               jsr GetBubbleOffscreenBits  ;get offscreen information
008240  2  20 CC BA               jsr DrawBubble              ;draw the air bubble
008243  2  CA                     dex
008244  2  10 EF                  bpl BublLoop                ;do this until all three are handled
008246  2  60           BublExit: rts                         ;then leave
008247  2               
008247  2               FireballXSpdData:
008247  2  40 C0              .byte $40, $c0
008249  2               
008249  2               FireballObjCore:
008249  2  86 08                 stx ObjectOffset             ;store offset as current object
00824B  2  B5 24                 lda Fireball_State,x         ;check for d7 = 1
00824D  2  0A                    asl
00824E  2  B0 63                 bcs FireballExplosion        ;if so, branch to get relative coordinates and draw explosion
008250  2  B4 24                 ldy Fireball_State,x         ;if fireball inactive, branch to leave
008252  2  F0 5E                 beq NoFBall
008254  2  88                    dey                          ;if fireball state set to 1, skip this part and just run it
008255  2  F0 27                 beq RunFB
008257  2  A5 86                 lda Player_X_Position        ;get player's horizontal position
008259  2  69 04                 adc #$04                     ;add four pixels and store as fireball's horizontal position
00825B  2  95 8D                 sta Fireball_X_Position,x
00825D  2  A5 6D                 lda Player_PageLoc           ;get player's page location
00825F  2  69 00                 adc #$00                     ;add carry and store as fireball's page location
008261  2  95 74                 sta Fireball_PageLoc,x
008263  2  A5 CE                 lda Player_Y_Position        ;get player's vertical position and store
008265  2  95 D5                 sta Fireball_Y_Position,x
008267  2  A9 01                 lda #$01                     ;set high byte of vertical position
008269  2  95 BC                 sta Fireball_Y_HighPos,x
00826B  2  A4 33                 ldy PlayerFacingDir          ;get player's facing direction
00826D  2  88                    dey                          ;decrement to use as offset here
00826E  2  B9 47 82              lda FireballXSpdData,y       ;set horizontal speed of fireball accordingly
008271  2  95 5E                 sta Fireball_X_Speed,x
008273  2  A9 04                 lda #$04                     ;set vertical speed of fireball
008275  2  95 A6                 sta Fireball_Y_Speed,x
008277  2  A9 07                 lda #$07
008279  2  9D A0 04              sta Fireball_BoundBoxCtrl,x  ;set bounding box size control for fireball
00827C  2  D6 24                 dec Fireball_State,x         ;decrement state to 1 to skip this part from now on
00827E  2  8A           RunFB:   txa                          ;add 7 to offset to use
00827F  2  18                    clc                          ;as fireball offset for next routines
008280  2  69 07                 adc #$07
008282  2  AA                    tax
008283  2  A9 50                 lda #$50                     ;set downward movement force here
008285  2  85 00                 sta $00
008287  2  A9 03                 lda #$03                     ;set maximum speed here
008289  2  85 02                 sta $02
00828B  2  A9 00                 lda #$00
00828D  2  20 E6 8B              jsr ImposeGravity            ;do sub here to impose gravity on fireball and move vertically
008290  2  20 1E 8B              jsr MoveObjectHorizontally   ;do another sub to move it horizontally
008293  2  A6 08                 ldx ObjectOffset             ;return fireball offset to X
008295  2  20 30 BE              jsr RelativeFireballPosition ;get relative coordinates
008298  2  20 7C BE              jsr GetFireballOffscreenBits ;get offscreen information
00829B  2  20 DD AE              jsr GetFireballBoundBox      ;get bounding box coordinates
00829E  2  20 78 AE              jsr FireballBGCollision      ;do fireball to background collision detection
0082A1  2  AD D2 03              lda FBall_OffscreenBits      ;get fireball offscreen bits
0082A4  2  29 CC                 and #%11001100               ;mask out certain bits
0082A6  2  D0 06                 bne EraseFB                  ;if any bits still set, branch to kill fireball
0082A8  2  20 15 A3              jsr FireballEnemyCollision   ;do fireball to enemy collision detection and deal with collisions
0082AB  2  4C C9 B9              jmp DrawFireball             ;draw fireball appropriately and leave
0082AE  2  A9 00        EraseFB: lda #$00                     ;erase fireball state
0082B0  2  95 24                 sta Fireball_State,x
0082B2  2  60           NoFBall: rts                          ;leave
0082B3  2               
0082B3  2               FireballExplosion:
0082B3  2  20 30 BE           jsr RelativeFireballPosition
0082B6  2  4C F4 B9           jmp DrawExplosion_Fireball
0082B9  2               
0082B9  2               BubbleCheck:
0082B9  2  BD A8 07           lda PseudoRandomBitReg+1,x  ;get part of LSFR
0082BC  2  29 01              and #$01
0082BE  2  85 07              sta $07                     ;store pseudorandom bit here
0082C0  2  B5 E4              lda Bubble_Y_Position,x     ;get vertical coordinate for air bubble
0082C2  2  C9 F8              cmp #$f8                    ;if offscreen coordinate not set,
0082C4  2  D0 2C              bne MoveBubl                ;branch to move air bubble
0082C6  2  AD 92 07           lda AirBubbleTimer          ;if air bubble timer not expired,
0082C9  2  D0 3F              bne ExitBubl                ;branch to leave, otherwise create new air bubble
0082CB  2               
0082CB  2               SetupBubble:
0082CB  2  A0 00                  ldy #$00                 ;load default value here
0082CD  2  A5 33                  lda PlayerFacingDir      ;get player's facing direction
0082CF  2  4A                     lsr                      ;move d0 to carry
0082D0  2  90 02                  bcc PosBubl              ;branch to use default value if facing left
0082D2  2  A0 08                  ldy #$08                 ;otherwise load alternate value here
0082D4  2  98           PosBubl:  tya                      ;use value loaded as adder
0082D5  2  65 86                  adc Player_X_Position    ;add to player's horizontal position
0082D7  2  95 9C                  sta Bubble_X_Position,x  ;save as horizontal position for airbubble
0082D9  2  A5 6D                  lda Player_PageLoc
0082DB  2  69 00                  adc #$00                 ;add carry to player's page location
0082DD  2  95 83                  sta Bubble_PageLoc,x     ;save as page location for airbubble
0082DF  2  A5 CE                  lda Player_Y_Position
0082E1  2  18                     clc                      ;add eight pixels to player's vertical position
0082E2  2  69 08                  adc #$08
0082E4  2  95 E4                  sta Bubble_Y_Position,x  ;save as vertical position for air bubble
0082E6  2  A9 01                  lda #$01
0082E8  2  95 CB                  sta Bubble_Y_HighPos,x   ;set vertical high byte for air bubble
0082EA  2  A4 07                  ldy $07                  ;get pseudorandom bit, use as offset
0082EC  2  B9 0D 83               lda BubbleTimerData,y    ;get data for air bubble timer
0082EF  2  8D 92 07               sta AirBubbleTimer       ;set air bubble timer
0082F2  2  A4 07        MoveBubl: ldy $07                  ;get pseudorandom bit again, use as offset
0082F4  2  BD 2C 04               lda Bubble_YMF_Dummy,x
0082F7  2  38                     sec                      ;subtract pseudorandom amount from dummy variable
0082F8  2  F9 0B 83               sbc Bubble_MForceData,y
0082FB  2  9D 2C 04               sta Bubble_YMF_Dummy,x   ;save dummy variable
0082FE  2  B5 E4                  lda Bubble_Y_Position,x
008300  2  E9 00                  sbc #$00                 ;subtract borrow from airbubble's vertical coordinate
008302  2  C9 20                  cmp #$20                 ;if below the status bar,
008304  2  B0 02                  bcs Y_Bubl               ;branch to go ahead and use to move air bubble upwards
008306  2  A9 F8                  lda #$f8                 ;otherwise set offscreen coordinate
008308  2  95 E4        Y_Bubl:   sta Bubble_Y_Position,x  ;store as new vertical coordinate for air bubble
00830A  2  60           ExitBubl: rts                      ;leave
00830B  2               
00830B  2               Bubble_MForceData:
00830B  2  FF 50              .byte $ff, $50
00830D  2               
00830D  2               BubbleTimerData:
00830D  2  40 20              .byte $40, $20
00830F  2               
00830F  2               ;-------------------------------------------------------------------------------------
00830F  2               
00830F  2               RunGameTimer:
00830F  2  AD 70 07                lda OperMode               ;get primary mode of operation
008312  2  F0 4F                   beq ExGTimer               ;branch to leave if in attract mode
008314  2  A5 0E                   lda GameEngineSubroutine
008316  2  C9 08                   cmp #$08                   ;if routine number less than eight running,
008318  2  90 49                   bcc ExGTimer               ;branch to leave
00831A  2  C9 0B                   cmp #$0b                   ;if running death routine,
00831C  2  F0 45                   beq ExGTimer               ;branch to leave
00831E  2  A5 B5                   lda Player_Y_HighPos
008320  2  C9 02                   cmp #$02                   ;if player below the screen,
008322  2  10 3F                   bpl ExGTimer               ;branch to leave regardless of level type
008324  2  AD 87 07                lda GameTimerCtrlTimer     ;if game timer control not yet expired,
008327  2  D0 3A                   bne ExGTimer               ;branch to leave
008329  2  AD EC 07                lda GameTimerDisplay
00832C  2  0D ED 07                ora GameTimerDisplay+1     ;otherwise check game timer digits
00832F  2  0D EE 07                ora GameTimerDisplay+2
008332  2  F0 26                   beq TimeUpOn               ;if game timer digits at 000, branch to time-up code
008334  2  AC EC 07                ldy GameTimerDisplay       ;otherwise check first digit
008337  2  88                      dey                        ;if first digit not on 1,
008338  2  D0 0C                   bne ResGTCtrl              ;branch to reset game timer control
00833A  2  AD ED 07                lda GameTimerDisplay+1     ;otherwise check second and third digits
00833D  2  0D EE 07                ora GameTimerDisplay+2
008340  2  D0 04                   bne ResGTCtrl              ;if timer not at 100, branch to reset game timer control
008342  2  A9 40                   lda #TimeRunningOutMusic
008344  2  85 FC                   sta EventMusicQueue        ;otherwise load time running out music
008346  2  A9 18        ResGTCtrl: lda #$18                   ;reset game timer control
008348  2  8D 87 07                sta GameTimerCtrlTimer
00834B  2  A0 17                   ldy #$17                   ;set offset for last digit
00834D  2  A9 FF                   lda #$ff                   ;set value to decrement game timer digit
00834F  2  8D 39 01                sta DigitModifier+5
008352  2  20 64 6E                jsr DigitsMathRoutine      ;do sub to decrement game timer slowly
008355  2  A9 A2                   lda #$a2                   ;set status nybbles to update game timer display
008357  2  4C 0B 6E                jmp PrintStatusBarNumbers  ;do sub to update the display
00835A  2  8D 56 07     TimeUpOn:  sta PlayerStatus           ;init player status (note A will always be zero here)
00835D  2  20 8B A5                jsr ForceInjury            ;do sub to kill the player (note player is small here)
008360  2  EE 59 07                inc GameTimerExpiredFlag   ;set game timer expiration flag
008363  2  60           ExGTimer:  rts                        ;leave
008364  2               
008364  2               ;-------------------------------------------------------------------------------------
008364  2               
008364  2               WarpZoneObject:
008364  2  AD 23 07           lda ScrollLock         ;check for scroll lock flag
008367  2  F0 FA              beq ExGTimer           ;branch if not set to leave
008369  2  A5 CE              lda Player_Y_Position  ;check to see if player's vertical coordinate has
00836B  2  25 B5              and Player_Y_HighPos   ;same bits set as in vertical high byte (why?)
00836D  2  D0 F4              bne ExGTimer           ;if so, branch to leave
00836F  2  8D 23 07           sta ScrollLock         ;otherwise nullify scroll lock flag
008372  2  4C CC 95           jmp EraseEnemyObject   ;kill this object
008375  2               
008375  2               ;-------------------------------------------------------------------------------------
008375  2               ;$00 - used in WhirlpoolActivate to store whirlpool length / 2, page location of center of whirlpool
008375  2               ;and also to store movement force exerted on player
008375  2               ;$01 - used in ProcessWhirlpools to store page location of right extent of whirlpool
008375  2               ;and in WhirlpoolActivate to store center of whirlpool
008375  2               ;$02 - used in ProcessWhirlpools to store right extent of whirlpool and in
008375  2               ;WhirlpoolActivate to store maximum vertical speed
008375  2               
008375  2               ProcessWhirlpools:
008375  2  AD 4E 07             lda AreaType                ;check for water type level
008378  2  D0 37                bne ExitWh                  ;branch to leave if not found
00837A  2  8D 7D 04             sta Whirlpool_Flag          ;otherwise initialize whirlpool flag
00837D  2  AD 47 07             lda TimerControl            ;if master timer control set,
008380  2  D0 2F                bne ExitWh                  ;branch to leave
008382  2  A0 04                ldy #$04                    ;otherwise start with last whirlpool data
008384  2  B9 71 04     WhLoop: lda Whirlpool_LeftExtent,y  ;get left extent of whirlpool
008387  2  18                   clc
008388  2  79 77 04             adc Whirlpool_Length,y      ;add length of whirlpool
00838B  2  85 02                sta $02                     ;store result as right extent here
00838D  2  B9 6B 04             lda Whirlpool_PageLoc,y     ;get page location
008390  2  F0 1C                beq NextWh                  ;if none or page 0, branch to get next data
008392  2  69 00                adc #$00                    ;add carry
008394  2  85 01                sta $01                     ;store result as page location of right extent here
008396  2  A5 86                lda Player_X_Position       ;get player's horizontal position
008398  2  38                   sec
008399  2  F9 71 04             sbc Whirlpool_LeftExtent,y  ;subtract left extent
00839C  2  A5 6D                lda Player_PageLoc          ;get player's page location
00839E  2  F9 6B 04             sbc Whirlpool_PageLoc,y     ;subtract borrow
0083A1  2  30 0B                bmi NextWh                  ;if player too far left, branch to get next data
0083A3  2  A5 02                lda $02                     ;otherwise get right extent
0083A5  2  38                   sec
0083A6  2  E5 86                sbc Player_X_Position       ;subtract player's horizontal coordinate
0083A8  2  A5 01                lda $01                     ;get right extent's page location
0083AA  2  E5 6D                sbc Player_PageLoc          ;subtract borrow
0083AC  2  10 04                bpl WhirlpoolActivate       ;if player within right extent, branch to whirlpool code
0083AE  2  88           NextWh: dey                         ;move onto next whirlpool data
0083AF  2  10 D3                bpl WhLoop                  ;do this until all whirlpools are checked
0083B1  2  60           ExitWh: rts                         ;leave
0083B2  2               
0083B2  2               WhirlpoolActivate:
0083B2  2  B9 77 04             lda Whirlpool_Length,y      ;get length of whirlpool
0083B5  2  4A                   lsr                         ;divide by 2
0083B6  2  85 00                sta $00                     ;save here
0083B8  2  B9 71 04             lda Whirlpool_LeftExtent,y  ;get left extent of whirlpool
0083BB  2  18                   clc
0083BC  2  65 00                adc $00                     ;add length divided by 2
0083BE  2  85 01                sta $01                     ;save as center of whirlpool
0083C0  2  B9 6B 04             lda Whirlpool_PageLoc,y     ;get page location
0083C3  2  69 00                adc #$00                    ;add carry
0083C5  2  85 00                sta $00                     ;save as page location of whirlpool center
0083C7  2  A5 09                lda FrameCounter            ;get frame counter
0083C9  2  4A                   lsr                         ;shift d0 into carry (to run on every other frame)
0083CA  2  90 2C                bcc WhPull                  ;if d0 not set, branch to last part of code
0083CC  2  A5 01                lda $01                     ;get center
0083CE  2  38                   sec
0083CF  2  E5 86                sbc Player_X_Position       ;subtract player's horizontal coordinate
0083D1  2  A5 00                lda $00                     ;get page location of center
0083D3  2  E5 6D                sbc Player_PageLoc          ;subtract borrow
0083D5  2  10 0E                bpl LeftWh                  ;if player to the left of center, branch
0083D7  2  A5 86                lda Player_X_Position       ;otherwise slowly pull player left, towards the center
0083D9  2  38                   sec
0083DA  2  E9 01                sbc #$01                    ;subtract one pixel
0083DC  2  85 86                sta Player_X_Position       ;set player's new horizontal coordinate
0083DE  2  A5 6D                lda Player_PageLoc
0083E0  2  E9 00                sbc #$00                    ;subtract borrow
0083E2  2  4C F6 83             jmp SetPWh                  ;jump to set player's new page location
0083E5  2  AD 90 04     LeftWh: lda Player_CollisionBits    ;get player's collision bits
0083E8  2  4A                   lsr                         ;shift d0 into carry
0083E9  2  90 0D                bcc WhPull                  ;if d0 not set, branch
0083EB  2  A5 86                lda Player_X_Position       ;otherwise slowly pull player right, towards the center
0083ED  2  18                   clc
0083EE  2  69 01                adc #$01                    ;add one pixel
0083F0  2  85 86                sta Player_X_Position       ;set player's new horizontal coordinate
0083F2  2  A5 6D                lda Player_PageLoc
0083F4  2  69 00                adc #$00                    ;add carry
0083F6  2  85 6D        SetPWh: sta Player_PageLoc          ;set player's new page location
0083F8  2  A9 10        WhPull: lda #$10
0083FA  2  85 00                sta $00                     ;set vertical movement force
0083FC  2  A9 01                lda #$01
0083FE  2  8D 7D 04             sta Whirlpool_Flag          ;set whirlpool flag to be used later
008401  2  85 02                sta $02                     ;also set maximum vertical speed
008403  2  4A                   lsr
008404  2  AA                   tax                         ;set X for player offset
008405  2  4C E6 8B             jmp ImposeGravity           ;jump to put whirlpool effect on player vertically, do not return
008408  2               
008408  2               ;-------------------------------------------------------------------------------------
008408  2               
008408  2               FlagpoleScoreMods:
008408  2  05 02 08 04        .byte $05, $02, $08, $04, $01
00840C  2  01           
00840D  2               
00840D  2               FlagpoleScoreDigits:
00840D  2  03 03 04 04        .byte $03, $03, $04, $04, $04
008411  2  04           
008412  2               
008412  2               FlagpoleRoutine:
008412  2  A2 05                   ldx #$05                  ;set enemy object offset
008414  2  86 08                   stx ObjectOffset          ;to special use slot
008416  2  B5 16                   lda Enemy_ID,x
008418  2  C9 30                   cmp #FlagpoleFlagObject   ;if flagpole flag not found,
00841A  2  D0 64                   bne ExitFlagP             ;branch to leave
00841C  2  A5 0E                   lda GameEngineSubroutine
00841E  2  C9 04                   cmp #$04                  ;if flagpole slide routine not running,
008420  2  D0 31                   bne SkipScore             ;branch to near the end of code
008422  2  A5 1D                   lda Player_State
008424  2  C9 03                   cmp #$03                  ;if player state not climbing,
008426  2  D0 2B                   bne SkipScore             ;branch to near the end of code
008428  2  B5 CF                   lda Enemy_Y_Position,x    ;check flagpole flag's vertical coordinate
00842A  2  C9 AA                   cmp #$aa                  ;if flagpole flag down to a certain point,
00842C  2  B0 28                   bcs GiveFPScr             ;branch to end the level
00842E  2  A5 CE                   lda Player_Y_Position     ;check player's vertical coordinate
008430  2  C9 A2                   cmp #$a2                  ;if player down to a certain point,
008432  2  B0 22                   bcs GiveFPScr             ;branch to end the level
008434  2  BD 17 04                lda Enemy_YMF_Dummy,x
008437  2  69 FF                   adc #$ff                  ;add movement amount to dummy variable
008439  2  9D 17 04                sta Enemy_YMF_Dummy,x     ;save dummy variable
00843C  2  B5 CF                   lda Enemy_Y_Position,x    ;get flag's vertical coordinate
00843E  2  69 01                   adc #$01                  ;add 1 plus carry to move flag, and
008440  2  95 CF                   sta Enemy_Y_Position,x    ;store vertical coordinate
008442  2  AD 0E 01                lda FlagpoleFNum_YMFDummy
008445  2  38                      sec                       ;subtract movement amount from dummy variable
008446  2  E9 FF                   sbc #$ff
008448  2  8D 0E 01                sta FlagpoleFNum_YMFDummy ;save dummy variable
00844B  2  AD 0D 01                lda FlagpoleFNum_Y_Pos
00844E  2  E9 01                   sbc #$01                  ;subtract one plus borrow to move floatey number,
008450  2  8D 0D 01                sta FlagpoleFNum_Y_Pos    ;and store vertical coordinate here
008453  2  4C 77 84     SkipScore: jmp FPGfx                 ;jump to skip ahead and draw flag and floatey number
008456  2  AC 0F 01     GiveFPScr: ldy FlagpoleScore         ;get score offset from earlier (when player touched flagpole)
008459  2  C0 05                   cpy #$05
00845B  2  D0 0A                   bne NoEL4F                ;if set to give player an extra life, do so now
00845D  2  EE 5A 07                inc NumberofLives
008460  2  A9 40                   lda #$40
008462  2  85 FE                   sta $fe
008464  2  4C 73 84                jmp NoSc4F
008467  2  B9 08 84     NoEL4F:    lda FlagpoleScoreMods,y   ;get amount to award player points
00846A  2  BE 0D 84                ldx FlagpoleScoreDigits,y ;get digit with which to award points
00846D  2  9D 34 01                sta DigitModifier,x       ;store in digit modifier
008470  2  20 33 88                jsr AddToScore            ;do sub to award player points depending on height of collision
008473  2  A9 05        NoSc4F:    lda #$05
008475  2  85 0E                   sta GameEngineSubroutine  ;set to run end-of-level subroutine on next frame
008477  2  20 A4 BE     FPGfx:     jsr GetEnemyOffscreenBits ;get offscreen information
00847A  2  20 47 BE                jsr RelativeEnemyPosition ;get relative coordinates
00847D  2  20 FC B1                jsr FlagpoleGfxHandler    ;draw flagpole flag and floatey number
008480  2  60           ExitFlagP: rts
008481  2               
008481  2               ;-------------------------------------------------------------------------------------
008481  2               
008481  2               Jumpspring_Y_PosData:
008481  2  08 10 08 00        .byte $08, $10, $08, $00
008485  2               
008485  2               JumpspringHandler:
008485  2  20 A4 BE                jsr GetEnemyOffscreenBits   ;get offscreen information
008488  2  AD 47 07                lda TimerControl            ;check master timer control
00848B  2  D0 4C                   bne DrawJSpr                ;branch to last section if set
00848D  2  AD 0E 07                lda JumpspringAnimCtrl      ;check jumpspring frame control
008490  2  F0 47                   beq DrawJSpr                ;branch to last section if not set
008492  2  A8                      tay
008493  2  88                      dey                         ;subtract one from frame control in A,
008494  2  98                      tya                         ;the only way a poor NMOS 6502 can
008495  2  29 02                   and #%00000010              ;mask out all but d1, original value still in Y
008497  2  D0 07                   bne DownJSpr                ;if set, branch to move player up
008499  2  E6 CE                   inc Player_Y_Position
00849B  2  E6 CE                   inc Player_Y_Position       ;move player's vertical position down two pixels
00849D  2  4C A4 84                jmp PosJSpr                 ;skip to next part
0084A0  2  C6 CE        DownJSpr:  dec Player_Y_Position       ;move player's vertical position up two pixels
0084A2  2  C6 CE                   dec Player_Y_Position
0084A4  2  B5 58        PosJSpr:   lda Jumpspring_FixedYPos,x  ;get permanent vertical position
0084A6  2  18                      clc
0084A7  2  79 81 84                adc Jumpspring_Y_PosData,y  ;add value using frame control as offset
0084AA  2  95 CF                   sta Enemy_Y_Position,x      ;store as new vertical position
0084AC  2  C0 01                   cpy #$01                    ;check frame control offset (second frame is $00)
0084AE  2  90 1B                   bcc BounceJS                ;if offset not yet at third frame ($01), skip to next part
0084B0  2  A5 0A                   lda A_B_Buttons
0084B2  2  29 80                   and #A_Button               ;check saved controller bits for A button press
0084B4  2  F0 15                   beq BounceJS                ;skip to next part if A not pressed
0084B6  2  25 0D                   and PreviousA_B_Buttons     ;check for A button pressed in previous frame
0084B8  2  D0 11                   bne BounceJS                ;skip to next part if so
0084BA  2  98                      tya
0084BB  2  48                      pha
0084BC  2  A9 F4                   lda #$f4                    ;set jumpspring force for red jumpsprings
0084BE  2               .ifdef ANN
0084BE  2  AC FB 07                ldy HardWorldFlag
0084C1  2  F0 03                   beq SetJSF
0084C3  2  20 rr rr                jsr HardWorldJumpSpringHandler
0084C6  2               .else
0084C6  2                          ldy WorldNumber
0084C6  2                          cpy #World2
0084C6  2                          beq GreenJS                 ;if world number is 2, 3 or 7
0084C6  2                          cpy #World3                 ;set jumpspring force for green jumpsprings
0084C6  2                          beq GreenJS
0084C6  2                          cpy #World7                 ;otherwise use red jumpspring force
0084C6  2                          bne SetJSF
0084C6  2               GreenJS:   lda #$e0
0084C6  2               .endif
0084C6  2  8D DB 06     SetJSF:    sta JumpspringForce         ;otherwise write new jumpspring force here
0084C9  2  68                      pla
0084CA  2  A8                      tay
0084CB  2  C0 03        BounceJS:  cpy #$03                    ;check frame control offset again
0084CD  2  D0 0A                   bne DrawJSpr                ;skip to last part if not yet at fifth frame ($03)
0084CF  2  AD DB 06                lda JumpspringForce
0084D2  2  85 9F                   sta Player_Y_Speed          ;store jumpspring force as player's new vertical speed
0084D4  2  A9 00                   lda #$00
0084D6  2  8D 0E 07                sta JumpspringAnimCtrl      ;initialize jumpspring frame control
0084D9  2  20 47 BE     DrawJSpr:  jsr RelativeEnemyPosition   ;get jumpspring's relative coordinates
0084DC  2  20 37 B5                jsr EnemyGfxHandler         ;draw jumpspring
0084DF  2  20 B1 A2                jsr OffscreenBoundsCheck    ;check to see if we need to kill it
0084E2  2  AD 0E 07                lda JumpspringAnimCtrl      ;if frame control at zero, don't bother
0084E5  2  F0 0D                   beq ExJSpring               ;trying to animate it, just leave
0084E7  2  AD 86 07                lda JumpspringTimer
0084EA  2  D0 08                   bne ExJSpring               ;if jumpspring timer not expired yet, leave
0084EC  2  A9 04                   lda #$04
0084EE  2  8D 86 07                sta JumpspringTimer         ;otherwise initialize jumpspring timer
0084F1  2  EE 0E 07                inc JumpspringAnimCtrl      ;increment frame control to animate jumpspring
0084F4  2  60           ExJSpring: rts                         ;leave
0084F5  2               
0084F5  2               ;-------------------------------------------------------------------------------------
0084F5  2               
0084F5  2               Setup_Vine:
0084F5  2  A9 2F                lda #VineObject          ;load identifier for vine object
0084F7  2  95 16                sta Enemy_ID,x           ;store in buffer
0084F9  2  A9 01                lda #$01
0084FB  2  95 0F                sta Enemy_Flag,x         ;set flag for enemy object buffer
0084FD  2  B9 76 00             lda Block_PageLoc,y
008500  2  95 6E                sta Enemy_PageLoc,x      ;copy page location from previous object
008502  2  B9 8F 00             lda Block_X_Position,y
008505  2  95 87                sta Enemy_X_Position,x   ;copy horizontal coordinate from previous object
008507  2  B9 D7 00             lda Block_Y_Position,y
00850A  2  95 CF                sta Enemy_Y_Position,x   ;copy vertical coordinate from previous object
00850C  2  AC 98 03             ldy VineFlagOffset       ;load vine flag/offset to next available vine slot
00850F  2  D0 03                bne NextVO               ;if set at all, don't bother to store vertical
008511  2  8D 9D 03             sta VineStart_Y_Position ;otherwise store vertical coordinate here
008514  2  8A           NextVO: txa                      ;store object offset to next available vine slot
008515  2  99 9A 03             sta VineObjOffset,y      ;using vine flag as offset
008518  2  EE 98 03             inc VineFlagOffset       ;increment vine flag offset
00851B  2  A9 04                lda #Sfx_GrowVine
00851D  2  85 FE                sta Square2SoundQueue    ;load vine grow sound
00851F  2  60                   rts
008520  2               
008520  2               ;-------------------------------------------------------------------------------------
008520  2               ;$06-$07 - used as address to block buffer data
008520  2               ;$02 - used as vertical high nybble of block buffer offset
008520  2               
008520  2               VineHeightData:
008520  2  30 60              .byte $30, $60
008522  2               
008522  2               VineObjectHandler:
008522  2  E0 05                    cpx #$05                  ;check enemy offset for special use slot
008524  2  F0 01                    beq ProcVO                ;if in special use slot, continue
008526  2  60                       rts
008527  2  AC 98 03     ProcVO:     ldy VineFlagOffset
00852A  2  88                       dey                       ;decrement vine flag in Y, use as offset
00852B  2  AD 99 03                 lda VineHeight
00852E  2  D9 20 85                 cmp VineHeightData,y      ;if vine has reached certain height,
008531  2  F0 0F                    beq RunVSubs              ;branch ahead to skip this part
008533  2  A5 09                    lda FrameCounter          ;get frame counter
008535  2  4A                       lsr                       ;shift d1 into carry
008536  2  4A                       lsr
008537  2  90 09                    bcc RunVSubs              ;if d1 not set (2 frames every 4) skip this part
008539  2  A5 D4                    lda Enemy_Y_Position+5
00853B  2  E9 01                    sbc #$01                  ;subtract vertical position of vine
00853D  2  85 D4                    sta Enemy_Y_Position+5    ;one pixel every frame it's time
00853F  2  EE 99 03                 inc VineHeight            ;increment vine height
008542  2  AD 99 03     RunVSubs:   lda VineHeight            ;if vine still very small,
008545  2  C9 08                    cmp #$08                  ;branch to last part
008547  2  90 46                    bcc ChkVOffscr
008549  2  20 47 BE                 jsr RelativeEnemyPosition ;get relative coordinates of vine,
00854C  2  20 A4 BE                 jsr GetEnemyOffscreenBits ;and any offscreen bits
00854F  2  A0 00                    ldy #$00                  ;initialize offset used in draw vine sub
008551  2  20 E4 B0     VDrawLoop:  jsr DrawVine              ;draw vine
008554  2  C8                       iny                       ;increment offset
008555  2  CC 98 03                 cpy VineFlagOffset        ;if offset in Y and offset here
008558  2  D0 F7                    bne VDrawLoop             ;do not yet match, loop back to draw more vine
00855A  2  AD D1 03                 lda Enemy_OffscreenBits
00855D  2  29 0C                    and #%00001100            ;mask offscreen bits
00855F  2  F0 10                    beq WrCMTile              ;if none of the saved offscreen bits set, skip ahead
008561  2  88                       dey                       ;otherwise decrement Y to get proper offset again
008562  2  BE 9A 03     KillVine:   ldx VineObjOffset,y       ;get enemy object offset for this vine object
008565  2  20 CC 95                 jsr EraseEnemyObject      ;kill this vine object
008568  2  88                       dey                       ;decrement Y
008569  2  10 F7                    bpl KillVine              ;if any vine objects left, loop back to kill it
00856B  2  8D 98 03                 sta VineFlagOffset        ;initialize vine flag/offset
00856E  2  8D 99 03                 sta VineHeight            ;initialize vine height
008571  2  AD 99 03     WrCMTile:   lda VineHeight            ;check vine height
008574  2  C9 20                    cmp #$20                  ;if vine small (less than 32 pixels tall)
008576  2  90 17                    bcc ChkVOffscr            ;then branch ahead to last part to skip this
008578  2  A2 06                    ldx #$06                  ;set offset in X to last enemy slot
00857A  2  A9 01                    lda #$01                  ;set A to obtain horizontal in $04, but we don't care
00857C  2  A0 1B                    ldy #$1b                  ;set Y to offset to get block at ($04, $10) of coordinates
00857E  2  20 A0 B0                 jsr BlockBufferCollision  ;do a sub to get block buffer address set, return contents
008581  2  A4 02                    ldy $02
008583  2  C0 D0                    cpy #$d0                  ;if vertical high nybble offset beyond extent of
008585  2  B0 08                    bcs ChkVOffscr            ;current block buffer, branch to leave, do not write
008587  2  B1 06                    lda ($06),y               ;otherwise check contents of block buffer at
008589  2  D0 04                    bne ChkVOffscr            ;current offset, if not empty, branch to leave
00858B  2               .ifdef ANN
00858B  2  A9 26                    lda #$26
00858D  2               .else
00858D  2                           lda #$23
00858D  2               .endif
00858D  2  91 06                    sta ($06),y               ;otherwise, write climbing metatile to block buffer
00858F  2  A5 8C        ChkVOffscr: lda Enemy_X_Position+5
008591  2  38                       sec
008592  2  ED 1C 07                 sbc ScreenLeft_X_Pos
008595  2  A8                       tay
008596  2  A5 73                    lda Enemy_PageLoc+5       ;compare horizontal position of vine
008598  2  ED 1A 07                 sbc ScreenLeft_PageLoc    ;to that of the left side of the screen
00859B  2  30 04                    bmi VineOffscr            ;if vine isn't within 8 pixels of the edge
00859D  2  C0 09                    cpy #$09                  ;or past the left edge, branch to leave
00859F  2  B0 2C                    bcs ExitVH
0085A1  2  A9 00        VineOffscr: lda #$00                  ;erase vine's flag to kill it
0085A3  2  85 14                    sta Enemy_Flag+5
0085A5  2  A5 73                    lda Enemy_PageLoc+5
0085A7  2  29 01                    and #$01                  ;fetch the right block buffer address
0085A9  2  A8                       tay
0085AA  2  B9 8E 7A                 lda BlockBufferAddr,y
0085AD  2  85 06                    sta $06
0085AF  2  B9 90 7A                 lda BlockBufferAddr+2,y
0085B2  2  85 07                    sta $07
0085B4  2  A5 8C                    lda Enemy_X_Position+5    ;divide upper nybble of X position by 16
0085B6  2  4A                       lsr                       ;to get appropriate offset
0085B7  2  4A                       lsr
0085B8  2  4A                       lsr
0085B9  2  4A                       lsr
0085BA  2  A8           EraseClM:   tay
0085BB  2  B1 06                    lda ($06),y               ;check for climbing metatile
0085BD  2               .ifdef ANN
0085BD  2  C9 26                    cmp #$26
0085BF  2               .else
0085BF  2                           cmp #$23                  ;if not found, move down a row
0085BF  2               .endif
0085BF  2  D0 04                    bne NoClimbM
0085C1  2  A9 00                    lda #$00                  ;otherwise erase climbing metatile
0085C3  2  91 06                    sta ($06),y
0085C5  2  98           NoClimbM:   tya
0085C6  2  18                       clc
0085C7  2  69 10                    adc #$10                  ;move 16 bytes (one row) ahead in block buffer
0085C9  2  C9 D0                    cmp #$d0                  ;if not at bottom row, loop
0085CB  2  90 ED                    bcc EraseClM
0085CD  2  A6 08        ExitVH:     ldx ObjectOffset          ;get enemy object offset and leave
0085CF  2  60                       rts
0085D0  2               
0085D0  2               ;-------------------------------------------------------------------------------------
0085D0  2               
0085D0  2               CannonBitmasks:
0085D0  2  0F 07              .byte %00001111, %00000111
0085D2  2               
0085D2  2               ProcessCannons:
0085D2  2  AD 4E 07                lda AreaType                ;get area type
0085D5  2  F0 6F                   beq ExCannon                ;if water type area, branch to leave
0085D7  2  A2 02                   ldx #$02
0085D9  2  86 08        ThreeSChk: stx ObjectOffset            ;start at third enemy slot
0085DB  2  B5 0F                   lda Enemy_Flag,x            ;check enemy buffer flag
0085DD  2  D0 51                   bne Chk_BB                  ;if set, branch to check enemy
0085DF  2  BD A8 07                lda PseudoRandomBitReg+1,x  ;otherwise get part of LSFR
0085E2  2  AC CC 06                ldy SecondaryHardMode       ;get secondary hard mode flag, use as offset
0085E5  2  39 D0 85                and CannonBitmasks,y        ;mask out bits of LSFR as decided by flag
0085E8  2  C9 06                   cmp #$06                    ;check to see if lower nybble is above certain value
0085EA  2  B0 44                   bcs Chk_BB                  ;if so, branch to check enemy
0085EC  2  A8                      tay                         ;transfer masked contents of LSFR to Y as pseudorandom offset
0085ED  2  B9 6B 04                lda Cannon_PageLoc,y        ;get page location
0085F0  2  F0 3E                   beq Chk_BB                  ;if not set or on page 0, branch to check enemy
0085F2  2  B9 7D 04                lda Cannon_Timer,y          ;get cannon timer
0085F5  2  F0 08                   beq FireCannon              ;if expired, branch to fire cannon
0085F7  2  E9 00                   sbc #$00                    ;otherwise subtract borrow (note carry will always be clear here)
0085F9  2  99 7D 04                sta Cannon_Timer,y          ;to count timer down
0085FC  2  4C 30 86                jmp Chk_BB                  ;then jump ahead to check enemy
0085FF  2               
0085FF  2               FireCannon:
0085FF  2  AD 47 07               lda TimerControl           ;if master timer control set,
008602  2  D0 2C                  bne Chk_BB                 ;branch to check enemy
008604  2  A9 0E                  lda #$0e                   ;otherwise we start creating one
008606  2  99 7D 04               sta Cannon_Timer,y         ;first, reset cannon timer
008609  2  B9 6B 04               lda Cannon_PageLoc,y       ;get page location of cannon
00860C  2  95 6E                  sta Enemy_PageLoc,x        ;save as page location of bullet bill
00860E  2  B9 71 04               lda Cannon_X_Position,y    ;get horizontal coordinate of cannon
008611  2  95 87                  sta Enemy_X_Position,x     ;save as horizontal coordinate of bullet bill
008613  2  B9 77 04               lda Cannon_Y_Position,y    ;get vertical coordinate of cannon
008616  2  38                     sec
008617  2  E9 08                  sbc #$08                   ;subtract eight pixels (because enemies are 24 pixels tall)
008619  2  95 CF                  sta Enemy_Y_Position,x     ;save as vertical coordinate of bullet bill
00861B  2  A9 01                  lda #$01
00861D  2  95 B6                  sta Enemy_Y_HighPos,x      ;set vertical high byte of bullet bill
00861F  2  95 0F                  sta Enemy_Flag,x           ;set buffer flag
008621  2  4A                     lsr                        ;shift right once to init A
008622  2  95 1E                  sta Enemy_State,x          ;then initialize enemy's state
008624  2  A9 09                  lda #$09
008626  2  9D 9A 04               sta Enemy_BoundBoxCtrl,x   ;set bounding box size control for bullet bill
008629  2  A9 33                  lda #BulletBill_CannonVar
00862B  2  95 16                  sta Enemy_ID,x             ;load identifier for bullet bill (cannon variant)
00862D  2  4C 43 86               jmp Next3Slt               ;move onto next slot
008630  2  B5 16        Chk_BB:   lda Enemy_ID,x             ;check enemy identifier for bullet bill (cannon variant)
008632  2  C9 33                  cmp #BulletBill_CannonVar
008634  2  D0 0D                  bne Next3Slt               ;if not found, branch to get next slot
008636  2  20 B1 A2               jsr OffscreenBoundsCheck   ;otherwise, check to see if it went offscreen
008639  2  B5 0F                  lda Enemy_Flag,x           ;check enemy buffer flag
00863B  2  F0 06                  beq Next3Slt               ;if not set, branch to get next slot
00863D  2  20 A4 BE               jsr GetEnemyOffscreenBits  ;otherwise, get offscreen information
008640  2  20 49 86               jsr BulletBillHandler      ;then do sub to handle bullet bill
008643  2  CA           Next3Slt: dex                        ;move onto next slot
008644  2  10 93                  bpl ThreeSChk              ;do this until first three slots are checked
008646  2  60           ExCannon: rts                        ;then leave
008647  2               
008647  2               ;--------------------------------
008647  2               
008647  2               BulletBillXSpdData:
008647  2  18 E8              .byte $18, $e8
008649  2               
008649  2               BulletBillHandler:
008649  2  AD 47 07                lda TimerControl          ;if master timer control set,
00864C  2  D0 3E                   bne RunBBSubs             ;branch to run subroutines except movement sub
00864E  2  B5 1E                   lda Enemy_State,x
008650  2  D0 2E                   bne ChkDSte               ;if bullet bill's state set, branch to check defeated state
008652  2  AD D1 03                lda Enemy_OffscreenBits   ;otherwise load offscreen bits
008655  2  29 0C                   and #%00001100            ;mask out bits
008657  2  C9 0C                   cmp #%00001100            ;check to see if all bits are set
008659  2  F0 40                   beq KillBB                ;if so, branch to kill this object
00865B  2  A0 01                   ldy #$01                  ;set to move right by default
00865D  2  20 EF AD                jsr PlayerEnemyDiff       ;get horizontal difference between player and bullet bill
008660  2  30 01                   bmi SetupBB               ;if enemy to the left of player, branch
008662  2  C8                      iny                       ;otherwise increment to move left
008663  2  94 46        SetupBB:   sty Enemy_MovingDir,x     ;set bullet bill's moving direction
008665  2  88                      dey                       ;decrement to use as offset
008666  2  B9 47 86                lda BulletBillXSpdData,y  ;get horizontal speed based on moving direction
008669  2  95 58                   sta Enemy_X_Speed,x       ;and store it
00866B  2  A5 00                   lda $00                   ;get horizontal difference
00866D  2  69 28                   adc #$28                  ;add 40 pixels
00866F  2  C9 50                   cmp #$50                  ;if less than a certain amount, player is too close
008671  2  90 28                   bcc KillBB                ;to cannon either on left or right side, thus branch
008673  2  A9 01                   lda #$01
008675  2  95 1E                   sta Enemy_State,x         ;otherwise set bullet bill's state
008677  2  A9 0A                   lda #$0a
008679  2  9D 8A 07                sta EnemyFrameTimer,x     ;set enemy frame timer
00867C  2  A9 08                   lda #Sfx_Blast
00867E  2  85 FE                   sta Square2SoundQueue     ;play fireworks/gunfire sound
008680  2  B5 1E        ChkDSte:   lda Enemy_State,x         ;check enemy state for d5 set
008682  2  29 20                   and #%00100000
008684  2  F0 03                   beq BBFly                 ;if not set, skip to move horizontally
008686  2  20 72 8B                jsr MoveD_EnemyVertically ;otherwise do sub to move bullet bill vertically
008689  2  20 11 8B     BBFly:     jsr MoveEnemyHorizontally ;do sub to move bullet bill horizontally
00868C  2  20 A4 BE     RunBBSubs: jsr GetEnemyOffscreenBits ;get offscreen information
00868F  2  20 47 BE                jsr RelativeEnemyPosition ;get relative coordinates
008692  2  20 F3 AE                jsr GetEnemyBoundBox      ;get bounding box coordinates
008695  2  20 A7 A4                jsr PlayerEnemyCollision  ;handle player to enemy collisions
008698  2  4C 37 B5                jmp EnemyGfxHandler       ;draw the bullet bill and leave
00869B  2  20 CC 95     KillBB:    jsr EraseEnemyObject      ;kill bullet bill and leave
00869E  2  60                      rts
00869F  2               
00869F  2               ;-------------------------------------------------------------------------------------
00869F  2               
00869F  2               HammerEnemyOfsData:
00869F  2  04 04 04 05        .byte $04, $04, $04, $05, $05, $05
0086A3  2  05 05        
0086A5  2  06 06 06           .byte $06, $06, $06
0086A8  2               
0086A8  2               HammerXSpdData:
0086A8  2  10 F0              .byte $10, $f0
0086AA  2               
0086AA  2               SpawnHammerObj:
0086AA  2  AD A8 07               lda PseudoRandomBitReg+1 ;get a pseudorandom number from 0 to 8
0086AD  2  29 07                  and #%00000111           ;from the second part of LSFR
0086AF  2  D0 05                  bne SetMOfs
0086B1  2  AD A8 07               lda PseudoRandomBitReg+1
0086B4  2  29 08                  and #%00001000
0086B6  2  A8           SetMOfs:  tay                      ;use as misc object offset
0086B7  2  B9 2A 00               lda Misc_State,y         ;check for enemy state, if found, branch to leave
0086BA  2  D0 19                  bne NoHammer
0086BC  2  BE 9F 86               ldx HammerEnemyOfsData,y ;get enemy slot offset number using misc obj offset
0086BF  2  B5 0F                  lda Enemy_Flag,x         ;then check enemy buffer flag at that offset
0086C1  2  D0 12                  bne NoHammer             ;if buffer flag set, branch to leave with carry clear
0086C3  2  A6 08                  ldx ObjectOffset         ;get original enemy object offset
0086C5  2  8A                     txa
0086C6  2  99 AE 06               sta HammerEnemyOffset,y  ;save here
0086C9  2  A9 90                  lda #$90
0086CB  2  99 2A 00               sta Misc_State,y         ;save hammer's state here
0086CE  2  A9 07                  lda #$07
0086D0  2  99 A2 04               sta Misc_BoundBoxCtrl,y  ;set something else entirely, here
0086D3  2  38                     sec                      ;return with carry set
0086D4  2  60                     rts
0086D5  2  A6 08        NoHammer: ldx ObjectOffset         ;get original enemy object offset
0086D7  2  18                     clc                      ;return with carry clear
0086D8  2  60                     rts
0086D9  2               
0086D9  2               ;--------------------------------
0086D9  2               ;$00 - used to set downward force
0086D9  2               ;$01 - used to set upward force (residual)
0086D9  2               ;$02 - used to set maximum speed
0086D9  2               
0086D9  2               ProcHammerObj:
0086D9  2  AD 47 07               lda TimerControl           ;if master timer control set
0086DC  2  D0 63                  bne RunHSubs               ;skip all of this code and go to last subs at the end
0086DE  2  B5 2A                  lda Misc_State,x           ;otherwise get hammer's state
0086E0  2  29 7F                  and #%01111111             ;mask out d7
0086E2  2  BC AE 06               ldy HammerEnemyOffset,x    ;get enemy object offset that spawned this hammer
0086E5  2  C9 02                  cmp #$02                   ;check hammer's state
0086E7  2  F0 20                  beq SetHSpd                ;if currently at 2, branch
0086E9  2  B0 34                  bcs SetHPos                ;if greater than 2, branch elsewhere
0086EB  2  8A                     txa
0086EC  2  18                     clc                        ;add 13 bytes to use
0086ED  2  69 0D                  adc #$0d                   ;proper misc object
0086EF  2  AA                     tax                        ;return offset to X
0086F0  2  A9 10                  lda #$10
0086F2  2  85 00                  sta $00                    ;set downward movement force
0086F4  2  A9 0F                  lda #$0f
0086F6  2  85 01                  sta $01                    ;set upward movement force (not used)
0086F8  2  A9 04                  lda #$04
0086FA  2  85 02                  sta $02                    ;set maximum vertical speed
0086FC  2  A9 00                  lda #$00                   ;set A to impose gravity on hammer
0086FE  2  20 E6 8B               jsr ImposeGravity          ;do sub to impose gravity on hammer and move vertically
008701  2  20 1E 8B               jsr MoveObjectHorizontally ;do sub to move it horizontally
008704  2  A6 08                  ldx ObjectOffset           ;get original misc object offset
008706  2  4C 3E 87               jmp RunAllH                ;branch to essential subroutines
008709  2  A9 FE        SetHSpd:  lda #$fe
00870B  2  95 AC                  sta Misc_Y_Speed,x         ;set hammer's vertical speed
00870D  2  B9 1E 00               lda Enemy_State,y          ;get enemy object state
008710  2  29 F7                  and #%11110111             ;mask out d3
008712  2  99 1E 00               sta Enemy_State,y          ;store new state
008715  2  B6 46                  ldx Enemy_MovingDir,y      ;get enemy's moving direction
008717  2  CA                     dex                        ;decrement to use as offset
008718  2  BD A8 86               lda HammerXSpdData,x       ;get proper speed to use based on moving direction
00871B  2  A6 08                  ldx ObjectOffset           ;reobtain hammer's buffer offset
00871D  2  95 64                  sta Misc_X_Speed,x         ;set hammer's horizontal speed
00871F  2  D6 2A        SetHPos:  dec Misc_State,x           ;decrement hammer's state
008721  2  B9 87 00               lda Enemy_X_Position,y     ;get enemy's horizontal position
008724  2  18                     clc
008725  2  69 02                  adc #$02                   ;set position 2 pixels to the right
008727  2  95 93                  sta Misc_X_Position,x      ;store as hammer's horizontal position
008729  2  B9 6E 00               lda Enemy_PageLoc,y        ;get enemy's page location
00872C  2  69 00                  adc #$00                   ;add carry
00872E  2  95 7A                  sta Misc_PageLoc,x         ;store as hammer's page location
008730  2  B9 CF 00               lda Enemy_Y_Position,y     ;get enemy's vertical position
008733  2  38                     sec
008734  2  E9 0A                  sbc #$0a                   ;move position 10 pixels upward
008736  2  95 DB                  sta Misc_Y_Position,x      ;store as hammer's vertical position
008738  2  A9 01                  lda #$01
00873A  2  95 C2                  sta Misc_Y_HighPos,x       ;set hammer's vertical high byte
00873C  2  D0 03                  bne RunHSubs               ;unconditional branch to skip first routine
00873E  2  20 0C A4     RunAllH:  jsr PlayerHammerCollision  ;handle collisions
008741  2  20 90 BE     RunHSubs: jsr GetMiscOffscreenBits   ;get offscreen information
008744  2  20 3D BE               jsr RelativeMiscPosition   ;get relative coordinates
008747  2  20 E6 AE               jsr GetMiscBoundBox        ;get bounding box coordinates
00874A  2  20 8B B1               jsr DrawHammer             ;draw the hammer
00874D  2  60                     rts                        ;and we are done here
00874E  2               
00874E  2               ;-------------------------------------------------------------------------------------
00874E  2               ;$02 - used to store vertical high nybble offset from block buffer routine
00874E  2               ;$06 - used to store low byte of block buffer address
00874E  2               
00874E  2               CoinBlock:
00874E  2  20 9A 87           jsr FindEmptyMiscSlot   ;set offset for empty or last misc object buffer slot
008751  2  B5 76              lda Block_PageLoc,x     ;get page location of block object
008753  2  99 7A 00           sta Misc_PageLoc,y      ;store as page location of misc object
008756  2  B5 8F              lda Block_X_Position,x  ;get horizontal coordinate of block object
008758  2  09 05              ora #$05                ;add 5 pixels
00875A  2  99 93 00           sta Misc_X_Position,y   ;store as horizontal coordinate of misc object
00875D  2  B5 D7              lda Block_Y_Position,x  ;get vertical coordinate of block object
00875F  2  E9 10              sbc #$10                ;subtract 16 pixels
008761  2  99 DB 00           sta Misc_Y_Position,y   ;store as vertical coordinate of misc object
008764  2  4C 82 87           jmp JCoinC              ;jump to rest of code as applies to this misc object
008767  2               
008767  2               SetupJumpCoin:
008767  2  20 9A 87             jsr FindEmptyMiscSlot  ;set offset for empty or last misc object buffer slot
00876A  2  BD EA 03             lda Block_PageLoc2,x   ;get page location saved earlier
00876D  2  99 7A 00             sta Misc_PageLoc,y     ;and save as page location for misc object
008770  2  A5 06                lda $06                ;get low byte of block buffer offset
008772  2  0A                   asl
008773  2  0A                   asl                    ;multiply by 16 to use lower nybble
008774  2  0A                   asl
008775  2  0A                   asl
008776  2  09 05                ora #$05               ;add five pixels
008778  2  99 93 00             sta Misc_X_Position,y  ;save as horizontal coordinate for misc object
00877B  2  A5 02                lda $02                ;get vertical high nybble offset from earlier
00877D  2  69 20                adc #$20               ;add 32 pixels for the status bar
00877F  2  99 DB 00             sta Misc_Y_Position,y  ;store as vertical coordinate
008782  2  A9 FB        JCoinC: lda #$fb
008784  2  99 AC 00             sta Misc_Y_Speed,y     ;set vertical speed
008787  2  A9 01                lda #$01
008789  2  99 C2 00             sta Misc_Y_HighPos,y   ;set vertical high byte
00878C  2  99 2A 00             sta Misc_State,y       ;set state for misc object
00878F  2  85 FE                sta Square2SoundQueue  ;load coin grab sound
008791  2  86 08                stx ObjectOffset       ;store current control bit as misc object offset
008793  2  20 0E 88             jsr GiveOneCoin        ;update coin tally on the screen and coin amount variable
008796  2  EE 48 07             inc CoinTallyFor1Ups   ;increment coin tally used to activate 1-up block flag
008799  2  60                   rts
00879A  2               
00879A  2               FindEmptyMiscSlot:
00879A  2  A0 08                   ldy #$08                ;start at end of misc objects buffer
00879C  2  B9 2A 00     FMiscLoop: lda Misc_State,y        ;get misc object state
00879F  2  F0 07                   beq UseMiscS            ;branch if none found to use current offset
0087A1  2  88                      dey                     ;decrement offset
0087A2  2  C0 05                   cpy #$05                ;do this for three slots
0087A4  2  D0 F6                   bne FMiscLoop           ;do this until all slots are checked
0087A6  2  A0 08                   ldy #$08                ;if no empty slots found, use last slot
0087A8  2  8C B7 06     UseMiscS:  sty JumpCoinMiscOffset  ;store offset of misc object buffer here (residual)
0087AB  2  60                      rts
0087AC  2               
0087AC  2               ;-------------------------------------------------------------------------------------
0087AC  2               
0087AC  2               MiscObjectsCore:
0087AC  2  A2 08                  ldx #$08          ;set at end of misc object buffer
0087AE  2  86 08        MiscLoop: stx ObjectOffset  ;store misc object offset here
0087B0  2  B5 2A                  lda Misc_State,x  ;check misc object state
0087B2  2  F0 56                  beq MiscLoopBack  ;branch to check next slot
0087B4  2  0A                     asl               ;otherwise shift d7 into carry
0087B5  2  90 06                  bcc ProcJumpCoin  ;if d7 not set, jumping coin, thus skip to rest of code here
0087B7  2  20 D9 86               jsr ProcHammerObj ;otherwise go to process hammer,
0087BA  2  4C 0A 88               jmp MiscLoopBack  ;then check next slot
0087BD  2               
0087BD  2               ;--------------------------------
0087BD  2               ;$00 - used to set downward force
0087BD  2               ;$01 - used to set upward force (residual)
0087BD  2               ;$02 - used to set maximum speed
0087BD  2               
0087BD  2               ProcJumpCoin:
0087BD  2  B4 2A                   ldy Misc_State,x          ;check misc object state
0087BF  2  88                      dey                       ;decrement to see if it's set to 1
0087C0  2  F0 1D                   beq JCoinRun              ;if so, branch to handle jumping coin
0087C2  2  F6 2A                   inc Misc_State,x          ;otherwise increment state to either start off or as timer
0087C4  2  B5 93                   lda Misc_X_Position,x     ;get horizontal coordinate for misc object
0087C6  2  18                      clc                       ;whether its jumping coin (state 0 only) or floatey number
0087C7  2  6D 75 07                adc ScrollAmount          ;add current scroll speed
0087CA  2  95 93                   sta Misc_X_Position,x     ;store as new horizontal coordinate
0087CC  2  B5 7A                   lda Misc_PageLoc,x        ;get page location
0087CE  2  69 00                   adc #$00                  ;add carry
0087D0  2  95 7A                   sta Misc_PageLoc,x        ;store as new page location
0087D2  2  B5 2A                   lda Misc_State,x
0087D4  2  C9 30                   cmp #$30                  ;check state of object for preset value
0087D6  2  D0 26                   bne RunJCSubs             ;if not yet reached, branch to subroutines
0087D8  2  A9 00                   lda #$00
0087DA  2  95 2A                   sta Misc_State,x          ;otherwise nullify object state
0087DC  2  4C 0A 88                jmp MiscLoopBack          ;and move onto next slot
0087DF  2  8A           JCoinRun:  txa
0087E0  2  18                      clc                       ;add 13 bytes to offset for next subroutine
0087E1  2  69 0D                   adc #$0d
0087E3  2  AA                      tax
0087E4  2  A9 50                   lda #$50                  ;set downward movement amount
0087E6  2  85 00                   sta $00
0087E8  2  A9 06                   lda #$06                  ;set maximum vertical speed
0087EA  2  85 02                   sta $02
0087EC  2  4A                      lsr                       ;divide by 2 and set
0087ED  2  85 01                   sta $01                   ;as upward movement amount (apparently residual)
0087EF  2  A9 00                   lda #$00                  ;set A to impose gravity on jumping coin
0087F1  2  20 E6 8B                jsr ImposeGravity         ;do sub to move coin vertically and impose gravity on it
0087F4  2  A6 08                   ldx ObjectOffset          ;get original misc object offset
0087F6  2  B5 AC                   lda Misc_Y_Speed,x        ;check vertical speed
0087F8  2  C9 05                   cmp #$05
0087FA  2  D0 02                   bne RunJCSubs             ;if not moving downward fast enough, keep state as-is
0087FC  2  F6 2A                   inc Misc_State,x          ;otherwise increment state to change to floatey number
0087FE  2  20 3D BE     RunJCSubs: jsr RelativeMiscPosition  ;get relative coordinates
008801  2  20 90 BE                jsr GetMiscOffscreenBits  ;get offscreen information
008804  2  20 E6 AE                jsr GetMiscBoundBox       ;get bounding box coordinates (why?)
008807  2  20 37 B3                jsr JCoinGfxHandler       ;draw the coin or floatey number
00880A  2               
00880A  2               MiscLoopBack:
00880A  2  CA                      dex                       ;decrement misc object offset
00880B  2  10 A1                   bpl MiscLoop              ;loop back until all misc objects handled
00880D  2  60                      rts                       ;then leave
00880E  2               
00880E  2               ;-------------------------------------------------------------------------------------
00880E  2               
00880E  2               GiveOneCoin:
00880E  2  A9 01              lda #$01               ;set digit modifier to add 1 coin
008810  2  8D 39 01           sta DigitModifier+5    ;to the current player's coin tally
008813  2  A0 11              ldy #$11               ;set offset for coin tally
008815  2  20 64 6E           jsr DigitsMathRoutine  ;update the coin tally
008818  2  EE 5E 07           inc CoinTally          ;increment onscreen player's coin amount
00881B  2  AD 5E 07           lda CoinTally
00881E  2  C9 64              cmp #100               ;does player have 100 coins yet?
008820  2  D0 0C              bne CoinPoints         ;if not, skip all of this
008822  2  A9 00              lda #$00
008824  2  8D 5E 07           sta CoinTally          ;otherwise, reinitialize coin amount
008827  2  EE 5A 07           inc NumberofLives      ;give the player an extra life
00882A  2  A9 40              lda #Sfx_ExtraLife
00882C  2  85 FE              sta Square2SoundQueue  ;play 1-up sound
00882E  2               
00882E  2               CoinPoints:
00882E  2  A9 02              lda #$02               ;set digit modifier to award
008830  2  8D 38 01           sta DigitModifier+4    ;200 points to the player
008833  2               
008833  2               AddToScore:
008833  2  A0 0B              ldy #$0b               ;get offset for player's score
008835  2  20 64 6E           jsr DigitsMathRoutine  ;update the score internally with value in digit modifier
008838  2               
008838  2               WriteScoreAndCoinTally:
008838  2  A9 01                lda #$01
00883A  2               WriteDigits:
00883A  2  20 0B 6E             jsr PrintStatusBarNumbers ;print status bar numbers
00883D  2  AC 00 03             ldy VRAM_Buffer1_Offset
008840  2  B9 FB 02             lda VRAM_Buffer1-6,y      ;check highest digit of score
008843  2  D0 05                bne NoZSup                ;if zero, overwrite with space tile for zero suppression
008845  2  A9 24                lda #$24
008847  2  99 FB 02             sta VRAM_Buffer1-6,y
00884A  2  A6 08        NoZSup: ldx ObjectOffset          ;get enemy object buffer offset
00884C  2  60                   rts
00884D  2               
00884D  2               ;-------------------------------------------------------------------------------------
00884D  2               
00884D  2               SetupPowerUp:
00884D  2  A9 2E                   lda #PowerUpObject        ;load power-up identifier into
00884F  2  85 1B                   sta Enemy_ID+5            ;special use slot of enemy object buffer
008851  2  B5 76                   lda Block_PageLoc,x       ;store page location of block object
008853  2  85 73                   sta Enemy_PageLoc+5       ;as page location of power-up object
008855  2  B5 8F                   lda Block_X_Position,x    ;store horizontal coordinate of block object
008857  2  85 8C                   sta Enemy_X_Position+5    ;as horizontal coordinate of power-up object
008859  2  A9 01                   lda #$01
00885B  2  85 BB                   sta Enemy_Y_HighPos+5     ;set vertical high byte of power-up object
00885D  2  B5 D7                   lda Block_Y_Position,x    ;get vertical coordinate of block object
00885F  2  38                      sec
008860  2  E9 08                   sbc #$08                  ;subtract 8 pixels
008862  2  85 D4                   sta Enemy_Y_Position+5    ;and use as vertical coordinate of power-up object
008864  2  A9 01        PwrUpJmp:  lda #$01                  ;this is a residual jump point in enemy object jump table
008866  2  85 23                   sta Enemy_State+5         ;set power-up object's state
008868  2  85 14                   sta Enemy_Flag+5          ;set buffer flag
00886A  2  A9 03                   lda #$03
00886C  2  8D 9F 04                sta Enemy_BoundBoxCtrl+5  ;set bounding box size control for power-up object
00886F  2  A5 39                   lda PowerUpType
008871  2  C9 02                   cmp #$02                  ;check currently loaded power-up type
008873  2  B0 0A                   bcs PutBehind             ;if star or 1-up, branch ahead
008875  2  AD 56 07                lda PlayerStatus          ;otherwise check player's current status
008878  2  C9 02                   cmp #$02
00887A  2  90 01                   bcc StrType               ;if player not fiery, use status as power-up type
00887C  2  4A                      lsr                       ;otherwise shift right to force fire flower type
00887D  2  85 39        StrType:   sta PowerUpType           ;store type here
00887F  2  A9 20        PutBehind: lda #%00100000
008881  2  8D CA 03                sta Enemy_SprAttrib+5     ;set background priority bit
008884  2  A9 02                   lda #Sfx_GrowPowerUp
008886  2  85 FE                   sta Square2SoundQueue     ;load power-up reveal sound and leave
008888  2  60                      rts
008889  2               
008889  2               ;-------------------------------------------------------------------------------------
008889  2               
008889  2               PowerUpObjHandler:
008889  2  A2 05                 ldx #$05                   ;set object offset for last slot in enemy object buffer
00888B  2  86 08                 stx ObjectOffset
00888D  2  A5 23                 lda Enemy_State+5          ;check power-up object's state
00888F  2  F0 65                 beq ExitPUp                ;if not set, branch to leave
008891  2  0A                    asl                        ;shift to check if d7 was set in object state
008892  2  90 2B                 bcc GrowThePowerUp         ;if not set, branch ahead to skip this part
008894  2  AD 47 07              lda TimerControl           ;if master timer control set,
008897  2  D0 4B                 bne RunPUSubs              ;branch ahead to enemy object routines
008899  2  A5 39                 lda PowerUpType            ;check power-up type
00889B  2  F0 19                 beq ShroomM                ;if normal mushroom, branch ahead to move it
00889D  2  C9 03                 cmp #$03
00889F  2  F0 15                 beq ShroomM                ;if 1-up mushroom, branch ahead to move it
0088A1  2  C9 04                 cmp #$04
0088A3  2  F0 11                 beq ShroomM
0088A5  2  C9 05                 cmp #$05
0088A7  2  F0 0D                 beq ShroomM
0088A9  2  C9 02                 cmp #$02
0088AB  2  D0 37                 bne RunPUSubs              ;if not star, branch elsewhere to skip movement
0088AD  2  20 32 97              jsr MoveJumpingEnemy       ;otherwise impose gravity on star power-up and make it jump
0088B0  2  20 0F AE              jsr EnemyJump              ;note that green paratroopa shares the same code here
0088B3  2  4C E4 88              jmp RunPUSubs              ;then jump to other power-up subroutines
0088B6  2  20 AB 96     ShroomM: jsr MoveNormalEnemy        ;do sub to make mushrooms move
0088B9  2  20 60 AC              jsr EnemyToBGCollisionDet  ;deal with collisions
0088BC  2  4C E4 88              jmp RunPUSubs              ;run the other subroutines
0088BF  2               
0088BF  2               GrowThePowerUp:
0088BF  2  A5 09                   lda FrameCounter           ;get frame counter
0088C1  2  29 03                   and #$03                   ;mask out all but 2 LSB
0088C3  2  D0 19                   bne ChkPUSte               ;if any bits set here, branch
0088C5  2  C6 D4                   dec Enemy_Y_Position+5     ;otherwise decrement vertical coordinate slowly
0088C7  2  A5 23                   lda Enemy_State+5          ;load power-up object state
0088C9  2  E6 23                   inc Enemy_State+5          ;increment state for next frame (to make power-up rise)
0088CB  2  C9 11                   cmp #$11                   ;if power-up object state not yet past 16th pixel,
0088CD  2  90 0F                   bcc ChkPUSte               ;branch ahead to last part here
0088CF  2  A9 10                   lda #$10
0088D1  2  95 58                   sta Enemy_X_Speed,x        ;otherwise set horizontal speed
0088D3  2  A9 80                   lda #%10000000
0088D5  2  85 23                   sta Enemy_State+5          ;and then set d7 in power-up object's state
0088D7  2  0A                      asl                        ;shift once to init A
0088D8  2  8D CA 03                sta Enemy_SprAttrib+5      ;initialize background priority bit set here
0088DB  2  2A                      rol                        ;rotate A to set right moving direction
0088DC  2  95 46                   sta Enemy_MovingDir,x      ;set moving direction
0088DE  2  A5 23        ChkPUSte:  lda Enemy_State+5          ;check power-up object's state
0088E0  2  C9 06                   cmp #$06                   ;for if power-up has risen enough
0088E2  2  90 12                   bcc ExitPUp                ;if not, don't even bother running these routines
0088E4  2  20 47 BE     RunPUSubs: jsr RelativeEnemyPosition  ;get coordinates relative to screen
0088E7  2  20 A4 BE                jsr GetEnemyOffscreenBits  ;get offscreen bits
0088EA  2  20 F3 AE                jsr GetEnemyBoundBox       ;get bounding box coordinates
0088ED  2  20 88 B3                jsr DrawPowerUp            ;draw the power-up object
0088F0  2  20 A7 A4                jsr PlayerEnemyCollision   ;check for collision with player
0088F3  2  20 B1 A2                jsr OffscreenBoundsCheck   ;check to see if it went offscreen
0088F6  2  60           ExitPUp:   rts                        ;and we're done
0088F7  2               
0088F7  2               ;-------------------------------------------------------------------------------------
0088F7  2               ;These apply to all routines in this section unless otherwise noted:
0088F7  2               ;$00 - used to store metatile from block buffer routine
0088F7  2               ;$02 - used to store vertical high nybble offset from block buffer routine
0088F7  2               ;$05 - used to store metatile stored in A at beginning of PlayerHeadCollision
0088F7  2               ;$06-$07 - used as block buffer address indirect
0088F7  2               
0088F7  2               BlockYPosAdderData:
0088F7  2  04 12              .byte $04, $12
0088F9  2               
0088F9  2               PlayerHeadCollision:
0088F9  2  48                      pha                      ;store metatile number to stack
0088FA  2  A9 11                   lda #$11                 ;load unbreakable block object state by default
0088FC  2  AE EE 03                ldx SprDataOffset_Ctrl   ;load offset control bit here
0088FF  2  AC 54 07                ldy PlayerSize           ;check player's size
008902  2  D0 02                   bne DBlockSte            ;if small, branch
008904  2  A9 12                   lda #$12                 ;otherwise load breakable block object state
008906  2  95 26        DBlockSte: sta Block_State,x        ;store into block object buffer
008908  2  20 E2 69                jsr DestroyBlockMetatile ;store blank metatile in vram buffer to write to name table
00890B  2  AE EE 03                ldx SprDataOffset_Ctrl   ;load offset control bit
00890E  2  A5 02                   lda $02                  ;get vertical high nybble offset used in block buffer routine
008910  2  9D E4 03                sta Block_Orig_YPos,x    ;set as vertical coordinate for block object
008913  2  A8                      tay
008914  2  A5 06                   lda $06                  ;get low byte of block buffer address used in same routine
008916  2  9D E6 03                sta Block_BBuf_Low,x     ;save as offset here to be used later
008919  2  B1 06                   lda ($06),y              ;get contents of block buffer at old address at $06, $07
00891B  2  20 05 8A                jsr BlockBumpedChk       ;do a sub to check which block player bumped head on
00891E  2  85 00                   sta $00                  ;store metatile here
008920  2  AC 54 07                ldy PlayerSize           ;check player's size
008923  2  D0 01                   bne ChkBrick             ;if small, use metatile itself as contents of A
008925  2  98                      tya                      ;otherwise init A (note: big = 0)
008926  2  90 25        ChkBrick:  bcc PutMTileB            ;if no match was found in previous sub, skip ahead
008928  2  A0 11                   ldy #$11                 ;otherwise load unbreakable state into block object buffer
00892A  2  94 26                   sty Block_State,x        ;note this applies to both player sizes
00892C  2               .ifdef ANN
00892C  2  A9 C4                   lda #$c4                 ;load empty block metatile into A for now
00892E  2               .else
00892E  2                          lda #$c5                 ;load empty block metatile into A for now
00892E  2               .endif
00892E  2  A4 00                   ldy $00                  ;get metatile from before
008930  2               .ifdef ANN
008930  2  C0 57                   cpy #$57                 ;is it brick with coins (with line)?
008932  2               .else
008932  2                          cpy #$56                 ;is it brick with coins (with line)?
008932  2               .endif
008932  2  F0 04                   beq StartBTmr            ;if so, branch
008934  2  C0 5C                   cpy #$5c                 ;is it brick with coins (without line)?
008936  2  D0 15                   bne PutMTileB            ;if not, branch ahead to store empty block metatile
008938  2  AD BC 06     StartBTmr: lda BrickCoinTimerFlag   ;check brick coin timer flag
00893B  2  D0 08                   bne ContBTmr             ;if set, timer expired or counting down, thus branch
00893D  2  A9 0B                   lda #$0b
00893F  2  8D 9D 07                sta BrickCoinTimer       ;if not set, set brick coin timer
008942  2  EE BC 06                inc BrickCoinTimerFlag   ;and set flag linked to it
008945  2  AD 9D 07     ContBTmr:  lda BrickCoinTimer       ;check brick coin timer
008948  2  D0 02                   bne PutOldMT             ;if not yet expired, branch to use current metatile
00894A  2               .ifdef ANN
00894A  2  A0 C4                   ldy #$c4                 ;otherwise use empty block metatile
00894C  2               .else
00894C  2                          ldy #$c5                 ;otherwise use empty block metatile
00894C  2               .endif
00894C  2  98           PutOldMT:  tya                      ;put metatile into A
00894D  2  9D E8 03     PutMTileB: sta Block_Metatile,x     ;store whatever metatile be appropriate here
008950  2  20 90 89                jsr InitBlock_XY_Pos     ;get block object horizontal coordinates saved
008953  2  A4 02                   ldy $02                  ;get vertical high nybble offset
008955  2               .ifdef ANN
008955  2  A9 23                   lda #$23
008957  2               .else
008957  2                          lda #$20
008957  2               .endif
008957  2  91 06                   sta ($06),y              ;write blank metatile $20 to block buffer
008959  2  A9 10                   lda #$10
00895B  2  8D 84 07                sta BlockBounceTimer     ;set block bounce timer
00895E  2  68                      pla                      ;pull original metatile from stack
00895F  2  85 05                   sta $05                  ;and save here
008961  2  A0 00                   ldy #$00                 ;set default offset
008963  2  AD 14 07                lda CrouchingFlag        ;is player crouching?
008966  2  D0 05                   bne SmallBP              ;if so, branch to increment offset
008968  2  AD 54 07                lda PlayerSize           ;is player big?
00896B  2  F0 01                   beq BigBP                ;if so, branch to use default offset
00896D  2  C8           SmallBP:   iny                      ;increment for small or big and crouching
00896E  2  A5 CE        BigBP:     lda Player_Y_Position    ;get player's vertical coordinate
008970  2  18                      clc
008971  2  79 F7 88                adc BlockYPosAdderData,y ;add value determined by size
008974  2  29 F0                   and #$f0                 ;mask out low nybble to get 16-pixel correspondence
008976  2  95 D7                   sta Block_Y_Position,x   ;save as vertical coordinate for block object
008978  2  B4 26                   ldy Block_State,x        ;get block object state
00897A  2  C0 11                   cpy #$11
00897C  2  F0 06                   beq Unbreak              ;if set to value loaded for unbreakable, branch
00897E  2  20 11 8A                jsr BrickShatter         ;execute code for breakable brick
008981  2  4C 87 89                jmp InvOBit              ;skip subroutine to do last part of code here
008984  2  20 A7 89     Unbreak:   jsr BumpBlock            ;execute code for unbreakable brick or question block
008987  2  AD EE 03     InvOBit:   lda SprDataOffset_Ctrl   ;invert control bit used by block objects
00898A  2  49 01                   eor #$01                 ;and floatey numbers
00898C  2  8D EE 03                sta SprDataOffset_Ctrl
00898F  2  60                      rts                      ;leave!
008990  2               
008990  2               ;--------------------------------
008990  2               
008990  2               InitBlock_XY_Pos:
008990  2  A5 86              lda Player_X_Position   ;get player's horizontal coordinate
008992  2  18                 clc
008993  2  69 08              adc #$08                ;add eight pixels
008995  2  29 F0              and #$f0                ;mask out low nybble to give 16-pixel correspondence
008997  2  95 8F              sta Block_X_Position,x  ;save as horizontal coordinate for block object
008999  2  A5 6D              lda Player_PageLoc
00899B  2  69 00              adc #$00                ;add carry to page location of player
00899D  2  95 76              sta Block_PageLoc,x     ;save as page location of block object
00899F  2  9D EA 03           sta Block_PageLoc2,x    ;save elsewhere to be used later
0089A2  2  A5 B5              lda Player_Y_HighPos
0089A4  2  95 BE              sta Block_Y_HighPos,x   ;save vertical high byte of player into
0089A6  2  60                 rts                     ;vertical high byte of block object and leave
0089A7  2               
0089A7  2               ;--------------------------------
0089A7  2               
0089A7  2               BumpBlock:
0089A7  2  20 2E 8A                jsr CheckTopOfBlock     ;check to see if there's a coin directly above this block
0089AA  2  A9 02                   lda #Sfx_Bump
0089AC  2  85 FF                   sta Square1SoundQueue   ;play bump sound
0089AE  2  A9 00                   lda #$00
0089B0  2  95 60                   sta Block_X_Speed,x     ;initialize horizontal speed for block object
0089B2  2  9D 3C 04                sta Block_Y_MoveForce,x ;init fractional movement force
0089B5  2  85 9F                   sta Player_Y_Speed      ;init player's vertical speed
0089B7  2  A9 FE                   lda #$fe
0089B9  2  95 A8                   sta Block_Y_Speed,x     ;set vertical speed for block object
0089BB  2  A5 05                   lda $05                 ;get original metatile from stack
0089BD  2  20 05 8A                jsr BlockBumpedChk      ;do a sub to check which block player bumped head on
0089C0  2  90 33                   bcc ExitBlockChk        ;if no match was found, branch to leave
0089C2  2  98                      tya                     ;move block number to A
0089C3  2               .ifdef ANN
0089C3  2  C9 0A                   cmp #$0a                ;if block number was within 0-$c range,
0089C5  2  90 02                   bcc BlockCode           ;branch to use current number
0089C7  2  E9 05                   sbc #$05                ;otherwise subtract 5 for second set to get proper number
0089C9  2               .else
0089C9  2                          cmp #$0d                ;if block number was within 0-$c range,
0089C9  2                          bcc BlockCode           ;branch to use current number
0089C9  2                          sbc #$06                ;otherwise subtract 6 for second set to get proper number
0089C9  2               .endif
0089C9  2  20 0F 6D     BlockCode: jsr JumpEngine          ;run appropriate subroutine depending on block number
0089CC  2               
0089CC  2  E0 89              .word MushFlowerBlock
0089CE  2               .ifndef ANN
0089CE  2                     .word PoisonMushBlock
0089CE  2               .endif
0089CE  2  4E 87              .word CoinBlock
0089D0  2  4E 87              .word CoinBlock
0089D2  2  E6 89              .word ExtraLifeMushBlock
0089D4  2               .ifndef ANN
0089D4  2                     .word PoisonMushBlock
0089D4  2               .endif
0089D4  2  E0 89              .word MushFlowerBlock
0089D6  2  E0 89              .word MushFlowerBlock
0089D8  2               .ifndef ANN
0089D8  2                     .word PoisonMushBlock
0089D8  2               .endif
0089D8  2  ED 89              .word VineBlock
0089DA  2  E3 89              .word StarBlock
0089DC  2  4E 87              .word CoinBlock
0089DE  2  E6 89              .word ExtraLifeMushBlock
0089E0  2               
0089E0  2               MushFlowerBlock:
0089E0  2  A9 00              lda #$00                ;load mushroom/flower type
0089E2  2  2C                 .byte $2c
0089E3  2               
0089E3  2               StarBlock:
0089E3  2  A9 02              lda #$02                ;load star type
0089E5  2  2C                 .byte $2c
0089E6  2               
0089E6  2               .ifndef ANN
0089E6  2               PoisonMushBlock:
0089E6  2                     lda #$04                ;load poison mushroom type
0089E6  2                     .byte $2c
0089E6  2               .endif
0089E6  2               
0089E6  2               ExtraLifeMushBlock:
0089E6  2  A9 03              lda #$03                ;load 1-up mushroom type
0089E8  2  85 39              sta $39                 ;store correct power-up type
0089EA  2  4C 4D 88           jmp SetupPowerUp
0089ED  2               
0089ED  2               VineBlock:
0089ED  2  A2 05              ldx #$05                ;load last slot for enemy object buffer
0089EF  2  AC EE 03           ldy SprDataOffset_Ctrl  ;get control bit
0089F2  2  20 F5 84           jsr Setup_Vine          ;set up vine object
0089F5  2               
0089F5  2               ExitBlockChk:
0089F5  2  60                 rts                     ;leave
0089F6  2               
0089F6  2               ;--------------------------------
0089F6  2               
0089F6  2               BrickQBlockMetatiles:
0089F6  2               .ifdef ANN
0089F6  2  C1 C0 5E 5F        .byte $C1,$C0,$5E,$5F,$60
0089FA  2  60           
0089FB  2  54 55 56 57        .byte $54,$55,$56,$57,$58
0089FF  2  58           
008A00  2  59 5A 5B 5C        .byte $59,$5A,$5B,$5C,$5D
008A04  2  5D           
008A05  2               .else
008A05  2                     .byte $c1, $c2, $c0, $5e, $5f, $60, $61 ;used by question blocks
008A05  2               
008A05  2                     .byte $52, $53, $54, $55, $56, $57 ;used by ground level bricks
008A05  2                     .byte $58, $59, $5a, $5b, $5c, $5d ;used by other level bricks
008A05  2               .endif
008A05  2               
008A05  2               BlockBumpedChk:
008A05  2               .ifdef ANN
008A05  2  A0 0E                     ldy #$0e                    ;start at end of metatile data
008A07  2               .else
008A07  2                            ldy #$12                    ;start at end of metatile data
008A07  2               .endif
008A07  2  D9 F6 89     BumpChkLoop: cmp BrickQBlockMetatiles,y  ;check to see if current metatile matches
008A0A  2  F0 04                     beq MatchBump               ;metatile found in block buffer, branch if so
008A0C  2  88                        dey                         ;otherwise move onto next metatile
008A0D  2  10 F8                     bpl BumpChkLoop             ;do this until all metatiles are checked
008A0F  2  18                        clc                         ;if none match, return with carry clear
008A10  2  60           MatchBump:   rts                         ;note carry is set if found match
008A11  2               
008A11  2               ;--------------------------------
008A11  2               
008A11  2               BrickShatter:
008A11  2  20 2E 8A           jsr CheckTopOfBlock    ;check to see if there's a coin directly above this block
008A14  2  A9 01              lda #Sfx_BrickShatter
008A16  2  9D EC 03           sta Block_RepFlag,x    ;set flag for block object to immediately replace metatile
008A19  2  85 FD              sta NoiseSoundQueue    ;load brick shatter sound
008A1B  2  20 50 8A           jsr SpawnBrickChunks   ;create brick chunk objects
008A1E  2  A9 FE              lda #$fe
008A20  2  85 9F              sta Player_Y_Speed     ;set vertical speed for player
008A22  2  A9 05              lda #$05
008A24  2  8D 39 01           sta DigitModifier+5    ;set digit modifier to give player 50 points
008A27  2  20 33 88           jsr AddToScore         ;do sub to update the score
008A2A  2  AE EE 03           ldx SprDataOffset_Ctrl ;load control bit and leave
008A2D  2  60                 rts
008A2E  2               
008A2E  2               ;--------------------------------
008A2E  2               
008A2E  2               CheckTopOfBlock:
008A2E  2  AE EE 03            ldx SprDataOffset_Ctrl  ;load control bit
008A31  2  A4 02               ldy $02                 ;get vertical high nybble offset used in block buffer
008A33  2  F0 1A               beq TopEx               ;branch to leave if set to zero, because we're at the top
008A35  2  98                  tya                     ;otherwise set to A
008A36  2  38                  sec
008A37  2  E9 10               sbc #$10                ;subtract $10 to move up one row in the block buffer
008A39  2  85 02               sta $02                 ;store as new vertical high nybble offset
008A3B  2  A8                  tay
008A3C  2  B1 06               lda ($06),y             ;get contents of block buffer in same column, one row up
008A3E  2               .ifdef ANN
008A3E  2  C9 C2               cmp #$c2                ;is it a coin? (not underwater)
008A40  2               .else
008A40  2                      cmp #$c3                ;is it a coin? (not underwater)
008A40  2               .endif
008A40  2  D0 0D               bne TopEx               ;if not, branch to leave
008A42  2  A9 00               lda #$00
008A44  2  91 06               sta ($06),y             ;otherwise put blank metatile where coin was
008A46  2  20 C4 69            jsr RemoveCoin_Axe      ;write blank metatile to vram buffer
008A49  2  AE EE 03            ldx SprDataOffset_Ctrl  ;get control bit
008A4C  2  20 67 87            jsr SetupJumpCoin       ;create jumping coin object and update coin variables
008A4F  2  60           TopEx: rts                     ;leave!
008A50  2               
008A50  2               ;--------------------------------
008A50  2               
008A50  2               SpawnBrickChunks:
008A50  2  B5 8F              lda Block_X_Position,x     ;set horizontal coordinate of block object
008A52  2  9D F1 03           sta Block_Orig_XPos,x      ;as original horizontal coordinate here
008A55  2  A9 F0              lda #$f0
008A57  2  95 60              sta Block_X_Speed,x        ;set horizontal speed for brick chunk objects
008A59  2  95 62              sta Block_X_Speed+2,x
008A5B  2  A9 FA              lda #$fa
008A5D  2  95 A8              sta Block_Y_Speed,x        ;set vertical speed for one
008A5F  2  A9 FC              lda #$fc
008A61  2  95 AA              sta Block_Y_Speed+2,x      ;set lower vertical speed for the other
008A63  2  A9 00              lda #$00
008A65  2  9D 3C 04           sta Block_Y_MoveForce,x    ;init fractional movement force for both
008A68  2  9D 3E 04           sta Block_Y_MoveForce+2,x
008A6B  2  B5 76              lda Block_PageLoc,x
008A6D  2  95 78              sta Block_PageLoc+2,x      ;copy page location
008A6F  2  B5 8F              lda Block_X_Position,x
008A71  2  95 91              sta Block_X_Position+2,x   ;copy horizontal coordinate
008A73  2  B5 D7              lda Block_Y_Position,x
008A75  2  18                 clc                        ;add 8 pixels to vertical coordinate
008A76  2  69 08              adc #$08                   ;and save as vertical coordinate for one of them
008A78  2  95 D9              sta Block_Y_Position+2,x
008A7A  2  A9 FA              lda #$fa
008A7C  2  95 A8              sta Block_Y_Speed,x        ;set vertical speed...again??? (redundant)
008A7E  2  60                 rts
008A7F  2               
008A7F  2               ;-------------------------------------------------------------------------------------
008A7F  2               
008A7F  2               BlockObjectsCore:
008A7F  2  B5 26                lda Block_State,x           ;get state of block object
008A81  2  F0 5D                beq UpdSte                  ;if not set, branch to leave
008A83  2  29 0F                and #$0f                    ;mask out high nybble
008A85  2  48                   pha                         ;push to stack
008A86  2  A8                   tay                         ;put in Y for now
008A87  2  8A                   txa
008A88  2  18                   clc
008A89  2  69 09                adc #$09                    ;add 9 bytes to offset (note two block objects are created
008A8B  2  AA                   tax                         ;when using brick chunks, but only one offset for both)
008A8C  2  88                   dey                         ;decrement Y to check for solid block state
008A8D  2  F0 33                beq BouncingBlockHandler    ;branch if found, otherwise continue for brick chunks
008A8F  2  20 B3 8B             jsr ImposeGravityBlock      ;do sub to impose gravity on one block object object
008A92  2  20 1E 8B             jsr MoveObjectHorizontally  ;do another sub to move horizontally
008A95  2  8A                   txa
008A96  2  18                   clc                         ;move onto next block object
008A97  2  69 02                adc #$02
008A99  2  AA                   tax
008A9A  2  20 B3 8B             jsr ImposeGravityBlock      ;do sub to impose gravity on other block object
008A9D  2  20 1E 8B             jsr MoveObjectHorizontally  ;do another sub to move horizontally
008AA0  2  A6 08                ldx ObjectOffset            ;get block object offset used for both
008AA2  2  20 4E BE             jsr RelativeBlockPosition   ;get relative coordinates
008AA5  2  20 AB BE             jsr GetBlockOffscreenBits   ;get offscreen information
008AA8  2  20 3E B9             jsr DrawBrickChunks         ;draw the brick chunks
008AAB  2  68                   pla                         ;get lower nybble of saved state
008AAC  2  B4 BE                ldy Block_Y_HighPos,x       ;check vertical high byte of block object
008AAE  2  F0 30                beq UpdSte                  ;if above the screen, branch to kill it
008AB0  2  48                   pha                         ;otherwise save state back into stack
008AB1  2  A9 F0                lda #$f0
008AB3  2  D5 D9                cmp Block_Y_Position+2,x    ;check to see if bottom block object went
008AB5  2  B0 02                bcs ChkTop                  ;to the bottom of the screen, and branch if not
008AB7  2  95 D9                sta Block_Y_Position+2,x    ;otherwise set offscreen coordinate
008AB9  2  B5 D7        ChkTop: lda Block_Y_Position,x      ;get top block object's vertical coordinate
008ABB  2  C9 F0                cmp #$f0                    ;see if it went to the bottom of the screen
008ABD  2  68                   pla                         ;pull block object state from stack
008ABE  2  90 20                bcc UpdSte                  ;if not, branch to save state
008AC0  2  B0 1C                bcs KillBlock               ;otherwise do unconditional branch to kill it
008AC2  2               
008AC2  2               BouncingBlockHandler:
008AC2  2  20 B3 8B                jsr ImposeGravityBlock     ;do sub to impose gravity on block object
008AC5  2  A6 08                   ldx ObjectOffset           ;get block object offset
008AC7  2  20 4E BE                jsr RelativeBlockPosition  ;get relative coordinates
008ACA  2  20 AB BE                jsr GetBlockOffscreenBits  ;get offscreen information
008ACD  2  20 BC B8                jsr DrawBlock              ;draw the block
008AD0  2  B5 D7                   lda Block_Y_Position,x     ;get vertical coordinate
008AD2  2  29 0F                   and #$0f                   ;mask out high nybble
008AD4  2  C9 05                   cmp #$05                   ;check to see if low nybble wrapped around
008AD6  2  68                      pla                        ;pull state from stack
008AD7  2  B0 07                   bcs UpdSte                 ;if still above amount, not time to kill block yet, thus branch
008AD9  2  A9 01                   lda #$01
008ADB  2  9D EC 03                sta Block_RepFlag,x        ;otherwise set flag to replace metatile
008ADE  2  A9 00        KillBlock: lda #$00                   ;if branched here, nullify object state
008AE0  2  95 26        UpdSte:    sta Block_State,x          ;store contents of A in block object state
008AE2  2  60                      rts
008AE3  2               
008AE3  2               ;-------------------------------------------------------------------------------------
008AE3  2               ;$02 - used to store offset to block buffer
008AE3  2               ;$06-$07 - used to store block buffer address
008AE3  2               
008AE3  2               BlockObjMT_Updater:
008AE3  2  A2 01                    ldx #$01                  ;set offset to start with second block object
008AE5  2  86 08        UpdateLoop: stx ObjectOffset          ;set offset here
008AE7  2  AD 01 03                 lda VRAM_Buffer1          ;if vram buffer already being used here,
008AEA  2  D0 21                    bne NextBUpd              ;branch to move onto next block object
008AEC  2  BD EC 03                 lda Block_RepFlag,x       ;if flag for block object already clear,
008AEF  2  F0 1C                    beq NextBUpd              ;branch to move onto next block object
008AF1  2  BD E6 03                 lda Block_BBuf_Low,x      ;get low byte of block buffer
008AF4  2  85 06                    sta $06                   ;store into block buffer address
008AF6  2  A9 05                    lda #$05
008AF8  2  85 07                    sta $07                   ;set high byte of block buffer address
008AFA  2  BD E4 03                 lda Block_Orig_YPos,x     ;get original vertical coordinate of block object
008AFD  2  85 02                    sta $02                   ;store here and use as offset to block buffer
008AFF  2  A8                       tay
008B00  2  BD E8 03                 lda Block_Metatile,x      ;get metatile to be written
008B03  2  91 06                    sta ($06),y               ;write it to the block buffer
008B05  2  20 D8 69                 jsr ReplaceBlockMetatile  ;do sub to replace metatile where block object is
008B08  2  A9 00                    lda #$00
008B0A  2  9D EC 03                 sta Block_RepFlag,x       ;clear block object flag
008B0D  2  CA           NextBUpd:   dex                       ;decrement block object offset
008B0E  2  10 D5                    bpl UpdateLoop            ;do this until both block objects are dealt with
008B10  2  60                       rts                       ;then leave
008B11  2               
008B11  2               ;-------------------------------------------------------------------------------------
008B11  2               ;$00 - used to store high nybble of horizontal speed as adder
008B11  2               ;$01 - used to store low nybble of horizontal speed
008B11  2               ;$02 - used to store adder to page location
008B11  2               
008B11  2               MoveEnemyHorizontally:
008B11  2  E8                 inx                         ;increment offset for enemy offset
008B12  2  20 1E 8B           jsr MoveObjectHorizontally  ;position object horizontally according to
008B15  2  A6 08              ldx ObjectOffset            ;counters, return with saved value in A,
008B17  2  60                 rts                         ;put enemy offset back in X and leave
008B18  2               
008B18  2               MovePlayerHorizontally:
008B18  2  AD 0E 07           lda JumpspringAnimCtrl  ;if jumpspring currently animating,
008B1B  2  D0 3E              bne ExXMove             ;branch to leave
008B1D  2  AA                 tax                     ;otherwise set zero for offset to use player's stuff
008B1E  2               
008B1E  2               MoveObjectHorizontally:
008B1E  2  B5 57                  lda SprObject_X_Speed,x     ;get currently saved value (horizontal
008B20  2  0A                     asl                         ;speed, secondary counter, whatever)
008B21  2  0A                     asl                         ;and move low nybble to high
008B22  2  0A                     asl
008B23  2  0A                     asl
008B24  2  85 01                  sta $01                     ;store result here
008B26  2  B5 57                  lda SprObject_X_Speed,x     ;get saved value again
008B28  2  4A                     lsr                         ;move high nybble to low
008B29  2  4A                     lsr
008B2A  2  4A                     lsr
008B2B  2  4A                     lsr
008B2C  2  C9 08                  cmp #$08                    ;if < 8, branch, do not change
008B2E  2  90 02                  bcc SaveXSpd
008B30  2  09 F0                  ora #%11110000              ;otherwise alter high nybble
008B32  2  85 00        SaveXSpd: sta $00                     ;save result here
008B34  2  A0 00                  ldy #$00                    ;load default Y value here
008B36  2  C9 00                  cmp #$00                    ;if result positive, leave Y alone
008B38  2  10 01                  bpl UseAdder
008B3A  2  88                     dey                         ;otherwise decrement Y
008B3B  2  84 02        UseAdder: sty $02                     ;save Y here
008B3D  2  BD 00 04               lda SprObject_X_MoveForce,x ;get whatever number's here
008B40  2  18                     clc
008B41  2  65 01                  adc $01                     ;add low nybble moved to high
008B43  2  9D 00 04               sta SprObject_X_MoveForce,x ;store result here
008B46  2  A9 00                  lda #$00                    ;init A
008B48  2  2A                     rol                         ;rotate carry into d0
008B49  2  48                     pha                         ;push onto stack
008B4A  2  6A                     ror                         ;rotate d0 back onto carry
008B4B  2  B5 86                  lda SprObject_X_Position,x
008B4D  2  65 00                  adc $00                     ;add carry plus saved value (high nybble moved to low
008B4F  2  95 86                  sta SprObject_X_Position,x  ;plus $f0 if necessary) to object's horizontal position
008B51  2  B5 6D                  lda SprObject_PageLoc,x
008B53  2  65 02                  adc $02                     ;add carry plus other saved value to the
008B55  2  95 6D                  sta SprObject_PageLoc,x     ;object's page location and save
008B57  2  68                     pla
008B58  2  18                     clc                         ;pull old carry from stack and add
008B59  2  65 00                  adc $00                     ;to high nybble moved to low
008B5B  2  60           ExXMove:  rts                         ;and leave
008B5C  2               
008B5C  2               ;-------------------------------------------------------------------------------------
008B5C  2               ;$00 - used for downward force
008B5C  2               ;$01 - used for upward force
008B5C  2               ;$02 - used for maximum vertical speed
008B5C  2               
008B5C  2               MovePlayerVertically:
008B5C  2  A2 00                 ldx #$00                ;set X for player offset
008B5E  2  AD 47 07              lda TimerControl
008B61  2  D0 05                 bne NoJSChk             ;if master timer control set, branch ahead
008B63  2  AD 0E 07              lda JumpspringAnimCtrl  ;otherwise check to see if jumpspring is animating
008B66  2  D0 F3                 bne ExXMove             ;branch to leave if so
008B68  2  AD 09 07     NoJSChk: lda VerticalForce       ;dump vertical force
008B6B  2  85 00                 sta $00
008B6D  2  A9 04                 lda #$04                ;set maximum vertical speed here
008B6F  2  4C BC 8B              jmp ImposeGravitySprObj ;then jump to move player vertically
008B72  2               
008B72  2               ;--------------------------------
008B72  2               
008B72  2               MoveD_EnemyVertically:
008B72  2  A0 3D              ldy #$3d           ;set quick movement amount downwards
008B74  2  B5 1E              lda Enemy_State,x  ;then check enemy state
008B76  2  C9 05              cmp #$05           ;if not set to unique state for spiny's egg, go ahead
008B78  2  D0 02              bne ContVMove      ;and use, otherwise set different movement amount, continue on
008B7A  2               
008B7A  2               MoveFallingPlatform:
008B7A  2  A0 20                   ldy #$20       ;set movement amount
008B7C  2  4C A3 8B     ContVMove: jmp SetHiMax   ;jump to skip the rest of this
008B7F  2               
008B7F  2               ;--------------------------------
008B7F  2               
008B7F  2               MoveRedPTroopaDown:
008B7F  2  A0 00              ldy #$00            ;set Y to move downwards
008B81  2  4C 86 8B           jmp MoveRedPTroopa  ;skip to movement routine
008B84  2               
008B84  2               MoveRedPTroopaUp:
008B84  2  A0 01              ldy #$01            ;set Y to move upwards
008B86  2               
008B86  2               MoveRedPTroopa:
008B86  2  E8                 inx                 ;increment X for enemy offset
008B87  2  A9 03              lda #$03
008B89  2  85 00              sta $00             ;set downward movement amount here
008B8B  2  A9 06              lda #$06
008B8D  2  85 01              sta $01             ;set upward movement amount here
008B8F  2  A9 02              lda #$02
008B91  2  85 02              sta $02             ;set maximum speed here
008B93  2  98                 tya                 ;set movement direction in A, and
008B94  2  4C E0 8B           jmp RedPTroopaGrav  ;jump to move this thing
008B97  2               
008B97  2               ;--------------------------------
008B97  2               
008B97  2               MoveDropPlatform:
008B97  2  A0 7F              ldy #$7f      ;set movement amount for drop platform
008B99  2  D0 02              bne SetMdMax  ;skip ahead of other value set here
008B9B  2               
008B9B  2               MoveEnemySlowVert:
008B9B  2  A0 0F                  ldy #$0f         ;set movement amount for bowser/other objects
008B9D  2  A9 02        SetMdMax: lda #$02         ;set maximum speed in A
008B9F  2  D0 04                  bne SetXMoveAmt  ;unconditional branch
008BA1  2               
008BA1  2               ;--------------------------------
008BA1  2               
008BA1  2               MoveJ_EnemyVertically:
008BA1  2  A0 1C                     ldy #$1c                ;set movement amount for podoboo/other objects
008BA3  2  A9 03        SetHiMax:    lda #$03                ;set maximum speed in A
008BA5  2  84 00        SetXMoveAmt: sty $00                 ;set movement amount here
008BA7  2  E8                        inx                     ;increment X for enemy offset
008BA8  2  20 BC 8B                  jsr ImposeGravitySprObj ;do a sub to move enemy object downwards
008BAB  2  A6 08                     ldx ObjectOffset        ;get enemy object buffer offset and leave
008BAD  2  60                        rts
008BAE  2               
008BAE  2               ;--------------------------------
008BAE  2               
008BAE  2               MaxSpdBlockData:
008BAE  2  06 08              .byte $06, $08
008BB0  2               
008BB0  2               ResidualGravityCode:
008BB0  2  A0 00              ldy #$00       ;this part appears to be residual,
008BB2  2  2C                 .byte $2c        ;no code branches or jumps to it...
008BB3  2               
008BB3  2               ImposeGravityBlock:
008BB3  2  A0 01              ldy #$01       ;set offset for maximum speed
008BB5  2  A9 50              lda #$50       ;set movement amount here
008BB7  2  85 00              sta $00
008BB9  2  B9 AE 8B           lda MaxSpdBlockData,y    ;get maximum speed
008BBC  2               
008BBC  2               ImposeGravitySprObj:
008BBC  2  85 02              sta $02            ;set maximum speed here
008BBE  2  A9 00              lda #$00           ;set value to move downwards
008BC0  2  4C E6 8B           jmp ImposeGravity  ;jump to the code that actually moves it
008BC3  2               
008BC3  2               ;--------------------------------
008BC3  2               
008BC3  2               MovePlatformDown:
008BC3  2  A9 00              lda #$00    ;save value to stack (if branching here, execute next
008BC5  2  2C                 .byte $2c     ;part as BIT instruction)
008BC6  2               
008BC6  2               MovePlatformUp:
008BC6  2  A9 01                   lda #$01        ;save value to stack
008BC8  2  48                      pha
008BC9  2  B4 16                   ldy Enemy_ID,x  ;get enemy object identifier
008BCB  2  E8                      inx             ;increment offset for enemy object
008BCC  2  A9 05                   lda #$05        ;load default value here
008BCE  2  C0 29                   cpy #$29        ;residual comparison, object #29 never executes
008BD0  2  D0 02                   bne SetDplSpd   ;this code, thus unconditional branch here
008BD2  2  A9 09                   lda #$09        ;residual code
008BD4  2  85 00        SetDplSpd: sta $00         ;save downward movement amount here
008BD6  2  A9 0A                   lda #$0a        ;save upward movement amount here
008BD8  2  85 01                   sta $01
008BDA  2  A9 03                   lda #$03        ;save maximum vertical speed here
008BDC  2  85 02                   sta $02
008BDE  2  68                      pla             ;get value from stack
008BDF  2  A8                      tay             ;use as Y, then move onto code shared by red koopa
008BE0  2               
008BE0  2               RedPTroopaGrav:
008BE0  2  20 E6 8B           jsr ImposeGravity  ;do a sub to move object gradually
008BE3  2  A6 08              ldx ObjectOffset   ;get enemy object offset and leave
008BE5  2  60                 rts
008BE6  2               
008BE6  2               ;-------------------------------------------------------------------------------------
008BE6  2               ;$00 - used for downward force
008BE6  2               ;$01 - used for upward force
008BE6  2               ;$07 - used as adder for vertical position
008BE6  2               
008BE6  2               ImposeGravity:
008BE6  2  48                    pha                          ;push value to stack
008BE7  2  BD 16 04              lda SprObject_YMF_Dummy,x
008BEA  2  18                    clc                          ;add value in movement force to contents of dummy variable
008BEB  2  7D 33 04              adc SprObject_Y_MoveForce,x
008BEE  2  9D 16 04              sta SprObject_YMF_Dummy,x
008BF1  2  A0 00                 ldy #$00                     ;set Y to zero by default
008BF3  2  B5 9F                 lda SprObject_Y_Speed,x      ;get current vertical speed
008BF5  2  10 01                 bpl AlterYP                  ;if currently moving downwards, do not decrement Y
008BF7  2  88                    dey                          ;otherwise decrement Y
008BF8  2  84 07        AlterYP: sty $07                      ;store Y here
008BFA  2  75 CE                 adc SprObject_Y_Position,x   ;add vertical position to vertical speed plus carry
008BFC  2  95 CE                 sta SprObject_Y_Position,x   ;store as new vertical position
008BFE  2  B5 B5                 lda SprObject_Y_HighPos,x
008C00  2  65 07                 adc $07                      ;add carry plus contents of $07 to vertical high byte
008C02  2  95 B5                 sta SprObject_Y_HighPos,x    ;store as new vertical high byte
008C04  2  BD 33 04              lda SprObject_Y_MoveForce,x
008C07  2  18                    clc
008C08  2  65 00                 adc $00                      ;add downward movement amount to contents of $0433
008C0A  2  9D 33 04              sta SprObject_Y_MoveForce,x
008C0D  2  B5 9F                 lda SprObject_Y_Speed,x      ;add carry to vertical speed and store
008C0F  2  69 00                 adc #$00
008C11  2  95 9F                 sta SprObject_Y_Speed,x
008C13  2  C5 02                 cmp $02                      ;compare to maximum speed
008C15  2  30 10                 bmi ChkUpM                   ;if less than preset value, skip this part
008C17  2  BD 33 04              lda SprObject_Y_MoveForce,x
008C1A  2  C9 80                 cmp #$80                     ;if less positively than preset maximum, skip this part
008C1C  2  90 09                 bcc ChkUpM
008C1E  2  A5 02                 lda $02
008C20  2  95 9F                 sta SprObject_Y_Speed,x      ;keep vertical speed within maximum value
008C22  2  A9 00                 lda #$00
008C24  2  9D 33 04              sta SprObject_Y_MoveForce,x  ;clear fractional
008C27  2  68           ChkUpM:  pla                          ;get value from stack
008C28  2  F0 2B                 beq ExVMove                  ;if set to zero, branch to leave
008C2A  2  A5 02                 lda $02
008C2C  2  49 FF                 eor #%11111111               ;otherwise get two's compliment of maximum speed
008C2E  2  A8                    tay
008C2F  2  C8                    iny
008C30  2  84 07                 sty $07                      ;store two's compliment here
008C32  2  BD 33 04              lda SprObject_Y_MoveForce,x
008C35  2  38                    sec                          ;subtract upward movement amount from contents
008C36  2  E5 01                 sbc $01                      ;of movement force, note that $01 is twice as large as $00,
008C38  2  9D 33 04              sta SprObject_Y_MoveForce,x  ;thus it effectively undoes add we did earlier
008C3B  2  B5 9F                 lda SprObject_Y_Speed,x
008C3D  2  E9 00                 sbc #$00                     ;subtract borrow from vertical speed and store
008C3F  2  95 9F                 sta SprObject_Y_Speed,x
008C41  2  C5 07                 cmp $07                      ;compare vertical speed to two's compliment
008C43  2  10 10                 bpl ExVMove                  ;if less negatively than preset maximum, skip this part
008C45  2  BD 33 04              lda SprObject_Y_MoveForce,x
008C48  2  C9 80                 cmp #$80                     ;check if fractional part is above certain amount,
008C4A  2  B0 09                 bcs ExVMove                  ;and if so, branch to leave
008C4C  2  A5 07                 lda $07
008C4E  2  95 9F                 sta SprObject_Y_Speed,x      ;keep vertical speed within maximum value
008C50  2  A9 FF                 lda #$ff
008C52  2  9D 33 04              sta SprObject_Y_MoveForce,x  ;clear fractional
008C55  2  60           ExVMove: rts                          ;leave!
008C56  2               
008C56  2               ;-------------------------------------------------------------------------------------
008C56  2               
008C56  2               .ifndef ANN
008C56  2               ;some unused bytes
008C56  2                        .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
008C56  2               .endif
008C56  2               
008C56  2               ;-------------------------------------------------------------------------------------
008C56  2               
008C56  2               EnemiesAndLoopsCore:
008C56  2  B5 0F                    lda Enemy_Flag,x         ;check data here for MSB set
008C58  2  48                       pha                      ;save in stack
008C59  2  0A                       asl
008C5A  2  B0 12                    bcs ChkBowserF           ;if MSB set in enemy flag, branch ahead of jumps
008C5C  2  68                       pla                      ;get from stack
008C5D  2  F0 03                    beq ChkAreaTsk           ;if data zero, branch
008C5F  2  4C B8 94                 jmp RunEnemyObjectsCore  ;otherwise, jump to run enemy subroutines
008C62  2  AD 1F 07     ChkAreaTsk: lda AreaParserTaskNum    ;check number of tasks to perform
008C65  2  29 07                    and #$07
008C67  2  C9 07                    cmp #$07                 ;if at a specific task, jump and leave
008C69  2  F0 0E                    beq ExitELCore
008C6B  2  4C E2 8C                 jmp ProcLoopCommand      ;otherwise, jump to process loop command/load enemies
008C6E  2  68           ChkBowserF: pla                      ;get data from stack
008C6F  2  29 0F                    and #%00001111           ;mask out high nybble
008C71  2  A8                       tay
008C72  2  B9 0F 00                 lda Enemy_Flag,y         ;use as pointer and load same place with different offset
008C75  2  D0 02                    bne ExitELCore
008C77  2  95 0F                    sta Enemy_Flag,x         ;if second enemy flag not set, also clear first one
008C79  2  60           ExitELCore: rts
008C7A  2               
008C7A  2               ;-------------------------------------------------------------------------------------
008C7A  2               
008C7A  2               ;loop command data
008C7A  2               ;note that some data is never used (it may have been
008C7A  2               ;used at one point, but the area data that ref'd it
008C7A  2               ;is now missing the loop command object)
008C7A  2               
008C7A  2               .ifdef ANN
008C7A  2               LoopCmdWorldNumber:
008C7A  2  03 03 06 06    .byte $03, $03, $06, $06, $06, $06, $06, $06, $07, $07
008C7E  2  06 06 06 06  
008C82  2  07 07        
008C84  2               
008C84  2               LoopCmdPageNumber:
008C84  2  05 09 04 05    .byte $05, $09, $04, $05, $06, $08, $09, $0A, $05, $0B
008C88  2  06 08 09 0A  
008C8C  2  05 0B        
008C8E  2               
008C8E  2               LoopCmdYPosition:
008C8E  2  B0 40 40 40    .byte $B0, $40, $40, $40, $40, $40, $80, $80, $F0, $B0
008C92  2  40 40 80 80  
008C96  2  F0 B0        
008C98  2               
008C98  2               MultiLoopCount:
008C98  2  01 01 03 03    .byte $01, $01, $03, $03, $03, $03, $03, $03, $01, $01
008C9C  2  03 03 03 03  
008CA0  2  01 01        
008CA2  2               
008CA2  2               .else
008CA2  2               LoopCmdWorldNumber:
008CA2  2                 .byte $02, $02, $02, $02, $05, $05, $05, $05, $06, $07, $07, $04
008CA2  2               
008CA2  2               LoopCmdPageNumber:
008CA2  2                 .byte $03, $05, $08, $09, $03, $06, $07, $0a, $05, $05, $0b, $05
008CA2  2               
008CA2  2               LoopCmdYPosition:
008CA2  2                 .byte $b0, $b0, $40, $30, $b0, $30, $b0, $b0, $f0, $f0, $b0, $f0
008CA2  2               
008CA2  2               MultiLoopCount:
008CA2  2                 .byte $02, $02, $02, $02, $02, $02, $02, $02, $01, $01, $01, $01
008CA2  2               .endif
008CA2  2               
008CA2  2               ExecGameLoopback:
008CA2  2  A5 6D              lda Player_PageLoc        ;send player back four pages
008CA4  2  38                 sec
008CA5  2  E9 04              sbc #$04
008CA7  2  85 6D              sta Player_PageLoc
008CA9  2  AD 25 07           lda CurrentPageLoc        ;send current page back four pages
008CAC  2  38                 sec
008CAD  2  E9 04              sbc #$04
008CAF  2  8D 25 07           sta CurrentPageLoc
008CB2  2  AD 1A 07           lda ScreenLeft_PageLoc    ;subtract four from page location
008CB5  2  38                 sec                       ;of screen's left border
008CB6  2  E9 04              sbc #$04
008CB8  2  8D 1A 07           sta ScreenLeft_PageLoc
008CBB  2  AD 1B 07           lda ScreenRight_PageLoc   ;do the same for the page location
008CBE  2  38                 sec                       ;of screen's right border
008CBF  2  E9 04              sbc #$04
008CC1  2  8D 1B 07           sta ScreenRight_PageLoc
008CC4  2  AD 2A 07           lda AreaObjectPageLoc     ;subtract four from page control
008CC7  2  38                 sec                       ;for area objects
008CC8  2  E9 04              sbc #$04
008CCA  2  8D 2A 07           sta AreaObjectPageLoc
008CCD  2  A9 00              lda #$00                  ;initialize page select for both
008CCF  2  8D 3B 07           sta EnemyObjectPageSel    ;area and enemy objects
008CD2  2  8D 2B 07           sta AreaObjectPageSel
008CD5  2  8D 39 07           sta EnemyDataOffset       ;initialize enemy object data offset
008CD8  2  8D 3A 07           sta EnemyObjectPageLoc    ;and enemy object page control
008CDB  2  B9 65 C3           lda AreaDataOfsLoopback,y ;adjust area object offset based on
008CDE  2  8D 2C 07           sta AreaDataOffset        ;which loop command we encountered
008CE1  2  60                 rts
008CE2  2               
008CE2  2               ProcLoopCommand:
008CE2  2  AD 45 07               lda LoopCommand           ;check if loop command was found
008CE5  2  F0 50                  beq ChkEnemyFrenzy
008CE7  2  AD 26 07               lda CurrentColumnPos      ;check to see if we're still on the first page
008CEA  2  D0 4B                  bne ChkEnemyFrenzy        ;if not, do not loop yet
008CEC  2               .ifdef ANN
008CEC  2  A0 0A                  ldy #$0a
008CEE  2               .else
008CEE  2                         ldy #$0c                  ;start at the end of each set of loop data
008CEE  2               .endif
008CEE  2  88           FindLoop: dey
008CEF  2  30 46                  bmi ChkEnemyFrenzy        ;if all data is checked and not match, do not loop
008CF1  2  AD 5F 07               lda WorldNumber           ;check to see if one of the world numbers
008CF4  2  D9 7A 8C               cmp LoopCmdWorldNumber,y  ;matches our current world number
008CF7  2  D0 F5                  bne FindLoop
008CF9  2  AD 25 07               lda CurrentPageLoc        ;check to see if one of the page numbers
008CFC  2  D9 84 8C               cmp LoopCmdPageNumber,y   ;matches the page we're currently on
008CFF  2  D0 ED                  bne FindLoop
008D01  2  A5 CE                  lda Player_Y_Position     ;check to see if the player is at the correct position
008D03  2  D9 8E 8C               cmp LoopCmdYPosition,y    ;if not, branch to check for world 7
008D06  2  D0 09                  bne WrongChk
008D08  2  A5 1D                  lda Player_State          ;check to see if the player is
008D0A  2  C9 00                  cmp #$00                  ;on solid ground (i.e. not jumping or falling)
008D0C  2  D0 03                  bne WrongChk              ;if not, player fails to pass loop, and loopback
008D0E  2  EE D9 06               inc MultiLoopCorrectCntr  ;increment counter for correct progression
008D11  2  EE DA 06     WrongChk: inc MultiLoopPassCntr     ;increment master multi-part counter
008D14  2  AD DA 06               lda MultiLoopPassCntr     ;have we done all parts?
008D17  2  D9 98 8C               cmp MultiLoopCount,y
008D1A  2  D0 16                  bne InitLCmd              ;if not, skip this part
008D1C  2  AD D9 06               lda MultiLoopCorrectCntr  ;if so, have we done them all correctly?
008D1F  2  D9 98 8C               cmp MultiLoopCount,y
008D22  2  F0 06                  beq InitMLp               ;if so, branch past unnecessary check here
008D24  2  20 A2 8C               jsr ExecGameLoopback      ;if player is not in right place, loop back
008D27  2  20 AA 9C               jsr KillAllEnemies
008D2A  2  A9 00        InitMLp:  lda #$00                  ;initialize counters used for multi-part loop commands
008D2C  2  8D DA 06               sta MultiLoopPassCntr
008D2F  2  8D D9 06               sta MultiLoopCorrectCntr
008D32  2  A9 00        InitLCmd: lda #$00                  ;initialize loop command flag
008D34  2  8D 45 07               sta LoopCommand
008D37  2               
008D37  2               ;--------------------------------
008D37  2               
008D37  2               ChkEnemyFrenzy:
008D37  2  AD CD 06           lda EnemyFrenzyQueue  ;check for enemy object in frenzy queue
008D3A  2  F0 10              beq ProcessEnemyData  ;if not, skip this part
008D3C  2  95 16              sta Enemy_ID,x        ;store as enemy object identifier here
008D3E  2  A9 01              lda #$01
008D40  2  95 0F              sta Enemy_Flag,x      ;activate enemy object flag
008D42  2  A9 00              lda #$00
008D44  2  95 1E              sta Enemy_State,x     ;initialize state and frenzy queue
008D46  2  8D CD 06           sta EnemyFrenzyQueue
008D49  2  4C 33 8E           jmp InitEnemyObject   ;and then jump to deal with this enemy
008D4C  2               
008D4C  2               ;--------------------------------
008D4C  2               ;$06 - used to hold page location of extended right boundary
008D4C  2               ;$07 - used to hold high nybble of position of extended right boundary
008D4C  2               
008D4C  2               ProcessEnemyData:
008D4C  2  AC 39 07             ldy EnemyDataOffset      ;get offset of enemy object data
008D4F  2  B1 E9                lda (EnemyData),y        ;load first byte
008D51  2  C9 FF                cmp #$ff                 ;check for EOD terminator
008D53  2  D0 03                bne CheckEndofBuffer
008D55  2  4C 23 8E             jmp CheckFrenzyBuffer    ;if found, jump to check frenzy buffer, otherwise
008D58  2               
008D58  2               CheckEndofBuffer:
008D58  2  29 0F                and #%00001111           ;check for special row $0e
008D5A  2  C9 0E                cmp #$0e
008D5C  2  F0 0E                beq CheckRightBounds     ;if found, branch, otherwise
008D5E  2  E0 05                cpx #$05                 ;check for end of buffer
008D60  2  90 0A                bcc CheckRightBounds     ;if not at end of buffer, branch
008D62  2  C8                   iny
008D63  2  B1 E9                lda (EnemyData),y        ;check for specific value here
008D65  2  29 3F                and #%00111111           ;not sure what this was intended for, exactly
008D67  2  C9 2E                cmp #$2e                 ;this part is quite possibly residual code
008D69  2  F0 01                beq CheckRightBounds     ;but it has the effect of keeping enemies out of
008D6B  2  60                   rts                      ;the sixth slot
008D6C  2               
008D6C  2               CheckRightBounds:
008D6C  2  AD 1D 07             lda ScreenRight_X_Pos    ;add 48 to pixel coordinate of right boundary
008D6F  2  18                   clc
008D70  2  69 30                adc #$30
008D72  2  29 F0                and #%11110000           ;store high nybble
008D74  2  85 07                sta $07
008D76  2  AD 1B 07             lda ScreenRight_PageLoc  ;add carry to page location of right boundary
008D79  2  69 00                adc #$00
008D7B  2  85 06                sta $06                  ;store page location + carry
008D7D  2  AC 39 07             ldy EnemyDataOffset
008D80  2  C8                   iny
008D81  2  B1 E9                lda (EnemyData),y        ;if MSB of enemy object is clear, branch to check for row $0f
008D83  2  0A                   asl
008D84  2  90 0B                bcc CheckPageCtrlRow
008D86  2  AD 3B 07             lda EnemyObjectPageSel   ;if page select already set, do not set again
008D89  2  D0 06                bne CheckPageCtrlRow
008D8B  2  EE 3B 07             inc EnemyObjectPageSel   ;otherwise, if MSB is set, set page select
008D8E  2  EE 3A 07             inc EnemyObjectPageLoc   ;and increment page control
008D91  2               
008D91  2               CheckPageCtrlRow:
008D91  2  88                   dey
008D92  2  B1 E9                lda (EnemyData),y        ;reread first byte
008D94  2  29 0F                and #$0f
008D96  2  C9 0F                cmp #$0f                 ;check for special row $0f
008D98  2  D0 19                bne PositionEnemyObj     ;if not found, branch to position enemy object
008D9A  2  AD 3B 07             lda EnemyObjectPageSel   ;if page select set,
008D9D  2  D0 14                bne PositionEnemyObj     ;branch without reading second byte
008D9F  2  C8                   iny
008DA0  2  B1 E9                lda (EnemyData),y        ;otherwise, get second byte, mask out 2 MSB
008DA2  2  29 3F                and #%00111111
008DA4  2  8D 3A 07             sta EnemyObjectPageLoc   ;store as page control for enemy object data
008DA7  2  EE 39 07             inc EnemyDataOffset      ;increment enemy object data offset 2 bytes
008DAA  2  EE 39 07             inc EnemyDataOffset
008DAD  2  EE 3B 07             inc EnemyObjectPageSel   ;set page select for enemy object data and
008DB0  2  4C E2 8C             jmp ProcLoopCommand      ;jump back to process loop commands again
008DB3  2               
008DB3  2               PositionEnemyObj:
008DB3  2  AD 3A 07             lda EnemyObjectPageLoc   ;store page control as page location
008DB6  2  95 6E                sta Enemy_PageLoc,x      ;for enemy object
008DB8  2  B1 E9                lda (EnemyData),y        ;get first byte of enemy object
008DBA  2  29 F0                and #%11110000
008DBC  2  95 87                sta Enemy_X_Position,x   ;store column position
008DBE  2  CD 1D 07             cmp ScreenRight_X_Pos    ;check column position against right boundary
008DC1  2  B5 6E                lda Enemy_PageLoc,x      ;without subtracting, then subtract borrow
008DC3  2  ED 1B 07             sbc ScreenRight_PageLoc  ;from page location
008DC6  2  B0 0B                bcs CheckRightExtBounds  ;if enemy object beyond or at boundary, branch
008DC8  2  B1 E9                lda (EnemyData),y
008DCA  2  29 0F                and #%00001111           ;check for special row $0e
008DCC  2  C9 0E                cmp #$0e                 ;if found, jump elsewhere
008DCE  2  F0 6E                beq ParseRow0e
008DD0  2  4C 5D 8E             jmp CheckThreeBytes      ;if not found, unconditional jump
008DD3  2               
008DD3  2               CheckRightExtBounds:
008DD3  2  A5 07                lda $07                  ;check right boundary + 48 against
008DD5  2  D5 87                cmp Enemy_X_Position,x   ;column position without subtracting,
008DD7  2  A5 06                lda $06                  ;then subtract borrow from page control temp
008DD9  2  F5 6E                sbc Enemy_PageLoc,x      ;plus carry
008DDB  2  90 46                bcc CheckFrenzyBuffer    ;if enemy object beyond extended boundary, branch
008DDD  2  A9 01                lda #$01                 ;store value in vertical high byte
008DDF  2  95 B6                sta Enemy_Y_HighPos,x
008DE1  2  B1 E9                lda (EnemyData),y        ;get first byte again
008DE3  2  0A                   asl                      ;multiply by four to get the vertical
008DE4  2  0A                   asl                      ;coordinate
008DE5  2  0A                   asl
008DE6  2  0A                   asl
008DE7  2  95 CF                sta Enemy_Y_Position,x
008DE9  2  C9 E0                cmp #$e0                 ;do one last check for special row $0e
008DEB  2  F0 51                beq ParseRow0e           ;(necessary if branched to $c1cb)
008DED  2  C8                   iny
008DEE  2  B1 E9                lda (EnemyData),y        ;get second byte of object
008DF0  2  29 40                and #%01000000           ;check to see if hard mode bit is set
008DF2  2  F0 05                beq CheckForEnemyGroup   ;if not, branch to check for group enemy objects
008DF4  2  AD CC 06             lda SecondaryHardMode    ;if set, check to see if secondary hard mode flag
008DF7  2  F0 72                beq Inc2B                ;is on, and if not, branch to skip this object completely
008DF9  2               
008DF9  2               CheckForEnemyGroup:
008DF9  2  B1 E9                lda (EnemyData),y      ;get second byte and mask out 2 MSB
008DFB  2  29 3F                and #%00111111
008DFD  2  C9 37                cmp #$37               ;check for value below $37
008DFF  2  90 04                bcc BuzzyBeetleMutate
008E01  2  C9 3F                cmp #$3f               ;if $37 or greater, check for value
008E03  2  90 36                bcc DoGroup            ;below $3f, branch if below $3f
008E05  2               
008E05  2               BuzzyBeetleMutate:
008E05  2  C9 06                cmp #Goomba          ;if below $37, check for goomba
008E07  2  D0 0C                bne StrID            ;value ($3f or more always fails)
008E09  2  AC 7D 07             ldy PrimaryHardMode  ;check if primary hard mode flag is set
008E0C  2  F0 07                beq StrID            ;and if so, change goomba to buzzy beetle
008E0E  2               .ifdef ANN
008E0E  2  AC FB 07             ldy HardWorldFlag
008E11  2  D0 02                bne StrID
008E13  2               .endif
008E13  2  A9 02                lda #BuzzyBeetle
008E15  2  95 16        StrID:  sta Enemy_ID,x       ;store enemy object number into buffer
008E17  2  A9 01                lda #$01
008E19  2  95 0F                sta Enemy_Flag,x     ;set flag for enemy in buffer
008E1B  2  20 33 8E             jsr InitEnemyObject
008E1E  2  B5 0F                lda Enemy_Flag,x     ;check to see if flag is set
008E20  2  D0 49                bne Inc2B            ;if not, leave, otherwise branch
008E22  2  60                   rts
008E23  2               
008E23  2               CheckFrenzyBuffer:
008E23  2  AD CB 06             lda EnemyFrenzyBuffer    ;if enemy object stored in frenzy buffer
008E26  2  D0 09                bne StrFre               ;then branch ahead to store in enemy object buffer
008E28  2  AD 98 03             lda VineFlagOffset       ;otherwise check vine flag offset
008E2B  2  C9 01                cmp #$01
008E2D  2  D0 0B                bne ExEPar               ;if other value <> 1, leave
008E2F  2  A9 2F                lda #VineObject          ;otherwise put vine in enemy identifier
008E31  2  95 16        StrFre: sta Enemy_ID,x           ;store contents of frenzy buffer into enemy identifier value
008E33  2               
008E33  2               InitEnemyObject:
008E33  2  A9 00                lda #$00                 ;initialize enemy state
008E35  2  95 1E                sta Enemy_State,x
008E37  2  20 79 8E             jsr CheckpointEnemyID    ;jump ahead to run jump engine and subroutines
008E3A  2  60           ExEPar: rts                      ;then leave
008E3B  2               
008E3B  2               DoGroup:
008E3B  2  4C 4E 93             jmp HandleGroupEnemies   ;handle enemy group objects
008E3E  2               
008E3E  2               ParseRow0e:
008E3E  2  C8                   iny                      ;increment Y to load third byte of object
008E3F  2  C8                   iny
008E40  2               .ifndef ANN
008E40  2                       lda WorldNumber
008E40  2                       cmp #World9              ;skip world number check if on world 9
008E40  2                       beq W9Skip
008E40  2               .endif
008E40  2  B1 E9                lda (EnemyData),y
008E42  2  4A                   lsr                      ;move 3 MSB to the bottom, effectively
008E43  2  4A                   lsr                      ;making %xxx00000 into %00000xxx
008E44  2  4A                   lsr
008E45  2  4A                   lsr
008E46  2  4A                   lsr
008E47  2  CD 5F 07             cmp WorldNumber          ;is it the same world number as we're on?
008E4A  2  D0 0E                bne NotUse               ;if not, do not use (this allows multiple uses
008E4C  2  88           W9Skip: dey                      ;of the same area, like the underground bonus areas)
008E4D  2  B1 E9                lda (EnemyData),y        ;otherwise, get second byte and use as offset
008E4F  2  8D 50 07             sta AreaPointer          ;to addresses for level and enemy object data
008E52  2  C8                   iny
008E53  2  B1 E9                lda (EnemyData),y        ;get third byte again, and this time mask out
008E55  2  29 1F                and #%00011111           ;the 3 MSB from before, save as page number to be
008E57  2  8D 51 07             sta EntrancePage         ;used upon entry to area, if area is entered
008E5A  2  4C 68 8E     NotUse: jmp Inc3B
008E5D  2               
008E5D  2               CheckThreeBytes:
008E5D  2  AC 39 07             ldy EnemyDataOffset      ;load current offset for enemy object data
008E60  2  B1 E9                lda (EnemyData),y        ;get first byte
008E62  2  29 0F                and #%00001111           ;check for special row $0e
008E64  2  C9 0E                cmp #$0e
008E66  2  D0 03                bne Inc2B
008E68  2  EE 39 07     Inc3B:  inc EnemyDataOffset      ;if row = $0e, increment three bytes
008E6B  2  EE 39 07     Inc2B:  inc EnemyDataOffset      ;otherwise increment two bytes
008E6E  2  EE 39 07             inc EnemyDataOffset
008E71  2  A9 00                lda #$00                 ;init page select for enemy objects
008E73  2  8D 3B 07             sta EnemyObjectPageSel
008E76  2  A6 08                ldx ObjectOffset         ;reload current offset in enemy buffers
008E78  2  60                   rts                      ;and leave
008E79  2               
008E79  2               CheckpointEnemyID:
008E79  2  B5 16                lda Enemy_ID,x
008E7B  2  C9 15                cmp #$15                     ;check enemy object identifier for $15 or greater
008E7D  2  B0 0D                bcs InitEnemyRoutines        ;and branch straight to the jump engine if found
008E7F  2  A8                   tay                          ;save identifier in Y register for now
008E80  2  B5 CF                lda Enemy_Y_Position,x
008E82  2  69 08                adc #$08                     ;add eight pixels to what will eventually be the
008E84  2  95 CF                sta Enemy_Y_Position,x       ;enemy object's vertical coordinate ($00-$14 only)
008E86  2  A9 01                lda #$01
008E88  2  9D D8 03             sta EnemyOffscrBitsMasked,x  ;set offscreen masked bit
008E8B  2  98                   tya                          ;get identifier back and use as offset for jump engine
008E8C  2               
008E8C  2               InitEnemyRoutines:
008E8C  2  20 0F 6D             jsr JumpEngine
008E8F  2               
008E8F  2  1B 8F                .word InitNormalEnemy
008E91  2  1B 8F                .word InitNormalEnemy
008E93  2  1B 8F                .word InitNormalEnemy
008E95  2  2B 8F                .word InitRedKoopa
008E97  2  BF 93                .word InitPiranhaPlant
008E99  2  35 8F                .word InitHammerBro
008E9B  2  FE 8E                .word InitGoomba
008E9D  2  56 8F                .word InitBloober
008E9F  2  7F 8F                .word InitBulletBill
008EA1  2  FD 8E                .word NoInitCode
008EA3  2  89 8F                .word InitCheepCheep
008EA5  2  89 8F                .word InitCheepCheep
008EA7  2  04 8F                .word InitPodoboo
008EA9  2  BF 93                .word InitPiranhaPlant
008EAB  2  08 94                .word InitJumpGPTroopa
008EAD  2  5E 8F                .word InitRedPTroopa
008EAF  2               
008EAF  2  51 8F                .word InitHorizFlySwimEnemy
008EB1  2  99 8F                .word InitLakitu
008EB3  2  D8 93                .word InitEnemyFrenzy
008EB5  2  FD 8E                .word NoInitCode
008EB7  2  D8 93                .word InitEnemyFrenzy
008EB9  2  D8 93                .word InitEnemyFrenzy
008EBB  2  D8 93                .word InitEnemyFrenzy
008EBD  2  D8 93                .word InitEnemyFrenzy
008EBF  2  EF 93                .word EndFrenzy
008EC1  2  FD 8E                .word NoInitCode
008EC3  2  FD 8E                .word NoInitCode
008EC5  2  77 90                .word InitShortFirebar
008EC7  2  77 90                .word InitShortFirebar
008EC9  2  77 90                .word InitShortFirebar
008ECB  2  77 90                .word InitShortFirebar
008ECD  2  74 90                .word InitLongFirebar
008ECF  2               
008ECF  2  FD 8E                .word NoInitCode
008ED1  2  FD 8E                .word NoInitCode
008ED3  2  FD 8E                .word NoInitCode
008ED5  2  FD 8E                .word NoInitCode
008ED7  2  16 94                .word InitBalPlatform
008ED9  2  49 94                .word InitVertPlatform
008EDB  2  76 94                .word LargeLiftUp
008EDD  2  7C 94                .word LargeLiftDown
008EDF  2  42 94                .word InitHoriPlatform
008EE1  2  3A 94                .word InitDropPlatform
008EE3  2  42 94                .word InitHoriPlatform
008EE5  2  82 94                .word PlatLiftUp
008EE7  2  8E 94                .word PlatLiftDown
008EE9  2  64 91                .word InitBowser
008EEB  2  64 88                .word PwrUpJmp
008EED  2  F5 84                .word Setup_Vine
008EEF  2               
008EEF  2  FD 8E                .word NoInitCode
008EF1  2  FD 8E                .word NoInitCode
008EF3  2  FD 8E                .word NoInitCode
008EF5  2  FD 8E                .word NoInitCode
008EF7  2  FD 8E                .word NoInitCode
008EF9  2  14 8F                .word InitRetainerObj
008EFB  2  B7 94                .word EndOfEnemyInitCode
008EFD  2               
008EFD  2               NoInitCode:
008EFD  2  60                   rts
008EFE  2               
008EFE  2               InitGoomba:
008EFE  2  20 1B 8F           jsr InitNormalEnemy  ;set appropriate horizontal speed
008F01  2  4C 5A 8F           jmp SmallBBox        ;set $09 as bounding box control, set other values
008F04  2               
008F04  2               InitPodoboo:
008F04  2  A9 02              lda #$02                  ;set enemy position to below
008F06  2  95 B6              sta Enemy_Y_HighPos,x     ;the bottom of the screen
008F08  2  95 CF              sta Enemy_Y_Position,x
008F0A  2  4A                 lsr
008F0B  2  9D 96 07           sta EnemyIntervalTimer,x  ;set timer for enemy
008F0E  2  4A                 lsr
008F0F  2  95 1E              sta Enemy_State,x         ;initialize enemy state, then jump to use
008F11  2  4C 5A 8F           jmp SmallBBox             ;$09 as bounding box size and set other things
008F14  2               
008F14  2               InitRetainerObj:
008F14  2  A9 B8              lda #$b8                ;set fixed vertical position for
008F16  2  95 CF              sta Enemy_Y_Position,x  ;princess/mushroom retainer object
008F18  2  60                 rts
008F19  2               
008F19  2               NormalXSpdData:
008F19  2  F8 F4              .byte $f8, $f4
008F1B  2               
008F1B  2               InitNormalEnemy:
008F1B  2  A0 01                 ldy #$01              ;load offset of 1 by default
008F1D  2  AD 7D 07              lda PrimaryHardMode   ;check for primary hard mode flag set
008F20  2  D0 01                 bne GetESpd
008F22  2  88                    dey                   ;if not set, decrement offset
008F23  2  B9 19 8F     GetESpd: lda NormalXSpdData,y  ;get appropriate horizontal speed
008F26  2  95 58        SetESpd: sta Enemy_X_Speed,x   ;store as speed for enemy object
008F28  2  4C 6E 8F              jmp TallBBox          ;branch to set bounding box control and other data
008F2B  2               
008F2B  2               InitRedKoopa:
008F2B  2  20 1B 8F           jsr InitNormalEnemy   ;load appropriate horizontal speed
008F2E  2  A9 01              lda #$01              ;set enemy state for red koopa troopa $03
008F30  2  95 1E              sta Enemy_State,x
008F32  2  60                 rts
008F33  2               
008F33  2               HBroWalkingTimerData:
008F33  2  80 50              .byte $80, $50
008F35  2               
008F35  2               InitHammerBro:
008F35  2  A9 00               lda #$00                    ;init horizontal speed and timer used by hammer bro
008F37  2  9D A2 03            sta HammerThrowingTimer,x   ;apparently to time hammer throwing
008F3A  2  95 58               sta Enemy_X_Speed,x
008F3C  2  AD 5F 07            lda WorldNumber             ;if on worlds 7-9, branch to skip the walk delay
008F3F  2  C9 06               cmp #World7
008F41  2  B0 09               bcs NoHBI
008F43  2  AC CC 06            ldy SecondaryHardMode       ;get secondary hard mode flag
008F46  2  B9 33 8F            lda HBroWalkingTimerData,y
008F49  2  9D 96 07            sta EnemyIntervalTimer,x    ;set value as delay for hammer bro to walk left
008F4C  2  A9 0B        NoHBI: lda #$0b                    ;set specific value for bounding box size control
008F4E  2  4C 70 8F            jmp SetBBox
008F51  2               
008F51  2               ;--------------------------------
008F51  2               
008F51  2               InitHorizFlySwimEnemy:
008F51  2  A9 00              lda #$00        ;initialize horizontal speed
008F53  2  4C 26 8F           jmp SetESpd
008F56  2               
008F56  2               ;--------------------------------
008F56  2               
008F56  2               InitBloober:
008F56  2  A9 00                   lda #$00               ;initialize horizontal speed
008F58  2  95 58                   sta BlooperMoveSpeed,x
008F5A  2  A9 09        SmallBBox: lda #$09               ;set specific bounding box size control
008F5C  2  D0 12                   bne SetBBox            ;unconditional branch
008F5E  2               
008F5E  2               InitRedPTroopa:
008F5E  2  A0 30                  ldy #$30                    ;load central position adder for 48 pixels down
008F60  2  B5 CF                  lda Enemy_Y_Position,x      ;set vertical coordinate into location to
008F62  2  9D 01 04               sta RedPTroopaOrigXPos,x    ;be used as original vertical coordinate
008F65  2  10 02                  bpl GetCent                 ;if vertical coordinate < $80
008F67  2  A0 E0                  ldy #$e0                    ;if => $80, load position adder for 32 pixels up
008F69  2  98           GetCent:  tya                         ;send central position adder to A
008F6A  2  75 CF                  adc Enemy_Y_Position,x      ;add to current vertical coordinate
008F6C  2  95 58                  sta RedPTroopaCenterYPos,x  ;store as central vertical coordinate
008F6E  2  A9 03        TallBBox: lda #$03                    ;set specific bounding box size control
008F70  2  9D 9A 04     SetBBox:  sta Enemy_BoundBoxCtrl,x    ;set bounding box control here
008F73  2  A9 02                  lda #$02                    ;set moving direction for left
008F75  2  95 46                  sta Enemy_MovingDir,x
008F77  2  A9 00        InitVStf: lda #$00                    ;initialize vertical speed
008F79  2  95 A0                  sta Enemy_Y_Speed,x         ;and movement force
008F7B  2  9D 34 04               sta Enemy_Y_MoveForce,x
008F7E  2  60                     rts
008F7F  2               
008F7F  2               InitBulletBill:
008F7F  2  A9 02              lda #$02                  ;set moving direction for left
008F81  2  95 46              sta Enemy_MovingDir,x
008F83  2  A9 09              lda #$09                  ;set bounding box control for $09
008F85  2  9D 9A 04           sta Enemy_BoundBoxCtrl,x
008F88  2  60                 rts
008F89  2               
008F89  2               InitCheepCheep:
008F89  2  20 5A 8F           jsr SmallBBox              ;set vertical bounding box, speed, init others
008F8C  2  BD A7 07           lda PseudoRandomBitReg,x   ;check one portion of LSFR
008F8F  2  29 10              and #%00010000             ;get d4 from it
008F91  2  95 58              sta CheepCheepMoveMFlag,x  ;save as movement flag of some sort
008F93  2  B5 CF              lda Enemy_Y_Position,x
008F95  2  9D 34 04           sta CheepCheepOrigYPos,x   ;save original vertical coordinate here
008F98  2  60                 rts
008F99  2               
008F99  2               InitLakitu:
008F99  2  AD CB 06           lda EnemyFrenzyBuffer      ;check to see if an enemy is already in
008F9C  2  D0 0B              bne KillLakitu             ;the frenzy buffer, and branch to kill lakitu if so
008F9E  2               
008F9E  2               SetupLakitu:
008F9E  2  A9 00              lda #$00                   ;erase counter for lakitu's reappearance
008FA0  2  8D D1 06           sta LakituReappearTimer
008FA3  2  20 51 8F           jsr InitHorizFlySwimEnemy  ;set $03 as bounding box, set other attributes
008FA6  2  4C 10 94           jmp TallBBox2              ;set $03 as bounding box again (not necessary) and leave
008FA9  2               
008FA9  2               KillLakitu:
008FA9  2  4C CC 95           jmp EraseEnemyObject
008FAC  2               
008FAC  2               ;--------------------------------
008FAC  2               ;$01-$03 - used to hold pseudorandom difference adjusters
008FAC  2               
008FAC  2               PRDiffAdjustData:
008FAC  2  26 2C 32 38        .byte $26, $2c, $32, $38
008FB0  2  20 22 24 26        .byte $20, $22, $24, $26
008FB4  2  13 14 15 16        .byte $13, $14, $15, $16
008FB8  2               
008FB8  2               LakituAndSpinyHandler:
008FB8  2  AD 8F 07               lda FrenzyEnemyTimer    ;if timer here not expired, leave
008FBB  2  D0 43                  bne ExLSHand
008FBD  2  E0 05                  cpx #$05                ;if we are on the special use slot, leave
008FBF  2  B0 3F                  bcs ExLSHand
008FC1  2  A9 80                  lda #$80                ;set timer
008FC3  2  8D 8F 07               sta FrenzyEnemyTimer
008FC6  2  A0 04                  ldy #$04                ;start with the last enemy slot
008FC8  2  B9 16 00     ChkLak:   lda Enemy_ID,y          ;check all enemy slots to see
008FCB  2  C9 11                  cmp #Lakitu             ;if lakitu is on one of them
008FCD  2  F0 32                  beq CreateSpiny         ;if so, branch out of this loop
008FCF  2  88                     dey                     ;otherwise check another slot
008FD0  2  10 F6                  bpl ChkLak              ;loop until all slots are checked
008FD2  2  EE D1 06               inc LakituReappearTimer ;increment reappearance timer
008FD5  2  AD D1 06               lda LakituReappearTimer
008FD8  2  C9 03                  cmp #$03                ;check to see if we're up to a certain value yet
008FDA  2  90 24                  bcc ExLSHand            ;if not, leave
008FDC  2  A2 04                  ldx #$04                ;start with the last enemy slot again
008FDE  2  B5 0F        ChkNoEn:  lda Enemy_Flag,x        ;check enemy buffer flag for non-active enemy slot
008FE0  2  F0 05                  beq CreateL             ;branch out of loop if found
008FE2  2  CA                     dex                     ;otherwise check next slot
008FE3  2  10 F9                  bpl ChkNoEn             ;branch until all slots are checked
008FE5  2  30 17                  bmi RetEOfs             ;if no empty slots were found, branch to leave
008FE7  2  A9 00        CreateL:  lda #$00                ;initialize enemy state
008FE9  2  95 1E                  sta Enemy_State,x
008FEB  2  A9 11                  lda #Lakitu             ;create lakitu enemy object
008FED  2  95 16                  sta Enemy_ID,x
008FEF  2  20 9E 8F               jsr SetupLakitu         ;do a sub to set up lakitu
008FF2  2  A9 20                  lda #$20
008FF4  2  AC FB 07               ldy HardWorldFlag
008FF7  2               .ifdef ANN
008FF7  2  F0 02                  beq SetLakXY
008FF9  2               .else
008FF9  2                         bne SetLowLY            ;if in worlds A-D, put lakitu lower on the screen
008FF9  2                         ldy WorldNumber
008FF9  2                         cpy #$06                ;if in worlds 1-6, branch to use default high position
008FF9  2                         bcc SetLakXY            ;otherwise put lakitu lower on the screen
008FF9  2               .endif
008FF9  2  A9 60        SetLowLY: lda #$60
008FFB  2  20 0B 92     SetLakXY: jsr PutAtRightExtent    ;finish setting up lakitu
008FFE  2  A6 08        RetEOfs:  ldx ObjectOffset        ;get enemy object buffer offset again and leave
009000  2  60           ExLSHand: rts
009001  2               
009001  2               CreateSpiny:
009001  2  A5 CE                  lda Player_Y_Position      ;if player above a certain point, branch to leave
009003  2  C9 2C                  cmp #$2c
009005  2  90 F9                  bcc ExLSHand
009007  2  B9 1E 00               lda Enemy_State,y          ;if lakitu is not in normal state, branch to leave
00900A  2  D0 F4                  bne ExLSHand
00900C  2  B9 6E 00               lda Enemy_PageLoc,y        ;store horizontal coordinates (high and low) of lakitu
00900F  2  95 6E                  sta Enemy_PageLoc,x        ;into the coordinates of the spiny we're going to create
009011  2  B9 87 00               lda Enemy_X_Position,y
009014  2  95 87                  sta Enemy_X_Position,x
009016  2  A9 01                  lda #$01                   ;put spiny within vertical screen unit
009018  2  95 B6                  sta Enemy_Y_HighPos,x
00901A  2  B9 CF 00               lda Enemy_Y_Position,y     ;put spiny eight pixels above where lakitu is
00901D  2  38                     sec
00901E  2  E9 08                  sbc #$08
009020  2  95 CF                  sta Enemy_Y_Position,x
009022  2  BD A7 07               lda PseudoRandomBitReg,x   ;get 2 LSB of LSFR and save to Y
009025  2  29 03                  and #%00000011
009027  2  A8                     tay
009028  2  A2 02                  ldx #$02
00902A  2  B9 AC 8F     DifLoop:  lda PRDiffAdjustData,y     ;get three values and save them
00902D  2  95 01                  sta $01,x                  ;to $01-$03
00902F  2  C8                     iny
009030  2  C8                     iny                        ;increment Y four bytes for each value
009031  2  C8                     iny
009032  2  C8                     iny
009033  2  CA                     dex                        ;decrement X for each one
009034  2  10 F4                  bpl DifLoop                ;loop until all three are written
009036  2  A6 08                  ldx ObjectOffset           ;get enemy object buffer offset
009038  2  20 A5 9B               jsr PlayerLakituDiff       ;move enemy, change direction, get value - difference
00903B  2  A4 57                  ldy Player_X_Speed         ;check player's horizontal speed
00903D  2  C0 08                  cpy #$08
00903F  2  B0 0E                  bcs SetSpSpd               ;if moving faster than a certain amount, branch elsewhere
009041  2  A8                     tay                        ;otherwise save value in A to Y for now
009042  2  BD A8 07               lda PseudoRandomBitReg+1,x
009045  2  29 03                  and #%00000011             ;get one of the LSFR parts and save the 2 LSB
009047  2  F0 05                  beq UsePosv                ;branch if neither bits are set
009049  2  98                     tya
00904A  2  49 FF                  eor #%11111111             ;otherwise get two's compliment of Y
00904C  2  A8                     tay
00904D  2  C8                     iny
00904E  2  98           UsePosv:  tya                        ;put value from A in Y back to A (they will be lost anyway)
00904F  2  20 5A 8F     SetSpSpd: jsr SmallBBox              ;set bounding box control, init attributes, lose contents of A
009052  2  A0 02                  ldy #$02                   ;(putting this call elsewhere will preserve A)
009054  2  95 58                  sta Enemy_X_Speed,x        ;set horizontal speed to zero because previous contents
009056  2  C9 00                  cmp #$00                   ;of A were lost...branch here will never be taken for
009058  2  30 01                  bmi SpinyRte               ;the same reason
00905A  2  88                     dey
00905B  2  94 46        SpinyRte: sty Enemy_MovingDir,x      ;set moving direction to the right
00905D  2  A9 FD                  lda #$fd
00905F  2  95 A0                  sta Enemy_Y_Speed,x        ;set vertical speed to move upwards
009061  2  A9 01                  lda #$01
009063  2  95 0F                  sta Enemy_Flag,x           ;enable enemy object by setting flag
009065  2  A9 05                  lda #$05
009067  2  95 1E                  sta Enemy_State,x          ;put spiny in egg state and leave
009069  2  60           ChpChpEx: rts
00906A  2               
00906A  2               ;--------------------------------
00906A  2               
00906A  2               FirebarSpinSpdData:
00906A  2  28 38 28 38        .byte $28, $38, $28, $38, $28
00906E  2  28           
00906F  2               
00906F  2               FirebarSpinDirData:
00906F  2  00 00 10 10        .byte $00, $00, $10, $10, $00
009073  2  00           
009074  2               
009074  2               InitLongFirebar:
009074  2  20 A8 91           jsr DuplicateEnemyObj       ;create enemy object for long firebar
009077  2               
009077  2               InitShortFirebar:
009077  2  A9 00              lda #$00                    ;initialize low byte of spin state
009079  2  95 58              sta FirebarSpinState_Low,x
00907B  2  B5 16              lda Enemy_ID,x              ;subtract $1b from enemy identifier
00907D  2  38                 sec                         ;to get proper offset for firebar data
00907E  2  E9 1B              sbc #$1b
009080  2  A8                 tay
009081  2  B9 6A 90           lda FirebarSpinSpdData,y    ;get spinning speed of firebar
009084  2  9D 88 03           sta FirebarSpinSpeed,x
009087  2  B9 6F 90           lda FirebarSpinDirData,y    ;get spinning direction of firebar
00908A  2  95 34              sta FirebarSpinDirection,x
00908C  2  B5 CF              lda Enemy_Y_Position,x
00908E  2  18                 clc                         ;add four pixels to vertical coordinate
00908F  2  69 04              adc #$04
009091  2  95 CF              sta Enemy_Y_Position,x
009093  2  B5 87              lda Enemy_X_Position,x
009095  2  18                 clc                         ;add four pixels to horizontal coordinate
009096  2  69 04              adc #$04
009098  2  95 87              sta Enemy_X_Position,x
00909A  2  B5 6E              lda Enemy_PageLoc,x
00909C  2  69 00              adc #$00                    ;add carry to page location
00909E  2  95 6E              sta Enemy_PageLoc,x
0090A0  2  4C 10 94           jmp TallBBox2               ;set bounding box control (not used) and leave
0090A3  2               
0090A3  2               ;--------------------------------
0090A3  2               ;$00-$01 - used to hold pseudorandom bits
0090A3  2               
0090A3  2               FlyCCXPositionData:
0090A3  2  80 30 40 80        .byte $80, $30, $40, $80
0090A7  2  30 50 50 70        .byte $30, $50, $50, $70
0090AB  2  20 40 80 A0        .byte $20, $40, $80, $a0
0090AF  2  70 40 90 68        .byte $70, $40, $90, $68
0090B3  2               
0090B3  2               FlyCCXSpeedData:
0090B3  2  0E 05 06 0E        .byte $0e, $05, $06, $0e
0090B7  2  1C 20 10 0C        .byte $1c, $20, $10, $0c
0090BB  2  1E 22 18 14        .byte $1e, $22, $18, $14
0090BF  2               
0090BF  2               FlyCCTimerData:
0090BF  2  10 60 20 48        .byte $10, $60, $20, $48
0090C3  2               
0090C3  2               InitFlyingCheepCheep:
0090C3  2  AD 8F 07              lda FrenzyEnemyTimer       ;if timer here not expired yet, branch to leave
0090C6  2  D0 A1                 bne ChpChpEx
0090C8  2  20 5A 8F              jsr SmallBBox              ;jump to set bounding box size $09 and init other values
0090CB  2  BD A8 07              lda PseudoRandomBitReg+1,x
0090CE  2  29 03                 and #%00000011             ;set pseudorandom offset here
0090D0  2  A8                    tay
0090D1  2  B9 BF 90              lda FlyCCTimerData,y       ;load timer with pseudorandom offset
0090D4  2  8D 8F 07              sta FrenzyEnemyTimer
0090D7  2  A0 03                 ldy #$03                   ;load Y with default value
0090D9  2  AD CC 06              lda SecondaryHardMode
0090DC  2  F0 01                 beq MaxCC                  ;if secondary hard mode flag not set, do not increment Y
0090DE  2  C8                    iny                        ;otherwise, increment Y to allow as many as four onscreen
0090DF  2  84 00        MaxCC:   sty $00                    ;store whatever pseudorandom bits are in Y
0090E1  2  E4 00                 cpx $00                    ;compare enemy object buffer offset with Y
0090E3  2  B0 84                 bcs ChpChpEx               ;if X => Y, branch to leave
0090E5  2  BD A7 07              lda PseudoRandomBitReg,x
0090E8  2  29 03                 and #%00000011             ;get last two bits of LSFR, first part
0090EA  2  85 00                 sta $00                    ;and store in two places
0090EC  2  85 01                 sta $01
0090EE  2  A9 FB                 lda #$fb                   ;set vertical speed for cheep-cheep
0090F0  2  95 A0                 sta Enemy_Y_Speed,x
0090F2  2  A9 00                 lda #$00                   ;load default value
0090F4  2  A4 57                 ldy Player_X_Speed         ;check player's horizontal speed
0090F6  2  F0 07                 beq GSeed                  ;if player not moving left or right, skip this part
0090F8  2  A9 04                 lda #$04
0090FA  2  C0 19                 cpy #$19                   ;if moving to the right but not very quickly,
0090FC  2  90 01                 bcc GSeed                  ;do not change A
0090FE  2  0A                    asl                        ;otherwise, multiply A by 2
0090FF  2  48           GSeed:   pha                        ;save to stack
009100  2  18                    clc
009101  2  65 00                 adc $00                    ;add to last two bits of LSFR we saved earlier
009103  2  85 00                 sta $00                    ;save it there
009105  2  BD A8 07              lda PseudoRandomBitReg+1,x
009108  2  29 03                 and #%00000011             ;if neither of the last two bits of second LSFR set,
00910A  2  F0 07                 beq RSeed                  ;skip this part and save contents of $00
00910C  2  BD A9 07              lda PseudoRandomBitReg+2,x
00910F  2  29 0F                 and #%00001111             ;otherwise overwrite with lower nybble of
009111  2  85 00                 sta $00                    ;third LSFR part
009113  2  68           RSeed:   pla                        ;get value from stack we saved earlier
009114  2  18                    clc
009115  2  65 01                 adc $01                    ;add to last two bits of LSFR we saved in other place
009117  2  A8                    tay                        ;use as pseudorandom offset here
009118  2  B9 B3 90              lda FlyCCXSpeedData,y      ;get horizontal speed using pseudorandom offset
00911B  2  95 58                 sta Enemy_X_Speed,x
00911D  2  A9 01                 lda #$01                   ;set to move towards the right
00911F  2  95 46                 sta Enemy_MovingDir,x
009121  2  A5 57                 lda Player_X_Speed         ;if player moving left or right, branch ahead of this part
009123  2  D0 12                 bne D2XPos1
009125  2  A4 00                 ldy $00                    ;get first LSFR or third LSFR lower nybble
009127  2  98                    tya                        ;and check for d1 set
009128  2  29 02                 and #%00000010
00912A  2  F0 0B                 beq D2XPos1                ;if d1 not set, branch
00912C  2  B5 58                 lda Enemy_X_Speed,x
00912E  2  49 FF                 eor #$ff                   ;if d1 set, change horizontal speed
009130  2  18                    clc                        ;into two's compliment, thus moving in the opposite
009131  2  69 01                 adc #$01                   ;direction
009133  2  95 58                 sta Enemy_X_Speed,x
009135  2  F6 46                 inc Enemy_MovingDir,x      ;increment to move towards the left
009137  2  98           D2XPos1: tya                        ;get first LSFR or third LSFR lower nybble again
009138  2  29 02                 and #%00000010
00913A  2  F0 0F                 beq D2XPos2                ;check for d1 set again, branch again if not set
00913C  2  A5 86                 lda Player_X_Position      ;get player's horizontal position
00913E  2  18                    clc
00913F  2  79 A3 90              adc FlyCCXPositionData,y   ;if d1 set, add value obtained from pseudorandom offset
009142  2  95 87                 sta Enemy_X_Position,x     ;and save as enemy's horizontal position
009144  2  A5 6D                 lda Player_PageLoc         ;get player's page location
009146  2  69 00                 adc #$00                   ;add carry and jump past this part
009148  2  4C 57 91              jmp FinCCSt
00914B  2  A5 86        D2XPos2: lda Player_X_Position      ;get player's horizontal position
00914D  2  38                    sec
00914E  2  F9 A3 90              sbc FlyCCXPositionData,y   ;if d1 not set, subtract value obtained from pseudorandom
009151  2  95 87                 sta Enemy_X_Position,x     ;offset and save as enemy's horizontal position
009153  2  A5 6D                 lda Player_PageLoc         ;get player's page location
009155  2  E9 00                 sbc #$00                   ;subtract borrow
009157  2  95 6E        FinCCSt: sta Enemy_PageLoc,x        ;save as enemy's page location
009159  2  A9 01                 lda #$01
00915B  2  95 0F                 sta Enemy_Flag,x           ;set enemy's buffer flag
00915D  2  95 B6                 sta Enemy_Y_HighPos,x      ;set enemy's high vertical byte
00915F  2  A9 F8                 lda #$f8
009161  2  95 CF                 sta Enemy_Y_Position,x     ;put enemy below the screen, and we are done
009163  2  60                    rts
009164  2               
009164  2               InitBowser:
009164  2  A0 04                  ldy #$04              ;if the slot about to be checked is the slot
009166  2  C4 08        KKCheck:  cpy ObjectOffset      ;where bowser is being initialized, skip it
009168  2  F0 0F                  beq NoBowser
00916A  2  B9 16 00               lda Enemy_ID,y        ;otherwise check to see if a bowser object
00916D  2  C9 2D                  cmp #Bowser           ;exists in another slot
00916F  2  D0 08                  bne NoBowser          ;if not, branch to check another enemy slot
009171  2  A9 00                  lda #$00
009173  2  99 16 00               sta Enemy_ID,y        ;do this until any previous bowser objects are erased
009176  2  99 0F 00               sta Enemy_Flag,y
009179  2  88           NoBowser: dey                   ;loop until all slots are checked
00917A  2  10 EA                  bpl KKCheck           ;except the slot where bowser is being initialized
00917C  2               
00917C  2               CreateBowser:
00917C  2  20 A8 91           jsr DuplicateEnemyObj     ;jump to create another bowser object
00917F  2  8E 68 03           stx BowserFront_Offset    ;save offset of first here
009182  2  A9 00              lda #$00
009184  2  8D 63 03           sta BowserBodyControls    ;initialize bowser's body controls
009187  2  8D 69 03           sta BridgeCollapseOffset  ;and bridge collapse offset
00918A  2  B5 87              lda Enemy_X_Position,x
00918C  2  8D 66 03           sta BowserOrigXPos        ;store original horizontal position here
00918F  2  A9 DF              lda #$df
009191  2  8D 90 07           sta BowserFireBreathTimer ;store something here
009194  2  95 46              sta Enemy_MovingDir,x     ;and in moving direction
009196  2  A9 20              lda #$20
009198  2  8D 64 03           sta BowserFeetCounter     ;set bowser's feet timer and in enemy timer
00919B  2  9D 8A 07           sta EnemyFrameTimer,x
00919E  2  A9 05              lda #$05
0091A0  2  8D 83 04           sta BowserHitPoints       ;give bowser 5 hit points
0091A3  2  4A                 lsr
0091A4  2  8D 65 03           sta BowserMovementSpeed   ;set default movement speed here
0091A7  2  60                 rts
0091A8  2               
0091A8  2               DuplicateEnemyObj:
0091A8  2  A0 FF                ldy #$ff                ;start at beginning of enemy slots
0091AA  2  C8           FSLoop: iny                     ;increment one slot
0091AB  2  B9 0F 00             lda Enemy_Flag,y        ;check enemy buffer flag for empty slot
0091AE  2  D0 FA                bne FSLoop              ;if set, branch and keep checking
0091B0  2  8C CF 06             sty DuplicateObj_Offset ;otherwise set offset here
0091B3  2  8A                   txa                     ;transfer original enemy buffer offset
0091B4  2  09 80                ora #%10000000          ;store with d7 set as flag in new enemy
0091B6  2  99 0F 00             sta Enemy_Flag,y        ;slot as well as enemy offset
0091B9  2  B5 6E                lda Enemy_PageLoc,x
0091BB  2  99 6E 00             sta Enemy_PageLoc,y     ;copy page location and horizontal coordinates
0091BE  2  B5 87                lda Enemy_X_Position,x  ;from original enemy to new enemy
0091C0  2  99 87 00             sta Enemy_X_Position,y
0091C3  2  A9 01                lda #$01
0091C5  2  95 0F                sta Enemy_Flag,x        ;set flag as normal for original enemy
0091C7  2  99 B6 00             sta Enemy_Y_HighPos,y   ;set high vertical byte for new enemy
0091CA  2  B5 CF                lda Enemy_Y_Position,x
0091CC  2  99 CF 00             sta Enemy_Y_Position,y  ;copy vertical coordinate from original to new
0091CF  2  60           FlmEx:  rts                     ;and then leave
0091D0  2               
0091D0  2               ;--------------------------------
0091D0  2               
0091D0  2               FlameYPosData:
0091D0  2  90 80 70 90        .byte $90, $80, $70, $90
0091D4  2               
0091D4  2               FlameYMFAdderData:
0091D4  2  FF 01              .byte $ff, $01
0091D6  2               
0091D6  2               InitBowserFlame:
0091D6  2  AD 8F 07             lda FrenzyEnemyTimer        ;if timer not expired yet, branch to leave
0091D9  2  D0 F4                bne FlmEx
0091DB  2  9D 34 04             sta Enemy_Y_MoveForce,x     ;reset something here
0091DE  2  A5 FD                lda NoiseSoundQueue
0091E0  2  09 02                ora #Sfx_BowserFlame        ;load bowser's flame sound into queue
0091E2  2  85 FD                sta NoiseSoundQueue
0091E4  2  AC 68 03             ldy BowserFront_Offset      ;get bowser's buffer offset
0091E7  2  B9 16 00             lda Enemy_ID,y              ;check for bowser
0091EA  2  C9 2D                cmp #Bowser
0091EC  2  F0 31                beq SpawnFromMouth          ;branch if found
0091EE  2  20 12 9E             jsr SetFlameTimer           ;get timer data based on flame counter
0091F1  2  18                   clc
0091F2  2  69 20                adc #$20                    ;add 32 frames by default
0091F4  2  AC CC 06             ldy SecondaryHardMode
0091F7  2  F0 03                beq SetFrT                  ;if secondary mode flag not set, use as timer setting
0091F9  2  38                   sec
0091FA  2  E9 10                sbc #$10                    ;otherwise subtract 16 frames for secondary hard mode
0091FC  2  8D 8F 07     SetFrT: sta FrenzyEnemyTimer        ;set timer accordingly
0091FF  2  BD A7 07             lda PseudoRandomBitReg,x
009202  2  29 03                and #%00000011              ;get 2 LSB from first part of LSFR
009204  2  9D 17 04             sta BowserFlamePRandomOfs,x ;set here
009207  2  A8                   tay                         ;use as offset
009208  2  B9 D0 91             lda FlameYPosData,y         ;load vertical position based on pseudorandom offset
00920B  2               
00920B  2               PutAtRightExtent:
00920B  2  95 CF              sta Enemy_Y_Position,x    ;set vertical position
00920D  2  AD 1D 07           lda ScreenRight_X_Pos
009210  2  18                 clc
009211  2  69 20              adc #$20                  ;place enemy 32 pixels beyond right side of screen
009213  2  95 87              sta Enemy_X_Position,x
009215  2  AD 1B 07           lda ScreenRight_PageLoc
009218  2  69 00              adc #$00                  ;add carry
00921A  2  95 6E              sta Enemy_PageLoc,x
00921C  2  4C 52 92           jmp FinishFlame           ;skip this part to finish setting values
00921F  2               
00921F  2               SpawnFromMouth:
00921F  2  B9 87 00            lda Enemy_X_Position,y    ;get bowser's horizontal position
009222  2  38                  sec
009223  2  E9 0E               sbc #$0e                  ;subtract 14 pixels
009225  2  95 87               sta Enemy_X_Position,x    ;save as flame's horizontal position
009227  2  B9 6E 00            lda Enemy_PageLoc,y
00922A  2  95 6E               sta Enemy_PageLoc,x       ;copy page location from bowser to flame
00922C  2  B9 CF 00            lda Enemy_Y_Position,y
00922F  2  18                  clc                       ;add 8 pixels to bowser's vertical position
009230  2  69 08               adc #$08
009232  2  95 CF               sta Enemy_Y_Position,x    ;save as flame's vertical position
009234  2  BD A7 07            lda PseudoRandomBitReg,x
009237  2  29 03               and #%00000011            ;get 2 LSB from first part of LSFR
009239  2  9D 17 04            sta Enemy_YMF_Dummy,x     ;save here
00923C  2  A8                  tay                       ;use as offset
00923D  2  B9 D0 91            lda FlameYPosData,y       ;get value here using bits as offset
009240  2  A0 00               ldy #$00                  ;load default offset
009242  2  D5 CF               cmp Enemy_Y_Position,x    ;compare value to flame's current vertical position
009244  2  90 01               bcc SetMF                 ;if less, do not increment offset
009246  2  C8                  iny                       ;otherwise increment now
009247  2  B9 D4 91     SetMF: lda FlameYMFAdderData,y   ;get value here and save
00924A  2  9D 34 04            sta Enemy_Y_MoveForce,x   ;to vertical movement force
00924D  2  A9 00               lda #$00
00924F  2  8D CB 06            sta EnemyFrenzyBuffer     ;clear enemy frenzy buffer
009252  2               
009252  2               FinishFlame:
009252  2  A9 08              lda #$08                 ;set $08 for bounding box control
009254  2  9D 9A 04           sta Enemy_BoundBoxCtrl,x
009257  2  A9 01              lda #$01                 ;set high byte of vertical and
009259  2  95 B6              sta Enemy_Y_HighPos,x    ;enemy buffer flag
00925B  2  95 0F              sta Enemy_Flag,x
00925D  2  4A                 lsr
00925E  2  9D 01 04           sta Enemy_X_MoveForce,x  ;initialize horizontal movement force, and
009261  2  95 1E              sta Enemy_State,x        ;enemy state
009263  2  60                 rts
009264  2               
009264  2               ;--------------------------------
009264  2               
009264  2               FireworksXPosData:
009264  2  00 30 60 60        .byte $00, $30, $60, $60, $00, $20
009268  2  00 20        
00926A  2               
00926A  2               FireworksYPosData:
00926A  2  60 40 70 40        .byte $60, $40, $70, $40, $60, $30
00926E  2  60 30        
009270  2               
009270  2               InitFireworks:
009270  2  AD 8F 07               lda FrenzyEnemyTimer         ;if timer not expired yet, branch to leave
009273  2  D0 47                  bne ExitFWk
009275  2  A9 20                  lda #$20                     ;otherwise reset timer
009277  2  8D 8F 07               sta FrenzyEnemyTimer
00927A  2  CE D7 06               dec FireworksCounter         ;decrement for each explosion
00927D  2  A0 06                  ldy #$06                     ;start at last slot
00927F  2  88           StarFChk: dey
009280  2  B9 16 00               lda Enemy_ID,y               ;check for presence of star flag object
009283  2  C9 31                  cmp #StarFlagObject          ;if there isn't a star flag object,
009285  2  D0 F8                  bne StarFChk                 ;routine goes into infinite loop = crash
009287  2  B9 87 00               lda Enemy_X_Position,y
00928A  2  38                     sec                          ;get horizontal coordinate of star flag object, then
00928B  2  E9 30                  sbc #$30                     ;subtract 48 pixels from it and save to
00928D  2  48                     pha                          ;the stack
00928E  2  B9 6E 00               lda Enemy_PageLoc,y
009291  2  E9 00                  sbc #$00                     ;subtract the carry from the page location
009293  2  85 00                  sta $00                      ;of the star flag object
009295  2  AD D7 06               lda FireworksCounter         ;get fireworks counter
009298  2  18                     clc
009299  2  79 1E 00               adc Enemy_State,y            ;add state of star flag object (possibly not necessary)
00929C  2  A8                     tay                          ;use as offset
00929D  2  68                     pla                          ;get saved horizontal coordinate of star flag - 48 pixels
00929E  2  18                     clc
00929F  2  79 64 92               adc FireworksXPosData,y      ;add number based on offset of fireworks counter
0092A2  2  95 87                  sta Enemy_X_Position,x       ;store as the fireworks object horizontal coordinate
0092A4  2  A5 00                  lda $00
0092A6  2  69 00                  adc #$00                     ;add carry and store as page location for
0092A8  2  95 6E                  sta Enemy_PageLoc,x          ;the fireworks object
0092AA  2  B9 6A 92               lda FireworksYPosData,y      ;get vertical position using same offset
0092AD  2  95 CF                  sta Enemy_Y_Position,x       ;and store as vertical coordinate for fireworks object
0092AF  2  A9 01                  lda #$01
0092B1  2  95 B6                  sta Enemy_Y_HighPos,x        ;store in vertical high byte
0092B3  2  95 0F                  sta Enemy_Flag,x             ;and activate enemy buffer flag
0092B5  2  4A                     lsr
0092B6  2  95 58                  sta ExplosionGfxCounter,x    ;initialize explosion counter
0092B8  2  A9 08                  lda #$08
0092BA  2  95 A0                  sta ExplosionTimerCounter,x  ;set explosion timing counter
0092BC  2  60           ExitFWk:  rts
0092BD  2               
0092BD  2               ;--------------------------------
0092BD  2               
0092BD  2               Bitmasks:
0092BD  2  01 02 04 08        .byte %00000001, %00000010, %00000100, %00001000, %00010000, %00100000, %01000000, %10000000
0092C1  2  10 20 40 80  
0092C5  2               
0092C5  2               Enemy17YPosData:
0092C5  2  40 30 90 50        .byte $40, $30, $90, $50, $20, $60, $a0, $70
0092C9  2  20 60 A0 70  
0092CD  2               
0092CD  2               SwimCC_IDData:
0092CD  2  0A 0B              .byte $0a, $0b
0092CF  2               
0092CF  2               BulletBillCheepCheep:
0092CF  2  AD 8F 07              lda FrenzyEnemyTimer      ;if timer not expired yet, branch to leave
0092D2  2  D0 6F                 bne ExF17
0092D4  2  AD 4E 07              lda AreaType              ;are we in a water-type level?
0092D7  2  D0 57                 bne DoBulletBills         ;if not, branch elsewhere
0092D9  2  E0 03                 cpx #$03                  ;are we past third enemy slot?
0092DB  2  B0 66                 bcs ExF17                 ;if so, branch to leave
0092DD  2  A0 00                 ldy #$00                  ;load default offset
0092DF  2  BD A7 07              lda PseudoRandomBitReg,x
0092E2  2  C9 AA                 cmp #$aa                  ;check first part of LSFR against preset value
0092E4  2  90 01                 bcc ChkW2                 ;if less than preset, do not increment offset
0092E6  2  C8                    iny                       ;otherwise increment
0092E7  2  AD 5F 07     ChkW2:   lda WorldNumber           ;check world number
0092EA  2  C9 01                 cmp #World2
0092EC  2  F0 01                 beq Get17ID               ;if we're on world 2, do not increment offset
0092EE  2  C8                    iny                       ;otherwise increment
0092EF  2  98           Get17ID: tya
0092F0  2  29 01                 and #%00000001            ;mask out all but last bit of offset
0092F2  2  A8                    tay
0092F3  2  B9 CD 92              lda SwimCC_IDData,y       ;load identifier for cheep-cheeps
0092F6  2  95 16        Set17ID: sta Enemy_ID,x            ;store whatever's in A as enemy identifier
0092F8  2  AD DD 06              lda BitMFilter
0092FB  2  C9 FF                 cmp #$ff                  ;if not all bits set, skip init part and compare bits
0092FD  2  D0 05                 bne GetRBit
0092FF  2  A9 00                 lda #$00                  ;initialize vertical position filter
009301  2  8D DD 06              sta BitMFilter
009304  2  BD A7 07     GetRBit: lda PseudoRandomBitReg,x  ;get first part of LSFR
009307  2  29 07                 and #%00000111            ;mask out all but 3 LSB
009309  2  A8           ChkRBit: tay                       ;use as offset
00930A  2  B9 BD 92              lda Bitmasks,y            ;load bitmask
00930D  2  2C DD 06              bit BitMFilter            ;perform AND on filter without changing it
009310  2  F0 07                 beq AddFBit
009312  2  C8                    iny                       ;increment offset
009313  2  98                    tya
009314  2  29 07                 and #%00000111            ;mask out all but 3 LSB thus keeping it 0-7
009316  2  4C 09 93              jmp ChkRBit               ;do another check
009319  2  0D DD 06     AddFBit: ora BitMFilter            ;add bit to already set bits in filter
00931C  2  8D DD 06              sta BitMFilter            ;and store
00931F  2  B9 C5 92              lda Enemy17YPosData,y     ;load vertical position using offset
009322  2  20 0B 92              jsr PutAtRightExtent      ;set vertical position and other values
009325  2  9D 17 04              sta Enemy_YMF_Dummy,x     ;initialize dummy variable
009328  2  A9 20                 lda #$20                  ;set timer
00932A  2  8D 8F 07              sta FrenzyEnemyTimer
00932D  2  4C 79 8E              jmp CheckpointEnemyID     ;process our new enemy object
009330  2               
009330  2               DoBulletBills:
009330  2  A0 FF                  ldy #$ff                   ;start at beginning of enemy slots
009332  2  C8           BB_SLoop: iny                        ;move onto the next slot
009333  2  C0 05                  cpy #$05                   ;branch to play sound if we've done all slots
009335  2  B0 0D                  bcs FireBulletBill
009337  2  B9 0F 00               lda Enemy_Flag,y           ;if enemy buffer flag not set,
00933A  2  F0 F6                  beq BB_SLoop               ;loop back and check another slot
00933C  2  B9 16 00               lda Enemy_ID,y
00933F  2  C9 08                  cmp #BulletBill_FrenzyVar  ;check enemy identifier for
009341  2  D0 EF                  bne BB_SLoop               ;bullet bill object (frenzy variant)
009343  2  60           ExF17:    rts                        ;if found, leave
009344  2               
009344  2               FireBulletBill:
009344  2  A5 FE              lda Square2SoundQueue
009346  2  09 08              ora #Sfx_Blast            ;play fireworks/gunfire sound
009348  2  85 FE              sta Square2SoundQueue
00934A  2  A9 08              lda #BulletBill_FrenzyVar ;load identifier for bullet bill object
00934C  2  D0 A8              bne Set17ID               ;unconditional branch
00934E  2               
00934E  2               ;--------------------------------
00934E  2               ;$00 - used to store Y position of group enemies
00934E  2               ;$01 - used to store enemy ID
00934E  2               ;$02 - used to store page location of right side of screen
00934E  2               ;$03 - used to store X position of right side of screen
00934E  2               
00934E  2               HandleGroupEnemies:
00934E  2  A0 00                ldy #$00                  ;load value for green koopa troopa
009350  2  38                   sec
009351  2  E9 37                sbc #$37                  ;subtract $37 from second byte read
009353  2  48                   pha                       ;save result in stack for now
009354  2  C9 04                cmp #$04                  ;was byte in $3b-$3e range?
009356  2  B0 10                bcs SnglID                ;if so, branch
009358  2  48                   pha                       ;save another copy to stack
009359  2  A0 06                ldy #Goomba               ;load value for goomba enemy
00935B  2  AD 7D 07             lda PrimaryHardMode       ;if primary hard mode flag not set,
00935E  2  F0 07                beq PullID                ;branch, otherwise change to value
009360  2               .ifdef ANN
009360  2  AD FB 07             lda HardWorldFlag
009363  2  D0 02                bne PullID
009365  2  A0 02                ldy #BuzzyBeetle
009367  2               .else
009367  2                       ldy #BuzzyBeetle          ;for buzzy beetle
009367  2               .endif
009367  2  68           PullID: pla                       ;get second copy from stack
009368  2  84 01        SnglID: sty $01                   ;save enemy id here
00936A  2  A0 B0                ldy #$b0                  ;load default y coordinate
00936C  2  29 02                and #$02                  ;check to see if d1 was set
00936E  2  F0 02                beq SetYGp                ;if so, move y coordinate up,
009370  2  A0 70                ldy #$70                  ;otherwise branch and use default
009372  2  84 00        SetYGp: sty $00                   ;save y coordinate here
009374  2  AD 1B 07             lda ScreenRight_PageLoc   ;get page number of right edge of screen
009377  2  85 02                sta $02                   ;save here
009379  2  AD 1D 07             lda ScreenRight_X_Pos     ;get pixel coordinate of right edge
00937C  2  85 03                sta $03                   ;save here
00937E  2  A0 02                ldy #$02                  ;load two enemies by default
009380  2  68                   pla                       ;get first copy from stack
009381  2  4A                   lsr                       ;check to see if d0 was set
009382  2  90 01                bcc CntGrp                ;if not, use default value
009384  2  C8                   iny                       ;otherwise increment to three enemies
009385  2  8C D3 06     CntGrp: sty NumberofGroupEnemies  ;save number of enemies here
009388  2  A2 FF        GrLoop: ldx #$ff                  ;start at beginning of enemy buffers
00938A  2  E8           GSltLp: inx                       ;increment and branch if past
00938B  2  E0 05                cpx #$05                  ;end of buffers
00938D  2  B0 2D                bcs NextED
00938F  2  B5 0F                lda Enemy_Flag,x          ;check to see if enemy is already
009391  2  D0 F7                bne GSltLp                ;stored in buffer, and branch if so
009393  2  A5 01                lda $01
009395  2  95 16                sta Enemy_ID,x            ;store enemy object identifier
009397  2  A5 02                lda $02
009399  2  95 6E                sta Enemy_PageLoc,x       ;store page location for enemy object
00939B  2  A5 03                lda $03
00939D  2  95 87                sta Enemy_X_Position,x    ;store x coordinate for enemy object
00939F  2  18                   clc
0093A0  2  69 18                adc #$18                  ;add 24 pixels for next enemy
0093A2  2  85 03                sta $03
0093A4  2  A5 02                lda $02                   ;add carry to page location for
0093A6  2  69 00                adc #$00                  ;next enemy
0093A8  2  85 02                sta $02
0093AA  2  A5 00                lda $00                   ;store y coordinate for enemy object
0093AC  2  95 CF                sta Enemy_Y_Position,x
0093AE  2  A9 01                lda #$01                  ;activate flag for buffer, and
0093B0  2  95 B6                sta Enemy_Y_HighPos,x     ;put enemy within the screen vertically
0093B2  2  95 0F                sta Enemy_Flag,x
0093B4  2  20 79 8E             jsr CheckpointEnemyID     ;process each enemy object separately
0093B7  2  CE D3 06             dec NumberofGroupEnemies  ;do this until we run out of enemy objects
0093BA  2  D0 CC                bne GrLoop
0093BC  2  4C 6B 8E     NextED: jmp Inc2B                 ;jump to increment data offset and leave
0093BF  2               
0093BF  2               ;--------------------------------
0093BF  2               ;$00 - used to store piranha plant attribute data
0093BF  2               ;$01 - used to store piranha plant range data for player
0093BF  2               
0093BF  2               InitPiranhaPlant:
0093BF  2               .ifndef ANN
0093BF  2                        lda #$22                     ;set default attribute and range data here
0093BF  2                        sta $00                      ;range data is used to detect how close player is
0093BF  2                        lda #$13                     ;to the piranha plant to keep it inside the pipe
0093BF  2                        sta $01                      ;default data makes red piranha plants
0093BF  2                        lda HardWorldFlag
0093BF  2                        bne PatchPP                  ;use default data if in worlds A-D
0093BF  2                        lda WorldNumber
0093BF  2                        cmp #$03
0093BF  2                        bcs PatchPP                  ;use default data if in worlds 4-8
0093BF  2                        dec $00
0093BF  2                        lda #$21                     ;otherwise make green piranha plant instead
0093BF  2                        sta $01
0093BF  2               PatchPP: lda $00
0093BF  2                        sta EnemyAttributeData+PiranhaPlant  ;patch over attribute and range data
0093BF  2                        lda $01
0093BF  2                        sta ChkPlayerNearPipe+3
0093BF  2               .endif
0093BF  2  A9 01                 lda #$01                     ;set initial speed
0093C1  2  95 58                 sta PiranhaPlant_Y_Speed,x
0093C3  2  4A                    lsr
0093C4  2  95 1E                 sta Enemy_State,x            ;initialize enemy state and what would normally
0093C6  2  95 A0                 sta PiranhaPlant_MoveFlag,x  ;be used as vertical speed, but not in this case
0093C8  2  B5 CF                 lda Enemy_Y_Position,x
0093CA  2  9D 34 04              sta PiranhaPlantDownYPos,x   ;save original vertical coordinate here
0093CD  2  38                    sec
0093CE  2  E9 18                 sbc #$18
0093D0  2  9D 17 04              sta PiranhaPlantUpYPos,x     ;save original vertical coordinate - 24 pixels here
0093D3  2  A9 09                 lda #$09
0093D5  2  4C 12 94              jmp SetBBox2                 ;set specific value for bounding box control
0093D8  2               
0093D8  2               ;--------------------------------
0093D8  2               
0093D8  2               InitEnemyFrenzy:
0093D8  2  B5 16              lda Enemy_ID,x        ;load enemy identifier
0093DA  2  8D CB 06           sta EnemyFrenzyBuffer ;save in enemy frenzy buffer
0093DD  2  38                 sec
0093DE  2  E9 12              sbc #$12              ;subtract 12 and use as offset for jump engine
0093E0  2  20 0F 6D           jsr JumpEngine
0093E3  2               
0093E3  2               ;frenzy object jump table
0093E3  2  B8 8F              .word LakituAndSpinyHandler
0093E5  2  07 94              .word NoFrenzyCode
0093E7  2  C3 90              .word InitFlyingCheepCheep
0093E9  2  D6 91              .word InitBowserFlame
0093EB  2  70 92              .word InitFireworks
0093ED  2  CF 92              .word BulletBillCheepCheep
0093EF  2               
0093EF  2               .ifndef ANN
0093EF  2               NoFrenzyCode:
0093EF  2                     rts
0093EF  2               .endif
0093EF  2               
0093EF  2               EndFrenzy:
0093EF  2  A0 05                   ldy #$05               ;start at last slot
0093F1  2  B9 16 00     LakituChk: lda Enemy_ID,y         ;check enemy identifiers
0093F4  2  C9 11                   cmp #Lakitu            ;for lakitu
0093F6  2  D0 05                   bne NextFSlot
0093F8  2  A9 01                   lda #$01               ;if found, set state
0093FA  2  99 1E 00                sta Enemy_State,y
0093FD  2  88           NextFSlot: dey                    ;move onto the next slot
0093FE  2  10 F1                   bpl LakituChk          ;do this until all slots are checked
009400  2  A9 00                   lda #$00
009402  2  8D CB 06                sta EnemyFrenzyBuffer  ;empty enemy frenzy buffer
009405  2  95 0F                   sta Enemy_Flag,x       ;disable enemy buffer flag for this object
009407  2               .ifdef ANN
009407  2               NoFrenzyCode:
009407  2               .endif
009407  2  60                      rts
009408  2               
009408  2               ;--------------------------------
009408  2               
009408  2               InitJumpGPTroopa:
009408  2  A9 02                   lda #$02                  ;set for movement to the left
00940A  2  95 46                   sta Enemy_MovingDir,x
00940C  2               .ifdef ANN
00940C  2  A9 F8                   lda #$f8
00940E  2               .else
00940E  2                          lda #$f4                  ;set horizontal speed
00940E  2               .endif
00940E  2  95 58                   sta Enemy_X_Speed,x
009410  2  A9 03        TallBBox2: lda #$03                  ;set specific value for bounding box control
009412  2  9D 9A 04     SetBBox2:  sta Enemy_BoundBoxCtrl,x  ;set bounding box control then leave
009415  2  60                      rts
009416  2               
009416  2               ;--------------------------------
009416  2               
009416  2               InitBalPlatform:
009416  2  D6 CF                dec Enemy_Y_Position,x    ;raise vertical position by two pixels
009418  2  D6 CF                dec Enemy_Y_Position,x
00941A  2  AC CC 06             ldy SecondaryHardMode     ;if secondary hard mode flag not set,
00941D  2  D0 05                bne AlignP                ;branch ahead
00941F  2  A0 02                ldy #$02                  ;otherwise set value here
009421  2  20 A8 94             jsr PosPlatform           ;do a sub to add or subtract pixels
009424  2  A0 FF        AlignP: ldy #$ff                  ;set default value here for now
009426  2  AD A0 03             lda BalPlatformAlignment  ;get current balance platform alignment
009429  2  95 1E                sta Enemy_State,x         ;set platform alignment to object state here
00942B  2  10 02                bpl SetBPA                ;if old alignment $ff, put $ff as alignment for negative
00942D  2  8A                   txa                       ;if old contents already $ff, put
00942E  2  A8                   tay                       ;object offset as alignment to make next positive
00942F  2  8C A0 03     SetBPA: sty BalPlatformAlignment  ;store whatever value's in Y here
009432  2  A9 00                lda #$00
009434  2  95 46                sta Enemy_MovingDir,x     ;init moving direction
009436  2  A8                   tay                       ;init Y
009437  2  20 A8 94             jsr PosPlatform           ;do a sub to add 8 pixels, then run shared code here
00943A  2               
00943A  2               ;--------------------------------
00943A  2               
00943A  2               InitDropPlatform:
00943A  2  A9 FF              lda #$ff
00943C  2  9D A2 03           sta PlatformCollisionFlag,x  ;set some value here
00943F  2  4C 5F 94           jmp CommonPlatCode           ;then jump ahead to execute more code
009442  2               
009442  2               ;--------------------------------
009442  2               
009442  2               InitHoriPlatform:
009442  2  A9 00              lda #$00
009444  2  95 58              sta XMoveSecondaryCounter,x  ;init one of the moving counters
009446  2  4C 5F 94           jmp CommonPlatCode           ;jump ahead to execute more code
009449  2               
009449  2               ;--------------------------------
009449  2               
009449  2               InitVertPlatform:
009449  2  A0 40               ldy #$40                    ;set default value here
00944B  2  B5 CF               lda Enemy_Y_Position,x      ;check vertical position
00944D  2  10 07               bpl SetYO                   ;if above a certain point, skip this part
00944F  2  49 FF               eor #$ff
009451  2  18                  clc                         ;otherwise get two's compliment
009452  2  69 01               adc #$01
009454  2  A0 C0               ldy #$c0                    ;get alternate value to add to vertical position
009456  2  9D 01 04     SetYO: sta YPlatformTopYPos,x      ;save as top vertical position
009459  2  98                  tya
00945A  2  18                  clc                         ;load value from earlier, add number of pixels
00945B  2  75 CF               adc Enemy_Y_Position,x      ;to vertical position
00945D  2  95 58               sta YPlatformCenterYPos,x   ;save result as central vertical position
00945F  2               
00945F  2               ;--------------------------------
00945F  2               
00945F  2               CommonPlatCode:
00945F  2  20 77 8F             jsr InitVStf              ;do a sub to init certain other values
009462  2  A9 05        SPBBox: lda #$05                  ;set default bounding box size control
009464  2  AC 4E 07             ldy AreaType
009467  2  C0 03                cpy #$03                  ;check for castle-type level
009469  2  F0 07                beq CasPBB                ;use default value if found
00946B  2  AC CC 06             ldy SecondaryHardMode     ;otherwise check for secondary hard mode flag
00946E  2  D0 02                bne CasPBB                ;if set, use default value
009470  2  A9 06                lda #$06                  ;use alternate value if not castle or secondary not set
009472  2  9D 9A 04     CasPBB: sta Enemy_BoundBoxCtrl,x  ;set bounding box size control here and leave
009475  2  60                   rts
009476  2               
009476  2               ;--------------------------------
009476  2               
009476  2               LargeLiftUp:
009476  2  20 82 94           jsr PlatLiftUp       ;execute code for platforms going up
009479  2  4C 7F 94           jmp LargeLiftBBox    ;overwrite bounding box for large platforms
00947C  2               
00947C  2               LargeLiftDown:
00947C  2  20 8E 94           jsr PlatLiftDown     ;execute code for platforms going down
00947F  2               
00947F  2               LargeLiftBBox:
00947F  2  4C 62 94           jmp SPBBox           ;jump to overwrite bounding box size control
009482  2               
009482  2               ;--------------------------------
009482  2               
009482  2               PlatLiftUp:
009482  2  A9 10              lda #$10                 ;set movement amount here
009484  2  9D 34 04           sta Enemy_Y_MoveForce,x
009487  2  A9 FF              lda #$ff                 ;set moving speed for platforms going up
009489  2  95 A0              sta Enemy_Y_Speed,x
00948B  2  4C 97 94           jmp CommonSmallLift      ;skip ahead to part we should be executing
00948E  2               
00948E  2               ;--------------------------------
00948E  2               
00948E  2               PlatLiftDown:
00948E  2  A9 F0              lda #$f0                 ;set movement amount here
009490  2  9D 34 04           sta Enemy_Y_MoveForce,x
009493  2  A9 00              lda #$00                 ;set moving speed for platforms going down
009495  2  95 A0              sta Enemy_Y_Speed,x
009497  2               
009497  2               ;--------------------------------
009497  2               
009497  2               CommonSmallLift:
009497  2  A0 01              ldy #$01
009499  2  20 A8 94           jsr PosPlatform           ;do a sub to add 12 pixels due to preset value
00949C  2  A9 04              lda #$04
00949E  2  9D 9A 04           sta Enemy_BoundBoxCtrl,x  ;set bounding box control for small platforms
0094A1  2  60                 rts
0094A2  2               
0094A2  2               ;--------------------------------
0094A2  2               
0094A2  2               PlatPosDataLow:
0094A2  2  08 0C F8           .byte $08,$0c,$f8
0094A5  2               
0094A5  2               PlatPosDataHigh:
0094A5  2  00 00 FF           .byte $00,$00,$ff
0094A8  2               
0094A8  2               PosPlatform:
0094A8  2  B5 87              lda Enemy_X_Position,x  ;get horizontal coordinate
0094AA  2  18                 clc
0094AB  2  79 A2 94           adc PlatPosDataLow,y    ;add or subtract pixels depending on offset
0094AE  2  95 87              sta Enemy_X_Position,x  ;store as new horizontal coordinate
0094B0  2  B5 6E              lda Enemy_PageLoc,x
0094B2  2  79 A5 94           adc PlatPosDataHigh,y   ;add or subtract page location depending on offset
0094B5  2  95 6E              sta Enemy_PageLoc,x     ;store as new page location
0094B7  2               .ifdef ANN
0094B7  2               EndOfEnemyInitCode:
0094B7  2               NoRunCode:
0094B7  2               NoMoveCode:
0094B7  2  60                 rts                     ;and go back
0094B8  2               .else
0094B8  2                     rts
0094B8  2               EndOfEnemyInitCode:
0094B8  2                     rts
0094B8  2               .endif
0094B8  2               
0094B8  2               ;-------------------------------------------------------------------------------------
0094B8  2               
0094B8  2               RunEnemyObjectsCore:
0094B8  2  A6 08               ldx ObjectOffset  ;get offset for enemy object buffer
0094BA  2  A9 00               lda #$00          ;load value 0 for jump engine by default
0094BC  2  B4 16               ldy Enemy_ID,x
0094BE  2  C0 15               cpy #$15          ;if enemy object < $15, use default value
0094C0  2  90 03               bcc JmpEO
0094C2  2  98                  tya               ;otherwise subtract $14 from the value and use
0094C3  2  E9 14               sbc #$14          ;as value for jump engine
0094C5  2  20 0F 6D     JmpEO: jsr JumpEngine
0094C8  2               
0094C8  2  15 95              .word RunNormalEnemies  ;for objects $00-$14
0094CA  2               
0094CA  2  69 95              .word RunBowserFlame    ;for objects $15-$1f
0094CC  2  CE 9E              .word RunFireworks
0094CE  2  B7 94              .word NoRunCode
0094D0  2  B7 94              .word NoRunCode
0094D2  2  B7 94              .word NoRunCode
0094D4  2  B7 94              .word NoRunCode
0094D6  2  7B 95              .word RunFirebarObj
0094D8  2  7B 95              .word RunFirebarObj
0094DA  2  7B 95              .word RunFirebarObj
0094DC  2  7B 95              .word RunFirebarObj
0094DE  2  7B 95              .word RunFirebarObj
0094E0  2               
0094E0  2  7B 95              .word RunFirebarObj     ;for objects $20-$2f
0094E2  2  7B 95              .word RunFirebarObj
0094E4  2  7B 95              .word RunFirebarObj
0094E6  2  B7 94              .word NoRunCode
0094E8  2  99 95              .word RunLargePlatform
0094EA  2  99 95              .word RunLargePlatform
0094EC  2  99 95              .word RunLargePlatform
0094EE  2  99 95              .word RunLargePlatform
0094F0  2  99 95              .word RunLargePlatform
0094F2  2  99 95              .word RunLargePlatform
0094F4  2  99 95              .word RunLargePlatform
0094F6  2  81 95              .word RunSmallPlatform
0094F8  2  81 95              .word RunSmallPlatform
0094FA  2  9E 9C              .word RunBowser
0094FC  2  89 88              .word PowerUpObjHandler
0094FE  2  22 85              .word VineObjectHandler
009500  2               
009500  2  B7 94              .word NoRunCode         ;for objects $30-$35
009502  2  12 9F              .word RunStarFlagObj
009504  2  85 84              .word JumpspringHandler
009506  2  B7 94              .word NoRunCode
009508  2  64 83              .word WarpZoneObject
00950A  2  0C 95              .word RunRetainerObj
00950C  2               
00950C  2               ;--------------------------------
00950C  2               
00950C  2               .ifndef ANN
00950C  2               NoRunCode:
00950C  2                     rts
00950C  2               .endif
00950C  2               
00950C  2               ;--------------------------------
00950C  2               
00950C  2               RunRetainerObj:
00950C  2  20 A4 BE           jsr GetEnemyOffscreenBits
00950F  2  20 47 BE           jsr RelativeEnemyPosition
009512  2  4C 37 B5           jmp EnemyGfxHandler
009515  2               
009515  2               ;--------------------------------
009515  2               
009515  2               RunNormalEnemies:
009515  2  A9 00                  lda #$00                  ;init sprite attributes
009517  2  9D C5 03               sta Enemy_SprAttrib,x
00951A  2  20 A4 BE               jsr GetEnemyOffscreenBits
00951D  2  20 47 BE               jsr RelativeEnemyPosition
009520  2  20 37 B5               jsr EnemyGfxHandler
009523  2  20 F3 AE               jsr GetEnemyBoundBox
009526  2  20 60 AC               jsr EnemyToBGCollisionDet
009529  2  20 98 A6               jsr EnemiesCollision
00952C  2  20 A7 A4               jsr PlayerEnemyCollision
00952F  2  AC 47 07               ldy TimerControl          ;if master timer control set, skip to last routine
009532  2  D0 03                  bne SkipMove
009534  2  20 3A 95               jsr EnemyMovementSubs
009537  2  4C B1 A2     SkipMove: jmp OffscreenBoundsCheck
00953A  2               
00953A  2               EnemyMovementSubs:
00953A  2  B5 16              lda Enemy_ID,x
00953C  2  20 0F 6D           jsr JumpEngine
00953F  2               
00953F  2  AB 96              .word MoveNormalEnemy      ;only objects $00-$14 use this table
009541  2  AB 96              .word MoveNormalEnemy
009543  2  AB 96              .word MoveNormalEnemy
009545  2  AB 96              .word MoveNormalEnemy
009547  2  rr rr              .word MoveUpsideDownPiranhaP
009549  2  0C 96              .word ProcHammerBro
00954B  2  AB 96              .word MoveNormalEnemy
00954D  2  C2 97              .word MoveBloober
00954F  2  6F 98              .word MoveBulletBill
009551  2  B7 94              .word NoMoveCode
009553  2  83 98              .word MoveSwimmingCheepCheep
009555  2  83 98              .word MoveSwimmingCheepCheep
009557  2  E4 95              .word MovePodoboo
009559  2  E0 9F              .word MovePiranhaPlant
00955B  2  32 97              .word MoveJumpingEnemy
00955D  2  38 97              .word ProcMoveRedPTroopa
00955F  2  5E 97              .word MoveFlyGreenPTroopa
009561  2  61 9B              .word MoveLakitu
009563  2  AB 96              .word MoveNormalEnemy
009565  2  B7 94              .word NoMoveCode            ;dummy
009567  2  18 9B              .word MoveFlyingCheepCheep
009569  2               
009569  2               ;--------------------------------
009569  2               
009569  2               .ifndef ANN
009569  2               NoMoveCode:
009569  2                     rts
009569  2               .endif
009569  2               
009569  2               ;--------------------------------
009569  2               
009569  2               RunBowserFlame:
009569  2  20 24 9E           jsr ProcBowserFlame
00956C  2  20 A4 BE           jsr GetEnemyOffscreenBits
00956F  2  20 47 BE           jsr RelativeEnemyPosition
009572  2  20 F3 AE           jsr GetEnemyBoundBox
009575  2  20 A7 A4           jsr PlayerEnemyCollision
009578  2  4C B1 A2           jmp OffscreenBoundsCheck
00957B  2               
00957B  2               ;--------------------------------
00957B  2               
00957B  2               RunFirebarObj:
00957B  2  20 75 99           jsr ProcFirebar
00957E  2  4C B1 A2           jmp OffscreenBoundsCheck
009581  2               
009581  2               ;--------------------------------
009581  2               
009581  2               RunSmallPlatform:
009581  2  20 A4 BE           jsr GetEnemyOffscreenBits
009584  2  20 47 BE           jsr RelativeEnemyPosition
009587  2  20 FC AE           jsr SmallPlatformBoundBox
00958A  2  20 EC A7           jsr SmallPlatformCollision
00958D  2  20 47 BE           jsr RelativeEnemyPosition
009590  2  20 51 BA           jsr DrawSmallPlatform
009593  2  20 8C A2           jsr MoveSmallPlatform
009596  2  4C B1 A2           jmp OffscreenBoundsCheck
009599  2               
009599  2               ;--------------------------------
009599  2               
009599  2               RunLargePlatform:
009599  2  20 A4 BE             jsr GetEnemyOffscreenBits
00959C  2  20 47 BE             jsr RelativeEnemyPosition
00959F  2  20 23 AF             jsr LargePlatformBoundBox
0095A2  2  20 B6 A7             jsr LargePlatformCollision
0095A5  2  AD 47 07             lda TimerControl             ;if master timer control set,
0095A8  2  D0 03                bne SkipPT                   ;skip subroutine tree
0095AA  2  20 B6 95             jsr LargePlatformSubroutines
0095AD  2  20 47 BE     SkipPT: jsr RelativeEnemyPosition
0095B0  2  20 79 B2             jsr DrawLargePlatform
0095B3  2  4C B1 A2             jmp OffscreenBoundsCheck
0095B6  2               
0095B6  2               ;--------------------------------
0095B6  2               
0095B6  2               LargePlatformSubroutines:
0095B6  2  B5 16              lda Enemy_ID,x  ;subtract $24 to get proper offset for jump table
0095B8  2  38                 sec
0095B9  2  E9 24              sbc #$24
0095BB  2  20 0F 6D           jsr JumpEngine
0095BE  2               
0095BE  2  62 A0              .word BalancePlatform   ;table used by objects $24-$2a
0095C0  2  0A A2              .word YMovingPlatform
0095C2  2  86 A2              .word MoveLargeLiftPlat
0095C4  2  86 A2              .word MoveLargeLiftPlat
0095C6  2  3E A2              .word XMovingPlatform
0095C8  2  68 A2              .word DropPlatform
0095CA  2  74 A2              .word RightPlatform
0095CC  2               
0095CC  2               ;-------------------------------------------------------------------------------------
0095CC  2               
0095CC  2               EraseEnemyObject:
0095CC  2  A9 00              lda #$00                 ;clear all enemy object variables
0095CE  2  95 0F              sta Enemy_Flag,x
0095D0  2  95 16              sta Enemy_ID,x
0095D2  2  95 1E              sta Enemy_State,x
0095D4  2  9D 10 01           sta FloateyNum_Control,x
0095D7  2  9D 96 07           sta EnemyIntervalTimer,x
0095DA  2  9D 25 01           sta ShellChainCounter,x
0095DD  2  9D C5 03           sta Enemy_SprAttrib,x
0095E0  2  9D 8A 07           sta EnemyFrameTimer,x
0095E3  2  60                 rts
0095E4  2               
0095E4  2               ;-------------------------------------------------------------------------------------
0095E4  2               
0095E4  2               MovePodoboo:
0095E4  2  BD 96 07           lda EnemyIntervalTimer,x   ;check enemy timer
0095E7  2  D0 16              bne PdbM                   ;branch to move enemy if not expired
0095E9  2  20 04 8F           jsr InitPodoboo            ;otherwise set up podoboo again
0095EC  2  BD A8 07           lda PseudoRandomBitReg+1,x ;get part of LSFR
0095EF  2  09 80              ora #%10000000             ;set d7
0095F1  2  9D 34 04           sta Enemy_Y_MoveForce,x    ;store as movement force
0095F4  2  29 0F              and #%00001111             ;mask out high nybble
0095F6  2  09 06              ora #$06                   ;set for at least six intervals
0095F8  2  9D 96 07           sta EnemyIntervalTimer,x   ;store as new enemy timer
0095FB  2  A9 F9              lda #$f9
0095FD  2  95 A0              sta Enemy_Y_Speed,x        ;set vertical speed to move podoboo upwards
0095FF  2  4C A1 8B     PdbM: jmp MoveJ_EnemyVertically  ;branch to impose gravity on podoboo
009602  2               
009602  2               ;--------------------------------
009602  2               ;$00 - used in HammerBroJumpCode as bitmask
009602  2               
009602  2               HammerThrowTmrData:
009602  2  30 1C              .byte $30, $1c
009604  2               
009604  2               XSpeedAdderData:
009604  2  00 E8 00 18        .byte $00, $e8, $00, $18
009608  2               
009608  2               RevivedXSpeed:
009608  2  08 F8 0C F4        .byte $08, $f8, $0c, $f4
00960C  2               
00960C  2               ProcHammerBro:
00960C  2  B5 1E               lda Enemy_State,x          ;check hammer bro's enemy state for d5 set
00960E  2  29 20               and #%00100000
009610  2  F0 03               beq ChkJH                  ;if not set, go ahead with code
009612  2  4C 1E 97            jmp MoveDefeatedEnemy      ;otherwise jump to something else
009615  2  B5 3C        ChkJH: lda HammerBroJumpTimer,x   ;check jump timer
009617  2  F0 2D               beq HammerBroJumpCode      ;if expired, branch to jump
009619  2  D6 3C               dec HammerBroJumpTimer,x   ;otherwise decrement jump timer
00961B  2  AD D1 03            lda Enemy_OffscreenBits
00961E  2  29 0C               and #%00001100             ;check offscreen bits
009620  2  D0 6A               bne MoveHammerBroXDir      ;if hammer bro a little offscreen, skip to movement code
009622  2  BD A2 03            lda HammerThrowingTimer,x  ;check hammer throwing timer
009625  2  D0 17               bne DecHT                  ;if not expired, skip ahead, do not throw hammer
009627  2  AC CC 06            ldy SecondaryHardMode      ;otherwise get secondary hard mode flag
00962A  2  B9 02 96            lda HammerThrowTmrData,y   ;get timer data using flag as offset
00962D  2  9D A2 03            sta HammerThrowingTimer,x  ;set as new timer
009630  2  20 AA 86            jsr SpawnHammerObj         ;do a sub here to spawn hammer object
009633  2  90 09               bcc DecHT                  ;if carry clear, hammer not spawned, skip to decrement timer
009635  2  B5 1E               lda Enemy_State,x
009637  2  09 08               ora #%00001000             ;set d3 in enemy state for hammer throw
009639  2  95 1E               sta Enemy_State,x
00963B  2  4C 8C 96            jmp MoveHammerBroXDir      ;jump to move hammer bro
00963E  2  DE A2 03     DecHT: dec HammerThrowingTimer,x  ;decrement timer
009641  2  4C 8C 96            jmp MoveHammerBroXDir      ;jump to move hammer bro
009644  2               
009644  2               HammerBroJumpLData:
009644  2  20 37              .byte $20, $37
009646  2               
009646  2               HammerBroJumpCode:
009646  2  B5 1E               lda Enemy_State,x           ;get hammer bro's enemy state
009648  2  29 07               and #%00000111              ;mask out all but 3 LSB
00964A  2  C9 01               cmp #$01                    ;check for d0 set (for jumping)
00964C  2  F0 3E               beq MoveHammerBroXDir       ;if set, branch ahead to moving code
00964E  2  A9 00               lda #$00                    ;load default value here
009650  2  85 00               sta $00                     ;save into temp variable for now
009652  2  A0 FA               ldy #$fa                    ;set default vertical speed
009654  2  B5 CF               lda Enemy_Y_Position,x      ;check hammer bro's vertical coordinate
009656  2  30 13               bmi SetHJ                   ;if on the bottom half of the screen, use current speed
009658  2  A0 FD               ldy #$fd                    ;otherwise set alternate vertical speed
00965A  2  C9 70               cmp #$70                    ;check to see if hammer bro is above the middle of screen
00965C  2  E6 00               inc $00                     ;increment preset value to $01
00965E  2  90 0B               bcc SetHJ                   ;if above the middle of the screen, use current speed and $01
009660  2  C6 00               dec $00                     ;otherwise return value to $00
009662  2  BD A8 07            lda PseudoRandomBitReg+1,x  ;get part of LSFR, mask out all but LSB
009665  2  29 01               and #$01
009667  2  D0 02               bne SetHJ                   ;if d0 of LSFR set, branch and use current speed and $00
009669  2  A0 FA               ldy #$fa                    ;otherwise reset to default vertical speed
00966B  2  94 A0        SetHJ: sty Enemy_Y_Speed,x         ;set vertical speed for jumping
00966D  2  B5 1E               lda Enemy_State,x           ;set d0 in enemy state for jumping
00966F  2  09 01               ora #$01
009671  2  95 1E               sta Enemy_State,x
009673  2  A5 00               lda $00                     ;load preset value here to use as bitmask
009675  2  3D A9 07            and PseudoRandomBitReg+2,x  ;and do bit-wise comparison with part of LSFR
009678  2  A8                  tay                         ;then use as offset
009679  2  AD CC 06            lda SecondaryHardMode       ;check secondary hard mode flag
00967C  2  D0 01               bne HJump
00967E  2  A8                  tay                         ;if secondary hard mode flag clear, set offset to 0
00967F  2  B9 44 96     HJump: lda HammerBroJumpLData,y    ;get jump length timer data using offset from before
009682  2  9D 8A 07            sta EnemyFrameTimer,x       ;save in enemy timer
009685  2  BD A8 07            lda PseudoRandomBitReg+1,x
009688  2  09 C0               ora #%11000000              ;get contents of part of LSFR, set d7 and d6, then
00968A  2  95 3C               sta HammerBroJumpTimer,x    ;store in jump timer
00968C  2               
00968C  2               MoveHammerBroXDir:
00968C  2  A0 FC                 ldy #$fc                  ;move hammer bro a little to the left
00968E  2  A5 09                 lda FrameCounter
009690  2  29 40                 and #%01000000            ;change hammer bro's direction every 64 frames
009692  2  D0 02                 bne Shimmy
009694  2  A0 04                 ldy #$04                  ;if d6 set in counter, move him a little to the right
009696  2  94 58        Shimmy:  sty Enemy_X_Speed,x       ;store horizontal speed
009698  2  A0 01                 ldy #$01                  ;set to face right by default
00969A  2  20 EF AD              jsr PlayerEnemyDiff       ;get horizontal difference between player and hammer bro
00969D  2  30 0A                 bmi SetShim               ;if enemy to the left of player, skip this part
00969F  2  C8                    iny                       ;set to face left
0096A0  2  BD 96 07              lda EnemyIntervalTimer,x  ;check walking timer
0096A3  2  D0 04                 bne SetShim               ;if not yet expired, skip to set moving direction
0096A5  2  A9 F8                 lda #$f8
0096A7  2  95 58                 sta Enemy_X_Speed,x       ;otherwise, make the hammer bro walk left towards player
0096A9  2  94 46        SetShim: sty Enemy_MovingDir,x     ;set moving direction
0096AB  2               
0096AB  2               MoveNormalEnemy:
0096AB  2  A0 00               ldy #$00                   ;init Y to leave horizontal movement as-is
0096AD  2  B5 1E               lda Enemy_State,x
0096AF  2  29 40               and #%01000000             ;check enemy state for d6 set, if set skip
0096B1  2  D0 19               bne FallE                  ;to move enemy vertically, then horizontally if necessary
0096B3  2  B5 1E               lda Enemy_State,x
0096B5  2  0A                  asl                        ;check enemy state for d7 set
0096B6  2  B0 30               bcs SteadM                 ;if set, branch to move enemy horizontally
0096B8  2  B5 1E               lda Enemy_State,x
0096BA  2  29 20               and #%00100000             ;check enemy state for d5 set
0096BC  2  D0 60               bne MoveDefeatedEnemy      ;if set, branch to move defeated enemy object
0096BE  2  B5 1E               lda Enemy_State,x
0096C0  2  29 07               and #%00000111             ;check d2-d0 of enemy state for any set bits
0096C2  2  F0 24               beq SteadM                 ;if enemy in normal state, branch to move enemy horizontally
0096C4  2  C9 05               cmp #$05
0096C6  2  F0 04               beq FallE                  ;if enemy in state used by spiny's egg, go ahead here
0096C8  2  C9 03               cmp #$03
0096CA  2  B0 30               bcs ReviveStunned          ;if enemy in states $03 or $04, skip ahead to yet another part
0096CC  2  20 72 8B     FallE: jsr MoveD_EnemyVertically  ;do a sub here to move enemy downwards
0096CF  2  A0 00               ldy #$00
0096D1  2  B5 1E               lda Enemy_State,x          ;check for enemy state $02
0096D3  2  C9 02               cmp #$02
0096D5  2  F0 0C               beq MEHor                  ;if found, branch to move enemy horizontally
0096D7  2  29 40               and #%01000000             ;check for d6 set
0096D9  2  F0 0D               beq SteadM                 ;if not set, branch to something else
0096DB  2  B5 16               lda Enemy_ID,x
0096DD  2  C9 2E               cmp #PowerUpObject         ;check for power-up object
0096DF  2  F0 07               beq SteadM
0096E1  2  D0 03               bne SlowM                  ;if any other object where d6 set, jump to set Y
0096E3  2  4C 11 8B     MEHor: jmp MoveEnemyHorizontally  ;jump here to move enemy horizontally for <> $2e and d6 set
0096E6  2               
0096E6  2  A0 01        SlowM:  ldy #$01                  ;if branched here, increment Y to slow horizontal movement
0096E8  2  B5 58        SteadM: lda Enemy_X_Speed,x       ;get current horizontal speed
0096EA  2  48                   pha                       ;save to stack
0096EB  2  10 02                bpl AddHS                 ;if not moving or moving right, skip, leave Y alone
0096ED  2  C8                   iny
0096EE  2  C8                   iny                       ;otherwise increment Y to next data
0096EF  2  18           AddHS:  clc
0096F0  2  79 04 96             adc XSpeedAdderData,y     ;add value here to slow enemy down if necessary
0096F3  2  95 58                sta Enemy_X_Speed,x       ;save as horizontal speed temporarily
0096F5  2  20 11 8B             jsr MoveEnemyHorizontally ;then do a sub to move horizontally
0096F8  2  68                   pla
0096F9  2  95 58                sta Enemy_X_Speed,x       ;get old horizontal speed from stack and return to
0096FB  2  60                   rts                       ;original memory location, then leave
0096FC  2               
0096FC  2               ReviveStunned:
0096FC  2  BD 96 07              lda EnemyIntervalTimer,x  ;if enemy timer not expired yet,
0096FF  2  D0 23                 bne ChkKillGoomba         ;skip ahead to something else
009701  2  95 1E                 sta Enemy_State,x         ;otherwise initialize enemy state to normal
009703  2  A5 09                 lda FrameCounter
009705  2  29 01                 and #$01                  ;get d0 of frame counter
009707  2  A8                    tay                       ;use as Y and increment for movement direction
009708  2  C8                    iny
009709  2  94 46                 sty Enemy_MovingDir,x     ;store as pseudorandom movement direction
00970B  2  88                    dey                       ;decrement for use as pointer
00970C  2  AD 7D 07              lda PrimaryHardMode       ;check primary hard mode flag
00970F  2  F0 07                 beq SetRSpd               ;if not set, use pointer as-is
009711  2               .ifdef ANN
009711  2  AD FB 07              lda HardWorldFlag
009714  2  D0 02                 bne SetRSpd               ;if hard world flag set, use pointer as-is
009716  2               .endif
009716  2  C8                    iny
009717  2  C8                    iny                       ;otherwise increment 2 bytes to next data
009718  2  B9 08 96     SetRSpd: lda RevivedXSpeed,y       ;load and store new horizontal speed
00971B  2  95 58                 sta Enemy_X_Speed,x       ;and leave
00971D  2  60                    rts
00971E  2               
00971E  2               MoveDefeatedEnemy:
00971E  2  20 72 8B           jsr MoveD_EnemyVertically      ;execute sub to move defeated enemy downwards
009721  2  4C 11 8B           jmp MoveEnemyHorizontally      ;now move defeated enemy horizontally
009724  2               
009724  2               ChkKillGoomba:
009724  2  C9 0E                cmp #$0e              ;check to see if enemy timer has reached
009726  2  D0 09                bne NKGmba            ;a certain point, and branch to leave if not
009728  2  B5 16                lda Enemy_ID,x
00972A  2  C9 06                cmp #Goomba           ;check for goomba object
00972C  2  D0 03                bne NKGmba            ;branch if not found
00972E  2  20 CC 95             jsr EraseEnemyObject  ;otherwise, kill this goomba object
009731  2  60           NKGmba: rts                   ;leave!
009732  2               
009732  2               ;--------------------------------
009732  2               
009732  2               MoveJumpingEnemy:
009732  2  20 A1 8B           jsr MoveJ_EnemyVertically  ;do a sub to impose gravity on green paratroopa
009735  2  4C 11 8B           jmp MoveEnemyHorizontally  ;jump to move enemy horizontally
009738  2               
009738  2               ;--------------------------------
009738  2               
009738  2               ProcMoveRedPTroopa:
009738  2  B5 A0                  lda Enemy_Y_Speed,x
00973A  2  1D 34 04               ora Enemy_Y_MoveForce,x     ;check for any vertical force or speed
00973D  2  D0 13                  bne MoveRedPTUpOrDown       ;branch if any found
00973F  2  9D 17 04               sta Enemy_YMF_Dummy,x       ;initialize something here
009742  2  B5 CF                  lda Enemy_Y_Position,x      ;check current vs. original vertical coordinate
009744  2  DD 01 04               cmp RedPTroopaOrigXPos,x
009747  2  B0 09                  bcs MoveRedPTUpOrDown       ;if current => original, skip ahead to more code
009749  2  A5 09                  lda FrameCounter            ;get frame counter
00974B  2  29 07                  and #%00000111              ;mask out all but 3 LSB
00974D  2  D0 02                  bne NoIncPT                 ;if any bits set, branch to leave
00974F  2  F6 CF                  inc Enemy_Y_Position,x      ;otherwise increment red paratroopa's vertical position
009751  2  60           NoIncPT:  rts                         ;leave
009752  2               
009752  2               MoveRedPTUpOrDown:
009752  2  B5 CF                  lda Enemy_Y_Position,x      ;check current vs. central vertical coordinate
009754  2  D5 58                  cmp RedPTroopaCenterYPos,x
009756  2  90 03                  bcc MovPTDwn                ;if current < central, jump to move downwards
009758  2  4C 84 8B               jmp MoveRedPTroopaUp        ;otherwise jump to move upwards
00975B  2  4C 7F 8B     MovPTDwn: jmp MoveRedPTroopaDown      ;move downwards
00975E  2               
00975E  2               ;--------------------------------
00975E  2               ;$00 - used to store adder for movement, also used as adder for platform
00975E  2               ;$01 - used to store maximum value for secondary counter
00975E  2               
00975E  2               MoveFlyGreenPTroopa:
00975E  2  20 7E 97             jsr XMoveCntr_GreenPTroopa ;do sub to increment primary and secondary counters
009761  2  20 9F 97             jsr MoveWithXMCntrs        ;do sub to move green paratroopa accordingly, and horizontally
009764  2  A0 01                ldy #$01                   ;set Y to move green paratroopa down
009766  2  A5 09                lda FrameCounter
009768  2  29 03                and #%00000011             ;check frame counter 2 LSB for any bits set
00976A  2  D0 11                bne NoMGPT                 ;branch to leave if set to move up/down every fourth frame
00976C  2  A5 09                lda FrameCounter
00976E  2  29 40                and #%01000000             ;check frame counter for d6 set
009770  2  D0 02                bne YSway                  ;branch to move green paratroopa down if set
009772  2  A0 FF                ldy #$ff                   ;otherwise set Y to move green paratroopa up
009774  2  84 00        YSway:  sty $00                    ;store adder here
009776  2  B5 CF                lda Enemy_Y_Position,x
009778  2  18                   clc                        ;add or subtract from vertical position
009779  2  65 00                adc $00                    ;to give green paratroopa a wavy flight
00977B  2  95 CF                sta Enemy_Y_Position,x
00977D  2  60           NoMGPT: rts                        ;leave!
00977E  2               
00977E  2               XMoveCntr_GreenPTroopa:
00977E  2  A9 13                 lda #$13                    ;load preset maximum value for secondary counter
009780  2               
009780  2               XMoveCntr_Platform:
009780  2  85 01                 sta $01                     ;store value here
009782  2  A5 09                 lda FrameCounter
009784  2  29 03                 and #%00000011              ;branch to leave if not on
009786  2  D0 0D                 bne NoIncXM                 ;every fourth frame
009788  2  B4 58                 ldy XMoveSecondaryCounter,x ;get secondary counter
00978A  2  B5 A0                 lda XMovePrimaryCounter,x   ;get primary counter
00978C  2  4A                    lsr
00978D  2  B0 0A                 bcs DecSeXM                 ;if d0 of primary counter set, branch elsewhere
00978F  2  C4 01                 cpy $01                     ;compare secondary counter to preset maximum value
009791  2  F0 03                 beq IncPXM                  ;if equal, branch ahead of this part
009793  2  F6 58                 inc XMoveSecondaryCounter,x ;increment secondary counter and leave
009795  2  60           NoIncXM: rts
009796  2  F6 A0        IncPXM:  inc XMovePrimaryCounter,x   ;increment primary counter and leave
009798  2  60                    rts
009799  2  98           DecSeXM: tya                         ;put secondary counter in A
00979A  2  F0 FA                 beq IncPXM                  ;if secondary counter at zero, branch back
00979C  2  D6 58                 dec XMoveSecondaryCounter,x ;otherwise decrement secondary counter and leave
00979E  2  60                    rts
00979F  2               
00979F  2               MoveWithXMCntrs:
00979F  2  B5 58                 lda XMoveSecondaryCounter,x  ;save secondary counter to stack
0097A1  2  48                    pha
0097A2  2  A0 01                 ldy #$01                     ;set value here by default
0097A4  2  B5 A0                 lda XMovePrimaryCounter,x
0097A6  2  29 02                 and #%00000010               ;if d1 of primary counter is
0097A8  2  D0 0B                 bne XMRight                  ;set, branch ahead of this part here
0097AA  2  B5 58                 lda XMoveSecondaryCounter,x
0097AC  2  49 FF                 eor #$ff                     ;otherwise change secondary
0097AE  2  18                    clc                          ;counter to two's compliment
0097AF  2  69 01                 adc #$01
0097B1  2  95 58                 sta XMoveSecondaryCounter,x
0097B3  2  A0 02                 ldy #$02                     ;load alternate value here
0097B5  2  94 46        XMRight: sty Enemy_MovingDir,x        ;store as moving direction
0097B7  2  20 11 8B              jsr MoveEnemyHorizontally
0097BA  2  85 00                 sta $00                      ;save value obtained from sub here
0097BC  2  68                    pla                          ;get secondary counter from stack
0097BD  2  95 58                 sta XMoveSecondaryCounter,x  ;and return to original place
0097BF  2  60                    rts
0097C0  2               
0097C0  2               ;--------------------------------
0097C0  2               
0097C0  2               
0097C0  2               BlooberBitmasks:
0097C0  2  3F 03              .byte %00111111, %00000011
0097C2  2               
0097C2  2               MoveBloober:
0097C2  2  B5 1E                lda Enemy_State,x
0097C4  2  29 20                and #%00100000             ;check enemy state for d5 set
0097C6  2  D0 4D                bne MoveDefeatedBloober    ;branch if set to move defeated bloober
0097C8  2  AC CC 06             ldy SecondaryHardMode      ;use secondary hard mode flag as offset
0097CB  2  BD A8 07             lda PseudoRandomBitReg+1,x ;get LSFR
0097CE  2  39 C0 97             and BlooberBitmasks,y      ;mask out bits in LSFR using bitmask loaded with offset
0097D1  2  D0 12                bne BlooberSwim            ;if any bits set, skip ahead to make swim
0097D3  2  8A                   txa
0097D4  2  4A                   lsr                        ;check to see if on second or fourth slot (1 or 3)
0097D5  2  90 04                bcc FBLeft                 ;if not, branch to figure out moving direction
0097D7  2  A4 45                ldy Player_MovingDir       ;otherwise, load player's moving direction and
0097D9  2  B0 08                bcs SBMDir                 ;do an unconditional branch to set
0097DB  2  A0 02        FBLeft: ldy #$02                   ;set left moving direction by default
0097DD  2  20 EF AD             jsr PlayerEnemyDiff        ;get horizontal difference between player and bloober
0097E0  2  10 01                bpl SBMDir                 ;if enemy to the right of player, keep left
0097E2  2  88                   dey                        ;otherwise decrement to set right moving direction
0097E3  2  94 46        SBMDir: sty Enemy_MovingDir,x      ;set moving direction of bloober, then continue on here
0097E5  2               
0097E5  2               BlooberSwim:
0097E5  2  20 18 98            jsr ProcSwimmingB        ;execute sub to make bloober swim characteristically
0097E8  2  B5 CF               lda Enemy_Y_Position,x   ;get vertical coordinate
0097EA  2  38                  sec
0097EB  2  FD 34 04            sbc Enemy_Y_MoveForce,x  ;subtract movement force
0097EE  2  C9 20               cmp #$20                 ;check to see if position is above edge of status bar
0097F0  2  90 02               bcc SwimX                ;if so, don't do it
0097F2  2  95 CF               sta Enemy_Y_Position,x   ;otherwise, set new vertical position, make bloober swim
0097F4  2  B4 46        SwimX: ldy Enemy_MovingDir,x    ;check moving direction
0097F6  2  88                  dey
0097F7  2  D0 0E               bne LeftSwim             ;if moving to the left, branch to second part
0097F9  2  B5 87               lda Enemy_X_Position,x
0097FB  2  18                  clc                      ;add movement speed to horizontal coordinate
0097FC  2  75 58               adc BlooperMoveSpeed,x
0097FE  2  95 87               sta Enemy_X_Position,x   ;store result as new horizontal coordinate
009800  2  B5 6E               lda Enemy_PageLoc,x
009802  2  69 00               adc #$00                 ;add carry to page location
009804  2  95 6E               sta Enemy_PageLoc,x      ;store as new page location and leave
009806  2  60                  rts
009807  2               
009807  2               LeftSwim:
009807  2  B5 87              lda Enemy_X_Position,x
009809  2  38                 sec                      ;subtract movement speed from horizontal coordinate
00980A  2  F5 58              sbc BlooperMoveSpeed,x
00980C  2  95 87              sta Enemy_X_Position,x   ;store result as new horizontal coordinate
00980E  2  B5 6E              lda Enemy_PageLoc,x
009810  2  E9 00              sbc #$00                 ;subtract borrow from page location
009812  2  95 6E              sta Enemy_PageLoc,x      ;store as new page location and leave
009814  2  60                 rts
009815  2               
009815  2               MoveDefeatedBloober:
009815  2  4C 9B 8B           jmp MoveEnemySlowVert    ;jump to move defeated bloober downwards
009818  2               
009818  2               ProcSwimmingB:
009818  2  B5 A0                lda BlooperMoveCounter,x  ;get enemy's movement counter
00981A  2  29 02                and #%00000010            ;check for d1 set
00981C  2  D0 37                bne ChkForFloatdown       ;branch if set
00981E  2  A5 09                lda FrameCounter
009820  2  29 07                and #%00000111            ;get 3 LSB of frame counter
009822  2  48                   pha                       ;and save it to the stack
009823  2  B5 A0                lda BlooperMoveCounter,x  ;get enemy's movement counter
009825  2  4A                   lsr                       ;check for d0 set
009826  2  B0 15                bcs SlowSwim              ;branch if set
009828  2  68                   pla                       ;pull 3 LSB of frame counter from the stack
009829  2  D0 11                bne BSwimE                ;branch to leave, execute code only every eighth frame
00982B  2  BD 34 04             lda Enemy_Y_MoveForce,x
00982E  2  18                   clc                       ;add to movement force to speed up swim
00982F  2  69 01                adc #$01
009831  2  9D 34 04             sta Enemy_Y_MoveForce,x   ;set movement force
009834  2  95 58                sta BlooperMoveSpeed,x    ;set as movement speed
009836  2  C9 02                cmp #$02
009838  2  D0 02                bne BSwimE                ;if certain horizontal speed, branch to leave
00983A  2  F6 A0                inc BlooperMoveCounter,x  ;otherwise increment movement counter
00983C  2  60           BSwimE: rts
00983D  2               
00983D  2               SlowSwim:
00983D  2  68                  pla                      ;pull 3 LSB of frame counter from the stack
00983E  2  D0 14               bne NoSSw                ;branch to leave, execute code only every eighth frame
009840  2  BD 34 04            lda Enemy_Y_MoveForce,x
009843  2  38                  sec                      ;subtract from movement force to slow swim
009844  2  E9 01               sbc #$01
009846  2  9D 34 04            sta Enemy_Y_MoveForce,x  ;set movement force
009849  2  95 58               sta BlooperMoveSpeed,x   ;set as movement speed
00984B  2  D0 07               bne NoSSw                ;if any speed, branch to leave
00984D  2  F6 A0               inc BlooperMoveCounter,x ;otherwise increment movement counter
00984F  2  A9 02               lda #$02
009851  2  9D 96 07            sta EnemyIntervalTimer,x ;set enemy's timer
009854  2  60           NoSSw: rts                      ;leave
009855  2               
009855  2               ChkForFloatdown:
009855  2  BD 96 07           lda EnemyIntervalTimer,x ;get enemy timer
009858  2  F0 08              beq ChkNearPlayer        ;branch if expired
00985A  2               
00985A  2               Floatdown:
00985A  2  A5 09              lda FrameCounter        ;get frame counter
00985C  2  4A                 lsr                     ;check for d0 set
00985D  2  B0 02              bcs NoFD                ;branch to leave on every other frame
00985F  2  F6 CF              inc Enemy_Y_Position,x  ;otherwise increment vertical coordinate
009861  2  60           NoFD: rts                     ;leave
009862  2               
009862  2               ChkNearPlayer:
009862  2  B5 CF              lda Enemy_Y_Position,x    ;get vertical coordinate
009864  2  69 10              adc #$10                  ;add sixteen pixels
009866  2  C5 CE              cmp Player_Y_Position     ;compare result with player's vertical coordinate
009868  2  90 F0              bcc Floatdown             ;if modified vertical less than player's, branch
00986A  2  A9 00              lda #$00
00986C  2  95 A0              sta BlooperMoveCounter,x  ;otherwise nullify movement counter
00986E  2  60                 rts
00986F  2               
00986F  2               ;--------------------------------
00986F  2               
00986F  2               MoveBulletBill:
00986F  2  B5 1E                 lda Enemy_State,x          ;check bullet bill's enemy object state for d5 set
009871  2  29 20                 and #%00100000
009873  2  F0 03                 beq NotDefB                ;if not set, continue with movement code
009875  2  4C A1 8B              jmp MoveJ_EnemyVertically  ;otherwise jump to move defeated bullet bill downwards
009878  2  A9 E8        NotDefB: lda #$e8                   ;set bullet bill's horizontal speed
00987A  2  95 58                 sta Enemy_X_Speed,x        ;and move it accordingly (note: this bullet bill
00987C  2  4C 11 8B              jmp MoveEnemyHorizontally  ;object occurs in frenzy object $17, not from cannons)
00987F  2               
00987F  2               ;--------------------------------
00987F  2               ;$02 - used to hold preset values
00987F  2               ;$03 - used to hold enemy state
00987F  2               
00987F  2               SwimCCXMoveData:
00987F  2  40 80              .byte $40, $80
009881  2  04 04              .byte $04, $04 ;residual data, not used
009883  2               
009883  2               MoveSwimmingCheepCheep:
009883  2  B5 1E                lda Enemy_State,x         ;check cheep-cheep's enemy object state
009885  2  29 20                and #%00100000            ;for d5 set
009887  2  F0 03                beq CCSwim                ;if not set, continue with movement code
009889  2  4C 9B 8B             jmp MoveEnemySlowVert     ;otherwise jump to move defeated cheep-cheep downwards
00988C  2  85 03        CCSwim: sta $03                   ;save enemy state in $03
00988E  2  B5 16                lda Enemy_ID,x            ;get enemy identifier
009890  2  38                   sec
009891  2  E9 0A                sbc #$0a                  ;subtract ten for cheep-cheep identifiers
009893  2  A8                   tay                       ;use as offset
009894  2  B9 7F 98             lda SwimCCXMoveData,y     ;load value here
009897  2  85 02                sta $02
009899  2  BD 01 04             lda Enemy_X_MoveForce,x   ;load horizontal force
00989C  2  38                   sec
00989D  2  E5 02                sbc $02                   ;subtract preset value from horizontal force
00989F  2  9D 01 04             sta Enemy_X_MoveForce,x   ;store as new horizontal force
0098A2  2  B5 87                lda Enemy_X_Position,x    ;get horizontal coordinate
0098A4  2  E9 00                sbc #$00                  ;subtract borrow (thus moving it slowly)
0098A6  2  95 87                sta Enemy_X_Position,x    ;and save as new horizontal coordinate
0098A8  2  B5 6E                lda Enemy_PageLoc,x
0098AA  2  E9 00                sbc #$00                  ;subtract borrow again, this time from the
0098AC  2  95 6E                sta Enemy_PageLoc,x       ;page location, then save
0098AE  2  A9 40                lda #$40
0098B0  2  85 02                sta $02                   ;save new value here
0098B2  2  E0 02                cpx #$02                  ;check enemy object offset
0098B4  2  90 49                bcc ExSwCC                ;if in first or second slot, branch to leave
0098B6  2  B5 58                lda CheepCheepMoveMFlag,x ;check movement flag
0098B8  2  C9 10                cmp #$10                  ;if movement speed set to $00,
0098BA  2  90 16                bcc CCSwimUpwards         ;branch to move upwards
0098BC  2  BD 17 04             lda Enemy_YMF_Dummy,x
0098BF  2  18                   clc
0098C0  2  65 02                adc $02                   ;add preset value to dummy variable to get carry
0098C2  2  9D 17 04             sta Enemy_YMF_Dummy,x     ;and save dummy
0098C5  2  B5 CF                lda Enemy_Y_Position,x    ;get vertical coordinate
0098C7  2  65 03                adc $03                   ;add carry to it plus enemy state to slowly move it downwards
0098C9  2  95 CF                sta Enemy_Y_Position,x    ;save as new vertical coordinate
0098CB  2  B5 B6                lda Enemy_Y_HighPos,x
0098CD  2  69 00                adc #$00                  ;add carry to page location and
0098CF  2  4C E5 98             jmp ChkSwimYPos           ;jump to end of movement code
0098D2  2               
0098D2  2               CCSwimUpwards:
0098D2  2  BD 17 04             lda Enemy_YMF_Dummy,x
0098D5  2  38                   sec
0098D6  2  E5 02                sbc $02                   ;subtract preset value to dummy variable to get borrow
0098D8  2  9D 17 04             sta Enemy_YMF_Dummy,x     ;and save dummy
0098DB  2  B5 CF                lda Enemy_Y_Position,x    ;get vertical coordinate
0098DD  2  E5 03                sbc $03                   ;subtract borrow to it plus enemy state to slowly move it upwards
0098DF  2  95 CF                sta Enemy_Y_Position,x    ;save as new vertical coordinate
0098E1  2  B5 B6                lda Enemy_Y_HighPos,x
0098E3  2  E9 00                sbc #$00                  ;subtract borrow from page location
0098E5  2               
0098E5  2               ChkSwimYPos:
0098E5  2  95 B6                sta Enemy_Y_HighPos,x     ;save new page location here
0098E7  2  A0 00                ldy #$00                  ;load movement speed to upwards by default
0098E9  2  B5 CF                lda Enemy_Y_Position,x    ;get vertical coordinate
0098EB  2  38                   sec
0098EC  2  FD 34 04             sbc CheepCheepOrigYPos,x  ;subtract original coordinate from current
0098EF  2  10 07                bpl YPDiff                ;if result positive, skip to next part
0098F1  2  A0 10                ldy #$10                  ;otherwise load movement speed to downwards
0098F3  2  49 FF                eor #$ff
0098F5  2  18                   clc                       ;get two's compliment of result
0098F6  2  69 01                adc #$01                  ;to obtain total difference of original vs. current
0098F8  2  C9 0F        YPDiff: cmp #$0f                  ;if difference between original vs. current vertical
0098FA  2  90 03                bcc ExSwCC                ;coordinates < 15 pixels, leave movement speed alone
0098FC  2  98                   tya
0098FD  2  95 58                sta CheepCheepMoveMFlag,x ;otherwise change movement speed
0098FF  2  60           ExSwCC: rts                       ;leave
009900  2               
009900  2               ;--------------------------------
009900  2               ;$00 - used as counter for firebar parts
009900  2               ;$01 - used for oscillated high byte of spin state or to hold horizontal adder
009900  2               ;$02 - used for oscillated high byte of spin state or to hold vertical adder
009900  2               ;$03 - used for mirror data
009900  2               ;$04 - used to store player's sprite 1 X coordinate
009900  2               ;$05 - used to evaluate mirror data
009900  2               ;$06 - used to store either screen X coordinate or sprite data offset
009900  2               ;$07 - used to store screen Y coordinate
009900  2               ;$ed - used to hold maximum length of firebar
009900  2               ;$ef - used to hold high byte of spinstate
009900  2               
009900  2               ;horizontal adder is at first byte + high byte of spinstate,
009900  2               ;vertical adder is same + 8 bytes, two's compliment
009900  2               ;if greater than $08 for proper oscillation
009900  2               FirebarPosLookupTbl:
009900  2  00 01 03 04        .byte $00, $01, $03, $04, $05, $06, $07, $07, $08
009904  2  05 06 07 07  
009908  2  08           
009909  2  00 03 06 09        .byte $00, $03, $06, $09, $0b, $0d, $0e, $0f, $10
00990D  2  0B 0D 0E 0F  
009911  2  10           
009912  2  00 04 09 0D        .byte $00, $04, $09, $0d, $10, $13, $16, $17, $18
009916  2  10 13 16 17  
00991A  2  18           
00991B  2  00 06 0C 12        .byte $00, $06, $0c, $12, $16, $1a, $1d, $1f, $20
00991F  2  16 1A 1D 1F  
009923  2  20           
009924  2  00 07 0F 16        .byte $00, $07, $0f, $16, $1c, $21, $25, $27, $28
009928  2  1C 21 25 27  
00992C  2  28           
00992D  2  00 09 12 1B        .byte $00, $09, $12, $1b, $21, $27, $2c, $2f, $30
009931  2  21 27 2C 2F  
009935  2  30           
009936  2  00 0B 15 1F        .byte $00, $0b, $15, $1f, $27, $2e, $33, $37, $38
00993A  2  27 2E 33 37  
00993E  2  38           
00993F  2  00 0C 18 24        .byte $00, $0c, $18, $24, $2d, $35, $3b, $3e, $40
009943  2  2D 35 3B 3E  
009947  2  40           
009948  2  00 0E 1B 28        .byte $00, $0e, $1b, $28, $32, $3b, $42, $46, $48
00994C  2  32 3B 42 46  
009950  2  48           
009951  2  00 0F 1F 2D        .byte $00, $0f, $1f, $2d, $38, $42, $4a, $4e, $50
009955  2  38 42 4A 4E  
009959  2  50           
00995A  2  00 11 22 31        .byte $00, $11, $22, $31, $3e, $49, $51, $56, $58
00995E  2  3E 49 51 56  
009962  2  58           
009963  2               
009963  2               FirebarMirrorData:
009963  2  01 03 02 00        .byte $01, $03, $02, $00
009967  2               
009967  2               FirebarTblOffsets:
009967  2  00 09 12 1B        .byte $00, $09, $12, $1b, $24, $2d
00996B  2  24 2D        
00996D  2  36 3F 48 51        .byte $36, $3f, $48, $51, $5a, $63
009971  2  5A 63        
009973  2               
009973  2               FirebarYPos:
009973  2  0C 18              .byte $0c, $18
009975  2               
009975  2               ProcFirebar:
009975  2  20 A4 BE               jsr GetEnemyOffscreenBits   ;get offscreen information
009978  2  AD D1 03               lda Enemy_OffscreenBits     ;check for d3 set
00997B  2  29 08                  and #%00001000              ;if so, branch to leave
00997D  2  D0 74                  bne SkipFBar
00997F  2  AD 47 07               lda TimerControl            ;if master timer control set, branch
009982  2  D0 0A                  bne SusFbar                 ;ahead of this part
009984  2  BD 88 03               lda FirebarSpinSpeed,x      ;load spinning speed of firebar
009987  2  20 40 A0               jsr FirebarSpin             ;modify current spinstate
00998A  2  29 1F                  and #%00011111              ;mask out all but 5 LSB
00998C  2  95 A0                  sta FirebarSpinState_High,x ;and store as new high byte of spinstate
00998E  2  B5 A0        SusFbar:  lda FirebarSpinState_High,x ;get high byte of spinstate
009990  2  B4 16                  ldy Enemy_ID,x              ;check enemy identifier
009992  2  C0 1F                  cpy #$1f
009994  2  90 0D                  bcc SetupGFB                ;if < $1f (long firebar), branch
009996  2  C9 08                  cmp #$08                    ;check high byte of spinstate
009998  2  F0 04                  beq SkpFSte                 ;if eight, branch to change
00999A  2  C9 18                  cmp #$18
00999C  2  D0 05                  bne SetupGFB                ;if not at twenty-four branch to not change
00999E  2  18           SkpFSte:  clc
00999F  2  69 01                  adc #$01                    ;add one to spinning thing to avoid horizontal state
0099A1  2  95 A0                  sta FirebarSpinState_High,x
0099A3  2  85 EF        SetupGFB: sta $ef                     ;save high byte of spinning thing, modified or otherwise
0099A5  2  20 47 BE               jsr RelativeEnemyPosition   ;get relative coordinates to screen
0099A8  2  20 C7 9A               jsr GetFirebarPosition      ;do a sub here (residual, too early to be used now)
0099AB  2  BC E5 06               ldy Enemy_SprDataOffset,x   ;get OAM data offset
0099AE  2  AD B9 03               lda Enemy_Rel_YPos          ;get relative vertical coordinate
0099B1  2  99 00 02               sta Sprite_Y_Position,y     ;store as Y in OAM data
0099B4  2  85 07                  sta $07                     ;also save here
0099B6  2  AD AE 03               lda Enemy_Rel_XPos          ;get relative horizontal coordinate
0099B9  2  99 03 02               sta Sprite_X_Position,y     ;store as X in OAM data
0099BC  2  85 06                  sta $06                     ;also save here
0099BE  2  A9 01                  lda #$01
0099C0  2  85 00                  sta $00                     ;set $01 value here (not necessary)
0099C2  2  20 41 9A               jsr FirebarCollision        ;draw fireball part and do collision detection
0099C5  2  A0 05                  ldy #$05                    ;load value for short firebars by default
0099C7  2  B5 16                  lda Enemy_ID,x
0099C9  2  C9 1F                  cmp #$1f                    ;are we doing a long firebar?
0099CB  2  90 02                  bcc SetMFbar                ;no, branch then
0099CD  2  A0 0B                  ldy #$0b                    ;otherwise load value for long firebars
0099CF  2  84 ED        SetMFbar: sty $ed                     ;store maximum value for length of firebars
0099D1  2  A9 00                  lda #$00
0099D3  2  85 00                  sta $00                     ;initialize counter here
0099D5  2  A5 EF        DrawFbar: lda $ef                     ;load high byte of spinstate
0099D7  2  20 C7 9A               jsr GetFirebarPosition      ;get fireball position data depending on firebar part
0099DA  2  20 F4 99               jsr DrawFirebar_Collision   ;position it properly, draw it and do collision detection
0099DD  2  A5 00                  lda $00                     ;check which firebar part
0099DF  2  C9 04                  cmp #$04
0099E1  2  D0 08                  bne NextFbar
0099E3  2  AC CF 06               ldy DuplicateObj_Offset     ;if we arrive at fifth firebar part,
0099E6  2  B9 E5 06               lda Enemy_SprDataOffset,y   ;get offset from long firebar and load OAM data offset
0099E9  2  85 06                  sta $06                     ;using long firebar offset, then store as new one here
0099EB  2  E6 00        NextFbar: inc $00                     ;move onto the next firebar part
0099ED  2  A5 00                  lda $00
0099EF  2  C5 ED                  cmp $ed                     ;if we end up at the maximum part, go on and leave
0099F1  2  90 E2                  bcc DrawFbar                ;otherwise go back and do another
0099F3  2  60           SkipFBar: rts
0099F4  2               
0099F4  2               DrawFirebar_Collision:
0099F4  2  A5 03                 lda $03                  ;store mirror data elsewhere
0099F6  2  85 05                 sta $05
0099F8  2  A4 06                 ldy $06                  ;load OAM data offset for firebar
0099FA  2  A5 01                 lda $01                  ;load horizontal adder we got from position loader
0099FC  2  46 05                 lsr $05                  ;shift LSB of mirror data
0099FE  2  B0 04                 bcs AddHA                ;if carry was set, skip this part
009A00  2  49 FF                 eor #$ff
009A02  2  69 01                 adc #$01                 ;otherwise get two's compliment of horizontal adder
009A04  2  18           AddHA:   clc                      ;add horizontal coordinate relative to screen to
009A05  2  6D AE 03              adc Enemy_Rel_XPos       ;horizontal adder, modified or otherwise
009A08  2  99 03 02              sta Sprite_X_Position,y  ;store as X coordinate here
009A0B  2  85 06                 sta $06                  ;store here for now, note offset is saved in Y still
009A0D  2  CD AE 03              cmp Enemy_Rel_XPos       ;compare X coordinate of sprite to original X of firebar
009A10  2  B0 09                 bcs SubtR1               ;if sprite coordinate => original coordinate, branch
009A12  2  AD AE 03              lda Enemy_Rel_XPos
009A15  2  38                    sec                      ;otherwise subtract sprite X from the
009A16  2  E5 06                 sbc $06                  ;original one and skip this part
009A18  2  4C 1F 9A              jmp ChkFOfs
009A1B  2  38           SubtR1:  sec                      ;subtract original X from the
009A1C  2  ED AE 03              sbc Enemy_Rel_XPos       ;current sprite X
009A1F  2  C9 59        ChkFOfs: cmp #$59                 ;if difference of coordinates within a certain range,
009A21  2  90 04                 bcc VAHandl              ;continue by handling vertical adder
009A23  2  A9 F8                 lda #$f8                 ;otherwise, load offscreen Y coordinate
009A25  2  D0 15                 bne SetVFbr              ;and unconditionally branch to move sprite offscreen
009A27  2  AD B9 03     VAHandl: lda Enemy_Rel_YPos       ;if vertical relative coordinate offscreen,
009A2A  2  C9 F8                 cmp #$f8                 ;skip ahead of this part and write into sprite Y coordinate
009A2C  2  F0 0E                 beq SetVFbr
009A2E  2  A5 02                 lda $02                  ;load vertical adder we got from position loader
009A30  2  46 05                 lsr $05                  ;shift LSB of mirror data one more time
009A32  2  B0 04                 bcs AddVA                ;if carry was set, skip this part
009A34  2  49 FF                 eor #$ff
009A36  2  69 01                 adc #$01                 ;otherwise get two's compliment of second part
009A38  2  18           AddVA:   clc                      ;add vertical coordinate relative to screen to
009A39  2  6D B9 03              adc Enemy_Rel_YPos       ;the second data, modified or otherwise
009A3C  2  99 00 02     SetVFbr: sta Sprite_Y_Position,y  ;store as Y coordinate here
009A3F  2  85 07                 sta $07                  ;also store here for now
009A41  2               
009A41  2               FirebarCollision:
009A41  2  20 D8 B9              jsr DrawFirebar          ;run sub here to draw current tile of firebar
009A44  2  98                    tya                      ;return OAM data offset and save
009A45  2  48                    pha                      ;to the stack for now
009A46  2  AD 9F 07              lda StarInvincibleTimer  ;if star mario invincibility timer
009A49  2  0D 47 07              ora TimerControl         ;or master timer controls set
009A4C  2  D0 70                 bne NoColFB              ;then skip all of this
009A4E  2  85 05                 sta $05                  ;otherwise initialize counter
009A50  2  A4 B5                 ldy Player_Y_HighPos
009A52  2  88                    dey                      ;if player's vertical high byte offscreen,
009A53  2  D0 69                 bne NoColFB              ;skip all of this
009A55  2  A4 CE                 ldy Player_Y_Position    ;get player's vertical position
009A57  2  AD 54 07              lda PlayerSize           ;get player's size
009A5A  2  D0 05                 bne AdjSm                ;if player small, branch to alter variables
009A5C  2  AD 14 07              lda CrouchingFlag
009A5F  2  F0 09                 beq BigJp                ;if player big and not crouching, jump ahead
009A61  2  E6 05        AdjSm:   inc $05                  ;if small or big but crouching, execute this part
009A63  2  E6 05                 inc $05                  ;first increment our counter twice (setting $02 as flag)
009A65  2  98                    tya
009A66  2  18                    clc                      ;then add 24 pixels to the player's
009A67  2  69 18                 adc #$18                 ;vertical coordinate
009A69  2  A8                    tay
009A6A  2  98           BigJp:   tya                      ;get vertical coordinate, altered or otherwise, from Y
009A6B  2  38           FBCLoop: sec                      ;subtract vertical position of firebar
009A6C  2  E5 07                 sbc $07                  ;from the vertical coordinate of the player
009A6E  2  10 05                 bpl ChkVFBD              ;if player lower on the screen than firebar,
009A70  2  49 FF                 eor #$ff                 ;skip two's compliment part
009A72  2  18                    clc                      ;otherwise get two's compliment
009A73  2  69 01                 adc #$01
009A75  2  C9 08        ChkVFBD: cmp #$08                 ;if difference => 8 pixels, skip ahead of this part
009A77  2  B0 1C                 bcs Chk2Ofs
009A79  2  A5 06                 lda $06                  ;if firebar on far right on the screen, skip this,
009A7B  2  C9 F0                 cmp #$f0                 ;because, really, what's the point?
009A7D  2  B0 16                 bcs Chk2Ofs
009A7F  2  AD 07 02              lda Sprite_X_Position+4  ;get OAM X coordinate for sprite #1
009A82  2  18                    clc
009A83  2  69 04                 adc #$04                 ;add four pixels
009A85  2  85 04                 sta $04                  ;store here
009A87  2  38                    sec                      ;subtract horizontal coordinate of firebar
009A88  2  E5 06                 sbc $06                  ;from the X coordinate of player's sprite 1
009A8A  2  10 05                 bpl ChkFBCl              ;if modded X coordinate to the right of firebar
009A8C  2  49 FF                 eor #$ff                 ;skip two's compliment part
009A8E  2  18                    clc                      ;otherwise get two's compliment
009A8F  2  69 01                 adc #$01
009A91  2  C9 08        ChkFBCl: cmp #$08                 ;if difference < 8 pixels, collision, thus branch
009A93  2  90 13                 bcc ChgSDir              ;to process
009A95  2  A5 05        Chk2Ofs: lda $05                  ;if value of $02 was set earlier for whatever reason,
009A97  2  C9 02                 cmp #$02                 ;branch to increment OAM offset and leave, no collision
009A99  2  F0 23                 beq NoColFB
009A9B  2  A4 05                 ldy $05                  ;otherwise get temp here and use as offset
009A9D  2  A5 CE                 lda Player_Y_Position
009A9F  2  18                    clc
009AA0  2  79 73 99              adc FirebarYPos,y        ;add value loaded with offset to player's vertical coordinate
009AA3  2  E6 05                 inc $05                  ;then increment temp and jump back
009AA5  2  4C 6B 9A              jmp FBCLoop
009AA8  2  A2 01        ChgSDir: ldx #$01                 ;set movement direction by default
009AAA  2  A5 04                 lda $04                  ;if OAM X coordinate of player's sprite 1
009AAC  2  C5 06                 cmp $06                  ;is greater than horizontal coordinate of firebar
009AAE  2  B0 01                 bcs SetSDir              ;then do not alter movement direction
009AB0  2  E8                    inx                      ;otherwise increment it
009AB1  2  86 46        SetSDir: stx Enemy_MovingDir      ;store movement direction here
009AB3  2  A2 00                 ldx #$00
009AB5  2  A5 00                 lda $00                  ;save value written to $00 to stack
009AB7  2  48                    pha
009AB8  2  20 83 A5              jsr InjurePlayer         ;perform sub to hurt or kill player
009ABB  2  68                    pla
009ABC  2  85 00                 sta $00                  ;get value of $00 from stack
009ABE  2  68           NoColFB: pla                      ;get OAM data offset
009ABF  2  18                    clc                      ;add four to it and save
009AC0  2  69 04                 adc #$04
009AC2  2  85 06                 sta $06
009AC4  2  A6 08                 ldx ObjectOffset         ;get enemy object buffer offset and leave
009AC6  2  60                    rts
009AC7  2               
009AC7  2               GetFirebarPosition:
009AC7  2  48                      pha                        ;save high byte of spinstate to the stack
009AC8  2  29 0F                   and #%00001111             ;mask out low nybble
009ACA  2  C9 09                   cmp #$09
009ACC  2  90 05                   bcc GetHAdder              ;if lower than $09, branch ahead
009ACE  2  49 0F                   eor #%00001111             ;otherwise get two's compliment to oscillate
009AD0  2  18                      clc
009AD1  2  69 01                   adc #$01
009AD3  2  85 01        GetHAdder: sta $01                    ;store result, modified or not, here
009AD5  2  A4 00                   ldy $00                    ;load number of firebar ball where we're at
009AD7  2  B9 67 99                lda FirebarTblOffsets,y    ;load offset to firebar position data
009ADA  2  18                      clc
009ADB  2  65 01                   adc $01                    ;add oscillated high byte of spinstate
009ADD  2  A8                      tay                        ;to offset here and use as new offset
009ADE  2  B9 00 99                lda FirebarPosLookupTbl,y  ;get data here and store as horizontal adder
009AE1  2  85 01                   sta $01
009AE3  2  68                      pla                        ;pull whatever was in A from the stack
009AE4  2  48                      pha                        ;save it again because we still need it
009AE5  2  18                      clc
009AE6  2  69 08                   adc #$08                   ;add eight this time, to get vertical adder
009AE8  2  29 0F                   and #%00001111             ;mask out high nybble
009AEA  2  C9 09                   cmp #$09                   ;if lower than $09, branch ahead
009AEC  2  90 05                   bcc GetVAdder
009AEE  2  49 0F                   eor #%00001111             ;otherwise get two's compliment
009AF0  2  18                      clc
009AF1  2  69 01                   adc #$01
009AF3  2  85 02        GetVAdder: sta $02                    ;store result here
009AF5  2  A4 00                   ldy $00
009AF7  2  B9 67 99                lda FirebarTblOffsets,y    ;load offset to firebar position data again
009AFA  2  18                      clc
009AFB  2  65 02                   adc $02                    ;this time add value in $02 to offset here and use as offset
009AFD  2  A8                      tay
009AFE  2  B9 00 99                lda FirebarPosLookupTbl,y  ;get data here and store as vertica adder
009B01  2  85 02                   sta $02
009B03  2  68                      pla                        ;pull out whatever was in A one last time
009B04  2  4A                      lsr                        ;divide by eight or shift three to the right
009B05  2  4A                      lsr
009B06  2  4A                      lsr
009B07  2  A8                      tay                        ;use as offset
009B08  2  B9 63 99                lda FirebarMirrorData,y    ;load mirroring data here
009B0B  2  85 03                   sta $03                    ;store
009B0D  2  60                      rts
009B0E  2               
009B0E  2               ;--------------------------------
009B0E  2               
009B0E  2               PRandomSubtracter:
009B0E  2  F8 A0 70 BD        .byte $f8, $a0, $70, $bd, $00
009B12  2  00           
009B13  2               
009B13  2               FlyCCBPriority:
009B13  2  20 20 20 00        .byte $20, $20, $20, $00, $00
009B17  2  00           
009B18  2               
009B18  2               MoveFlyingCheepCheep:
009B18  2  B5 1E                lda Enemy_State,x          ;check cheep-cheep's enemy state
009B1A  2  29 20                and #%00100000             ;for d5 set
009B1C  2  F0 08                beq FlyCC                  ;branch to continue code if not set
009B1E  2  A9 00                lda #$00
009B20  2  9D C5 03             sta Enemy_SprAttrib,x      ;otherwise clear sprite attributes
009B23  2  4C A1 8B             jmp MoveJ_EnemyVertically  ;and jump to move defeated cheep-cheep downwards
009B26  2  20 11 8B     FlyCC:  jsr MoveEnemyHorizontally  ;move cheep-cheep horizontally based on speed and force
009B29  2  A0 0D                ldy #$0d                   ;set vertical movement amount
009B2B  2  A9 05                lda #$05                   ;set maximum speed
009B2D  2  20 A5 8B             jsr SetXMoveAmt            ;branch to impose gravity on flying cheep-cheep
009B30  2  BD 34 04             lda Enemy_Y_MoveForce,x
009B33  2  4A                   lsr                        ;get vertical movement force and
009B34  2  4A                   lsr                        ;move high nybble to low
009B35  2  4A                   lsr
009B36  2  4A                   lsr
009B37  2  A8                   tay                        ;save as offset (note this tends to go into reach of code)
009B38  2  B5 CF                lda Enemy_Y_Position,x     ;get vertical position
009B3A  2  38                   sec                        ;subtract pseudorandom value based on offset from position
009B3B  2  F9 0E 9B             sbc PRandomSubtracter,y
009B3E  2  10 05                bpl AddCCF                  ;if result within top half of screen, skip this part
009B40  2  49 FF                eor #$ff
009B42  2  18                   clc                        ;otherwise get two's compliment
009B43  2  69 01                adc #$01
009B45  2  C9 08        AddCCF: cmp #$08                   ;if result or two's compliment greater than eight,
009B47  2  B0 0E                bcs BPGet                  ;skip to the end without changing movement force
009B49  2  BD 34 04             lda Enemy_Y_MoveForce,x
009B4C  2  18                   clc
009B4D  2  69 10                adc #$10                   ;otherwise add to it
009B4F  2  9D 34 04             sta Enemy_Y_MoveForce,x
009B52  2  4A                   lsr                        ;move high nybble to low again
009B53  2  4A                   lsr
009B54  2  4A                   lsr
009B55  2  4A                   lsr
009B56  2  A8                   tay
009B57  2  B9 13 9B     BPGet:  lda FlyCCBPriority,y       ;load bg priority data and store (this is very likely
009B5A  2  9D C5 03             sta Enemy_SprAttrib,x      ;broken or residual code, value is overwritten before
009B5D  2  60                   rts                        ;drawing it next frame), then leave
009B5E  2               
009B5E  2               ;--------------------------------
009B5E  2               ;$00 - used to hold horizontal difference
009B5E  2               ;$01-$03 - used to hold difference adjusters
009B5E  2               
009B5E  2               LakituDiffAdj:
009B5E  2  15 30 40           .byte $15, $30, $40
009B61  2               
009B61  2               MoveLakitu:
009B61  2  B5 1E                 lda Enemy_State,x          ;check lakitu's enemy state
009B63  2  29 20                 and #%00100000             ;for d5 set
009B65  2  F0 03                 beq ChkLS                  ;if not set, continue with code
009B67  2  4C 72 8B              jmp MoveD_EnemyVertically  ;otherwise jump to move defeated lakitu downwards
009B6A  2  B5 1E        ChkLS:   lda Enemy_State,x          ;if lakitu's enemy state not set at all,
009B6C  2  F0 0B                 beq Fr12S                  ;go ahead and continue with code
009B6E  2  A9 00                 lda #$00
009B70  2  95 A0                 sta LakituMoveDirection,x  ;otherwise initialize moving direction to move to left
009B72  2  8D CB 06              sta EnemyFrenzyBuffer      ;initialize frenzy buffer
009B75  2  A9 10                 lda #$10
009B77  2  D0 13                 bne SetLSpd                ;load horizontal speed and do unconditional branch
009B79  2  A9 12        Fr12S:   lda #Spiny
009B7B  2  8D CB 06              sta EnemyFrenzyBuffer      ;set spiny identifier in frenzy buffer
009B7E  2  A0 02                 ldy #$02
009B80  2  B9 5E 9B     LdLDa:   lda LakituDiffAdj,y        ;load values
009B83  2  99 01 00              sta $0001,y                ;store in zero page
009B86  2  88                    dey
009B87  2  10 F7                 bpl LdLDa                  ;do this until all values are stired
009B89  2  20 A5 9B              jsr PlayerLakituDiff       ;execute sub to set speed and create spinys
009B8C  2  95 58        SetLSpd: sta LakituMoveSpeed,x      ;set movement speed returned from sub
009B8E  2  A0 01                 ldy #$01                   ;set moving direction to right by default
009B90  2  B5 A0                 lda LakituMoveDirection,x
009B92  2  29 01                 and #$01                   ;get LSB of moving direction
009B94  2  D0 0A                 bne SetLMov                ;if set, branch to the end to use moving direction
009B96  2  B5 58                 lda LakituMoveSpeed,x
009B98  2  49 FF                 eor #$ff                   ;get two's compliment of moving speed
009B9A  2  18                    clc
009B9B  2  69 01                 adc #$01
009B9D  2  95 58                 sta LakituMoveSpeed,x      ;store as new moving speed
009B9F  2  C8                    iny                        ;increment moving direction to left
009BA0  2  94 46        SetLMov: sty Enemy_MovingDir,x      ;store moving direction
009BA2  2  4C 11 8B              jmp MoveEnemyHorizontally  ;move lakitu horizontally
009BA5  2               
009BA5  2               PlayerLakituDiff:
009BA5  2  A0 00                   ldy #$00                   ;set Y for default value
009BA7  2  20 EF AD                jsr PlayerEnemyDiff        ;get horizontal difference between enemy and player
009BAA  2  10 0A                   bpl ChkLakDif              ;branch if enemy is to the right of the player
009BAC  2  C8                      iny                        ;increment Y for left of player
009BAD  2  A5 00                   lda $00
009BAF  2  49 FF                   eor #$ff                   ;get two's compliment of low byte of horizontal difference
009BB1  2  18                      clc
009BB2  2  69 01                   adc #$01                   ;store two's compliment as horizontal difference
009BB4  2  85 00                   sta $00
009BB6  2  A5 00        ChkLakDif: lda $00                    ;get low byte of horizontal difference
009BB8  2  C9 3C                   cmp #$3c                   ;if within a certain distance of player, branch
009BBA  2  90 1C                   bcc ChkPSpeed
009BBC  2  A9 3C                   lda #$3c                   ;otherwise set maximum distance
009BBE  2  85 00                   sta $00
009BC0  2  B5 16                   lda Enemy_ID,x             ;check if lakitu is in our current enemy slot
009BC2  2  C9 11                   cmp #Lakitu
009BC4  2  D0 12                   bne ChkPSpeed              ;if not, branch elsewhere
009BC6  2  98                      tya                        ;compare contents of Y, now in A
009BC7  2  D5 A0                   cmp LakituMoveDirection,x  ;to what is being used as horizontal movement direction
009BC9  2  F0 0D                   beq ChkPSpeed              ;if moving toward the player, branch, do not alter
009BCB  2  B5 A0                   lda LakituMoveDirection,x  ;if moving to the left beyond maximum distance,
009BCD  2  F0 06                   beq SetLMovD               ;branch and alter without delay
009BCF  2  D6 58                   dec LakituMoveSpeed,x      ;decrement horizontal speed
009BD1  2  B5 58                   lda LakituMoveSpeed,x      ;if horizontal speed not yet at zero, branch to leave
009BD3  2  D0 40                   bne ExMoveLak
009BD5  2  98           SetLMovD:  tya                        ;set horizontal direction depending on horizontal
009BD6  2  95 A0                   sta LakituMoveDirection,x  ;difference between enemy and player if necessary
009BD8  2  A5 00        ChkPSpeed: lda $00
009BDA  2  29 3C                   and #%00111100             ;mask out all but four bits in the middle
009BDC  2  4A                      lsr                        ;divide masked difference by four
009BDD  2  4A                      lsr
009BDE  2  85 00                   sta $00                    ;store as new value
009BE0  2  A0 00                   ldy #$00                   ;init offset
009BE2  2  A5 57                   lda Player_X_Speed
009BE4  2  F0 24                   beq SubDifAdj              ;if player not moving horizontally, branch
009BE6  2  AD 75 07                lda ScrollAmount
009BE9  2  F0 1F                   beq SubDifAdj              ;if scroll speed not set, branch to same place
009BEB  2  C8                      iny                        ;otherwise increment offset
009BEC  2  A5 57                   lda Player_X_Speed
009BEE  2  C9 19                   cmp #$19                   ;if player not running, branch
009BF0  2  90 08                   bcc ChkSpinyO
009BF2  2  AD 75 07                lda ScrollAmount
009BF5  2  C9 02                   cmp #$02                   ;if scroll speed below a certain amount, branch
009BF7  2  90 01                   bcc ChkSpinyO              ;to same place
009BF9  2  C8                      iny                        ;otherwise increment once more
009BFA  2  B5 16        ChkSpinyO: lda Enemy_ID,x             ;check for spiny object
009BFC  2  C9 12                   cmp #Spiny
009BFE  2  D0 04                   bne ChkEmySpd              ;branch if not found
009C00  2  A5 57                   lda Player_X_Speed         ;if player not moving, skip this part
009C02  2  D0 06                   bne SubDifAdj
009C04  2  B5 A0        ChkEmySpd: lda Enemy_Y_Speed,x        ;check vertical speed
009C06  2  D0 02                   bne SubDifAdj              ;branch if nonzero
009C08  2  A0 00                   ldy #$00                   ;otherwise reinit offset
009C0A  2  B9 01 00     SubDifAdj: lda $0001,y                ;get one of three saved values from earlier
009C0D  2  A4 00                   ldy $00                    ;get saved horizontal difference
009C0F  2  38           SPixelLak: sec                        ;subtract one for each pixel of horizontal difference
009C10  2  E9 01                   sbc #$01                   ;from one of three saved values
009C12  2  88                      dey
009C13  2  10 FA                   bpl SPixelLak              ;branch until all pixels are subtracted, to adjust difference
009C15  2  60           ExMoveLak: rts                        ;leave!!!
009C16  2               
009C16  2               ;-------------------------------------------------------------------------------------
009C16  2               ;$04-$05 - used to store name table address in little endian order
009C16  2               
009C16  2               BridgeCollapseData:
009C16  2  1A                 .byte $1a ;axe
009C17  2  58                 .byte $58 ;chain
009C18  2  98 96 94 92        .byte $98, $96, $94, $92, $90, $8e, $8c ;bridge
009C1C  2  90 8E 8C     
009C1F  2  8A 88 86 84        .byte $8a, $88, $86, $84, $82, $80
009C23  2  82 80        
009C25  2               
009C25  2               BridgeCollapse:
009C25  2  AE 68 03            ldx BowserFront_Offset    ;get enemy offset for bowser
009C28  2  B5 16               lda Enemy_ID,x            ;check enemy object identifier for bowser
009C2A  2  C9 2D               cmp #Bowser               ;if not found, branch ahead,
009C2C  2  D0 10               bne SetM2                 ;metatile removal not necessary
009C2E  2  86 08               stx ObjectOffset          ;store as enemy offset here
009C30  2  B5 1E               lda Enemy_State,x         ;if bowser in normal state, skip all of this
009C32  2  F0 1A               beq RemoveBridge
009C34  2  29 40               and #%01000000            ;if bowser's state has d6 clear, skip to silence music
009C36  2  F0 06               beq SetM2
009C38  2  B5 CF               lda Enemy_Y_Position,x    ;check bowser's vertical coordinate
009C3A  2  C9 E0               cmp #$e0                  ;if bowser not yet low enough, skip this part ahead
009C3C  2  90 0A               bcc MoveD_Bowser
009C3E  2  A9 80        SetM2: lda #Silence              ;silence music
009C40  2  85 FC               sta EventMusicQueue
009C42  2  EE 72 07            inc OperMode_Task         ;move onto next secondary mode in victory mode
009C45  2  4C AA 9C            jmp KillAllEnemies        ;jump to empty all enemy slots and then leave
009C48  2               
009C48  2               MoveD_Bowser:
009C48  2  20 9B 8B            jsr MoveEnemySlowVert     ;do a sub to move bowser downwards
009C4B  2  4C B4 9D            jmp BowserGfxHandler      ;jump to draw bowser's front and rear, then leave
009C4E  2               
009C4E  2               RemoveBridge:
009C4E  2  CE 64 03              dec BowserFeetCounter     ;decrement timer to control bowser's feet
009C51  2  D0 44                 bne NoBFall               ;if not expired, skip all of this
009C53  2  A9 04                 lda #$04
009C55  2  8D 64 03              sta BowserFeetCounter     ;otherwise, set timer now
009C58  2  AD 63 03              lda BowserBodyControls
009C5B  2  49 01                 eor #$01                  ;invert bit to control bowser's feet
009C5D  2  8D 63 03              sta BowserBodyControls
009C60  2  A9 22                 lda #$22                  ;put high byte of name table address here for now
009C62  2  85 05                 sta $05
009C64  2  AC 69 03              ldy BridgeCollapseOffset  ;get bridge collapse offset here
009C67  2  B9 16 9C              lda BridgeCollapseData,y  ;load low byte of name table address and store here
009C6A  2  85 04                 sta $04
009C6C  2  AC 00 03              ldy VRAM_Buffer1_Offset   ;increment vram buffer offset
009C6F  2  C8                    iny
009C70  2  A2 0C                 ldx #$0c                  ;set offset for tile data for sub to draw blank metatile
009C72  2  20 44 6A              jsr RemBridge             ;do sub here to remove bowser's bridge metatiles
009C75  2  A6 08                 ldx ObjectOffset          ;get enemy offset
009C77  2  20 06 6A              jsr MoveVOffset           ;set new vram buffer offset
009C7A  2  A9 08                 lda #Sfx_Blast            ;load the fireworks/gunfire sound into the square 2 sfx
009C7C  2  85 FE                 sta Square2SoundQueue     ;queue while at the same time loading the brick
009C7E  2  A9 01                 lda #Sfx_BrickShatter     ;shatter sound into the noise sfx queue thus
009C80  2  85 FD                 sta NoiseSoundQueue       ;producing the unique sound of the bridge collapsing
009C82  2  EE 69 03              inc BridgeCollapseOffset  ;increment bridge collapse offset
009C85  2  AD 69 03              lda BridgeCollapseOffset
009C88  2  C9 0F                 cmp #$0f                  ;if bridge collapse offset has not yet reached
009C8A  2  D0 0B                 bne NoBFall               ;the end, go ahead and skip this part
009C8C  2  20 77 8F              jsr InitVStf              ;initialize whatever vertical speed bowser has
009C8F  2  A9 40                 lda #%01000000
009C91  2  95 1E                 sta Enemy_State,x         ;set bowser's state to one of defeated states (d6 set)
009C93  2  A9 80                 lda #Sfx_BowserFall
009C95  2  85 FE                 sta Square2SoundQueue     ;play bowser defeat sound
009C97  2  4C B4 9D     NoBFall: jmp BowserGfxHandler      ;jump to code that draws bowser
009C9A  2               
009C9A  2               ;--------------------------------
009C9A  2               
009C9A  2               PRandomRange:
009C9A  2  21 41 11 31        .byte $21, $41, $11, $31
009C9E  2               
009C9E  2               RunBowser:
009C9E  2  B5 1E              lda Enemy_State,x       ;if d5 in enemy state is not set
009CA0  2  29 20              and #%00100000          ;then branch elsewhere to run bowser
009CA2  2  F0 14              beq BowserControl
009CA4  2  B5 CF              lda Enemy_Y_Position,x  ;otherwise check vertical position
009CA6  2  C9 E0              cmp #$e0                ;if above a certain point, branch to move defeated bowser
009CA8  2  90 9E              bcc MoveD_Bowser        ;otherwise proceed to KillAllEnemies
009CAA  2               
009CAA  2               KillAllEnemies:
009CAA  2  A2 04                  ldx #$04              ;start with last enemy slot
009CAC  2  20 CC 95     KillLoop: jsr EraseEnemyObject  ;branch to kill enemy objects
009CAF  2  CA                     dex                   ;move onto next enemy slot
009CB0  2  10 FA                  bpl KillLoop          ;do this until all slots are emptied
009CB2  2  8D CB 06               sta EnemyFrenzyBuffer ;empty frenzy buffer
009CB5  2  A6 08                  ldx ObjectOffset      ;get enemy object offset and leave
009CB7  2  60                     rts
009CB8  2               
009CB8  2               BowserControl:
009CB8  2  A9 00                   lda #$00
009CBA  2  8D CB 06                sta EnemyFrenzyBuffer      ;empty frenzy buffer
009CBD  2  AD 47 07                lda TimerControl           ;if master timer control not set,
009CC0  2  F0 03                   beq ChkMouth               ;skip jump and execute code here
009CC2  2  4C 72 9D                jmp SkipToFB               ;otherwise, jump over a bunch of code
009CC5  2  AD 63 03     ChkMouth:  lda BowserBodyControls     ;check bowser's mouth
009CC8  2  10 03                   bpl FeetTmr                ;if bit clear, go ahead with code here
009CCA  2  4C 48 9D                jmp HammerChk              ;otherwise skip a whole section starting here
009CCD  2  CE 64 03     FeetTmr:   dec BowserFeetCounter      ;decrement timer to control bowser's feet
009CD0  2  D0 0D                   bne ResetMDr               ;if not expired, skip this part
009CD2  2  A9 20                   lda #$20                   ;otherwise, reset timer
009CD4  2  8D 64 03                sta BowserFeetCounter
009CD7  2  AD 63 03                lda BowserBodyControls     ;and invert bit used
009CDA  2  49 01                   eor #%00000001             ;to control bowser's feet
009CDC  2  8D 63 03                sta BowserBodyControls
009CDF  2  A5 09        ResetMDr:  lda FrameCounter           ;check frame counter
009CE1  2  29 0F                   and #%00001111             ;if not on every sixteenth frame, skip
009CE3  2  D0 04                   bne B_FaceP                ;ahead to continue code
009CE5  2  A9 02                   lda #$02                   ;otherwise reset moving/facing direction every
009CE7  2  95 46                   sta Enemy_MovingDir,x      ;sixteen frames
009CE9  2  BD 8A 07     B_FaceP:   lda EnemyFrameTimer,x      ;if timer set here expired,
009CEC  2  F0 1C                   beq GetPRCmp               ;branch to next section
009CEE  2  20 EF AD                jsr PlayerEnemyDiff        ;get horizontal difference between player and bowser,
009CF1  2  10 17                   bpl GetPRCmp               ;and branch if bowser to the right of the player
009CF3  2  A9 01                   lda #$01
009CF5  2  95 46                   sta Enemy_MovingDir,x      ;set bowser to move and face to the right
009CF7  2  A9 02                   lda #$02
009CF9  2  8D 65 03                sta BowserMovementSpeed    ;set movement speed
009CFC  2  A9 20                   lda #$20
009CFE  2  9D 8A 07                sta EnemyFrameTimer,x      ;set timer here
009D01  2  8D 90 07                sta BowserFireBreathTimer  ;set timer used for bowser's flame
009D04  2  B5 87                   lda Enemy_X_Position,x
009D06  2  C9 C8                   cmp #$c8                   ;if bowser to the right past a certain point,
009D08  2  B0 3E                   bcs HammerChk              ;skip ahead to some other section
009D0A  2  A5 09        GetPRCmp:  lda FrameCounter           ;get frame counter
009D0C  2  29 03                   and #%00000011
009D0E  2  D0 38                   bne HammerChk              ;execute this code every fourth frame, otherwise branch
009D10  2  B5 87                   lda Enemy_X_Position,x
009D12  2  CD 66 03                cmp BowserOrigXPos         ;if bowser not at original horizontal position,
009D15  2  D0 0C                   bne GetDToO                ;branch to skip this part
009D17  2  BD A7 07                lda PseudoRandomBitReg,x
009D1A  2  29 03                   and #%00000011             ;get pseudorandom offset
009D1C  2  A8                      tay
009D1D  2  B9 9A 9C                lda PRandomRange,y         ;load value using pseudorandom offset
009D20  2  8D DC 06                sta MaxRangeFromOrigin     ;and store here
009D23  2  B5 87        GetDToO:   lda Enemy_X_Position,x
009D25  2  18                      clc                        ;add movement speed to bowser's horizontal
009D26  2  6D 65 03                adc BowserMovementSpeed    ;coordinate and save as new horizontal position
009D29  2  95 87                   sta Enemy_X_Position,x
009D2B  2  B4 46                   ldy Enemy_MovingDir,x
009D2D  2  C0 01                   cpy #$01                   ;if bowser moving and facing to the right, skip ahead
009D2F  2  F0 17                   beq HammerChk
009D31  2  A0 FF                   ldy #$ff                   ;set default movement speed here (move left)
009D33  2  38                      sec                        ;get difference of current vs. original
009D34  2  ED 66 03                sbc BowserOrigXPos         ;horizontal position
009D37  2  10 07                   bpl CompDToO               ;if current position to the right of original, skip ahead
009D39  2  49 FF                   eor #$ff
009D3B  2  18                      clc                        ;get two's compliment
009D3C  2  69 01                   adc #$01
009D3E  2  A0 01                   ldy #$01                   ;set alternate movement speed here (move right)
009D40  2  CD DC 06     CompDToO:  cmp MaxRangeFromOrigin     ;compare difference with pseudorandom value
009D43  2  90 03                   bcc HammerChk              ;if difference < pseudorandom value, leave speed alone
009D45  2  8C 65 03                sty BowserMovementSpeed    ;otherwise change bowser's movement speed
009D48  2  BD 8A 07     HammerChk: lda EnemyFrameTimer,x      ;if timer set here not expired yet, skip ahead to
009D4B  2  D0 28                   bne MakeBJump              ;some other section of code
009D4D  2  20 9B 8B                jsr MoveEnemySlowVert      ;otherwise start by moving bowser downwards
009D50  2  AD 5F 07                lda WorldNumber            ;check world number
009D53  2  C9 05                   cmp #World6
009D55  2  90 09                   bcc SetHmrTmr              ;if world 1-5, skip this part (not time to throw hammers yet)
009D57  2  A5 09                   lda FrameCounter
009D59  2  29 03                   and #%00000011             ;check to see if it's time to execute sub
009D5B  2  D0 03                   bne SetHmrTmr              ;if not, skip sub, otherwise
009D5D  2  20 AA 86                jsr SpawnHammerObj         ;execute sub on every fourth frame to spawn hammer
009D60  2  B5 CF        SetHmrTmr: lda Enemy_Y_Position,x     ;get current vertical position
009D62  2  C9 80                   cmp #$80                   ;if still above a certain point
009D64  2  90 1C                   bcc ChkFireB               ;then skip to world number check for flames
009D66  2  BD A7 07                lda PseudoRandomBitReg,x
009D69  2  29 03                   and #%00000011             ;get pseudorandom offset
009D6B  2  A8                      tay
009D6C  2  B9 9A 9C                lda PRandomRange,y         ;get value using pseudorandom offset
009D6F  2  9D 8A 07                sta EnemyFrameTimer,x      ;set for timer here
009D72  2  4C 82 9D     SkipToFB:  jmp ChkFireB               ;jump to execute flames code
009D75  2  C9 01        MakeBJump: cmp #$01                   ;if timer not yet about to expire,
009D77  2  D0 09                   bne ChkFireB               ;skip ahead to next part
009D79  2  D6 CF                   dec Enemy_Y_Position,x     ;otherwise decrement vertical coordinate
009D7B  2  20 77 8F                jsr InitVStf               ;initialize movement amount
009D7E  2  A9 FE                   lda #$fe
009D80  2  95 A0                   sta Enemy_Y_Speed,x        ;set vertical speed to move bowser upwards
009D82  2  AD 5F 07     ChkFireB:  lda WorldNumber            ;check world number here
009D85  2  C9 07                   cmp #World8                ;world 8?
009D87  2  F0 04                   beq SpawnFBr               ;if so, execute this part here
009D89  2  C9 05                   cmp #World6                ;world 6-7?
009D8B  2  B0 27                   bcs BowserGfxHandler       ;if so, skip this part here
009D8D  2  AD 90 07     SpawnFBr:  lda BowserFireBreathTimer  ;check timer here
009D90  2  D0 22                   bne BowserGfxHandler       ;if not expired yet, skip all of this
009D92  2  A9 20                   lda #$20
009D94  2  8D 90 07                sta BowserFireBreathTimer  ;set timer here
009D97  2  AD 63 03                lda BowserBodyControls
009D9A  2  49 80                   eor #%10000000             ;invert bowser's mouth bit to open
009D9C  2  8D 63 03                sta BowserBodyControls     ;and close bowser's mouth
009D9F  2  30 E1                   bmi ChkFireB               ;if bowser's mouth open, loop back
009DA1  2  20 12 9E                jsr SetFlameTimer          ;get timing for bowser's flame
009DA4  2  AC CC 06                ldy SecondaryHardMode
009DA7  2  F0 03                   beq SetFBTmr               ;if secondary hard mode flag not set, skip this
009DA9  2  38                      sec
009DAA  2  E9 10                   sbc #$10                   ;otherwise subtract from value in A
009DAC  2  8D 90 07     SetFBTmr:  sta BowserFireBreathTimer  ;set value as timer here
009DAF  2  A9 15                   lda #BowserFlame           ;put bowser's flame identifier
009DB1  2  8D CB 06                sta EnemyFrenzyBuffer      ;in enemy frenzy buffer
009DB4  2               
009DB4  2               ;--------------------------------
009DB4  2               
009DB4  2               BowserGfxHandler:
009DB4  2  20 F5 9D               jsr ProcessBowserHalf    ;do a sub here to process bowser's front
009DB7  2  A0 10                  ldy #$10                 ;load default value here to position bowser's rear
009DB9  2  B5 46                  lda Enemy_MovingDir,x    ;check moving direction
009DBB  2  4A                     lsr
009DBC  2  90 02                  bcc CopyFToR             ;if moving left, use default
009DBE  2  A0 F0                  ldy #$f0                 ;otherwise load alternate positioning value here
009DC0  2  98           CopyFToR: tya                      ;move bowser's rear object position value to A
009DC1  2  18                     clc
009DC2  2  75 87                  adc Enemy_X_Position,x   ;add to bowser's front object horizontal coordinate
009DC4  2  AC CF 06               ldy DuplicateObj_Offset  ;get bowser's rear object offset
009DC7  2  99 87 00               sta Enemy_X_Position,y   ;store A as bowser's rear horizontal coordinate
009DCA  2  B5 CF                  lda Enemy_Y_Position,x
009DCC  2  18                     clc                      ;add eight pixels to bowser's front object
009DCD  2  69 08                  adc #$08                 ;vertical coordinate and store as vertical coordinate
009DCF  2  99 CF 00               sta Enemy_Y_Position,y   ;for bowser's rear
009DD2  2  B5 1E                  lda Enemy_State,x
009DD4  2  99 1E 00               sta Enemy_State,y        ;copy enemy state directly from front to rear
009DD7  2  B5 46                  lda Enemy_MovingDir,x
009DD9  2  99 46 00               sta Enemy_MovingDir,y    ;copy moving direction also
009DDC  2  A5 08                  lda ObjectOffset         ;save enemy object offset of front to stack
009DDE  2  48                     pha
009DDF  2  AE CF 06               ldx DuplicateObj_Offset  ;put enemy object offset of rear as current
009DE2  2  86 08                  stx ObjectOffset
009DE4  2  A9 2D                  lda #Bowser              ;set bowser's enemy identifier
009DE6  2  95 16                  sta Enemy_ID,x           ;store in bowser's rear object
009DE8  2  20 F5 9D               jsr ProcessBowserHalf    ;do a sub here to process bowser's rear
009DEB  2  68                     pla
009DEC  2  85 08                  sta ObjectOffset         ;get original enemy object offset
009DEE  2  AA                     tax
009DEF  2  A9 00                  lda #$00                 ;nullify bowser's front/rear graphics flag
009DF1  2  8D 6A 03               sta BowserGfxFlag
009DF4  2  60           ExBGfxH:  rts                      ;leave!
009DF5  2               
009DF5  2               ProcessBowserHalf:
009DF5  2  EE 6A 03           inc BowserGfxFlag         ;increment bowser's graphics flag, then run subroutines
009DF8  2  20 0C 95           jsr RunRetainerObj        ;to get offscreen bits, relative position and draw bowser (finally!)
009DFB  2  B5 1E              lda Enemy_State,x
009DFD  2  D0 F5              bne ExBGfxH               ;if either enemy object not in normal state, branch to leave
009DFF  2  A9 0A              lda #$0a
009E01  2  9D 9A 04           sta Enemy_BoundBoxCtrl,x  ;set bounding box size control
009E04  2  20 F3 AE           jsr GetEnemyBoundBox      ;get bounding box coordinates
009E07  2  4C A7 A4           jmp PlayerEnemyCollision  ;do player-to-enemy collision detection
009E0A  2               
009E0A  2               ;-------------------------------------------------------------------------------------
009E0A  2               ;$00 - used to hold movement force and tile number
009E0A  2               ;$01 - used to hold sprite attribute data
009E0A  2               
009E0A  2               FlameTimerData:
009E0A  2  BF 40 BF BF        .byte $bf, $40, $bf, $bf, $bf, $40, $40, $bf
009E0E  2  BF 40 40 BF  
009E12  2               
009E12  2               SetFlameTimer:
009E12  2  AC 67 03           ldy BowserFlameTimerCtrl  ;load counter as offset
009E15  2  EE 67 03           inc BowserFlameTimerCtrl  ;increment
009E18  2  AD 67 03           lda BowserFlameTimerCtrl  ;mask out all but 3 LSB
009E1B  2  29 07              and #%00000111            ;to keep in range of 0-7
009E1D  2  8D 67 03           sta BowserFlameTimerCtrl
009E20  2  B9 0A 9E           lda FlameTimerData,y      ;load value to be used then leave
009E23  2  60           ExFl: rts
009E24  2               
009E24  2               ProcBowserFlame:
009E24  2  AD 47 07              lda TimerControl            ;if master timer control flag set,
009E27  2  D0 30                 bne SetGfxF                 ;skip all of this
009E29  2  A9 40                 lda #$40                    ;load default movement force
009E2B  2  AC CC 06              ldy SecondaryHardMode
009E2E  2  F0 02                 beq SFlmX                   ;if secondary hard mode flag not set, use default
009E30  2  A9 60                 lda #$60                    ;otherwise load alternate movement force to go faster
009E32  2  85 00        SFlmX:   sta $00                     ;store value here
009E34  2  BD 01 04              lda Enemy_X_MoveForce,x
009E37  2  38                    sec                         ;subtract value from movement force
009E38  2  E5 00                 sbc $00
009E3A  2  9D 01 04              sta Enemy_X_MoveForce,x     ;save new value
009E3D  2  B5 87                 lda Enemy_X_Position,x
009E3F  2  E9 01                 sbc #$01                    ;subtract one from horizontal position to move
009E41  2  95 87                 sta Enemy_X_Position,x      ;to the left
009E43  2  B5 6E                 lda Enemy_PageLoc,x
009E45  2  E9 00                 sbc #$00                    ;subtract borrow from page location
009E47  2  95 6E                 sta Enemy_PageLoc,x
009E49  2  BC 17 04              ldy BowserFlamePRandomOfs,x ;get some value here and use as offset
009E4C  2  B5 CF                 lda Enemy_Y_Position,x      ;load vertical coordinate
009E4E  2  D9 D0 91              cmp FlameYPosData,y         ;compare against coordinate data using $0417,x as offset
009E51  2  F0 06                 beq SetGfxF                 ;if equal, branch and do not modify coordinate
009E53  2  18                    clc
009E54  2  7D 34 04              adc Enemy_Y_MoveForce,x     ;otherwise add value here to coordinate and store
009E57  2  95 CF                 sta Enemy_Y_Position,x      ;as new vertical coordinate
009E59  2  20 47 BE     SetGfxF: jsr RelativeEnemyPosition   ;get new relative coordinates
009E5C  2  B5 1E                 lda Enemy_State,x           ;if bowser's flame not in normal state,
009E5E  2  D0 C3                 bne ExFl                    ;branch to leave
009E60  2  A9 51                 lda #$51                    ;otherwise, continue
009E62  2  85 00                 sta $00                     ;write first tile number
009E64  2  A0 02                 ldy #$02                    ;load attributes without vertical flip by default
009E66  2  A5 09                 lda FrameCounter
009E68  2  29 02                 and #%00000010              ;invert vertical flip bit every 2 frames
009E6A  2  F0 02                 beq FlmeAt                  ;if d1 not set, write default value
009E6C  2  A0 82                 ldy #$82                    ;otherwise write value with vertical flip bit set
009E6E  2  84 01        FlmeAt:  sty $01                     ;set bowser's flame sprite attributes here
009E70  2  BC E5 06              ldy Enemy_SprDataOffset,x   ;get OAM data offset
009E73  2  A2 00                 ldx #$00
009E75  2               
009E75  2               DrawFlameLoop:
009E75  2  AD B9 03              lda Enemy_Rel_YPos         ;get Y relative coordinate of current enemy object
009E78  2  99 00 02              sta Sprite_Y_Position,y    ;write into Y coordinate of OAM data
009E7B  2  A5 00                 lda $00
009E7D  2  99 01 02              sta Sprite_Tilenumber,y    ;write current tile number into OAM data
009E80  2  E6 00                 inc $00                    ;increment tile number to draw more bowser's flame
009E82  2  A5 01                 lda $01
009E84  2  99 02 02              sta Sprite_Attributes,y    ;write saved attributes into OAM data
009E87  2  AD AE 03              lda Enemy_Rel_XPos
009E8A  2  99 03 02              sta Sprite_X_Position,y    ;write X relative coordinate of current enemy object
009E8D  2  18                    clc
009E8E  2  69 08                 adc #$08
009E90  2  8D AE 03              sta Enemy_Rel_XPos         ;then add eight to it and store
009E93  2  C8                    iny
009E94  2  C8                    iny
009E95  2  C8                    iny
009E96  2  C8                    iny                        ;increment Y four times to move onto the next OAM
009E97  2  E8                    inx                        ;move onto the next OAM, and branch if three
009E98  2  E0 03                 cpx #$03                   ;have not yet been done
009E9A  2  90 D9                 bcc DrawFlameLoop
009E9C  2  A6 08                 ldx ObjectOffset           ;reload original enemy offset
009E9E  2  20 A4 BE              jsr GetEnemyOffscreenBits  ;get offscreen information
009EA1  2  BC E5 06              ldy Enemy_SprDataOffset,x  ;get OAM data offset
009EA4  2  AD D1 03              lda Enemy_OffscreenBits    ;get enemy object offscreen bits
009EA7  2  4A                    lsr                        ;move d0 to carry and result to stack
009EA8  2  48                    pha
009EA9  2  90 05                 bcc M3FOfs                 ;branch if carry not set
009EAB  2  A9 F8                 lda #$f8                   ;otherwise move sprite offscreen, this part likely
009EAD  2  99 0C 02              sta Sprite_Y_Position+12,y ;residual since flame is only made of three sprites
009EB0  2  68           M3FOfs:  pla                        ;get bits from stack
009EB1  2  4A                    lsr                        ;move d1 to carry and move bits back to stack
009EB2  2  48                    pha
009EB3  2  90 05                 bcc M2FOfs                 ;branch if carry not set again
009EB5  2  A9 F8                 lda #$f8                   ;otherwise move third sprite offscreen
009EB7  2  99 08 02              sta Sprite_Y_Position+8,y
009EBA  2  68           M2FOfs:  pla                        ;get bits from stack again
009EBB  2  4A                    lsr                        ;move d2 to carry and move bits back to stack again
009EBC  2  48                    pha
009EBD  2  90 05                 bcc M1FOfs                 ;branch if carry not set yet again
009EBF  2  A9 F8                 lda #$f8                   ;otherwise move second sprite offscreen
009EC1  2  99 04 02              sta Sprite_Y_Position+4,y
009EC4  2  68           M1FOfs:  pla                        ;get bits from stack one last time
009EC5  2  4A                    lsr                        ;move d3 to carry
009EC6  2  90 05                 bcc ExFlmeD                ;branch if carry not set one last time
009EC8  2  A9 F8                 lda #$f8
009ECA  2  99 00 02              sta Sprite_Y_Position,y    ;otherwise move first sprite offscreen
009ECD  2  60           ExFlmeD: rts                        ;leave
009ECE  2               
009ECE  2               ;--------------------------------
009ECE  2               
009ECE  2               RunFireworks:
009ECE  2  D6 A0                   dec ExplosionTimerCounter,x ;decrement explosion timing counter here
009ED0  2  D0 0C                   bne SetupExpl               ;if not expired, skip this part
009ED2  2  A9 08                   lda #$08
009ED4  2  95 A0                   sta ExplosionTimerCounter,x ;reset counter
009ED6  2  F6 58                   inc ExplosionGfxCounter,x   ;increment explosion graphics counter
009ED8  2  B5 58                   lda ExplosionGfxCounter,x
009EDA  2  C9 03                   cmp #$03                    ;check explosion graphics counter
009EDC  2  B0 18                   bcs FireworksSoundScore     ;if at a certain point, branch to kill this object
009EDE  2  20 47 BE     SetupExpl: jsr RelativeEnemyPosition   ;get relative coordinates of explosion
009EE1  2  AD B9 03                lda Enemy_Rel_YPos          ;copy relative coordinates
009EE4  2  8D BA 03                sta Fireball_Rel_YPos       ;from the enemy object to the fireball object
009EE7  2  AD AE 03                lda Enemy_Rel_XPos          ;first vertical, then horizontal
009EEA  2  8D AF 03                sta Fireball_Rel_XPos
009EED  2  BC E5 06                ldy Enemy_SprDataOffset,x   ;get OAM data offset
009EF0  2  B5 58                   lda ExplosionGfxCounter,x   ;get explosion graphics counter
009EF2  2  20 02 BA                jsr DrawExplosion_Fireworks ;do a sub to draw the explosion then leave
009EF5  2  60                      rts
009EF6  2               
009EF6  2               FireworksSoundScore:
009EF6  2  A9 00              lda #$00               ;disable enemy buffer flag
009EF8  2  95 0F              sta Enemy_Flag,x
009EFA  2  A9 08              lda #Sfx_Blast         ;play fireworks/gunfire sound
009EFC  2  85 FE              sta Square2SoundQueue
009EFE  2  A9 05              lda #$05               ;set part of score modifier for 500 points
009F00  2  8D 38 01           sta DigitModifier+4
009F03  2  4C 74 9F           jmp EndAreaPoints     ;jump to award points accordingly then leave
009F06  2               
009F06  2               ;--------------------------------
009F06  2               
009F06  2               StarFlagYPosAdder:
009F06  2  00 00 08 08        .byte $00, $00, $08, $08
009F0A  2               
009F0A  2               StarFlagXPosAdder:
009F0A  2  00 08 00 08        .byte $00, $08, $00, $08
009F0E  2               
009F0E  2               StarFlagTileData:
009F0E  2  54 55 56 57        .byte $54, $55, $56, $57
009F12  2               
009F12  2               RunStarFlagObj:
009F12  2  A9 00              lda #$00                 ;initialize enemy frenzy buffer
009F14  2  8D CB 06           sta EnemyFrenzyBuffer
009F17  2  AD 46 07           lda StarFlagTaskControl  ;check star flag object task number here
009F1A  2  C9 05              cmp #$05                 ;if greater than 5, branch to exit
009F1C  2  B0 31              bcs StarFlagExit
009F1E  2  20 0F 6D           jsr JumpEngine           ;otherwise jump to appropriate sub
009F21  2               
009F21  2  4F 9F              .word StarFlagExit
009F23  2  2B 9F              .word GameTimerFireworks
009F25  2  50 9F              .word AwardGameTimerPoints
009F27  2  7E 9F              .word RaiseFlagSetoffFWorks
009F29  2  D2 9F              .word DelayToAreaEnd
009F2B  2               
009F2B  2               GameTimerFireworks:
009F2B  2  AD EE 07              lda GameTimerDisplay+2 ;check to see if last digit of timer matches
009F2E  2  CD E8 07              cmp CoinDisplay+1      ;the last digit in the coin tally
009F31  2  D0 10                 bne NoFWks             ;if not, skip the fireworks
009F33  2  29 01                 and #$01
009F35  2  F0 06                 beq EvenDgs            ;if so, check to see if they are both odd or even
009F37  2  A0 03                 ldy #$03
009F39  2  A9 03                 lda #$03               ;if they are both odd, set state and counter
009F3B  2  D0 0A                 bne SetFWC             ;for 3 fireworks to go off
009F3D  2  A0 00        EvenDgs: ldy #$00               ;if they are both even, set state and counter
009F3F  2  A9 06                 lda #$06               ;for 6 fireworks to go off
009F41  2  D0 04                 bne SetFWC
009F43  2  A0 00        NoFWks:  ldy #$00
009F45  2  A9 FF                 lda #$ff               ;otherwise set value for no fireworks
009F47  2  8D D7 06     SetFWC:  sta FireworksCounter   ;set fireworks counter here
009F4A  2  94 1E                 sty Enemy_State,x      ;set whatever state we have in star flag object
009F4C  2               
009F4C  2               IncrementSFTask1:
009F4C  2  EE 46 07           inc StarFlagTaskControl  ;increment star flag object task number
009F4F  2               
009F4F  2               StarFlagExit:
009F4F  2  60                 rts                      ;leave
009F50  2               
009F50  2               AwardGameTimerPoints:
009F50  2  AD EC 07              lda GameTimerDisplay   ;check all game timer digits for any intervals left
009F53  2  0D ED 07              ora GameTimerDisplay+1
009F56  2  0D EE 07              ora GameTimerDisplay+2
009F59  2  F0 F1                 beq IncrementSFTask1   ;if no time left on game timer at all, branch to next task
009F5B  2               AwardTimerCastle:
009F5B  2  A5 09                 lda FrameCounter
009F5D  2  29 04                 and #%00000100         ;check frame counter for d2 set (skip ahead
009F5F  2  F0 04                 beq NoTTick            ;for four frames every four frames) branch if not set
009F61  2  A9 10                 lda #Sfx_TimerTick
009F63  2  85 FE                 sta Square2SoundQueue  ;load timer tick sound
009F65  2  A0 17        NoTTick: ldy #$17               ;set offset here to subtract from game timer's last digit
009F67  2  A9 FF                 lda #$ff               ;set adder here to $ff, or -1, to subtract one
009F69  2  8D 39 01              sta DigitModifier+5    ;from the last digit of the game timer
009F6C  2  20 64 6E              jsr DigitsMathRoutine  ;subtract digit
009F6F  2  A9 05                 lda #$05               ;set now to add 50 points
009F71  2  8D 39 01              sta DigitModifier+5    ;per game timer interval subtracted
009F74  2               
009F74  2               EndAreaPoints:
009F74  2  A0 0B                 ldy #$0b               ;load offset for score, then jump to handle the awarding
009F76  2  20 64 6E              jsr DigitsMathRoutine
009F79  2  A9 02                 lda #$02               ;now update the score on the screen
009F7B  2  4C 3A 88              jmp WriteDigits
009F7E  2               
009F7E  2               RaiseFlagSetoffFWorks:
009F7E  2  B5 CF                 lda Enemy_Y_Position,x  ;check star flag's vertical position
009F80  2  C9 72                 cmp #$72                ;against preset value
009F82  2  90 05                 bcc SetoffF             ;if star flag higher vertically, branch to other code
009F84  2  D6 CF                 dec Enemy_Y_Position,x  ;otherwise, raise star flag by one pixel
009F86  2  4C 95 9F              jmp DrawStarFlag        ;and skip this part here
009F89  2  AD D7 06     SetoffF: lda FireworksCounter    ;check fireworks counter
009F8C  2  F0 38                 beq DrawFlagSetTimer    ;if no fireworks left to go off, skip this part
009F8E  2  30 36                 bmi DrawFlagSetTimer    ;if no fireworks set to go off, skip this part
009F90  2  A9 16                 lda #Fireworks
009F92  2  8D CB 06              sta EnemyFrenzyBuffer   ;otherwise set fireworks object in frenzy queue
009F95  2               
009F95  2               DrawStarFlag:
009F95  2  20 47 BE              jsr RelativeEnemyPosition  ;get relative coordinates of star flag
009F98  2  BC E5 06              ldy Enemy_SprDataOffset,x  ;get OAM data offset
009F9B  2  A2 03                 ldx #$03                   ;do four sprites
009F9D  2  AD B9 03     DSFLoop: lda Enemy_Rel_YPos         ;get relative vertical coordinate
009FA0  2  18                    clc
009FA1  2  7D 06 9F              adc StarFlagYPosAdder,x    ;add Y coordinate adder data
009FA4  2  99 00 02              sta Sprite_Y_Position,y    ;store as Y coordinate
009FA7  2  BD 0E 9F              lda StarFlagTileData,x     ;get tile number
009FAA  2  99 01 02              sta Sprite_Tilenumber,y    ;store as tile number
009FAD  2  A9 22                 lda #$22                   ;set palette and background priority bits
009FAF  2  99 02 02              sta Sprite_Attributes,y    ;store as attributes
009FB2  2  AD AE 03              lda Enemy_Rel_XPos         ;get relative horizontal coordinate
009FB5  2  18                    clc
009FB6  2  7D 0A 9F              adc StarFlagXPosAdder,x    ;add X coordinate adder data
009FB9  2  99 03 02              sta Sprite_X_Position,y    ;store as X coordinate
009FBC  2  C8                    iny
009FBD  2  C8                    iny                        ;increment OAM data offset four bytes
009FBE  2  C8                    iny                        ;for next sprite
009FBF  2  C8                    iny
009FC0  2  CA                    dex                        ;move onto next sprite
009FC1  2  10 DA                 bpl DSFLoop                ;do this until all sprites are done
009FC3  2  A6 08                 ldx ObjectOffset           ;get enemy object offset and leave
009FC5  2  60                    rts
009FC6  2               
009FC6  2               DrawFlagSetTimer:
009FC6  2  20 95 9F           jsr DrawStarFlag          ;do sub to draw star flag
009FC9  2  A9 06              lda #$06
009FCB  2  9D 96 07           sta EnemyIntervalTimer,x  ;set interval timer here
009FCE  2               
009FCE  2               IncrementSFTask2:
009FCE  2  EE 46 07           inc StarFlagTaskControl   ;move onto next task
009FD1  2  60                 rts
009FD2  2               
009FD2  2               DelayToAreaEnd:
009FD2  2  20 95 9F           jsr DrawStarFlag          ;do sub to draw star flag
009FD5  2  BD 96 07           lda EnemyIntervalTimer,x  ;if interval timer set in previous task
009FD8  2  D0 05              bne StarFlagExit2         ;not yet expired, branch to leave
009FDA  2  AD B1 07           lda EventMusicBuffer      ;if event music buffer empty,
009FDD  2  F0 EF              beq IncrementSFTask2      ;branch to increment task
009FDF  2               
009FDF  2               StarFlagExit2:
009FDF  2  60                 rts                       ;otherwise leave
009FE0  2               
009FE0  2               ;--------------------------------
009FE0  2               ;$00 - used to store horizontal difference between player and piranha plant
009FE0  2               
009FE0  2               MovePiranhaPlant:
009FE0  2  B5 1E              lda Enemy_State,x           ;check enemy state
009FE2  2  D0 56              bne PutinPipe               ;if set at all, branch to leave
009FE4  2  BD 8A 07           lda EnemyFrameTimer,x       ;check enemy's timer here
009FE7  2  D0 51              bne PutinPipe               ;branch to end if not yet expired
009FE9  2  B5 A0              lda PiranhaPlant_MoveFlag,x ;check movement flag
009FEB  2  D0 23              bne SetupToMovePPlant       ;if moving, skip to part ahead
009FED  2  B5 58              lda PiranhaPlant_Y_Speed,x  ;if currently rising, branch
009FEF  2  30 14              bmi ReversePlantSpeed       ;to move enemy upwards out of pipe
009FF1  2  20 EF AD           jsr PlayerEnemyDiff         ;get horizontal difference between player and
009FF4  2  10 09              bpl ChkPlayerNearPipe       ;piranha plant, and branch if enemy to right of player
009FF6  2  A5 00              lda $00                     ;otherwise get saved horizontal difference
009FF8  2  49 FF              eor #$ff
009FFA  2  18                 clc                         ;and change to two's compliment
009FFB  2  69 01              adc #$01
009FFD  2  85 00              sta $00                     ;save as new horizontal difference
009FFF  2               
009FFF  2               ChkPlayerNearPipe:
009FFF  2  A5 00              lda $00                     ;get saved horizontal difference
00A001  2               .ifdef ANN
00A001  2  C9 13              cmp #$13
00A003  2               .else
00A003  2                     cmp #$21
00A003  2               .endif
00A003  2  90 35              bcc PutinPipe               ;if player within a certain distance, branch to leave
00A005  2               
00A005  2               ReversePlantSpeed:
00A005  2  B5 58              lda PiranhaPlant_Y_Speed,x  ;get vertical speed
00A007  2  49 FF              eor #$ff
00A009  2  18                 clc                         ;change to two's compliment
00A00A  2  69 01              adc #$01
00A00C  2  95 58              sta PiranhaPlant_Y_Speed,x  ;save as new vertical speed
00A00E  2  F6 A0              inc PiranhaPlant_MoveFlag,x ;increment to set movement flag
00A010  2               
00A010  2               SetupToMovePPlant:
00A010  2  BD 34 04           lda PiranhaPlantDownYPos,x  ;get original vertical coordinate (lowest point)
00A013  2  B4 58              ldy PiranhaPlant_Y_Speed,x  ;get vertical speed
00A015  2  10 03              bpl RiseFallPiranhaPlant    ;branch if moving downwards
00A017  2  BD 17 04           lda PiranhaPlantUpYPos,x    ;otherwise get other vertical coordinate (highest point)
00A01A  2               
00A01A  2               RiseFallPiranhaPlant:
00A01A  2  85 00               sta $00                     ;save vertical coordinate here
00A01C  2               .ifndef ANN
00A01C  2                      lda EnemyAttributeData+PiranhaPlant
00A01C  2                      cmp #$22                    ;check for red piranha plants
00A01C  2                      beq RedPP                   ;if found, skip to next part to execute code on every frame
00A01C  2               .endif
00A01C  2  A5 09               lda FrameCounter            ;get frame counter
00A01E  2  4A                  lsr
00A01F  2  90 19               bcc PutinPipe               ;branch to leave if d0 set (execute code every other frame)
00A021  2  AD 47 07     RedPP: lda TimerControl            ;get master timer control
00A024  2  D0 14               bne PutinPipe               ;branch to leave if set (likely not necessary)
00A026  2  B5 CF               lda Enemy_Y_Position,x      ;get current vertical coordinate
00A028  2  18                  clc
00A029  2  75 58               adc PiranhaPlant_Y_Speed,x  ;add vertical speed to move up or down
00A02B  2  95 CF               sta Enemy_Y_Position,x      ;save as new vertical coordinate
00A02D  2  C5 00               cmp $00                     ;compare against low or high coordinate
00A02F  2  D0 09               bne PutinPipe               ;branch to leave if not yet reached
00A031  2  A9 00               lda #$00
00A033  2  95 A0               sta PiranhaPlant_MoveFlag,x ;otherwise clear movement flag
00A035  2  A9 40               lda #$40
00A037  2  9D 8A 07            sta EnemyFrameTimer,x       ;set timer to delay piranha plant movement
00A03A  2               
00A03A  2               PutinPipe:
00A03A  2  A9 20              lda #%00100000              ;set background priority bit in sprite
00A03C  2  9D C5 03           sta Enemy_SprAttrib,x       ;attributes to give illusion of being inside pipe
00A03F  2  60                 rts                         ;then leave
00A040  2               
00A040  2               ;-------------------------------------------------------------------------------------
00A040  2               ;$07 - spinning speed
00A040  2               
00A040  2               FirebarSpin:
00A040  2  85 07              sta $07                     ;save spinning speed here
00A042  2  B5 34              lda FirebarSpinDirection,x  ;check spinning direction
00A044  2  D0 0E              bne SpinCounterClockwise    ;if moving counter-clockwise, branch to other part
00A046  2  A0 18              ldy #$18                    ;possibly residual ldy
00A048  2  B5 58              lda FirebarSpinState_Low,x
00A04A  2  18                 clc                         ;add spinning speed to what would normally be
00A04B  2  65 07              adc $07                     ;the horizontal speed
00A04D  2  95 58              sta FirebarSpinState_Low,x
00A04F  2  B5 A0              lda FirebarSpinState_High,x ;add carry to what would normally be the vertical speed
00A051  2  69 00              adc #$00
00A053  2  60                 rts
00A054  2               
00A054  2               SpinCounterClockwise:
00A054  2  A0 08              ldy #$08                    ;possibly residual ldy
00A056  2  B5 58              lda FirebarSpinState_Low,x
00A058  2  38                 sec                         ;subtract spinning speed to what would normally be
00A059  2  E5 07              sbc $07                     ;the horizontal speed
00A05B  2  95 58              sta FirebarSpinState_Low,x
00A05D  2  B5 A0              lda FirebarSpinState_High,x ;add carry to what would normally be the vertical speed
00A05F  2  E9 00              sbc #$00
00A061  2  60                 rts
00A062  2               
00A062  2               
00A062  2               ;-------------------------------------------------------------------------------------
00A062  2               ;$00 - used to hold collision flag, Y movement force + 5 or low byte of name table for rope
00A062  2               ;$01 - used to hold high byte of name table for rope
00A062  2               ;$02 - used to hold page location of rope
00A062  2               
00A062  2               BalancePlatform:
00A062  2  B5 B6                lda Enemy_Y_HighPos,x       ;check high byte of vertical position
00A064  2  C9 03                cmp #$03
00A066  2  D0 03                bne DoBPl
00A068  2  4C CC 95             jmp EraseEnemyObject        ;if far below screen, kill the object
00A06B  2  B5 1E        DoBPl:  lda Enemy_State,x           ;get object's state (set to $ff or other platform offset)
00A06D  2  10 01                bpl CheckBalPlatform        ;if doing other balance platform, branch to handle it
00A06F  2  60           ExBalP: rts
00A070  2               
00A070  2               
00A070  2               CheckBalPlatform:
00A070  2  A8                  tay                         ;save offset from state as Y
00A071  2  B9 16 00            lda Enemy_ID,y
00A074  2  C9 24               cmp #$24                    ;check to see if other object is balance platform
00A076  2  D0 F7               bne ExBalP                  ;if not, branch to leave
00A078  2  BD A2 03            lda PlatformCollisionFlag,x ;get collision flag of platform
00A07B  2  85 00               sta $00                     ;store here
00A07D  2  B5 46               lda Enemy_MovingDir,x       ;get moving direction
00A07F  2  F0 03               beq ChkForFall
00A081  2  4C F2 A1            jmp PlatformFall            ;if set, jump here
00A084  2               
00A084  2               ChkForFall:
00A084  2  A9 2D               lda #$2d                    ;check if platform is above a certain point
00A086  2  D5 CF               cmp Enemy_Y_Position,x
00A088  2  90 0F               bcc ChkOtherForFall         ;if not, branch elsewhere
00A08A  2  C4 00               cpy $00                     ;if collision flag is set to same value as
00A08C  2  F0 08               beq MakePlatformFall        ;enemy state, branch to make platforms fall
00A08E  2  18                  clc
00A08F  2  69 02               adc #$02                    ;otherwise add 2 pixels to vertical position
00A091  2  95 CF               sta Enemy_Y_Position,x      ;of current platform and branch elsewhere
00A093  2  4C E8 A1            jmp StopPlatforms           ;to make platforms stop
00A096  2               
00A096  2               MakePlatformFall:
00A096  2  4C CF A1            jmp InitPlatformFall        ;make platforms fall
00A099  2               
00A099  2               ChkOtherForFall:
00A099  2  D9 CF 00            cmp Enemy_Y_Position,y      ;check if other platform is above a certain point
00A09C  2  90 0D               bcc ChkToMoveBalPlat        ;if not, branch elsewhere
00A09E  2  E4 00               cpx $00                     ;if collision flag is set to same value as
00A0A0  2  F0 F4               beq MakePlatformFall        ;enemy state, branch to make platforms fall
00A0A2  2  18                  clc
00A0A3  2  69 02               adc #$02                    ;otherwise add 2 pixels to vertical position
00A0A5  2  99 CF 00            sta Enemy_Y_Position,y      ;of other platform and branch elsewhere
00A0A8  2  4C E8 A1            jmp StopPlatforms           ;jump to stop movement and do not return
00A0AB  2               
00A0AB  2               ChkToMoveBalPlat:
00A0AB  2  B5 CF                lda Enemy_Y_Position,x      ;save vertical position to stack
00A0AD  2  48                   pha
00A0AE  2  BD A2 03             lda PlatformCollisionFlag,x ;get collision flag
00A0B1  2  10 18                bpl ColFlg                  ;branch if collision
00A0B3  2  BD 34 04             lda Enemy_Y_MoveForce,x
00A0B6  2  18                   clc                         ;add $05 to contents of moveforce, whatever they be
00A0B7  2  69 05                adc #$05
00A0B9  2  85 00                sta $00                     ;store here
00A0BB  2  B5 A0                lda Enemy_Y_Speed,x
00A0BD  2  69 00                adc #$00                    ;add carry to vertical speed
00A0BF  2  30 1A                bmi PlatDn                  ;branch if moving downwards
00A0C1  2  D0 0C                bne PlatUp                  ;branch elsewhere if moving upwards
00A0C3  2  A5 00                lda $00
00A0C5  2  C9 0B                cmp #$0b                    ;check if there's still a little force left
00A0C7  2  90 0C                bcc PlatSt                  ;if not enough, branch to stop movement
00A0C9  2  B0 04                bcs PlatUp                  ;otherwise keep branch to move upwards
00A0CB  2  C5 08        ColFlg: cmp ObjectOffset            ;if collision flag matches
00A0CD  2  F0 0C                beq PlatDn                  ;current enemy object offset, branch
00A0CF  2  20 C6 8B     PlatUp: jsr MovePlatformUp          ;do a sub to move upwards
00A0D2  2  4C DE A0             jmp DoOtherPlatform         ;jump ahead to remaining code
00A0D5  2  20 E8 A1     PlatSt: jsr StopPlatforms           ;do a sub to stop movement
00A0D8  2  4C DE A0             jmp DoOtherPlatform         ;jump ahead to remaining code
00A0DB  2  20 C3 8B     PlatDn: jsr MovePlatformDown        ;do a sub to move downwards
00A0DE  2               
00A0DE  2               DoOtherPlatform:
00A0DE  2  B4 1E               ldy Enemy_State,x           ;get offset of other platform
00A0E0  2  68                  pla                         ;get old vertical coordinate from stack
00A0E1  2  38                  sec
00A0E2  2  F5 CF               sbc Enemy_Y_Position,x      ;get difference of old vs. new coordinate
00A0E4  2  18                  clc
00A0E5  2  79 CF 00            adc Enemy_Y_Position,y      ;add difference to vertical coordinate of other
00A0E8  2  99 CF 00            sta Enemy_Y_Position,y      ;platform to move it in the opposite direction
00A0EB  2  BD A2 03            lda PlatformCollisionFlag,x ;if no collision, skip this part here
00A0EE  2  30 04               bmi DrawEraseRope
00A0F0  2  AA                  tax                         ;put offset which collision occurred here
00A0F1  2  20 A2 A8            jsr PositionPlayerOnVPlat   ;and use it to position player accordingly
00A0F4  2               
00A0F4  2               DrawEraseRope:
00A0F4  2  A4 08                 ldy ObjectOffset            ;get enemy object offset
00A0F6  2  B9 A0 00              lda Enemy_Y_Speed,y         ;check to see if current platform is
00A0F9  2  19 34 04              ora Enemy_Y_MoveForce,y     ;moving at all
00A0FC  2  F0 77                 beq ExitRp                  ;if not, skip all of this and branch to leave
00A0FE  2  AE 00 03              ldx VRAM_Buffer1_Offset     ;get vram buffer offset
00A101  2  E0 20                 cpx #$20                    ;if offset beyond a certain point, go ahead
00A103  2  B0 70                 bcs ExitRp                  ;and skip this, branch to leave
00A105  2  B9 A0 00              lda Enemy_Y_Speed,y
00A108  2  48                    pha                         ;save two copies of vertical speed to stack
00A109  2  48                    pha
00A10A  2  20 78 A1              jsr SetupPlatformRope       ;do a sub to figure out where to put new bg tiles
00A10D  2  A5 01                 lda $01                     ;write name table address to vram buffer
00A10F  2  9D 01 03              sta VRAM_Buffer1,x          ;first the high byte, then the low
00A112  2  A5 00                 lda $00
00A114  2  9D 02 03              sta VRAM_Buffer1+1,x
00A117  2  A9 02                 lda #$02                    ;set length for 2 bytes
00A119  2  9D 03 03              sta VRAM_Buffer1+2,x
00A11C  2  B9 A0 00              lda Enemy_Y_Speed,y         ;if platform moving upwards, branch
00A11F  2  30 0D                 bmi EraseR1                 ;to do something else
00A121  2  A9 A2                 lda #$a2
00A123  2  9D 04 03              sta VRAM_Buffer1+3,x        ;otherwise put tile numbers for left
00A126  2  A9 A3                 lda #$a3                    ;and right sides of rope in vram buffer
00A128  2  9D 05 03              sta VRAM_Buffer1+4,x
00A12B  2  4C 36 A1              jmp OtherRope               ;jump to skip this part
00A12E  2  A9 24        EraseR1: lda #$24                    ;put blank tiles in vram buffer
00A130  2  9D 04 03              sta VRAM_Buffer1+3,x        ;to erase rope
00A133  2  9D 05 03              sta VRAM_Buffer1+4,x
00A136  2               
00A136  2               OtherRope:
00A136  2  B9 1E 00              lda Enemy_State,y           ;get offset of other platform from state
00A139  2  A8                    tay                         ;use as Y here
00A13A  2  68                    pla                         ;pull second copy of vertical speed from stack
00A13B  2  49 FF                 eor #$ff                    ;invert bits to reverse speed
00A13D  2  20 78 A1              jsr SetupPlatformRope       ;do sub again to figure out where to put bg tiles
00A140  2  A5 01                 lda $01                     ;write name table address to vram buffer
00A142  2  9D 06 03              sta VRAM_Buffer1+5,x        ;this time we're doing putting tiles for
00A145  2  A5 00                 lda $00                     ;the other platform
00A147  2  9D 07 03              sta VRAM_Buffer1+6,x
00A14A  2  A9 02                 lda #$02
00A14C  2  9D 08 03              sta VRAM_Buffer1+7,x        ;set length again for 2 bytes
00A14F  2  68                    pla                         ;pull first copy of vertical speed from stack
00A150  2  10 0D                 bpl EraseR2                 ;if moving upwards (note inversion earlier), skip this
00A152  2  A9 A2                 lda #$a2
00A154  2  9D 09 03              sta VRAM_Buffer1+8,x        ;otherwise put tile numbers for left
00A157  2  A9 A3                 lda #$a3                    ;and right sides of rope in vram
00A159  2  9D 0A 03              sta VRAM_Buffer1+9,x        ;transfer buffer
00A15C  2  4C 67 A1              jmp EndRp                   ;jump to skip this part
00A15F  2  A9 24        EraseR2: lda #$24                    ;put blank tiles in vram buffer
00A161  2  9D 09 03              sta VRAM_Buffer1+8,x        ;to erase rope
00A164  2  9D 0A 03              sta VRAM_Buffer1+9,x
00A167  2  A9 00        EndRp:   lda #$00                    ;put null terminator at the end
00A169  2  9D 0B 03              sta VRAM_Buffer1+10,x
00A16C  2  AD 00 03              lda VRAM_Buffer1_Offset     ;add ten bytes to the vram buffer offset
00A16F  2  18                    clc                         ;and store
00A170  2  69 0A                 adc #10
00A172  2  8D 00 03              sta VRAM_Buffer1_Offset
00A175  2  A6 08        ExitRp:  ldx ObjectOffset            ;get enemy object buffer offset and leave
00A177  2  60                    rts
00A178  2               
00A178  2               SetupPlatformRope:
00A178  2  48                   pha                     ;save second/third copy to stack
00A179  2  B9 87 00             lda Enemy_X_Position,y  ;get horizontal coordinate
00A17C  2  18                   clc
00A17D  2  69 08                adc #$08                ;add eight pixels
00A17F  2  AE CC 06             ldx SecondaryHardMode   ;if secondary hard mode flag set,
00A182  2  D0 03                bne GetLRp              ;use coordinate as-is
00A184  2  18                   clc
00A185  2  69 10                adc #$10                ;otherwise add sixteen more pixels
00A187  2  48           GetLRp: pha                     ;save modified horizontal coordinate to stack
00A188  2  B9 6E 00             lda Enemy_PageLoc,y
00A18B  2  69 00                adc #$00                ;add carry to page location
00A18D  2  85 02                sta $02                 ;and save here
00A18F  2  68                   pla                     ;pull modified horizontal coordinate
00A190  2  29 F0                and #%11110000          ;from the stack, mask out low nybble
00A192  2  4A                   lsr                     ;and shift three bits to the right
00A193  2  4A                   lsr
00A194  2  4A                   lsr
00A195  2  85 00                sta $00                 ;store result here as part of name table low byte
00A197  2  B6 CF                ldx Enemy_Y_Position,y  ;get vertical coordinate
00A199  2  68                   pla                     ;get second/third copy of vertical speed from stack
00A19A  2  10 05                bpl GetHRp              ;skip this part if moving downwards or not at all
00A19C  2  8A                   txa
00A19D  2  18                   clc
00A19E  2  69 08                adc #$08                ;add eight to vertical coordinate and
00A1A0  2  AA                   tax                     ;save as X
00A1A1  2  8A           GetHRp: txa                     ;move vertical coordinate to A
00A1A2  2  AE 00 03             ldx VRAM_Buffer1_Offset ;get vram buffer offset
00A1A5  2  0A                   asl
00A1A6  2  2A                   rol                     ;rotate d7 to d0 and d6 into carry
00A1A7  2  48                   pha                     ;save modified vertical coordinate to stack
00A1A8  2  2A                   rol                     ;rotate carry to d0, thus d7 and d6 are at 2 LSB
00A1A9  2  29 03                and #%00000011          ;mask out all bits but d7 and d6, then set
00A1AB  2  09 20                ora #%00100000          ;d5 to get appropriate high byte of name table
00A1AD  2  85 01                sta $01                 ;address, then store
00A1AF  2  A5 02                lda $02                 ;get saved page location from earlier
00A1B1  2  29 01                and #$01                ;mask out all but LSB
00A1B3  2  0A                   asl
00A1B4  2  0A                   asl                     ;shift twice to the left and save with the
00A1B5  2  05 01                ora $01                 ;rest of the bits of the high byte, to get
00A1B7  2  85 01                sta $01                 ;the proper name table and the right place on it
00A1B9  2  68                   pla                     ;get modified vertical coordinate from stack
00A1BA  2  29 E0                and #%11100000          ;mask out low nybble and LSB of high nybble
00A1BC  2  18                   clc
00A1BD  2  65 00                adc $00                 ;add to horizontal part saved here
00A1BF  2  85 00                sta $00                 ;save as name table low byte
00A1C1  2  B9 CF 00             lda Enemy_Y_Position,y
00A1C4  2  C9 E8                cmp #$e8                ;if vertical position not below the
00A1C6  2  90 06                bcc ExPRp               ;bottom of the screen, we're done, branch to leave
00A1C8  2  A5 00                lda $00
00A1CA  2  29 BF                and #%10111111          ;mask out d6 of low byte of name table address
00A1CC  2  85 00                sta $00
00A1CE  2  60           ExPRp:  rts                     ;leave!
00A1CF  2               
00A1CF  2               InitPlatformFall:
00A1CF  2  98                 tya                        ;move offset of other platform from Y to X
00A1D0  2  AA                 tax
00A1D1  2  20 A4 BE           jsr GetEnemyOffscreenBits  ;get offscreen bits
00A1D4  2  A9 06              lda #$06
00A1D6  2  20 76 A6           jsr SetupFloateyNumber     ;award 1000 points to player
00A1D9  2  AD AD 03           lda Player_Rel_XPos
00A1DC  2  9D 17 01           sta FloateyNum_X_Pos,x     ;put floatey number coordinates where player is
00A1DF  2  A5 CE              lda Player_Y_Position
00A1E1  2  9D 1E 01           sta FloateyNum_Y_Pos,x
00A1E4  2  A9 01              lda #$01                   ;set moving direction as flag for
00A1E6  2  95 46              sta Enemy_MovingDir,x      ;falling platforms
00A1E8  2               
00A1E8  2               StopPlatforms:
00A1E8  2  20 77 8F           jsr InitVStf             ;initialize vertical speed and low byte
00A1EB  2  99 A0 00           sta Enemy_Y_Speed,y      ;for both platforms and leave
00A1EE  2  99 34 04           sta Enemy_Y_MoveForce,y
00A1F1  2  60                 rts
00A1F2  2               
00A1F2  2               PlatformFall:
00A1F2  2  98                 tya                         ;save offset for other platform to stack
00A1F3  2  48                 pha
00A1F4  2  20 7A 8B           jsr MoveFallingPlatform     ;make current platform fall
00A1F7  2  68                 pla
00A1F8  2  AA                 tax                         ;pull offset from stack and save to X
00A1F9  2  20 7A 8B           jsr MoveFallingPlatform     ;make other platform fall
00A1FC  2  A6 08              ldx ObjectOffset
00A1FE  2  BD A2 03           lda PlatformCollisionFlag,x ;if player not standing on either platform,
00A201  2  30 04              bmi ExPF                    ;skip this part
00A203  2  AA                 tax                         ;transfer collision flag offset as offset to X
00A204  2  20 A2 A8           jsr PositionPlayerOnVPlat   ;and position player appropriately
00A207  2  A6 08        ExPF: ldx ObjectOffset            ;get enemy object buffer offset and leave
00A209  2  60                 rts
00A20A  2               
00A20A  2               ;--------------------------------
00A20A  2               
00A20A  2               YMovingPlatform:
00A20A  2  B5 A0                lda Enemy_Y_Speed,x          ;if platform moving up or down, skip ahead to
00A20C  2  1D 34 04             ora Enemy_Y_MoveForce,x      ;check on other position
00A20F  2  D0 15                bne ChkYCenterPos
00A211  2  9D 17 04             sta Enemy_YMF_Dummy,x        ;initialize dummy variable
00A214  2  B5 CF                lda Enemy_Y_Position,x
00A216  2  DD 01 04             cmp YPlatformTopYPos,x       ;if current vertical position => top position, branch
00A219  2  B0 0B                bcs ChkYCenterPos            ;ahead of all this
00A21B  2  A5 09                lda FrameCounter
00A21D  2  29 07                and #%00000111               ;check for every eighth frame
00A21F  2  D0 02                bne SkipIY
00A221  2  F6 CF                inc Enemy_Y_Position,x       ;increase vertical position every eighth frame
00A223  2  4C 35 A2     SkipIY: jmp ChkYPCollision           ;skip ahead to last part
00A226  2               
00A226  2               ChkYCenterPos:
00A226  2  B5 CF                lda Enemy_Y_Position,x       ;if current vertical position < central position, branch
00A228  2  D5 58                cmp YPlatformCenterYPos,x    ;to slow ascent/move downwards
00A22A  2  90 06                bcc YMDown
00A22C  2  20 C6 8B             jsr MovePlatformUp           ;otherwise start slowing descent/moving upwards
00A22F  2  4C 35 A2             jmp ChkYPCollision
00A232  2  20 C3 8B     YMDown: jsr MovePlatformDown         ;start slowing ascent/moving downwards
00A235  2               
00A235  2               ChkYPCollision:
00A235  2  BD A2 03            lda PlatformCollisionFlag,x  ;if collision flag not set here, branch
00A238  2  30 03               bmi ExYPl                    ;to leave
00A23A  2  20 A2 A8            jsr PositionPlayerOnVPlat    ;otherwise position player appropriately
00A23D  2  60           ExYPl: rts                          ;leave
00A23E  2               
00A23E  2               ;--------------------------------
00A23E  2               ;$00 - used as adder to position player hotizontally
00A23E  2               
00A23E  2               XMovingPlatform:
00A23E  2  A9 0E              lda #$0e                     ;load preset maximum value for secondary counter
00A240  2  20 80 97           jsr XMoveCntr_Platform       ;do a sub to increment counters for movement
00A243  2  20 9F 97           jsr MoveWithXMCntrs          ;do a sub to move platform accordingly, and return value
00A246  2  BD A2 03           lda PlatformCollisionFlag,x  ;if no collision with player,
00A249  2  30 1C              bmi ExXMP                    ;branch ahead to leave
00A24B  2               
00A24B  2               PositionPlayerOnHPlat:
00A24B  2  A5 86                 lda Player_X_Position
00A24D  2  18                    clc                       ;add saved value from second subroutine to
00A24E  2  65 00                 adc $00                   ;current player's position to position
00A250  2  85 86                 sta Player_X_Position     ;player accordingly in horizontal position
00A252  2  A5 6D                 lda Player_PageLoc        ;get player's page location
00A254  2  A4 00                 ldy $00                   ;check to see if saved value here is positive or negative
00A256  2  30 05                 bmi PPHSubt               ;if negative, branch to subtract
00A258  2  69 00                 adc #$00                  ;otherwise add carry to page location
00A25A  2  4C 5F A2              jmp SetPVar               ;jump to skip subtraction
00A25D  2  E9 00        PPHSubt: sbc #$00                  ;subtract borrow from page location
00A25F  2  85 6D        SetPVar: sta Player_PageLoc        ;save result to player's page location
00A261  2  8C A1 03              sty Platform_X_Scroll     ;put saved value from second sub here to be used later
00A264  2  20 A2 A8              jsr PositionPlayerOnVPlat ;position player vertically and appropriately
00A267  2  60           ExXMP:   rts                       ;and we are done here
00A268  2               
00A268  2               ;--------------------------------
00A268  2               
00A268  2               DropPlatform:
00A268  2  BD A2 03            lda PlatformCollisionFlag,x  ;if no collision between platform and player
00A26B  2  30 06               bmi ExDPl                    ;occurred, just leave without moving anything
00A26D  2  20 97 8B            jsr MoveDropPlatform         ;otherwise do a sub to move platform down very quickly
00A270  2  20 A2 A8            jsr PositionPlayerOnVPlat    ;do a sub to position player appropriately
00A273  2  60           ExDPl: rts                          ;leave
00A274  2               
00A274  2               ;--------------------------------
00A274  2               ;$00 - residual value from sub
00A274  2               
00A274  2               RightPlatform:
00A274  2  20 11 8B            jsr MoveEnemyHorizontally     ;move platform with current horizontal speed, if any
00A277  2  85 00               sta $00                       ;store saved value here (residual code)
00A279  2  BD A2 03            lda PlatformCollisionFlag,x   ;check collision flag, if no collision between player
00A27C  2  30 07               bmi ExRPl                     ;and platform, branch ahead, leave speed unaltered
00A27E  2  A9 10               lda #$10
00A280  2  95 58               sta Enemy_X_Speed,x           ;otherwise set new speed (gets moving if motionless)
00A282  2  20 4B A2            jsr PositionPlayerOnHPlat     ;use saved value from earlier sub to position player
00A285  2  60           ExRPl: rts                           ;then leave
00A286  2               
00A286  2               ;--------------------------------
00A286  2               
00A286  2               MoveLargeLiftPlat:
00A286  2  20 92 A2           jsr MoveLiftPlatforms  ;execute common to all large and small lift platforms
00A289  2  4C 35 A2           jmp ChkYPCollision     ;branch to position player correctly
00A28C  2               
00A28C  2               MoveSmallPlatform:
00A28C  2  20 92 A2           jsr MoveLiftPlatforms      ;execute common to all large and small lift platforms
00A28F  2  4C A8 A2           jmp ChkSmallPlatCollision  ;branch to position player correctly
00A292  2               
00A292  2               MoveLiftPlatforms:
00A292  2  AD 47 07           lda TimerControl         ;if master timer control set, skip all of this
00A295  2  D0 19              bne ExLiftP              ;and branch to leave
00A297  2  BD 17 04           lda Enemy_YMF_Dummy,x
00A29A  2  18                 clc                      ;add contents of movement amount to whatever's here
00A29B  2  7D 34 04           adc Enemy_Y_MoveForce,x
00A29E  2  9D 17 04           sta Enemy_YMF_Dummy,x
00A2A1  2  B5 CF              lda Enemy_Y_Position,x   ;add whatever vertical speed is set to current
00A2A3  2  75 A0              adc Enemy_Y_Speed,x      ;vertical position plus carry to move up or down
00A2A5  2  95 CF              sta Enemy_Y_Position,x   ;and then leave
00A2A7  2  60                 rts
00A2A8  2               
00A2A8  2               ChkSmallPlatCollision:
00A2A8  2  BD A2 03              lda PlatformCollisionFlag,x ;get bounding box counter saved in collision flag
00A2AB  2  F0 03                 beq ExLiftP                 ;if none found, leave player position alone
00A2AD  2  20 9A A8              jsr PositionPlayerOnS_Plat  ;use to position player correctly
00A2B0  2  60           ExLiftP: rts                         ;then leave
00A2B1  2               
00A2B1  2               ;-------------------------------------------------------------------------------------
00A2B1  2               ;$00 - page location of extended left boundary
00A2B1  2               ;$01 - extended left boundary position
00A2B1  2               ;$02 - page location of extended right boundary
00A2B1  2               ;$03 - extended right boundary position
00A2B1  2               
00A2B1  2               OffscreenBoundsCheck:
00A2B1  2  B5 16                  lda Enemy_ID,x          ;check for cheep-cheep object
00A2B3  2  C9 14                  cmp #FlyingCheepCheep   ;branch to leave if found
00A2B5  2  F0 5D                  beq ExScrnBd
00A2B7  2  AD 1C 07               lda ScreenLeft_X_Pos    ;get horizontal coordinate for left side of screen
00A2BA  2  B4 16                  ldy Enemy_ID,x
00A2BC  2  C0 05                  cpy #HammerBro          ;check for hammer bro object
00A2BE  2  F0 08                  beq LimitB
00A2C0  2  C0 04                  cpy #UpsideDownPiranhaP ;check for upside-down piranha plant object
00A2C2  2  F0 04                  beq LimitB
00A2C4  2  C0 0D                  cpy #PiranhaPlant       ;check for piranha plant object
00A2C6  2  D0 02                  bne ExtendLB            ;these three will be erased sooner than others if too far left
00A2C8  2  69 38        LimitB:   adc #$38                ;add 56 pixels to coordinate if hammer bro or piranha plant
00A2CA  2  E9 48        ExtendLB: sbc #$48                ;subtract 72 pixels regardless of enemy object
00A2CC  2  85 01                  sta $01                 ;store result here
00A2CE  2  AD 1A 07               lda ScreenLeft_PageLoc
00A2D1  2  E9 00                  sbc #$00                ;subtract borrow from page location of left side
00A2D3  2  85 00                  sta $00                 ;store result here
00A2D5  2  AD 1D 07               lda ScreenRight_X_Pos   ;add 72 pixels to the right side horizontal coordinate
00A2D8  2  69 48                  adc #$48
00A2DA  2  85 03                  sta $03                 ;store result here
00A2DC  2  AD 1B 07               lda ScreenRight_PageLoc
00A2DF  2  69 00                  adc #$00                ;then add the carry to the page location
00A2E1  2  85 02                  sta $02                 ;and store result here
00A2E3  2  B5 87                  lda Enemy_X_Position,x  ;compare horizontal coordinate of the enemy object
00A2E5  2  C5 01                  cmp $01                 ;to modified horizontal left edge coordinate to get carry
00A2E7  2  B5 6E                  lda Enemy_PageLoc,x
00A2E9  2  E5 00                  sbc $00                 ;then subtract it from the page coordinate of the enemy object
00A2EB  2  30 24                  bmi TooFar              ;if enemy object is too far left, branch to erase it
00A2ED  2  B5 87                  lda Enemy_X_Position,x  ;compare horizontal coordinate of the enemy object
00A2EF  2  C5 03                  cmp $03                 ;to modified horizontal right edge coordinate to get carry
00A2F1  2  B5 6E                  lda Enemy_PageLoc,x
00A2F3  2  E5 02                  sbc $02                 ;then subtract it from the page coordinate of the enemy object
00A2F5  2  30 1D                  bmi ExScrnBd            ;if enemy object is on the screen, leave, do not erase enemy
00A2F7  2  B5 1E                  lda Enemy_State,x       ;if at this point, enemy is offscreen to the right, so check
00A2F9  2  C9 05                  cmp #HammerBro          ;if in state used by spiny's egg, do not erase
00A2FB  2  F0 17                  beq ExScrnBd
00A2FD  2  C0 0D                  cpy #PiranhaPlant       ;if piranha plant, do not erase
00A2FF  2  F0 13                  beq ExScrnBd
00A301  2  C0 04                  cpy #UpsideDownPiranhaP ;if upside-down piranha plant, do not erase
00A303  2  F0 0F                  beq ExScrnBd
00A305  2  C0 30                  cpy #FlagpoleFlagObject ;if flagpole flag, do not erase
00A307  2  F0 0B                  beq ExScrnBd
00A309  2  C0 31                  cpy #StarFlagObject     ;if star flag, do not erase
00A30B  2  F0 07                  beq ExScrnBd
00A30D  2  C0 32                  cpy #JumpspringObject   ;if jumpspring, do not erase
00A30F  2  F0 03                  beq ExScrnBd            ;erase all others too far to the right
00A311  2  20 CC 95     TooFar:   jsr EraseEnemyObject    ;erase object if necessary
00A314  2  60           ExScrnBd: rts                     ;leave
00A315  2               
00A315  2               .ifndef ANN
00A315  2               ;unused space
00A315  2                .byte $ff
00A315  2                .endif
00A315  2               
00A315  2               ;-------------------------------------------------------------------------------------
00A315  2               ;$01 - enemy buffer offset
00A315  2               
00A315  2               FireballEnemyCollision:
00A315  2  B5 24              lda Fireball_State,x  ;check to see if fireball state is set at all
00A317  2  F0 56              beq ExitFBallEnemy    ;branch to leave if not
00A319  2  0A                 asl
00A31A  2  B0 53              bcs ExitFBallEnemy    ;branch to leave also if d7 in state is set
00A31C  2  A5 09              lda FrameCounter
00A31E  2  4A                 lsr                   ;get LSB of frame counter
00A31F  2  B0 4E              bcs ExitFBallEnemy    ;branch to leave if set (do routine every other frame)
00A321  2  8A                 txa
00A322  2  0A                 asl                   ;multiply fireball offset by four
00A323  2  0A                 asl
00A324  2  18                 clc
00A325  2  69 1C              adc #$1c              ;then add $1c or 28 bytes to it
00A327  2  A8                 tay                   ;to use fireball's bounding box coordinates
00A328  2  A2 04              ldx #$04
00A32A  2               
00A32A  2               FireballEnemyCDLoop:
00A32A  2  86 01                   stx $01                     ;store enemy object offset here
00A32C  2  98                      tya
00A32D  2  48                      pha                         ;push fireball offset to the stack
00A32E  2  B5 1E                   lda Enemy_State,x
00A330  2  29 20                   and #%00100000              ;check to see if d5 is set in enemy state
00A332  2  D0 34                   bne NoFToECol               ;if so, skip to next enemy slot
00A334  2  B5 0F                   lda Enemy_Flag,x            ;check to see if buffer flag is set
00A336  2  F0 30                   beq NoFToECol               ;if not, skip to next enemy slot
00A338  2  B5 16                   lda Enemy_ID,x              ;check enemy identifier
00A33A  2  C9 24                   cmp #$24
00A33C  2  90 04                   bcc GoombaDie               ;if < $24, branch to check further
00A33E  2  C9 2B                   cmp #$2b
00A340  2  90 26                   bcc NoFToECol               ;if in range $24-$2a, skip to next enemy slot
00A342  2  C9 06        GoombaDie: cmp #Goomba                 ;check for goomba identifier
00A344  2  D0 06                   bne NotGoomba               ;if not found, continue with code
00A346  2  B5 1E                   lda Enemy_State,x           ;otherwise check for defeated state
00A348  2  C9 02                   cmp #$02                    ;if stomped or otherwise defeated,
00A34A  2  B0 1C                   bcs NoFToECol               ;skip to next enemy slot
00A34C  2  BD D8 03     NotGoomba: lda EnemyOffscrBitsMasked,x ;if any masked offscreen bits set,
00A34F  2  D0 17                   bne NoFToECol               ;skip to next enemy slot
00A351  2  8A                      txa
00A352  2  0A                      asl                         ;otherwise multiply enemy offset by four
00A353  2  0A                      asl
00A354  2  18                      clc
00A355  2  69 04                   adc #$04                    ;add 4 bytes to it
00A357  2  AA                      tax                         ;to use enemy's bounding box coordinates
00A358  2  20 D7 AF                jsr SprObjectCollisionCore  ;do fireball-to-enemy collision detection
00A35B  2  A6 08                   ldx ObjectOffset            ;return fireball's original offset
00A35D  2  90 09                   bcc NoFToECol               ;if carry clear, no collision, thus do next enemy slot
00A35F  2  A9 80                   lda #%10000000
00A361  2  95 24                   sta Fireball_State,x        ;set d7 in enemy state
00A363  2  A6 01                   ldx $01                     ;get enemy offset
00A365  2  20 7B A3                jsr HandleEnemyFBallCol     ;jump to handle fireball to enemy collision
00A368  2  68           NoFToECol: pla                         ;pull fireball offset from stack
00A369  2  A8                      tay                         ;put it in Y
00A36A  2  A6 01                   ldx $01                     ;get enemy object offset
00A36C  2  CA                      dex                         ;decrement it
00A36D  2  10 BB                   bpl FireballEnemyCDLoop     ;loop back until collision detection done on all enemies
00A36F  2               
00A36F  2               ExitFBallEnemy:
00A36F  2  A6 08              ldx ObjectOffset                 ;get original fireball offset and leave
00A371  2  60                 rts
00A372  2               
00A372  2               BowserIdentities:
00A372  2  06 00 02 12        .byte Goomba, GreenKoopa, BuzzyBeetle, Spiny, Lakitu, Bloober, HammerBro, Bowser, Bowser
00A376  2  11 07 05 2D  
00A37A  2  2D           
00A37B  2               
00A37B  2               HandleEnemyFBallCol:
00A37B  2  20 47 BE           jsr RelativeEnemyPosition  ;get relative coordinate of enemy
00A37E  2  A6 01              ldx $01                    ;get current enemy object offset
00A380  2  B5 0F              lda Enemy_Flag,x           ;check buffer flag for d7 set
00A382  2  10 0B              bpl ChkBuzzyBeetle         ;branch if not set to continue
00A384  2  29 0F              and #%00001111             ;otherwise mask out high nybble and
00A386  2  AA                 tax                        ;use low nybble as enemy offset
00A387  2  B5 16              lda Enemy_ID,x
00A389  2  C9 2D              cmp #Bowser                ;check enemy identifier for bowser
00A38B  2  F0 0C              beq HurtBowser             ;branch if found
00A38D  2  A6 01              ldx $01                    ;otherwise retrieve current enemy offset
00A38F  2               
00A38F  2               ChkBuzzyBeetle:
00A38F  2  B5 16              lda Enemy_ID,x
00A391  2  C9 02              cmp #BuzzyBeetle           ;check for buzzy beetle
00A393  2  F0 76              beq ExHCF                  ;branch if found to leave (buzzy beetles fireproof)
00A395  2  C9 2D              cmp #Bowser                ;check for bowser one more time (necessary if d7 of flag was clear)
00A397  2  D0 2D              bne ChkOtherEnemies        ;if not found, branch to check other enemies
00A399  2               
00A399  2               HurtBowser:
00A399  2  CE 83 04               dec BowserHitPoints        ;decrement bowser's hit points
00A39C  2  D0 6D                  bne ExHCF                  ;if bowser still has hit points, branch to leave
00A39E  2  20 77 8F               jsr InitVStf               ;otherwise do sub to init vertical speed and movement force
00A3A1  2  95 58                  sta Enemy_X_Speed,x        ;initialize horizontal speed
00A3A3  2  8D CB 06               sta EnemyFrenzyBuffer      ;init enemy frenzy buffer
00A3A6  2  A9 FE                  lda #$fe
00A3A8  2  95 A0                  sta Enemy_Y_Speed,x        ;set vertical speed to make defeated bowser jump a little
00A3AA  2  AC 5F 07               ldy WorldNumber            ;use world number as offset
00A3AD  2  B9 72 A3               lda BowserIdentities,y     ;get enemy identifier to replace bowser with
00A3B0  2  95 16                  sta Enemy_ID,x             ;set as new enemy identifier
00A3B2  2  A9 20                  lda #$20                   ;set A to use starting value for state
00A3B4  2  C0 03                  cpy #$03                   ;check to see if using offset of 3 or more
00A3B6  2  B0 02                  bcs SetDBSte               ;branch if so
00A3B8  2  09 03                  ora #$03                   ;otherwise add 3 to enemy state
00A3BA  2  95 1E        SetDBSte: sta Enemy_State,x          ;set defeated enemy state
00A3BC  2  A9 80                  lda #Sfx_BowserFall
00A3BE  2  85 FE                  sta Square2SoundQueue      ;load bowser defeat sound
00A3C0  2  A6 01                  ldx $01                    ;get enemy offset
00A3C2  2  A9 09                  lda #$09                   ;award 5000 points to player for defeating bowser
00A3C4  2  D0 3E                  bne EnemySmackScore        ;unconditional branch to award points
00A3C6  2               
00A3C6  2               ChkOtherEnemies:
00A3C6  2  C9 08              cmp #BulletBill_FrenzyVar
00A3C8  2  F0 41              beq ExHCF                 ;branch to leave if bullet bill (frenzy variant)
00A3CA  2  C9 0C              cmp #Podoboo
00A3CC  2  F0 3D              beq ExHCF                 ;branch to leave if podoboo
00A3CE  2  C9 15              cmp #$15
00A3D0  2  B0 39              bcs ExHCF                 ;branch to leave if identifier => $15
00A3D2  2               
00A3D2  2               ShellOrBlockDefeat:
00A3D2  2  B5 16               lda Enemy_ID,x            ;check for both kinds of piranha plant
00A3D4  2  C9 04               cmp #UpsideDownPiranhaP
00A3D6  2  F0 04               beq DinP
00A3D8  2  C9 0D               cmp #PiranhaPlant
00A3DA  2  D0 0D               bne StnE                  ;branch if not found
00A3DC  2  A8           DinP:  tay
00A3DD  2  B5 CF               lda Enemy_Y_Position,x
00A3DF  2  69 18               adc #$18                  ;add 24 pixels to enemy object's vertical position
00A3E1  2  C0 04               cpy #UpsideDownPiranhaP   ;to put defeated piranha plant back in pipe
00A3E3  2  D0 02               bne SetDY
00A3E5  2  E9 31               sbc #$31                  ;subtract 49 pixels to vertical position to put
00A3E7  2  95 CF        SetDY: sta Enemy_Y_Position,x    ;defeated upside down piranha plant back in pipe
00A3E9  2  20 B9 AC     StnE:  jsr ChkToStunEnemies      ;do yet another sub
00A3EC  2  B5 1E               lda Enemy_State,x
00A3EE  2  29 1F               and #%00011111            ;mask out 2 MSB of enemy object's state
00A3F0  2  09 20               ora #%00100000            ;set d5 to defeat enemy and save as new state
00A3F2  2  95 1E               sta Enemy_State,x
00A3F4  2  A9 02               lda #$02                  ;award 200 points by default
00A3F6  2  B4 16               ldy Enemy_ID,x            ;check for hammer bro
00A3F8  2  C0 05               cpy #HammerBro
00A3FA  2  D0 02               bne GoombaPoints          ;branch if not found
00A3FC  2  A9 06               lda #$06                  ;award 1000 points for hammer bro
00A3FE  2               
00A3FE  2               GoombaPoints:
00A3FE  2  C0 06              cpy #Goomba               ;check for goomba
00A400  2  D0 02              bne EnemySmackScore       ;branch if not found
00A402  2  A9 01              lda #$01                  ;award 100 points for goomba
00A404  2               
00A404  2               EnemySmackScore:
00A404  2  20 76 A6            jsr SetupFloateyNumber   ;update necessary score variables
00A407  2  A9 08               lda #Sfx_EnemySmack      ;play smack enemy sound
00A409  2  85 FF               sta Square1SoundQueue
00A40B  2  60           ExHCF: rts                      ;and now let's leave
00A40C  2               
00A40C  2               ;-------------------------------------------------------------------------------------
00A40C  2               
00A40C  2               PlayerHammerCollision:
00A40C  2  A5 09                lda FrameCounter          ;get frame counter
00A40E  2  4A                   lsr                       ;shift d0 into carry
00A40F  2  90 39                bcc ExPHC                 ;branch to leave if d0 not set to execute every other frame
00A411  2  AD D0 03             lda Player_OffscreenBits  ;if player offscreen bits, master timer control
00A414  2  0D 47 07             ora TimerControl          ;or any offscreen bits for hammer are set
00A417  2  0D D6 03             ora Misc_OffscreenBits    ;then branch to leave
00A41A  2  D0 2E                bne ExPHC
00A41C  2  8A                   txa
00A41D  2  0A                   asl                       ;multiply misc object offset by four
00A41E  2  0A                   asl
00A41F  2  18                   clc
00A420  2  69 24                adc #$24                  ;add 36 or $24 bytes to get proper offset
00A422  2  A8                   tay                       ;for misc object bounding box coordinates
00A423  2  20 D5 AF             jsr PlayerCollisionCore   ;do player-to-hammer collision detection
00A426  2  A6 08                ldx ObjectOffset          ;get misc object offset
00A428  2  90 1B                bcc ClHCol                ;if no collision, then branch
00A42A  2  BD BE 06             lda Misc_Collision_Flag,x ;otherwise read collision flag
00A42D  2  D0 1B                bne ExPHC                 ;if collision flag already set, branch to leave
00A42F  2  A9 01                lda #$01
00A431  2  9D BE 06             sta Misc_Collision_Flag,x ;otherwise set collision flag now
00A434  2  B5 64                lda Misc_X_Speed,x
00A436  2  49 FF                eor #$ff                  ;get two's compliment of
00A438  2  18                   clc                       ;hammer's horizontal speed
00A439  2  69 01                adc #$01
00A43B  2  95 64                sta Misc_X_Speed,x        ;set to send hammer flying the opposite direction
00A43D  2  AD 9F 07             lda StarInvincibleTimer   ;if star mario invincibility timer set,
00A440  2  D0 08                bne ExPHC                 ;branch to leave
00A442  2  4C 83 A5             jmp InjurePlayer          ;otherwise jump to hurt player, do not return
00A445  2  A9 00        ClHCol: lda #$00                  ;clear collision flag
00A447  2  9D BE 06             sta Misc_Collision_Flag,x
00A44A  2  60           ExPHC:  rts
00A44B  2               
00A44B  2               ;-------------------------------------------------------------------------------------
00A44B  2               
00A44B  2               HandlePowerUpCollision:
00A44B  2  20 CC 95           jsr EraseEnemyObject    ;erase the power-up object
00A44E  2  A5 39              lda PowerUpType
00A450  2  C9 04              cmp #$04                ;check power-up type
00A452  2  D0 03              bne Safe                ;if not a poison shroom, branch
00A454  2  4C 83 A5           jmp InjurePlayer        ;otherwise injure the player properly
00A457  2  A9 06        Safe: lda #$06
00A459  2  20 76 A6           jsr SetupFloateyNumber  ;award 1000 points to player by default
00A45C  2  A9 20              lda #Sfx_PowerUpGrab
00A45E  2  85 FE              sta Square2SoundQueue   ;play the power-up sound
00A460  2  A5 39              lda PowerUpType         ;check power-up type
00A462  2  C9 02              cmp #$02
00A464  2  90 0E              bcc Shroom_Flower_PUp   ;if mushroom or fire flower, branch
00A466  2  C9 03              cmp #$03
00A468  2  F0 24              beq SetFor1Up           ;if 1-up mushroom, branch
00A46A  2  A9 23              lda #$23                ;otherwise set star mario invincibility
00A46C  2  8D 9F 07           sta StarInvincibleTimer ;timer, and load the star mario music
00A46F  2  A9 40              lda #StarPowerMusic     ;into the area music queue, then leave
00A471  2  85 FB              sta AreaMusicQueue
00A473  2  60                 rts
00A474  2               
00A474  2               Shroom_Flower_PUp:
00A474  2  AD 56 07           lda PlayerStatus    ;if player status = small, branch
00A477  2  F0 1B              beq UpToSuper
00A479  2  C9 01              cmp #$01            ;if player status not super, leave
00A47B  2  D0 23              bne NoPUp
00A47D  2  A6 08              ldx ObjectOffset    ;get enemy offset, not necessary
00A47F  2  A9 02              lda #$02            ;set player status to fiery
00A481  2  8D 56 07           sta PlayerStatus
00A484  2  20 D4 65           jsr GetPlayerColors ;run sub to change colors of player
00A487  2  A6 08              ldx ObjectOffset    ;get enemy offset again, and again not necessary
00A489  2  A9 0C              lda #$0c            ;set value to be used by subroutine tree (fiery)
00A48B  2  4C 9B A4           jmp UpToFiery       ;jump to set values accordingly
00A48E  2               
00A48E  2               SetFor1Up:
00A48E  2  A9 0B              lda #$0b                 ;change 1000 points into 1-up instead
00A490  2  9D 10 01           sta FloateyNum_Control,x ;and then leave
00A493  2  60                 rts
00A494  2               
00A494  2               UpToSuper:
00A494  2  A9 01               lda #$01         ;set player status to super
00A496  2  8D 56 07            sta PlayerStatus
00A499  2  A9 09               lda #$09         ;set value to be used by subroutine tree (super)
00A49B  2               
00A49B  2               UpToFiery:
00A49B  2  A0 00               ldy #$00         ;set value to be used as new player state
00A49D  2  20 A2 A5            jsr SetPRout     ;set values to stop certain things in motion
00A4A0  2  60           NoPUp: rts
00A4A1  2               
00A4A1  2               ;--------------------------------
00A4A1  2               
00A4A1  2               ResidualXSpdData:
00A4A1  2  18 E8              .byte $18, $e8
00A4A3  2               
00A4A3  2               KickedShellXSpdData:
00A4A3  2  30 D0              .byte $30, $d0
00A4A5  2               
00A4A5  2               DemotedKoopaXSpdData:
00A4A5  2  08 F8              .byte $08, $f8
00A4A7  2               
00A4A7  2               PlayerEnemyCollision:
00A4A7  2  A5 09                 lda FrameCounter            ;check counter for d0 set
00A4A9  2  4A                    lsr
00A4AA  2  B0 F4                 bcs NoPUp                   ;if set, branch to leave
00A4AC  2  20 C2 A8              jsr CheckPlayerVertical     ;if player object is completely offscreen or
00A4AF  2  B0 23                 bcs NoPECol                 ;if down past 224th pixel row, branch to leave
00A4B1  2  BD D8 03              lda EnemyOffscrBitsMasked,x ;if current enemy is offscreen by any amount,
00A4B4  2  D0 1E                 bne NoPECol                 ;go ahead and branch to leave
00A4B6  2  A5 0E                 lda GameEngineSubroutine
00A4B8  2  C9 08                 cmp #$08                    ;if not set to run player control routine
00A4BA  2  D0 18                 bne NoPECol                 ;on next frame, branch to leave
00A4BC  2  B5 1E                 lda Enemy_State,x
00A4BE  2  29 20                 and #%00100000              ;if enemy state has d5 set, branch to leave
00A4C0  2  D0 12                 bne NoPECol
00A4C2  2  20 CC A8              jsr GetEnemyBoundBoxOfs     ;get bounding box offset for current enemy object
00A4C5  2  20 D5 AF              jsr PlayerCollisionCore     ;do collision detection on player vs. enemy
00A4C8  2  A6 08                 ldx ObjectOffset            ;get enemy object buffer offset
00A4CA  2  B0 09                 bcs CheckForPUpCollision    ;if collision, branch past this part here
00A4CC  2  BD 91 04              lda Enemy_CollisionBits,x
00A4CF  2  29 FE                 and #%11111110              ;otherwise, clear d0 of current enemy object's
00A4D1  2  9D 91 04              sta Enemy_CollisionBits,x   ;collision bit
00A4D4  2  60           NoPECol: rts
00A4D5  2               
00A4D5  2               CheckForPUpCollision:
00A4D5  2  B4 16               ldy Enemy_ID,x
00A4D7  2  C0 2E               cpy #PowerUpObject            ;check for power-up object
00A4D9  2  D0 03               bne EColl                     ;if not found, branch to next part
00A4DB  2  4C 4B A4            jmp HandlePowerUpCollision    ;otherwise, unconditional jump backwards
00A4DE  2  AD 9F 07     EColl: lda StarInvincibleTimer       ;if star mario invincibility timer expired,
00A4E1  2  F0 06               beq HandlePECollisions        ;perform task here, otherwise kill enemy like
00A4E3  2  4C D2 A3            jmp ShellOrBlockDefeat        ;hit with a shell, or from beneath
00A4E6  2               
00A4E6  2               KickedShellPtsData:
00A4E6  2  0A 06 04           .byte $0a, $06, $04
00A4E9  2               
00A4E9  2               HandlePECollisions:
00A4E9  2  BD 91 04            lda Enemy_CollisionBits,x    ;check enemy collision bits for d0 set
00A4EC  2  29 01               and #%00000001               ;or for being offscreen at all
00A4EE  2  1D D8 03            ora EnemyOffscrBitsMasked,x
00A4F1  2  D0 5D               bne ExPEC                    ;branch to leave if either is true
00A4F3  2  A9 01               lda #$01
00A4F5  2  1D 91 04            ora Enemy_CollisionBits,x    ;otherwise set d0 now
00A4F8  2  9D 91 04            sta Enemy_CollisionBits,x
00A4FB  2  C0 12               cpy #Spiny                   ;branch if spiny
00A4FD  2  F0 52               beq ChkForPlayerInjury
00A4FF  2  C0 33               cpy #BulletBill_CannonVar    ;branch if bullet bill
00A501  2  F0 4E               beq ChkForPlayerInjury
00A503  2  C0 0D               cpy #PiranhaPlant            ;branch if piranha plant
00A505  2  F0 7C               beq InjurePlayer
00A507  2  C0 04               cpy #UpsideDownPiranhaP      ;branch if upside-down piranha plant
00A509  2  F0 78               beq InjurePlayer
00A50B  2  C0 0C               cpy #Podoboo                 ;branch if podoboo
00A50D  2  F0 74               beq InjurePlayer
00A50F  2  C0 15               cpy #$15                     ;branch if object => $15
00A511  2  B0 70               bcs InjurePlayer
00A513  2  AD 4E 07            lda AreaType                 ;branch if water type level
00A516  2  F0 6B               beq InjurePlayer
00A518  2  B5 1E               lda Enemy_State,x            ;branch if d7 of enemy state was set
00A51A  2  0A                  asl
00A51B  2  B0 34               bcs ChkForPlayerInjury
00A51D  2  B5 1E               lda Enemy_State,x            ;mask out all but 3 LSB of enemy state
00A51F  2  29 07               and #%00000111
00A521  2  C9 02               cmp #$02                     ;branch if enemy is in normal or falling state
00A523  2  90 2C               bcc ChkForPlayerInjury
00A525  2  B5 16               lda Enemy_ID,x               ;branch to leave if goomba in defeated state
00A527  2  C9 06               cmp #Goomba
00A529  2  F0 25               beq ExPEC
00A52B  2  A9 08               lda #Sfx_EnemySmack          ;play smack enemy sound
00A52D  2  85 FF               sta Square1SoundQueue
00A52F  2  B5 1E               lda Enemy_State,x            ;set d7 in enemy state, thus become moving shell
00A531  2  09 80               ora #%10000000
00A533  2  95 1E               sta Enemy_State,x
00A535  2  20 6A A6            jsr EnemyFacePlayer          ;set moving direction and get offset
00A538  2  B9 A3 A4            lda KickedShellXSpdData,y    ;load and set horizontal speed data with offset
00A53B  2  95 58               sta Enemy_X_Speed,x
00A53D  2  A9 03               lda #$03                     ;add three to whatever the stomp counter contains
00A53F  2  18                  clc                          ;to give points for kicking the shell
00A540  2  6D 84 04            adc StompChainCounter
00A543  2  BC 96 07            ldy EnemyIntervalTimer,x     ;check shell enemy's timer
00A546  2  C0 03               cpy #$03                     ;if above a certain point, branch using the points
00A548  2  B0 03               bcs KSPts                    ;data obtained from the stomp counter + 3
00A54A  2  B9 E6 A4            lda KickedShellPtsData,y     ;otherwise, set points based on proximity to timer expiration
00A54D  2  20 76 A6     KSPts: jsr SetupFloateyNumber       ;set values for floatey number now
00A550  2  60           ExPEC: rts                          ;leave!!!
00A551  2               
00A551  2               ChkForPlayerInjury:
00A551  2  A4 9F                  ldy Player_Y_Speed     ;check player's vertical speed
00A553  2  88                     dey                    ;branch elsewhere if player is not moving downwards
00A554  2  10 6D                  bpl EnemyStomped
00A556  2  B5 16        ChkInj:   lda Enemy_ID,x         ;branch if enemy object < $07
00A558  2  C9 07                  cmp #Bloober
00A55A  2  90 09                  bcc ChkETmrs
00A55C  2  A5 CE                  lda Player_Y_Position  ;add 12 pixels to player's vertical position
00A55E  2  18                     clc
00A55F  2  69 0C                  adc #$0c
00A561  2  D5 CF                  cmp Enemy_Y_Position,x ;compare modified player's position to enemy's position
00A563  2  90 5E                  bcc EnemyStomped       ;branch if this player's position above (less than) enemy's
00A565  2  AD 91 07     ChkETmrs: lda StompTimer         ;check stomp timer
00A568  2  D0 59                  bne EnemyStomped       ;branch if set
00A56A  2  AD 9E 07               lda InjuryTimer        ;check to see if injured invincibility timer still
00A56D  2  D0 40                  bne ExInjColRoutines   ;counting down, and branch elsewhere to leave if so
00A56F  2  AD AD 03               lda Player_Rel_XPos
00A572  2  CD AE 03               cmp Enemy_Rel_XPos     ;if player's relative position to the left of enemy's
00A575  2  90 03                  bcc TInjE              ;relative position, branch here
00A577  2  4C 5B A6               jmp ChkEnemyFaceRight  ;otherwise do a jump here
00A57A  2  B5 46        TInjE:    lda Enemy_MovingDir,x  ;if enemy moving towards the left,
00A57C  2  C9 01                  cmp #$01               ;branch, otherwise do a jump here
00A57E  2  D0 03                  bne InjurePlayer       ;to turn the enemy around
00A580  2  4C 64 A6               jmp LInj
00A583  2               
00A583  2               InjurePlayer:
00A583  2  AD 9E 07           lda InjuryTimer          ;check again to see if either of the two
00A586  2  0D 9F 07           ora StarInvincibleTimer  ;invincibility timers have expired, branch if not
00A589  2  D0 24              bne ExInjColRoutines
00A58B  2               
00A58B  2               ForceInjury:
00A58B  2  AE 56 07               ldx PlayerStatus          ;check player's status
00A58E  2  F0 22                  beq KillPlayer            ;branch if small
00A590  2  8D 56 07               sta PlayerStatus          ;otherwise set player's status to small
00A593  2  A9 08                  lda #$08
00A595  2  8D 9E 07               sta InjuryTimer           ;set injured invincibility timer
00A598  2  0A                     asl
00A599  2  85 FF                  sta Square1SoundQueue     ;play pipedown/injury sound
00A59B  2  20 D4 65               jsr GetPlayerColors       ;change player's palette if necessary
00A59E  2  A9 0A                  lda #$0a                  ;set subroutine to run on next frame
00A5A0  2  A0 01        SetKRout: ldy #$01                  ;set new player state
00A5A2  2  85 0E        SetPRout: sta GameEngineSubroutine  ;load new value to run subroutine on next frame
00A5A4  2  84 1D                  sty Player_State          ;store new player state
00A5A6  2  A0 FF                  ldy #$ff
00A5A8  2  8C 47 07               sty TimerControl          ;set master timer control flag to halt timers
00A5AB  2  C8                     iny
00A5AC  2  8C 75 07               sty ScrollAmount          ;initialize scroll speed
00A5AF  2               
00A5AF  2               ExInjColRoutines:
00A5AF  2  A6 08              ldx ObjectOffset              ;get enemy offset and leave
00A5B1  2  60                 rts
00A5B2  2               
00A5B2  2               KillPlayer:
00A5B2  2  86 57              stx Player_X_Speed   ;halt player's horizontal movement by initializing speed
00A5B4  2  E8                 inx
00A5B5  2  86 FC              stx EventMusicQueue  ;set event music queue to death music
00A5B7  2  A9 FC              lda #$fc
00A5B9  2  85 9F              sta Player_Y_Speed   ;set new vertical speed
00A5BB  2  A9 0B              lda #$0b             ;set subroutine to run on next frame
00A5BD  2  D0 E1              bne SetKRout         ;branch to set player's state and other things
00A5BF  2               
00A5BF  2               StompedEnemyPtsData:
00A5BF  2  02 06 05 06        .byte $02, $06, $05, $06
00A5C3  2               
00A5C3  2               EnemyStomped:
00A5C3  2  B5 16              lda Enemy_ID,x             ;check for spiny, branch to hurt player
00A5C5  2  C9 12              cmp #Spiny                 ;if found
00A5C7  2  F0 BA              beq InjurePlayer
00A5C9  2  A9 04              lda #Sfx_EnemyStomp        ;otherwise play stomp/swim sound
00A5CB  2  85 FF              sta Square1SoundQueue
00A5CD  2  B5 16              lda Enemy_ID,x
00A5CF  2  A0 00              ldy #$00                   ;initialize points data offset for stomped enemies
00A5D1  2  C9 14              cmp #FlyingCheepCheep      ;branch for cheep-cheep
00A5D3  2  F0 1B              beq EnemyStompedPts
00A5D5  2  C9 08              cmp #BulletBill_FrenzyVar  ;branch for either bullet bill object
00A5D7  2  F0 17              beq EnemyStompedPts
00A5D9  2  C9 33              cmp #BulletBill_CannonVar
00A5DB  2  F0 13              beq EnemyStompedPts
00A5DD  2  C9 0C              cmp #Podoboo               ;branch for podoboo (this branch is logically impossible
00A5DF  2  F0 0F              beq EnemyStompedPts        ;for cpu to take due to earlier checking of podoboo)
00A5E1  2  C8                 iny                        ;increment points data offset
00A5E2  2  C9 05              cmp #HammerBro             ;branch for hammer bro
00A5E4  2  F0 0A              beq EnemyStompedPts
00A5E6  2  C8                 iny                        ;increment points data offset
00A5E7  2  C9 11              cmp #Lakitu                ;branch for lakitu
00A5E9  2  F0 05              beq EnemyStompedPts
00A5EB  2  C8                 iny                        ;increment points data offset
00A5EC  2  C9 07              cmp #Bloober               ;branch if NOT bloober
00A5EE  2  D0 1B              bne ChkForDemoteKoopa
00A5F0  2               
00A5F0  2               EnemyStompedPts:
00A5F0  2  B9 BF A5           lda StompedEnemyPtsData,y  ;load points data using offset in Y
00A5F3  2  20 76 A6           jsr SetupFloateyNumber     ;run sub to set floatey number controls
00A5F6  2  B5 46              lda Enemy_MovingDir,x
00A5F8  2  48                 pha                        ;save enemy movement direction to stack
00A5F9  2  20 D7 AC           jsr NoDemote               ;run sub to kill enemy
00A5FC  2  68                 pla
00A5FD  2  95 46              sta Enemy_MovingDir,x      ;return enemy movement direction from stack
00A5FF  2  A9 20              lda #%00100000
00A601  2  95 1E              sta Enemy_State,x          ;set d5 in enemy state
00A603  2  20 77 8F           jsr InitVStf               ;nullify vertical speed, physics-related thing,
00A606  2  95 58              sta Enemy_X_Speed,x        ;and horizontal speed
00A608  2  4C 4A A6           jmp SetBounce
00A60B  2               
00A60B  2               ChkForDemoteKoopa:
00A60B  2  C9 09              cmp #$09                   ;branch elsewhere if enemy object < $09
00A60D  2  90 1E              bcc HandleStompedShellE
00A60F  2  20 4A A6           jsr SetBounce
00A612  2  29 01              and #%00000001             ;demote koopa paratroopas to ordinary troopas
00A614  2  95 16              sta Enemy_ID,x
00A616  2  A9 00              lda #$00                   ;return enemy to normal state
00A618  2  95 1E              sta Enemy_State,x
00A61A  2  A9 03              lda #$03                   ;award 400 points to the player
00A61C  2  20 76 A6           jsr SetupFloateyNumber
00A61F  2  20 77 8F           jsr InitVStf               ;nullify physics-related thing and vertical speed
00A622  2  20 6A A6           jsr EnemyFacePlayer        ;turn enemy around if necessary
00A625  2  B9 A5 A4           lda DemotedKoopaXSpdData,y
00A628  2  95 58              sta Enemy_X_Speed,x        ;set appropriate moving speed based on direction
00A62A  2  60                 rts
00A62B  2               
00A62B  2               RevivalRateData:
00A62B  2  10 0B              .byte $10, $0b
00A62D  2               
00A62D  2               HandleStompedShellE:
00A62D  2  A9 04               lda #$04                   ;set defeated state for enemy
00A62F  2  95 1E               sta Enemy_State,x
00A631  2  EE 84 04            inc StompChainCounter      ;increment the stomp counter
00A634  2  AD 84 04            lda StompChainCounter      ;add whatever is in the stomp counter
00A637  2  18                  clc                        ;to whatever is in the stomp timer
00A638  2  6D 91 07            adc StompTimer
00A63B  2  20 76 A6            jsr SetupFloateyNumber     ;award points accordingly
00A63E  2  EE 91 07            inc StompTimer             ;increment stomp timer of some sort
00A641  2  AC 7D 07            ldy PrimaryHardMode        ;check primary hard mode flag
00A644  2  B9 2B A6            lda RevivalRateData,y      ;load timer setting according to flag
00A647  2  9D 96 07            sta EnemyIntervalTimer,x   ;set as enemy timer to revive stomped enemy
00A64A  2               SetBounce:
00A64A  2  A0 FA               ldy #$fa                   ;set a regular bounce rate for all other enemies
00A64C  2  B5 16               lda Enemy_ID,x
00A64E  2  C9 0F               cmp #RedParatroopa         ;set a higher bounce rate for red paratroopas
00A650  2  F0 04               beq BnceH                  ;and green paratroopas that fly
00A652  2  C9 10               cmp #GreenParatroopaFly
00A654  2  D0 02               bne BnceL
00A656  2  A0 F8        BnceH: ldy #$f8                   ;set player's vertical speed for bounce
00A658  2  84 9F        BnceL: sty Player_Y_Speed         ;and then leave!!!
00A65A  2  60                  rts
00A65B  2               
00A65B  2               ChkEnemyFaceRight:
00A65B  2  B5 46               lda Enemy_MovingDir,x ;check to see if enemy is moving to the right
00A65D  2  C9 01               cmp #$01
00A65F  2  D0 03               bne LInj              ;if not, branch
00A661  2  4C 83 A5            jmp InjurePlayer      ;otherwise go back to hurt player
00A664  2  20 89 A7     LInj:  jsr EnemyTurnAround   ;turn the enemy around, if necessary
00A667  2  4C 83 A5            jmp InjurePlayer      ;go back to hurt player
00A66A  2               
00A66A  2               EnemyFacePlayer:
00A66A  2  A0 01               ldy #$01               ;set to move right by default
00A66C  2  20 EF AD            jsr PlayerEnemyDiff    ;get horizontal difference between player and enemy
00A66F  2  10 01               bpl SFcRt              ;if enemy is to the right of player, do not increment
00A671  2  C8                  iny                    ;otherwise, increment to set to move to the left
00A672  2  94 46        SFcRt: sty Enemy_MovingDir,x  ;set moving direction here
00A674  2  88                  dey                    ;then decrement to use as a proper offset
00A675  2  60                  rts
00A676  2               
00A676  2               SetupFloateyNumber:
00A676  2  9D 10 01            sta FloateyNum_Control,x ;set number of points control for floatey numbers
00A679  2  A9 30               lda #$30
00A67B  2  9D 2C 01            sta FloateyNum_Timer,x   ;set timer for floatey numbers
00A67E  2  B5 CF               lda Enemy_Y_Position,x
00A680  2  9D 1E 01            sta FloateyNum_Y_Pos,x   ;set vertical coordinate
00A683  2  AD AE 03            lda Enemy_Rel_XPos
00A686  2  9D 17 01            sta FloateyNum_X_Pos,x   ;set horizontal coordinate and leave
00A689  2  60           ExSFN: rts
00A68A  2               
00A68A  2               ;-------------------------------------------------------------------------------------
00A68A  2               ;$01 - used to hold enemy offset for second enemy
00A68A  2               
00A68A  2               SetBitsMask:
00A68A  2  80 40 20 10        .byte %10000000, %01000000, %00100000, %00010000, %00001000, %00000100, %00000010
00A68E  2  08 04 02     
00A691  2               
00A691  2               ClearBitsMask:
00A691  2  7F BF DF EF        .byte %01111111, %10111111, %11011111, %11101111, %11110111, %11111011, %11111101
00A695  2  F7 FB FD     
00A698  2               
00A698  2               EnemiesCollision:
00A698  2  A5 09                lda FrameCounter            ;check counter for d0 set
00A69A  2  4A                   lsr
00A69B  2  90 EC                bcc ExSFN                   ;if d0 not set, leave
00A69D  2  AD 4E 07             lda AreaType
00A6A0  2  F0 E7                beq ExSFN                   ;if water area type, leave
00A6A2  2  B5 16                lda Enemy_ID,x
00A6A4  2  C9 15                cmp #$15                    ;if enemy object => $15, branch to leave
00A6A6  2  B0 76                bcs ExitECRoutine
00A6A8  2  C9 11                cmp #Lakitu                 ;if lakitu, branch to leave
00A6AA  2  F0 72                beq ExitECRoutine
00A6AC  2  C9 0D                cmp #PiranhaPlant           ;if piranha plant, branch to leave
00A6AE  2  F0 6E                beq ExitECRoutine
00A6B0  2  C9 04                cmp #UpsideDownPiranhaP     ;if upside-down piranha plant, branch to leave
00A6B2  2  F0 6A                beq ExitECRoutine
00A6B4  2  BD D8 03             lda EnemyOffscrBitsMasked,x ;if masked offscreen bits nonzero, branch to leave
00A6B7  2  D0 65                bne ExitECRoutine
00A6B9  2  20 CC A8             jsr GetEnemyBoundBoxOfs     ;otherwise, do sub, get appropriate bounding box offset for
00A6BC  2  CA                   dex                         ;first enemy we're going to compare, then decrement for second
00A6BD  2  30 5F                bmi ExitECRoutine           ;branch to leave if there are no other enemies
00A6BF  2  86 01        ECLoop: stx $01                     ;save enemy object buffer offset for second enemy here
00A6C1  2  98                   tya                         ;save first enemy's bounding box offset to stack
00A6C2  2  48                   pha
00A6C3  2  B5 0F                lda Enemy_Flag,x            ;check enemy object enable flag
00A6C5  2  F0 50                beq ReadyNextEnemy          ;branch if flag not set
00A6C7  2  B5 16                lda Enemy_ID,x
00A6C9  2  C9 15                cmp #$15                    ;check for enemy object => $15
00A6CB  2  B0 4A                bcs ReadyNextEnemy          ;branch if true
00A6CD  2  C9 11                cmp #Lakitu
00A6CF  2  F0 46                beq ReadyNextEnemy          ;branch if enemy object is lakitu
00A6D1  2  C9 0D                cmp #PiranhaPlant
00A6D3  2  F0 42                beq ReadyNextEnemy          ;branch if enemy object is piranha plant
00A6D5  2  C9 04                cmp #UpsideDownPiranhaP
00A6D7  2  F0 3E                beq ReadyNextEnemy          ;branch if enemy object is upside-down piranha plant
00A6D9  2  BD D8 03             lda EnemyOffscrBitsMasked,x
00A6DC  2  D0 39                bne ReadyNextEnemy          ;branch if masked offscreen bits set
00A6DE  2  8A                   txa                         ;get second enemy object's bounding box offset
00A6DF  2  0A                   asl                         ;multiply by four, then add four
00A6E0  2  0A                   asl
00A6E1  2  18                   clc
00A6E2  2  69 04                adc #$04
00A6E4  2  AA                   tax                         ;use as new contents of X
00A6E5  2  20 D7 AF             jsr SprObjectCollisionCore  ;do collision detection using the two enemies here
00A6E8  2  A6 08                ldx ObjectOffset            ;use first enemy offset for X
00A6EA  2  A4 01                ldy $01                     ;use second enemy offset for Y
00A6EC  2  90 20                bcc NoEnemyCollision        ;if carry clear, no collision, branch ahead of this
00A6EE  2  B5 1E                lda Enemy_State,x
00A6F0  2  19 1E 00             ora Enemy_State,y           ;check both enemy states for d7 set
00A6F3  2  29 80                and #%10000000
00A6F5  2  D0 11                bne YesEC                   ;branch if at least one of them is set
00A6F7  2  B9 91 04             lda Enemy_CollisionBits,y   ;load first enemy's collision-related bits
00A6FA  2  3D 8A A6             and SetBitsMask,x           ;check to see if bit connected to second enemy is
00A6FD  2  D0 18                bne ReadyNextEnemy          ;already set, and move onto next enemy slot if set
00A6FF  2  B9 91 04             lda Enemy_CollisionBits,y
00A702  2  1D 8A A6             ora SetBitsMask,x           ;if the bit is not set, set it now
00A705  2  99 91 04             sta Enemy_CollisionBits,y
00A708  2  20 21 A7     YesEC:  jsr ProcEnemyCollisions     ;react according to the nature of collision
00A70B  2  4C 17 A7             jmp ReadyNextEnemy          ;move onto next enemy slot
00A70E  2               
00A70E  2               NoEnemyCollision:
00A70E  2  B9 91 04           lda Enemy_CollisionBits,y     ;load first enemy's collision-related bits
00A711  2  3D 91 A6           and ClearBitsMask,x           ;clear bit connected to second enemy
00A714  2  99 91 04           sta Enemy_CollisionBits,y     ;then move onto next enemy slot
00A717  2               
00A717  2               ReadyNextEnemy:
00A717  2  68                 pla              ;get first enemy's bounding box offset from the stack
00A718  2  A8                 tay              ;use as Y again
00A719  2  A6 01              ldx $01          ;get and decrement second enemy's object buffer offset
00A71B  2  CA                 dex
00A71C  2  10 A1              bpl ECLoop       ;loop until all enemy slots have been checked
00A71E  2               
00A71E  2               ExitECRoutine:
00A71E  2  A6 08              ldx ObjectOffset ;get enemy object buffer offset
00A720  2  60                 rts              ;leave
00A721  2               
00A721  2               ProcEnemyCollisions:
00A721  2  B9 1E 00           lda Enemy_State,y        ;check both enemy states for d5 set
00A724  2  15 1E              ora Enemy_State,x
00A726  2  29 20              and #%00100000           ;if d5 is set in either state, or both, branch
00A728  2  D0 33              bne ExitProcessEColl     ;to leave and do nothing else at this point
00A72A  2  B5 1E              lda Enemy_State,x
00A72C  2  C9 06              cmp #$06                 ;if second enemy state < $06, branch elsewhere
00A72E  2  90 2E              bcc ProcSecondEnemyColl
00A730  2  B5 16              lda Enemy_ID,x           ;check second enemy identifier for hammer bro
00A732  2  C9 05              cmp #HammerBro           ;if hammer bro found in alt state, branch to leave
00A734  2  F0 27              beq ExitProcessEColl
00A736  2  B9 1E 00           lda Enemy_State,y        ;check first enemy state for d7 set
00A739  2  0A                 asl
00A73A  2  90 0A              bcc ShellCollisions      ;branch if d7 is clear
00A73C  2  A9 06              lda #$06
00A73E  2  20 76 A6           jsr SetupFloateyNumber   ;award 1000 points for killing enemy
00A741  2  20 D2 A3           jsr ShellOrBlockDefeat   ;then kill enemy, then load
00A744  2  A4 01              ldy $01                  ;original offset of second enemy
00A746  2               
00A746  2               ShellCollisions:
00A746  2  98                 tya                      ;move Y to X
00A747  2  AA                 tax
00A748  2  20 D2 A3           jsr ShellOrBlockDefeat   ;kill second enemy
00A74B  2  A6 08              ldx ObjectOffset
00A74D  2  BD 25 01           lda ShellChainCounter,x  ;get chain counter for shell
00A750  2  18                 clc
00A751  2  69 04              adc #$04                 ;add four to get appropriate point offset
00A753  2  A6 01              ldx $01
00A755  2  20 76 A6           jsr SetupFloateyNumber   ;award appropriate number of points for second enemy
00A758  2  A6 08              ldx ObjectOffset         ;load original offset of first enemy
00A75A  2  FE 25 01           inc ShellChainCounter,x  ;increment chain counter for additional enemies
00A75D  2               
00A75D  2               ExitProcessEColl:
00A75D  2  60                 rts                      ;leave!!!
00A75E  2               
00A75E  2               ProcSecondEnemyColl:
00A75E  2  B9 1E 00           lda Enemy_State,y        ;if first enemy state < $06, branch elsewhere
00A761  2  C9 06              cmp #$06
00A763  2  90 1D              bcc MoveEOfs
00A765  2  B9 16 00           lda Enemy_ID,y           ;check first enemy identifier for hammer bro
00A768  2  C9 05              cmp #HammerBro           ;if hammer bro found in alt state, branch to leave
00A76A  2  F0 F1              beq ExitProcessEColl
00A76C  2  20 D2 A3           jsr ShellOrBlockDefeat   ;otherwise, kill first enemy
00A76F  2  A4 01              ldy $01
00A771  2  B9 25 01           lda ShellChainCounter,y  ;get chain counter for shell
00A774  2  18                 clc
00A775  2  69 04              adc #$04                 ;add four to get appropriate point offset
00A777  2  A6 08              ldx ObjectOffset
00A779  2  20 76 A6           jsr SetupFloateyNumber   ;award appropriate number of points for first enemy
00A77C  2  A6 01              ldx $01                  ;load original offset of second enemy
00A77E  2  FE 25 01           inc ShellChainCounter,x  ;increment chain counter for additional enemies
00A781  2  60                 rts                      ;leave!!!
00A782  2               
00A782  2               MoveEOfs:
00A782  2  98                 tya                      ;move Y ($01) to X
00A783  2  AA                 tax
00A784  2  20 89 A7           jsr EnemyTurnAround      ;do the sub here using value from $01
00A787  2  A6 08              ldx ObjectOffset         ;then do it again using value from $08
00A789  2               
00A789  2               EnemyTurnAround:
00A789  2  B5 16               lda Enemy_ID,x           ;check for specific enemies
00A78B  2  C9 0D               cmp #PiranhaPlant
00A78D  2  F0 26               beq ExTA                 ;if piranha plant, leave
00A78F  2  C9 04               cmp #UpsideDownPiranhaP
00A791  2  F0 22               beq ExTA                 ;if upside-down piranha plant, leave
00A793  2  C9 11               cmp #Lakitu
00A795  2  F0 1E               beq ExTA                 ;if lakitu, leave
00A797  2  C9 05               cmp #HammerBro
00A799  2  F0 1A               beq ExTA                 ;if hammer bro, leave
00A79B  2  C9 12               cmp #Spiny
00A79D  2  F0 08               beq RXSpd                ;if spiny, turn it around
00A79F  2  C9 0E               cmp #GreenParatroopaJump
00A7A1  2  F0 04               beq RXSpd                ;if green paratroopa, turn it around
00A7A3  2  C9 07               cmp #$07
00A7A5  2  B0 0E               bcs ExTA                 ;if any OTHER enemy object => $07, leave
00A7A7  2  B5 58        RXSpd: lda Enemy_X_Speed,x      ;load horizontal speed
00A7A9  2  49 FF               eor #$ff                 ;get two's compliment for horizontal speed
00A7AB  2  A8                  tay
00A7AC  2  C8                  iny
00A7AD  2  94 58               sty Enemy_X_Speed,x      ;store as new horizontal speed
00A7AF  2  B5 46               lda Enemy_MovingDir,x
00A7B1  2  49 03               eor #%00000011           ;invert moving direction and store, then leave
00A7B3  2  95 46               sta Enemy_MovingDir,x    ;thus effectively turning the enemy around
00A7B5  2  60           ExTA:  rts                      ;leave!!!
00A7B6  2               
00A7B6  2               ;-------------------------------------------------------------------------------------
00A7B6  2               ;$00 - vertical position of platform
00A7B6  2               
00A7B6  2               LargePlatformCollision:
00A7B6  2  A9 FF               lda #$ff                     ;save value here
00A7B8  2  9D A2 03            sta PlatformCollisionFlag,x
00A7BB  2  AD 47 07            lda TimerControl             ;check master timer control
00A7BE  2  D0 29               bne ExLPC                    ;if set, branch to leave
00A7C0  2  B5 1E               lda Enemy_State,x            ;if d7 set in object state,
00A7C2  2  30 25               bmi ExLPC                    ;branch to leave
00A7C4  2  B5 16               lda Enemy_ID,x
00A7C6  2  C9 24               cmp #$24                     ;check enemy object identifier for
00A7C8  2  D0 06               bne ChkForPlayerC_LargeP     ;balance platform, branch if not found
00A7CA  2  B5 1E               lda Enemy_State,x
00A7CC  2  AA                  tax                          ;set state as enemy offset here
00A7CD  2  20 D0 A7            jsr ChkForPlayerC_LargeP     ;perform code with state offset, then original offset, in X
00A7D0  2               
00A7D0  2               ChkForPlayerC_LargeP:
00A7D0  2  20 C2 A8            jsr CheckPlayerVertical      ;figure out if player is below a certain point
00A7D3  2  B0 14               bcs ExLPC                    ;or offscreen, branch to leave if true
00A7D5  2  8A                  txa
00A7D6  2  20 CE A8            jsr GetEnemyBoundBoxOfsArg   ;get bounding box offset in Y
00A7D9  2  B5 CF               lda Enemy_Y_Position,x       ;store vertical coordinate in
00A7DB  2  85 00               sta $00                      ;temp variable for now
00A7DD  2  8A                  txa                          ;send offset we're on to the stack
00A7DE  2  48                  pha
00A7DF  2  20 D5 AF            jsr PlayerCollisionCore      ;do player-to-platform collision detection
00A7E2  2  68                  pla                          ;retrieve offset from the stack
00A7E3  2  AA                  tax
00A7E4  2  90 03               bcc ExLPC                    ;if no collision, branch to leave
00A7E6  2  20 2D A8            jsr ProcLPlatCollisions      ;otherwise collision, perform sub
00A7E9  2  A6 08        ExLPC: ldx ObjectOffset             ;get enemy object buffer offset and leave
00A7EB  2  60                  rts
00A7EC  2               
00A7EC  2               ;--------------------------------
00A7EC  2               ;$00 - counter for bounding boxes
00A7EC  2               
00A7EC  2               SmallPlatformCollision:
00A7EC  2  AD 47 07           lda TimerControl             ;if master timer control set,
00A7EF  2  D0 37              bne ExSPC                    ;branch to leave
00A7F1  2  9D A2 03           sta PlatformCollisionFlag,x  ;otherwise initialize collision flag
00A7F4  2  20 C2 A8           jsr CheckPlayerVertical      ;do a sub to see if player is below a certain point
00A7F7  2  B0 2F              bcs ExSPC                    ;or entirely offscreen, and branch to leave if true
00A7F9  2  A9 02              lda #$02
00A7FB  2  85 00              sta $00                      ;load counter here for 2 bounding boxes
00A7FD  2               
00A7FD  2               ChkSmallPlatLoop:
00A7FD  2  A6 08              ldx ObjectOffset           ;get enemy object offset
00A7FF  2  20 CC A8           jsr GetEnemyBoundBoxOfs    ;get bounding box offset in Y
00A802  2  29 02              and #%00000010             ;if d1 of offscreen lower nybble bits was set
00A804  2  D0 22              bne ExSPC                  ;then branch to leave
00A806  2  B9 AD 04           lda BoundingBox_UL_YPos,y  ;check top of platform's bounding box for being
00A809  2  C9 20              cmp #$20                   ;above a specific point
00A80B  2  90 05              bcc MoveBoundBox           ;if so, branch, don't do collision detection
00A80D  2  20 D5 AF           jsr PlayerCollisionCore    ;otherwise, perform player-to-platform collision detection
00A810  2  B0 19              bcs ProcSPlatCollisions    ;skip ahead if collision
00A812  2               
00A812  2               MoveBoundBox:
00A812  2  B9 AD 04            lda BoundingBox_UL_YPos,y  ;move bounding box vertical coordinates
00A815  2  18                  clc                        ;128 pixels downwards
00A816  2  69 80               adc #$80
00A818  2  99 AD 04            sta BoundingBox_UL_YPos,y
00A81B  2  B9 AF 04            lda BoundingBox_DR_YPos,y
00A81E  2  18                  clc
00A81F  2  69 80               adc #$80
00A821  2  99 AF 04            sta BoundingBox_DR_YPos,y
00A824  2  C6 00               dec $00                    ;decrement counter we set earlier
00A826  2  D0 D5               bne ChkSmallPlatLoop       ;loop back until both bounding boxes are checked
00A828  2  A6 08        ExSPC: ldx ObjectOffset           ;get enemy object buffer offset, then leave
00A82A  2  60                  rts
00A82B  2               
00A82B  2               ;--------------------------------
00A82B  2               
00A82B  2               ProcSPlatCollisions:
00A82B  2  A6 08              ldx ObjectOffset             ;return enemy object buffer offset to X, then continue
00A82D  2               
00A82D  2               ProcLPlatCollisions:
00A82D  2  B9 AF 04           lda BoundingBox_DR_YPos,y    ;get difference by subtracting the top
00A830  2  38                 sec                          ;of the player's bounding box from the bottom
00A831  2  ED AD 04           sbc BoundingBox_UL_YPos      ;of the platform's bounding box
00A834  2  C9 04              cmp #$04                     ;if difference too large or negative,
00A836  2  B0 08              bcs ChkForTopCollision       ;branch, do not alter vertical speed of player
00A838  2  A5 9F              lda Player_Y_Speed           ;check to see if player's vertical speed is moving down
00A83A  2  10 04              bpl ChkForTopCollision       ;if so, don't mess with it
00A83C  2  A9 01              lda #$01                     ;otherwise, set vertical
00A83E  2  85 9F              sta Player_Y_Speed           ;speed of player to kill jump
00A840  2               
00A840  2               ChkForTopCollision:
00A840  2  AD AF 04           lda BoundingBox_DR_YPos      ;get difference by subtracting the top
00A843  2  38                 sec                          ;of the platform's bounding box from the bottom
00A844  2  F9 AD 04           sbc BoundingBox_UL_YPos,y    ;of the player's bounding box
00A847  2  C9 06              cmp #$06
00A849  2  B0 2B              bcs PlatformSideCollisions   ;if difference not close enough, skip all of this
00A84B  2  A5 9F              lda Player_Y_Speed
00A84D  2  30 27              bmi PlatformSideCollisions   ;if player's vertical speed moving upwards, skip this
00A84F  2  A5 00              lda $00                      ;get saved bounding box counter from earlier
00A851  2  B4 16              ldy Enemy_ID,x
00A853  2  C0 2B              cpy #$2b                     ;if either of the two small platform objects are found,
00A855  2  F0 05              beq SetCollisionFlag         ;regardless of which one, branch to use bounding box counter
00A857  2  C0 2C              cpy #$2c                     ;as contents of collision flag
00A859  2  F0 01              beq SetCollisionFlag
00A85B  2  8A                 txa                          ;otherwise use enemy object buffer offset
00A85C  2               
00A85C  2               SetCollisionFlag:
00A85C  2  A6 08              ldx ObjectOffset             ;get enemy object buffer offset
00A85E  2               .ifdef ANN
00A85E  2  48                 pha
00A85F  2  A5 B5              lda Player_Y_HighPos
00A861  2  C9 01              cmp #$01
00A863  2  D0 08              bne @Continue
00A865  2  A5 CE              lda Player_Y_Position
00A867  2  C9 DF              cmp #$DF
00A869  2  90 02              bcc @Continue
00A86B  2  68                 pla
00A86C  2  60                 rts
00A86D  2               @Continue:
00A86D  2  68                 pla
00A86E  2               .endif
00A86E  2  9D A2 03           sta PlatformCollisionFlag,x  ;save either bounding box counter or enemy offset here
00A871  2  A9 00              lda #$00
00A873  2  85 1D              sta Player_State             ;set player state to normal then leave
00A875  2  60                 rts
00A876  2               
00A876  2               PlatformSideCollisions:
00A876  2  A9 01                 lda #$01                   ;set value here to indicate possible horizontal
00A878  2  85 00                 sta $00                    ;collision on left side of platform
00A87A  2  AD AE 04              lda BoundingBox_DR_XPos    ;get difference by subtracting platform's left edge
00A87D  2  38                    sec                        ;from player's right edge
00A87E  2  F9 AC 04              sbc BoundingBox_UL_XPos,y
00A881  2  C9 08                 cmp #$08                   ;if difference close enough, skip all of this
00A883  2  90 0D                 bcc SideC
00A885  2  E6 00                 inc $00                    ;otherwise increment value set here for right side collision
00A887  2  B9 AE 04              lda BoundingBox_DR_XPos,y  ;get difference by subtracting player's left edge
00A88A  2  18                    clc                        ;from platform's right edge
00A88B  2  ED AC 04              sbc BoundingBox_UL_XPos
00A88E  2  C9 09                 cmp #$09                   ;if difference not close enough, skip subroutine
00A890  2  B0 03                 bcs NoSideC                ;and instead branch to leave (no collision)
00A892  2  20 EA AB     SideC:   jsr ImpedePlayerMove       ;deal with horizontal collision
00A895  2  A6 08        NoSideC: ldx ObjectOffset           ;return with enemy object buffer offset
00A897  2  60                    rts
00A898  2               
00A898  2               ;-------------------------------------------------------------------------------------
00A898  2               
00A898  2               PlayerPosSPlatData:
00A898  2  80 00              .byte $80, $00
00A89A  2               
00A89A  2               PositionPlayerOnS_Plat:
00A89A  2  A8                 tay                        ;use bounding box counter saved in collision flag
00A89B  2  B5 CF              lda Enemy_Y_Position,x     ;for offset
00A89D  2  18                 clc                        ;add positioning data using offset to the vertical
00A89E  2  79 97 A8           adc PlayerPosSPlatData-1,y ;coordinate
00A8A1  2  2C                 .byte $2c                    ;BIT instruction opcode
00A8A2  2               
00A8A2  2               PositionPlayerOnVPlat:
00A8A2  2  B5 CF                 lda Enemy_Y_Position,x    ;get vertical coordinate
00A8A4  2  A4 0E                 ldy GameEngineSubroutine
00A8A6  2  C0 0B                 cpy #$0b                  ;if certain routine being executed on this frame,
00A8A8  2  F0 17                 beq ExPlPos               ;skip all of this
00A8AA  2  B4 B6                 ldy Enemy_Y_HighPos,x
00A8AC  2  C0 01                 cpy #$01                  ;if vertical high byte offscreen, skip this
00A8AE  2  D0 11                 bne ExPlPos
00A8B0  2  38                    sec                       ;subtract 32 pixels from vertical coordinate
00A8B1  2  E9 20                 sbc #$20                  ;for the player object's height
00A8B3  2  85 CE                 sta Player_Y_Position     ;save as player's new vertical coordinate
00A8B5  2  98                    tya
00A8B6  2  E9 00                 sbc #$00                  ;subtract borrow and store as player's
00A8B8  2  85 B5                 sta Player_Y_HighPos      ;new vertical high byte
00A8BA  2  A9 00                 lda #$00
00A8BC  2  85 9F                 sta Player_Y_Speed        ;initialize vertical speed and low byte of force
00A8BE  2  8D 33 04              sta Player_Y_MoveForce    ;and then leave
00A8C1  2  60           ExPlPos: rts
00A8C2  2               
00A8C2  2               ;-------------------------------------------------------------------------------------
00A8C2  2               
00A8C2  2               CheckPlayerVertical:
00A8C2  2  AD D0 03            lda Player_OffscreenBits  ;if player object is not offscreen
00A8C5  2  29 F0               and #$f0                  ;then branch with clear carry flag
00A8C7  2  18                  clc
00A8C8  2  F0 01               beq ExCPV                 ;otherwise fall through and set carry flag
00A8CA  2  38                  sec                       ;to symbolize that player is offscreen
00A8CB  2  60           ExCPV: rts
00A8CC  2               
00A8CC  2               ;-------------------------------------------------------------------------------------
00A8CC  2               
00A8CC  2               GetEnemyBoundBoxOfs:
00A8CC  2  A5 08              lda ObjectOffset         ;get enemy object buffer offset
00A8CE  2               
00A8CE  2               GetEnemyBoundBoxOfsArg:
00A8CE  2  0A                 asl                      ;multiply A by four, then add four
00A8CF  2  0A                 asl                      ;to skip player's bounding box
00A8D0  2  18                 clc
00A8D1  2  69 04              adc #$04
00A8D3  2  A8                 tay                      ;send to Y
00A8D4  2  AD D1 03           lda Enemy_OffscreenBits  ;get offscreen bits for enemy object
00A8D7  2  29 0F              and #%00001111           ;save low nybble
00A8D9  2  C9 0F              cmp #%00001111           ;check for all bits set
00A8DB  2  60                 rts
00A8DC  2               
00A8DC  2               ;-------------------------------------------------------------------------------------
00A8DC  2               ;$00-$01 - used to hold many values, essentially temp variables
00A8DC  2               ;$04 - holds lower nybble of vertical coordinate from block buffer routine
00A8DC  2               ;$eb - used to hold block buffer adder
00A8DC  2               
00A8DC  2               PlayerBGUpperExtent:
00A8DC  2  20 10              .byte $20, $10
00A8DE  2               
00A8DE  2               PlayerBGCollision:
00A8DE  2  AD 16 07               lda DisableCollisionDet   ;if collision detection disabled flag set,
00A8E1  2  D0 2E                  bne ExPBGCol              ;branch to leave
00A8E3  2  A5 0E                  lda GameEngineSubroutine
00A8E5  2  C9 0B                  cmp #$0b                  ;if running routine #11 or $0b
00A8E7  2  F0 28                  beq ExPBGCol              ;branch to leave
00A8E9  2  C9 04                  cmp #$04
00A8EB  2  90 24                  bcc ExPBGCol              ;if running routines $00-$03 branch to leave
00A8ED  2  A9 01                  lda #$01                  ;load default player state for swimming
00A8EF  2  AC 04 07               ldy SwimmingFlag          ;if swimming flag set,
00A8F2  2  D0 0A                  bne SetPSte               ;branch ahead to set default state
00A8F4  2  A5 1D                  lda Player_State          ;if player in normal state,
00A8F6  2  F0 04                  beq SetFallS              ;branch to set default state for falling
00A8F8  2  C9 03                  cmp #$03
00A8FA  2  D0 04                  bne ChkOnScr              ;if in any other state besides climbing, skip to next part
00A8FC  2  A9 02        SetFallS: lda #$02                  ;load default player state for falling
00A8FE  2  85 1D        SetPSte:  sta Player_State          ;set whatever player state is appropriate
00A900  2  A5 B5        ChkOnScr: lda Player_Y_HighPos
00A902  2  C9 01                  cmp #$01                  ;check player's vertical high byte for still on the screen
00A904  2  D0 0B                  bne ExPBGCol              ;branch to leave if not
00A906  2  A9 FF                  lda #$ff
00A908  2  8D 90 04               sta Player_CollisionBits  ;initialize player's collision flag
00A90B  2  A5 CE                  lda Player_Y_Position
00A90D  2  C9 CF                  cmp #$cf                  ;check player's vertical coordinate
00A90F  2  90 01                  bcc ChkCollSize           ;if not too close to the bottom of screen, continue
00A911  2  60           ExPBGCol: rts                       ;otherwise leave
00A912  2               
00A912  2               ChkCollSize:
00A912  2  A0 02                 ldy #$02                    ;load default offset
00A914  2  AD 14 07              lda CrouchingFlag
00A917  2  D0 0C                 bne GBBAdr                  ;if player crouching, skip ahead
00A919  2  AD 54 07              lda PlayerSize
00A91C  2  D0 07                 bne GBBAdr                  ;if player small, skip ahead
00A91E  2  88                    dey                         ;otherwise decrement offset for big player not crouching
00A91F  2  AD 04 07              lda SwimmingFlag
00A922  2  D0 01                 bne GBBAdr                  ;if swimming flag set, skip ahead
00A924  2  88                    dey                         ;otherwise decrement offset
00A925  2  B9 5D B0     GBBAdr:  lda BlockBufferAdderData,y  ;get value using offset
00A928  2  85 EB                 sta $eb                     ;store value here
00A92A  2  A8                    tay                         ;put value into Y, as offset for block buffer routine
00A92B  2  AE 54 07              ldx PlayerSize              ;get player's size as offset
00A92E  2  AD 14 07              lda CrouchingFlag
00A931  2  F0 01                 beq HeadChk                 ;if player not crouching, branch ahead
00A933  2  E8                    inx                         ;otherwise increment size as offset
00A934  2  A5 CE        HeadChk: lda Player_Y_Position       ;get player's vertical coordinate
00A936  2  DD DC A8              cmp PlayerBGUpperExtent,x   ;compare with upper extent value based on offset
00A939  2  90 35                 bcc DoFootCheck             ;if player is too high, skip this part
00A93B  2  20 99 B0              jsr BlockBufferColli_Head   ;do player-to-bg collision detection on top of
00A93E  2  F0 30                 beq DoFootCheck             ;player, and branch if nothing above player's head
00A940  2  20 40 AC              jsr CheckForCoinMTiles      ;check to see if player touched coin with their head
00A943  2  B0 4F                 bcs AwardTouchedCoin        ;if so, branch to some other part of code
00A945  2  A4 9F                 ldy Player_Y_Speed          ;check player's vertical speed
00A947  2  10 27                 bpl DoFootCheck             ;if player not moving upwards, branch elsewhere
00A949  2  A4 04                 ldy $04                     ;check lower nybble of vertical coordinate returned
00A94B  2  C0 04                 cpy #$04                    ;from collision detection routine
00A94D  2  90 21                 bcc DoFootCheck             ;if low nybble < 4, branch
00A94F  2  20 2E AC              jsr CheckForSolidMTiles     ;check to see what player's head bumped on
00A952  2  B0 10                 bcs SolidOrClimb            ;if player collided with solid metatile, branch
00A954  2  AC 4E 07              ldy AreaType                ;otherwise check area type
00A957  2  F0 13                 beq NYSpd                   ;if water level, branch ahead
00A959  2  AC 84 07              ldy BlockBounceTimer        ;if block bounce timer not expired,
00A95C  2  D0 0E                 bne NYSpd                   ;branch ahead, do not process collision
00A95E  2  20 F9 88              jsr PlayerHeadCollision     ;otherwise do a sub to process collision
00A961  2  4C 70 A9              jmp DoFootCheck             ;jump ahead to skip these other parts here
00A964  2               
00A964  2               SolidOrClimb:
00A964  2               .ifdef ANN
00A964  2  C9 26               cmp #$26               ;if climbing metatile,
00A966  2               .else
00A966  2                      cmp #$23               ;if climbing metatile,
00A966  2               .endif
00A966  2  F0 04               beq NYSpd              ;branch ahead and do not play sound
00A968  2  A9 02               lda #Sfx_Bump
00A96A  2  85 FF               sta Square1SoundQueue  ;otherwise load bump sound
00A96C  2  A9 01        NYSpd: lda #$01               ;set player's vertical speed to nullify
00A96E  2  85 9F               sta Player_Y_Speed     ;jump or swim
00A970  2               
00A970  2               DoFootCheck:
00A970  2  A4 EB              ldy $eb                    ;get block buffer adder offset
00A972  2  A5 CE              lda Player_Y_Position
00A974  2  C9 CF              cmp #$cf                   ;check to see how low player is
00A976  2  B0 60              bcs DoPlayerSideCheck      ;if player is too far down on screen, skip all of this
00A978  2  20 98 B0           jsr BlockBufferColli_Feet  ;do player-to-bg collision detection on bottom left of player
00A97B  2  20 40 AC           jsr CheckForCoinMTiles     ;check to see if player touched coin with their left foot
00A97E  2  B0 14              bcs AwardTouchedCoin       ;if so, branch to some other part of code
00A980  2  48                 pha                        ;save bottom left metatile to stack
00A981  2  20 98 B0           jsr BlockBufferColli_Feet  ;do player-to-bg collision detection on bottom right of player
00A984  2  85 00              sta $00                    ;save bottom right metatile here
00A986  2  68                 pla
00A987  2  85 01              sta $01                    ;pull bottom left metatile and save here
00A989  2  D0 0C              bne ChkFootMTile           ;if anything here, skip this part
00A98B  2  A5 00              lda $00                    ;otherwise check for anything in bottom right metatile
00A98D  2  F0 49              beq DoPlayerSideCheck      ;and skip ahead if not
00A98F  2  20 40 AC           jsr CheckForCoinMTiles     ;check to see if player touched coin with their right foot
00A992  2  90 03              bcc ChkFootMTile           ;if not, skip unconditional jump and continue code
00A994  2               
00A994  2               AwardTouchedCoin:
00A994  2  4C 7F AA           jmp HandleCoinMetatile     ;follow the code to erase coin and award to player 1 coin
00A997  2               
00A997  2               ChkFootMTile:
00A997  2  20 39 AC               jsr CheckForClimbMTiles    ;check to see if player landed on climbable metatiles
00A99A  2  B0 3C                  bcs DoPlayerSideCheck      ;if so, branch
00A99C  2  A4 9F                  ldy Player_Y_Speed         ;check player's vertical speed
00A99E  2  30 38                  bmi DoPlayerSideCheck      ;if player moving upwards, branch
00A9A0  2               .ifdef ANN
00A9A0  2  C9 C5                  cmp #$c5
00A9A2  2               .else
00A9A2  2                         cmp #$c6
00A9A2  2               .endif
00A9A2  2  D0 03                  bne ContChk                ;if player did not touch axe, skip ahead
00A9A4  2  4C 88 AA               jmp HandleAxeMetatile      ;otherwise jump to set modes of operation
00A9A7  2  20 4C AB     ContChk:  jsr ChkInvisibleMTiles     ;do sub to check for hidden coin or 1-up blocks
00A9AA  2  F0 2C                  beq DoPlayerSideCheck      ;if either found, branch
00A9AC  2  AC 0E 07               ldy JumpspringAnimCtrl     ;if jumpspring animating right now,
00A9AF  2  D0 23                  bne InitSteP               ;branch ahead
00A9B1  2  A4 04                  ldy $04                    ;check lower nybble of vertical coordinate returned
00A9B3  2  C0 05                  cpy #$05                   ;from collision detection routine
00A9B5  2  90 07                  bcc LandPlyr               ;if lower nybble < 5, branch
00A9B7  2  A5 45                  lda Player_MovingDir
00A9B9  2  85 00                  sta $00                    ;use player's moving direction as temp variable
00A9BB  2  4C EA AB               jmp ImpedePlayerMove       ;jump to impede player's movement in that direction
00A9BE  2  20 57 AB     LandPlyr: jsr ChkForLandJumpSpring   ;do sub to check for jumpspring metatiles and deal with it
00A9C1  2  A9 F0                  lda #$f0
00A9C3  2  25 CE                  and Player_Y_Position      ;mask out lower nybble of player's vertical position
00A9C5  2  85 CE                  sta Player_Y_Position      ;and store as new vertical position to land player properly
00A9C7  2  20 7E AB               jsr HandlePipeEntry        ;do sub to process potential pipe entry
00A9CA  2  A9 00                  lda #$00
00A9CC  2  85 9F                  sta Player_Y_Speed         ;initialize vertical speed and fractional
00A9CE  2  8D 33 04               sta Player_Y_MoveForce     ;movement force to stop player's vertical movement
00A9D1  2  8D 84 04               sta StompChainCounter      ;initialize enemy stomp counter
00A9D4  2  A9 00        InitSteP: lda #$00
00A9D6  2  85 1D                  sta Player_State           ;set player's state to normal
00A9D8  2               
00A9D8  2               DoPlayerSideCheck:
00A9D8  2  A4 EB              ldy $eb       ;get block buffer adder offset
00A9DA  2  C8                 iny
00A9DB  2  C8                 iny           ;increment offset 2 bytes to use adders for side collisions
00A9DC  2  A9 02              lda #$02      ;set value here to be used as counter
00A9DE  2  85 00              sta $00
00A9E0  2               
00A9E0  2               SideCheckLoop:
00A9E0  2  C8                  iny                       ;move onto the next one
00A9E1  2  84 EB               sty $eb                   ;store it
00A9E3  2  A5 CE               lda Player_Y_Position
00A9E5  2  C9 20               cmp #$20                  ;check player's vertical position
00A9E7  2  90 16               bcc BHalf                 ;if player is in status bar area, branch ahead to skip this part
00A9E9  2  C9 E4               cmp #$e4
00A9EB  2  B0 28               bcs ExSCH                 ;branch to leave if player is too far down
00A9ED  2  20 9C B0            jsr BlockBufferColli_Side ;do player-to-bg collision detection on one half of player
00A9F0  2  F0 0D               beq BHalf                 ;branch ahead if nothing found
00A9F2  2               .ifdef ANN
00A9F2  2  C9 1C               cmp #$1c                  ;otherwise check for pipe metatiles
00A9F4  2  F0 09               beq BHalf                 ;if collided with sideways pipe (top), branch ahead
00A9F6  2  C9 6C               cmp #$6c
00A9F8  2  F0 05               beq BHalf                 ;if collided with water pipe (top), branch ahead
00A9FA  2               .else
00A9FA  2                      cmp #$19                  ;otherwise check for pipe metatiles
00A9FA  2                      beq BHalf                 ;if collided with sideways pipe (top), branch ahead
00A9FA  2                      cmp #$6d
00A9FA  2                      beq BHalf                 ;if collided with water pipe (top), branch ahead
00A9FA  2               .endif
00A9FA  2  20 39 AC            jsr CheckForClimbMTiles   ;do sub to see if player bumped into anything climbable
00A9FD  2  90 17               bcc CheckSideMTiles       ;if not, branch to alternate section of code
00A9FF  2  A4 EB        BHalf: ldy $eb                   ;load block adder offset
00AA01  2  C8                  iny                       ;increment it
00AA02  2  A5 CE               lda Player_Y_Position     ;get player's vertical position
00AA04  2  C9 08               cmp #$08
00AA06  2  90 0D               bcc ExSCH                 ;if too high, branch to leave
00AA08  2  C9 D0               cmp #$d0
00AA0A  2  B0 09               bcs ExSCH                 ;if too low, branch to leave
00AA0C  2  20 9C B0            jsr BlockBufferColli_Side ;do player-to-bg collision detection on other half of player
00AA0F  2  D0 05               bne CheckSideMTiles       ;if something found, branch
00AA11  2  C6 00               dec $00                   ;otherwise decrement counter
00AA13  2  D0 CB               bne SideCheckLoop         ;run code until both sides of player are checked
00AA15  2  60           ExSCH: rts                       ;leave
00AA16  2               
00AA16  2               CheckSideMTiles:
00AA16  2  20 4C AB               jsr ChkInvisibleMTiles     ;check for hidden or coin 1-up blocks
00AA19  2  F0 61                  beq ExCSM                  ;branch to leave if either found
00AA1B  2  20 39 AC               jsr CheckForClimbMTiles    ;check for climbable metatiles
00AA1E  2  90 03                  bcc ContSChk               ;if not found, skip and continue with code
00AA20  2  4C AB AA               jmp HandleClimbing         ;otherwise jump to handle climbing
00AA23  2  20 40 AC     ContSChk: jsr CheckForCoinMTiles     ;check to see if player touched coin
00AA26  2  B0 57                  bcs HandleCoinMetatile     ;if so, execute code to erase coin and award to player 1 coin
00AA28  2  20 73 AB               jsr ChkJumpspringMetatiles ;check for jumpspring metatiles
00AA2B  2  90 08                  bcc ChkPBtm                ;if not found, branch ahead to continue cude
00AA2D  2  AD 0E 07               lda JumpspringAnimCtrl     ;otherwise check jumpspring animation control
00AA30  2  D0 4A                  bne ExCSM                  ;branch to leave if set
00AA32  2  4C 79 AA               jmp StopPlayerMove         ;otherwise jump to impede player's movement
00AA35  2  A4 1D        ChkPBtm:  ldy Player_State           ;get player's state
00AA37  2  C0 00                  cpy #$00                   ;check for player's state set to normal
00AA39  2  D0 3E                  bne StopPlayerMove         ;if not, branch to impede player's movement
00AA3B  2  A4 33                  ldy PlayerFacingDir        ;get player's facing direction
00AA3D  2  88                     dey
00AA3E  2  D0 39                  bne StopPlayerMove         ;if facing left, branch to impede movement
00AA40  2               .ifdef ANN
00AA40  2  C9 6D                  cmp #$6d                   ;otherwise check for pipe metatiles
00AA42  2  F0 04                  beq PipeDwnS               ;if collided with sideways pipe (bottom), branch
00AA44  2  C9 1F                  cmp #$1f                   ;if collided with water pipe (bottom), continue
00AA46  2               .else
00AA46  2                         cmp #$6e                   ;otherwise check for pipe metatiles
00AA46  2                         beq PipeDwnS               ;if collided with sideways pipe (bottom), branch
00AA46  2                         cmp #$1c                   ;if collided with water pipe (bottom), continue
00AA46  2               .endif
00AA46  2  D0 31                  bne StopPlayerMove         ;otherwise branch to impede player's movement
00AA48  2  AD C4 03     PipeDwnS: lda Player_SprAttrib       ;check player's attributes
00AA4B  2  D0 04                  bne PlyrPipe               ;if already set, branch, do not play sound again
00AA4D  2  A0 10                  ldy #Sfx_PipeDown_Injury
00AA4F  2  84 FF                  sty Square1SoundQueue      ;otherwise load pipedown/injury sound
00AA51  2  09 20        PlyrPipe: ora #%00100000
00AA53  2  8D C4 03               sta Player_SprAttrib       ;set background priority bit in player attributes
00AA56  2  A5 86                  lda Player_X_Position
00AA58  2  29 0F                  and #%00001111             ;get lower nybble of player's horizontal coordinate
00AA5A  2  F0 0E                  beq ChkGERtn               ;if at zero, branch ahead to skip this part
00AA5C  2  A0 00                  ldy #$00                   ;set default offset for timer setting data
00AA5E  2  AD 1A 07               lda ScreenLeft_PageLoc     ;load page location for left side of screen
00AA61  2  F0 01                  beq SetCATmr               ;if at page zero, use default offset
00AA63  2  C8                     iny                        ;otherwise increment offset
00AA64  2  B9 7D AA     SetCATmr: lda AreaChangeTimerData,y  ;set timer for change of area as appropriate
00AA67  2  8D DE 06               sta ChangeAreaTimer
00AA6A  2  A5 0E        ChkGERtn: lda GameEngineSubroutine   ;get number of game engine routine running
00AA6C  2  C9 07                  cmp #$07
00AA6E  2  F0 0C                  beq ExCSM                  ;if running player entrance routine or
00AA70  2  C9 08                  cmp #$08                   ;player control routine, go ahead and branch to leave
00AA72  2  D0 08                  bne ExCSM
00AA74  2  A9 02                  lda #$02
00AA76  2  85 0E                  sta GameEngineSubroutine   ;otherwise set sideways pipe entry routine to run
00AA78  2  60                     rts                        ;and leave
00AA79  2               
00AA79  2               ;--------------------------------
00AA79  2               ;$02 - high nybble of vertical coordinate from block buffer
00AA79  2               ;$04 - low nybble of horizontal coordinate from block buffer
00AA79  2               ;$06-$07 - block buffer address
00AA79  2               
00AA79  2               StopPlayerMove:
00AA79  2  20 EA AB            jsr ImpedePlayerMove      ;stop player's movement
00AA7C  2  60           ExCSM: rts                       ;leave
00AA7D  2               
00AA7D  2               AreaChangeTimerData:
00AA7D  2  A0 34              .byte $a0, $34
00AA7F  2               
00AA7F  2               HandleCoinMetatile:
00AA7F  2  20 99 AA           jsr ErACM             ;do sub to erase coin metatile from block buffer
00AA82  2  EE 48 07           inc CoinTallyFor1Ups  ;increment coin tally used for 1-up blocks
00AA85  2  4C 0E 88           jmp GiveOneCoin       ;update coin amount and tally on the screen
00AA88  2               
00AA88  2               HandleAxeMetatile:
00AA88  2  A9 00               lda #$00
00AA8A  2  8D 72 07            sta OperMode_Task   ;reset secondary mode
00AA8D  2  A9 02               lda #$02
00AA8F  2  8D 70 07            sta OperMode        ;set primary mode to victory mode
00AA92  2  20 5B C2            jsr LoadMarioPhysics
00AA95  2  A9 18               lda #$18
00AA97  2  85 57               sta Player_X_Speed  ;set horizontal speed and continue to erase axe metatile
00AA99  2  A4 02        ErACM: ldy $02             ;load vertical high nybble offset for block buffer
00AA9B  2  A9 00               lda #$00            ;load blank metatile
00AA9D  2  91 06               sta ($06),y         ;store to remove old contents from block buffer
00AA9F  2  4C C4 69            jmp RemoveCoin_Axe  ;update the screen accordingly
00AAA2  2               
00AAA2  2               ;--------------------------------
00AAA2  2               ;$02 - high nybble of vertical coordinate from block buffer
00AAA2  2               ;$04 - low nybble of horizontal coordinate from block buffer
00AAA2  2               ;$06-$07 - block buffer address
00AAA2  2               
00AAA2  2               ClimbXPosAdder:
00AAA2  2  F9 07              .byte $f9, $07
00AAA4  2               
00AAA4  2               ClimbPLocAdder:
00AAA4  2  FF 00              .byte $ff, $00
00AAA6  2               
00AAA6  2               FlagpoleYPosData:
00AAA6  2  18 22 50 68        .byte $18, $22, $50, $68, $90
00AAAA  2  90           
00AAAB  2               
00AAAB  2               HandleClimbing:
00AAAB  2  A4 04              ldy $04            ;check low nybble of horizontal coordinate returned from
00AAAD  2  C0 06              cpy #$06           ;collision detection routine against certain values, this
00AAAF  2  90 04              bcc ExHC           ;makes actual physical part of vine or flagpole thinner
00AAB1  2  C0 0A              cpy #$0a           ;than 16 pixels
00AAB3  2  90 01              bcc ChkForFlagpole
00AAB5  2  60           ExHC: rts                ;leave if too far left or too far right
00AAB6  2               
00AAB6  2               ChkForFlagpole:
00AAB6  2               .ifdef ANN
00AAB6  2  C9 24              cmp #$24               ;check climbing metatiles
00AAB8  2  F0 04              beq FlagpoleCollision  ;branch if flagpole ball found
00AABA  2  C9 25              cmp #$25
00AABC  2               .else
00AABC  2                     cmp #$21               ;check climbing metatiles
00AABC  2                     beq FlagpoleCollision  ;branch if flagpole ball found
00AABC  2                     cmp #$22
00AABC  2               .endif
00AABC  2  D0 4B              bne VineCollision      ;branch to alternate code if flagpole shaft not found
00AABE  2               
00AABE  2               FlagpoleCollision:
00AABE  2  A5 0E              lda GameEngineSubroutine
00AAC0  2  C9 05              cmp #$05                  ;check for end-of-level routine running
00AAC2  2  F0 53              beq PutPlayerOnVine       ;if running, branch to end of climbing code
00AAC4  2  A9 01              lda #$01
00AAC6  2  85 33              sta PlayerFacingDir       ;set player's facing direction to right
00AAC8  2  EE 23 07           inc ScrollLock            ;set scroll lock flag
00AACB  2  A5 0E              lda GameEngineSubroutine
00AACD  2  C9 04              cmp #$04                  ;check for flagpole slide routine running
00AACF  2  F0 31              beq RunFR                 ;if running, branch to end of flagpole code here
00AAD1  2  A9 33              lda #BulletBill_CannonVar ;load identifier for bullet bills (cannon variant)
00AAD3  2  20 BF 75           jsr KillEnemies           ;get rid of them
00AAD6  2  A9 80              lda #Silence
00AAD8  2  85 FC              sta EventMusicQueue       ;silence music
00AADA  2  4A                 lsr
00AADB  2  8D 13 07           sta FlagpoleSoundQueue    ;load flagpole sound into flagpole sound queue
00AADE  2  A2 04              ldx #$04                  ;start at end of vertical coordinate data
00AAE0  2  A5 CE              lda Player_Y_Position
00AAE2  2  8D 0F 07           sta FlagpoleCollisionYPos ;store player's vertical coordinate here to be used later
00AAE5  2               
00AAE5  2               ChkFlagpoleYPosLoop:
00AAE5  2  DD A6 AA            cmp FlagpoleYPosData,x    ;compare with current vertical coordinate data
00AAE8  2  B0 03               bcs MtchF                 ;if player's => current, branch to use current offset
00AAEA  2  CA                  dex                       ;otherwise decrement offset to use
00AAEB  2  D0 F8               bne ChkFlagpoleYPosLoop   ;do this until all data is checked (use last one if all checked)
00AAED  2  8E 0F 01     MtchF: stx FlagpoleScore         ;store offset here to be used later
00AAF0  2  AD E7 07            lda CoinDisplay
00AAF3  2  CD E8 07            cmp CoinDisplay+1         ;check to see if coin tally digits are the same
00AAF6  2  D0 0A               bne RunFR                 ;if not, branch to use flagpole score data as-is
00AAF8  2  CD EE 07            cmp GameTimerDisplay+2    ;check to see if the last digit of game timer matches
00AAFB  2  D0 05               bne RunFR                 ;the two digits, if not, branch to use data as-is
00AAFD  2  A9 05               lda #$05
00AAFF  2  8D 0F 01            sta FlagpoleScore         ;otherwise, set to give player an extra life
00AB02  2  A9 04        RunFR: lda #$04
00AB04  2  85 0E               sta GameEngineSubroutine  ;set value to run flagpole slide routine
00AB06  2  4C 17 AB            jmp PutPlayerOnVine       ;jump to end of climbing code
00AB09  2               
00AB09  2               VineCollision:
00AB09  2               .ifdef ANN
00AB09  2  C9 26              cmp #$26                  ;check for climbing metatile used on vines
00AB0B  2               .else
00AB0B  2                     cmp #$23                  ;check for climbing metatile used on vines
00AB0B  2               .endif
00AB0B  2  D0 0A              bne PutPlayerOnVine
00AB0D  2  A5 CE              lda Player_Y_Position     ;check player's vertical coordinate
00AB0F  2  C9 20              cmp #$20                  ;for being in status bar area
00AB11  2  B0 04              bcs PutPlayerOnVine       ;branch if not that far up
00AB13  2  A9 01              lda #$01
00AB15  2  85 0E              sta GameEngineSubroutine  ;otherwise set to run autoclimb routine next frame
00AB17  2               
00AB17  2               PutPlayerOnVine:
00AB17  2  A9 03                 lda #$03                ;set player state to climbing
00AB19  2  85 1D                 sta Player_State
00AB1B  2  A9 00                 lda #$00                ;nullify player's horizontal speed
00AB1D  2  85 57                 sta Player_X_Speed      ;and fractional horizontal movement force
00AB1F  2  8D 05 07              sta Player_X_MoveForce
00AB22  2  A5 86                 lda Player_X_Position   ;get player's horizontal coordinate
00AB24  2  38                    sec
00AB25  2  ED 1C 07              sbc ScreenLeft_X_Pos    ;subtract from left side horizontal coordinate
00AB28  2  C9 10                 cmp #$10
00AB2A  2  B0 04                 bcs SetVXPl             ;if 16 or more pixels difference, do not alter facing direction
00AB2C  2  A9 02                 lda #$02
00AB2E  2  85 33                 sta PlayerFacingDir     ;otherwise force player to face left
00AB30  2  A4 33        SetVXPl: ldy PlayerFacingDir     ;get current facing direction, use as offset
00AB32  2  A5 06                 lda $06                 ;get low byte of block buffer address
00AB34  2  0A                    asl
00AB35  2  0A                    asl                     ;move low nybble to high
00AB36  2  0A                    asl
00AB37  2  0A                    asl
00AB38  2  18                    clc
00AB39  2  79 A1 AA              adc ClimbXPosAdder-1,y  ;add pixels depending on facing direction
00AB3C  2  85 86                 sta Player_X_Position   ;store as player's horizontal coordinate
00AB3E  2  A5 06                 lda $06                 ;get low byte of block buffer address again
00AB40  2  D0 09                 bne ExPVne              ;if not zero, branch
00AB42  2  AD 1B 07              lda ScreenRight_PageLoc ;load page location of right side of screen
00AB45  2  18                    clc
00AB46  2  79 A3 AA              adc ClimbPLocAdder-1,y  ;add depending on facing location
00AB49  2  85 6D                 sta Player_PageLoc      ;store as player's page location
00AB4B  2  60           ExPVne:  rts                     ;finally, we're done!
00AB4C  2               
00AB4C  2               ;--------------------------------
00AB4C  2               
00AB4C  2               ChkInvisibleMTiles:
00AB4C  2  C9 5E                 cmp #$5e       ;check for hidden coin block
00AB4E  2  F0 06                 beq ExCInvT
00AB50  2  C9 5F                 cmp #$5f       ;check for hidden 1-up block
00AB52  2  F0 02                 beq ExCInvT
00AB54  2               .ifdef ANN
00AB54  2  C9 60                 cmp #$60       ;check for hidden power-up block
00AB56  2               .else
00AB56  2                        cmp #$60       ;check for hidden poison shroom block
00AB56  2                        beq ExCInvT
00AB56  2                        cmp #$61       ;check for hidden power-up block
00AB56  2               .endif
00AB56  2  60           ExCInvT: rts            ;leave with zero flag set if any of these found
00AB57  2               
00AB57  2               ;--------------------------------
00AB57  2               ;$00-$01 - used to hold bottom right and bottom left metatiles (in that order)
00AB57  2               ;$00 - used as flag by ImpedePlayerMove to restrict specific movement
00AB57  2               
00AB57  2               ChkForLandJumpSpring:
00AB57  2  20 73 AB             jsr ChkJumpspringMetatiles  ;do sub to check if player landed on jumpspring
00AB5A  2  90 16                bcc ExCJSp                  ;if carry not set, jumpspring not found, therefore leave
00AB5C  2  A9 70                lda #$70
00AB5E  2  8D 09 07             sta VerticalForce           ;otherwise set vertical movement force for player
00AB61  2  8D 0A 07             sta VerticalForceDown
00AB64  2  A9 F9                lda #$f9
00AB66  2  8D DB 06             sta JumpspringForce         ;set default jumpspring force
00AB69  2  A9 03                lda #$03
00AB6B  2  8D 86 07             sta JumpspringTimer         ;set jumpspring timer to be used later
00AB6E  2  4A                   lsr
00AB6F  2  8D 0E 07             sta JumpspringAnimCtrl      ;set jumpspring animation control to start animating
00AB72  2  60           ExCJSp: rts                         ;and leave
00AB73  2               
00AB73  2               ChkJumpspringMetatiles:
00AB73  2               .ifdef ANN
00AB73  2  C9 67                 cmp #$67      ;check for top jumpspring metatile
00AB75  2  F0 05                 beq JSFnd     ;branch to set carry if found
00AB77  2  C9 68                 cmp #$68      ;check for bottom jumpspring metatile
00AB79  2               .else
00AB79  2                        cmp #$68      ;check for top jumpspring metatile
00AB79  2                        beq JSFnd     ;branch to set carry if found
00AB79  2                        cmp #$69      ;check for bottom jumpspring metatile
00AB79  2               .endif
00AB79  2  18                    clc           ;clear carry flag
00AB7A  2  D0 01                 bne NoJSFnd   ;branch to use cleared carry if not found
00AB7C  2  38           JSFnd:   sec           ;set carry if found
00AB7D  2  60           NoJSFnd: rts           ;leave
00AB7E  2               
00AB7E  2               HandlePipeEntry:
00AB7E  2  A5 0B                  lda Up_Down_Buttons       ;check saved controller bits from earlier
00AB80  2  29 04                  and #%00000100            ;for pressing down
00AB82  2  F0 65                  beq ExPipeE               ;if not pressing down, branch to leave
00AB84  2  A5 00                  lda $00
00AB86  2  C9 11                  cmp #$11                  ;check right foot metatile for warp pipe right metatile
00AB88  2  D0 5F                  bne ExPipeE               ;branch to leave if not found
00AB8A  2  A5 01                  lda $01
00AB8C  2  C9 10                  cmp #$10                  ;check left foot metatile for warp pipe left metatile
00AB8E  2  D0 59                  bne ExPipeE               ;branch to leave if not found
00AB90  2  A9 30                  lda #$30
00AB92  2  8D DE 06               sta ChangeAreaTimer       ;set timer for change of area
00AB95  2  A9 03                  lda #$03
00AB97  2  85 0E                  sta GameEngineSubroutine  ;set to run vertical pipe entry routine on next frame
00AB99  2  A9 10                  lda #Sfx_PipeDown_Injury
00AB9B  2  85 FF                  sta Square1SoundQueue     ;load pipedown/injury sound
00AB9D  2  A9 20                  lda #%00100000
00AB9F  2  8D C4 03               sta Player_SprAttrib      ;set background priority bit in player's attributes
00ABA2  2  AD D6 06               lda WarpZoneControl       ;check warp zone control
00ABA5  2  F0 42                  beq ExPipeE               ;branch to leave if none found
00ABA7  2               .ifdef ANN
00ABA7  2  29 07                 and #%00000111            ;mask bits
00ABA9  2  0A                    asl
00ABAA  2  0A                    asl                       ;multiply by four
00ABAB  2  AA                    tax                       ;save as offset to warp zone numbers (starts at left pipe)
00ABAC  2  A5 86                 lda Player_X_Position     ;get player's horizontal position
00ABAE  2  C9 60                 cmp #$60
00ABB0  2  90 06                 bcc GetWNum               ;if player at left, not near middle, use offset and skip ahead
00ABB2  2  E8                    inx                       ;otherwise increment for middle pipe
00ABB3  2  C9 A0                 cmp #$a0
00ABB5  2  90 01                 bcc GetWNum               ;if player at middle, but not too far right, use offset and skip
00ABB7  2  E8                    inx                       ;otherwise increment for last pipe
00ABB8  2               .else
00ABB8  2                         and #%00001111            ;mask out all but lower nybble
00ABB8  2                         tax                       ;save as offset, then use to load warp zone destination
00ABB8  2               .endif
00ABB8  2               GetWNum:
00ABB8  2  BD 8C 67               lda WarpZoneNumbers,x
00ABBB  2  AC FB 07               ldy HardWorldFlag         ;if playing worlds A-D, branch to skip this part
00ABBE  2  F0 03                  beq SetWDest
00ABC0  2  38                     sec
00ABC1  2  E9 09                  sbc #$09                  ;otherwise subtract 9 to get correct world number
00ABC3  2  A8           SetWDest: tay
00ABC4  2  88                     dey                       ;decrement for use as world number
00ABC5  2  8C 5F 07               sty WorldNumber           ;store as world number and offset
00ABC8  2  BE 39 C3               ldx WorldAddrOffsets,y    ;get offset to where this world's area offsets are
00ABCB  2  BD 41 C3               lda AreaAddrOffsets,x     ;get area offset based on world offset
00ABCE  2  8D 50 07               sta AreaPointer           ;store area offset here to be used to change areas
00ABD1  2  A9 80                  lda #Silence
00ABD3  2  85 FC                  sta EventMusicQueue       ;silence music
00ABD5  2  A9 00                  lda #$00
00ABD7  2  8D 51 07               sta EntrancePage          ;initialize starting page number
00ABDA  2  8D 60 07               sta AreaNumber            ;initialize area number used for area address offset
00ABDD  2  8D 5C 07               sta LevelNumber           ;initialize level number used for world display
00ABE0  2  8D 52 07               sta AltEntranceControl    ;initialize mode of entry
00ABE3  2  EE 5D 07               inc Hidden1UpFlag         ;set flag for hidden 1-up blocks
00ABE6  2  EE 57 07               inc FetchNewGameTimerFlag ;set flag to load new game timer
00ABE9  2  60           ExPipeE:  rts                       ;leave!!!
00ABEA  2               
00ABEA  2               ImpedePlayerMove:
00ABEA  2  A9 00               lda #$00                  ;initialize value here
00ABEC  2  A4 57               ldy Player_X_Speed        ;get player's horizontal speed
00ABEE  2  A6 00               ldx $00                   ;check value set earlier for
00ABF0  2  CA                  dex                       ;left side collision
00ABF1  2  D0 0A               bne RImpd                 ;if right side collision, skip this part
00ABF3  2  E8                  inx                       ;return value to X
00ABF4  2  C0 00               cpy #$00                  ;if player moving to the left,
00ABF6  2  30 28               bmi ExIPM                 ;branch to invert bit and leave
00ABF8  2  A9 FF               lda #$ff                  ;otherwise load A with value to be used later
00ABFA  2  4C 05 AC            jmp NXSpd                 ;and jump to affect movement
00ABFD  2  A2 02        RImpd: ldx #$02                  ;return $02 to X
00ABFF  2  C0 01               cpy #$01                  ;if player moving to the right,
00AC01  2  10 1D               bpl ExIPM                 ;branch to invert bit and leave
00AC03  2  A9 01               lda #$01                  ;otherwise load A with value to be used here
00AC05  2  A0 10        NXSpd: ldy #$10
00AC07  2  8C 85 07            sty SideCollisionTimer    ;set timer of some sort
00AC0A  2  A0 00               ldy #$00
00AC0C  2  84 57               sty Player_X_Speed        ;nullify player's horizontal speed
00AC0E  2  C9 00               cmp #$00                  ;if value set in A not set to $ff,
00AC10  2  10 01               bpl PlatF                 ;branch ahead, do not decrement Y
00AC12  2  88                  dey                       ;otherwise decrement Y now
00AC13  2  84 00        PlatF: sty $00                   ;store Y as high bits of horizontal adder
00AC15  2  18                  clc
00AC16  2  65 86               adc Player_X_Position     ;add contents of A to player's horizontal
00AC18  2  85 86               sta Player_X_Position     ;position to move player left or right
00AC1A  2  A5 6D               lda Player_PageLoc
00AC1C  2  65 00               adc $00                   ;add high bits and carry to
00AC1E  2  85 6D               sta Player_PageLoc        ;page location if necessary
00AC20  2  8A           ExIPM: txa                       ;invert contents of X
00AC21  2  49 FF               eor #$ff
00AC23  2  2D 90 04            and Player_CollisionBits  ;mask out bit that was set here
00AC26  2  8D 90 04            sta Player_CollisionBits  ;store to clear bit
00AC29  2  60                  rts
00AC2A  2               
00AC2A  2               ;--------------------------------
00AC2A  2               
00AC2A  2               SolidMTileUpperExt:
00AC2A  2               .ifdef ANN
00AC2A  2  10 61 88 C4        .byte $10, $61, $88, $c4
00AC2E  2               .else
00AC2E  2                     .byte $10, $62, $88, $c5
00AC2E  2               .endif
00AC2E  2               
00AC2E  2               CheckForSolidMTiles:
00AC2E  2  20 4F AC           jsr GetMTileAttrib        ;find appropriate offset based on metatile's 2 MSB
00AC31  2  DD 2A AC           cmp SolidMTileUpperExt,x  ;compare current metatile with solid metatiles
00AC34  2  60                 rts
00AC35  2               
00AC35  2               ClimbMTileUpperExt:
00AC35  2               .ifdef ANN
00AC35  2  24 6E 8A C6        .byte $24, $6e, $8a, $c6
00AC39  2               .else
00AC39  2                     .byte $21, $6f, $8d, $c7
00AC39  2               .endif
00AC39  2               
00AC39  2               CheckForClimbMTiles:
00AC39  2  20 4F AC           jsr GetMTileAttrib        ;find appropriate offset based on metatile's 2 MSB
00AC3C  2  DD 35 AC           cmp ClimbMTileUpperExt,x  ;compare current metatile with climbable metatiles
00AC3F  2  60                 rts
00AC40  2               
00AC40  2               CheckForCoinMTiles:
00AC40  2               .ifdef ANN
00AC40  2  C9 C2                 cmp #$c2              ;check for regular coin
00AC42  2  F0 06                 beq CoinSd            ;branch if found
00AC44  2  C9 C3                 cmp #$c3              ;check for underwater coin
00AC46  2               .else
00AC46  2                        cmp #$c3              ;check for regular coin
00AC46  2                        beq CoinSd            ;branch if found
00AC46  2                        cmp #$c4              ;check for underwater coin
00AC46  2               .endif
00AC46  2  F0 02                 beq CoinSd            ;branch if found
00AC48  2  18                    clc                   ;otherwise clear carry and leave
00AC49  2  60                    rts
00AC4A  2  A9 01        CoinSd:  lda #Sfx_CoinGrab
00AC4C  2  85 FE                 sta Square2SoundQueue ;load coin grab sound and leave
00AC4E  2  60                    rts
00AC4F  2               
00AC4F  2               GetMTileAttrib:
00AC4F  2  A8                  tay            ;save metatile value into Y
00AC50  2  29 C0               and #%11000000 ;mask out all but 2 MSB
00AC52  2  0A                  asl
00AC53  2  2A                  rol            ;shift and rotate d7-d6 to d1-d0
00AC54  2  2A                  rol
00AC55  2  AA                  tax            ;use as offset for metatile data
00AC56  2  98                  tya            ;get original metatile value back
00AC57  2  60           ExEBG: rts            ;leave
00AC58  2               
00AC58  2               ;-------------------------------------------------------------------------------------
00AC58  2               ;$06-$07 - address from block buffer routine
00AC58  2               
00AC58  2               EnemyBGCStateData:
00AC58  2  01 01 02 02        .byte $01, $01, $02, $02, $02, $05
00AC5C  2  02 05        
00AC5E  2               
00AC5E  2               EnemyBGCXSpdData:
00AC5E  2  10 F0              .byte $10, $f0
00AC60  2               
00AC60  2               EnemyToBGCollisionDet:
00AC60  2  B5 1E              lda Enemy_State,x        ;check enemy state for d6 set
00AC62  2  29 20              and #%00100000
00AC64  2  D0 F1              bne ExEBG                ;if set, branch to leave
00AC66  2  20 07 AE           jsr SubtEnemyYPos        ;otherwise, do a subroutine here
00AC69  2  90 EC              bcc ExEBG                ;if enemy vertical coord + 62 < 68, branch to leave
00AC6B  2  B4 16              ldy Enemy_ID,x
00AC6D  2  C0 12              cpy #Spiny               ;if enemy object is not spiny, branch elsewhere
00AC6F  2  D0 06              bne DoIDCheckBGColl
00AC71  2  B5 CF              lda Enemy_Y_Position,x
00AC73  2  C9 25              cmp #$25                 ;if enemy vertical coordinate < 36 branch to leave
00AC75  2  90 E0              bcc ExEBG
00AC77  2               
00AC77  2               DoIDCheckBGColl:
00AC77  2  C0 0E                  cpy #GreenParatroopaJump ;check for some other enemy object
00AC79  2  D0 03                  bne HBChk                ;branch if not found
00AC7B  2  4C 0F AE               jmp EnemyJump            ;otherwise jump elsewhere
00AC7E  2  C0 05        HBChk:    cpy #HammerBro           ;check for hammer bro
00AC80  2  D0 04                  bne CInvu                ;branch if not found
00AC82  2  4C 31 AE               jmp HammerBroBGColl      ;otherwise jump elsewhere
00AC85  2  60           ExIDBChk: rts
00AC86  2  C0 12        CInvu:    cpy #Spiny               ;if enemy object is spiny, branch
00AC88  2  F0 0C                  beq YesIn
00AC8A  2  C0 2E                  cpy #PowerUpObject       ;if special power-up object, branch
00AC8C  2  F0 08                  beq YesIn
00AC8E  2  C0 04                  cpy #UpsideDownPiranhaP  ;if enemy object is upside-down piranha plant
00AC90  2  F0 F3                  beq ExIDBChk             ;then branch to leave
00AC92  2  C0 07                  cpy #$07                 ;if enemy object =>$07, branch to leave
00AC94  2  B0 EF                  bcs ExIDBChk
00AC96  2  20 5A AE     YesIn:    jsr ChkUnderEnemy        ;if enemy object < $07, or = $12 or $2e, do this sub
00AC99  2  D0 03                  bne HandleEToBGCollision ;if block underneath enemy, branch
00AC9B  2               
00AC9B  2               NoEToBGCollision:
00AC9B  2  4C 8E AD            jmp ChkForRedKoopa       ;otherwise skip and do something else
00AC9E  2               
00AC9E  2               ;--------------------------------
00AC9E  2               ;$02 - vertical coordinate from block buffer routine
00AC9E  2               
00AC9E  2               HandleEToBGCollision:
00AC9E  2  20 61 AE           jsr ChkForNonSolids       ;if something is underneath enemy, find out what
00ACA1  2  F0 F8              beq NoEToBGCollision      ;if blank $26, coins, or hidden blocks, jump, enemy falls through
00ACA3  2               .ifdef ANN
00ACA3  2  C9 23              cmp #$23
00ACA5  2               .else
00ACA5  2                     cmp #$20
00ACA5  2               .endif
00ACA5  2  D0 6C              bne LandEnemyProperly     ;check for blank metatile $20 and branch if not found
00ACA7  2  B5 16              lda Enemy_ID,x
00ACA9  2  C9 15              cmp #$15                  ;if enemy object => $15, branch ahead
00ACAB  2  B0 0C              bcs ChkToStunEnemies
00ACAD  2  C9 06              cmp #Goomba               ;if enemy object not goomba, branch ahead of this routine
00ACAF  2  D0 03              bne GiveOEPoints
00ACB1  2  20 3A AE           jsr KillEnemyAboveBlock   ;if enemy object IS goomba, do this sub
00ACB4  2               
00ACB4  2               GiveOEPoints:
00ACB4  2  A9 01              lda #$01                  ;award 100 points for hitting block beneath enemy
00ACB6  2  20 76 A6           jsr SetupFloateyNumber
00ACB9  2               
00ACB9  2               ChkToStunEnemies:
00ACB9  2  B5 16                   lda Enemy_ID,x
00ACBB  2  C9 09                   cmp #$09                   ;perform many comparisons on enemy object identifier
00ACBD  2  90 18                   bcc NoDemote               ;if the enemy object identifier is equal to the values
00ACBF  2  C9 11                   cmp #$11                   ;$0e-$10 it will be demoted, in practice $0e and $10
00ACC1  2  B0 14                   bcs NoDemote               ;are values used by green paratroopas
00ACC3  2  C9 0D                   cmp #PiranhaPlant
00ACC5  2  F0 10                   beq NoDemote               ;enemy objects $0a-$0d will not be demoted
00ACC7  2  C9 04                   cmp #UpsideDownPiranhaP
00ACC9  2  F0 0C                   beq NoDemote
00ACCB  2  C9 0A                   cmp #$0a                   ;demote enemy object $09 even though it is not used
00ACCD  2  90 04                   bcc Demote
00ACCF  2  C9 0D                   cmp #PiranhaPlant
00ACD1  2  90 04                   bcc NoDemote
00ACD3  2  29 01        Demote:    and #%00000001             ;erase all but LSB, essentially turning enemy object
00ACD5  2  95 16                   sta Enemy_ID,x             ;into green or red koopa troopa to demote them
00ACD7  2  C9 2E        NoDemote:  cmp #PowerUpObject
00ACD9  2  F0 08                   beq BounceOff              ;if power-up object, branch to bounce it
00ACDB  2  C9 06                   cmp #Goomba
00ACDD  2  F0 04                   beq BounceOff              ;redundant, already checked for goomba
00ACDF  2  A9 02                   lda #$02
00ACE1  2  95 1E                   sta Enemy_State,x          ;set enemy state to 2 (stunned)
00ACE3  2  D6 CF        BounceOff: dec Enemy_Y_Position,x
00ACE5  2  D6 CF                   dec Enemy_Y_Position,x     ;subtract two pixels from enemy's vertical position
00ACE7  2  B5 16                   lda Enemy_ID,x
00ACE9  2  C9 07                   cmp #Bloober               ;check for bloober object
00ACEB  2  F0 07                   beq SetWYSpd
00ACED  2  A9 FD                   lda #$fd                   ;set default vertical speed
00ACEF  2  AC 4E 07                ldy AreaType
00ACF2  2  D0 02                   bne SetNotW                ;if area type not water, set as speed, otherwise
00ACF4  2  A9 FF        SetWYSpd:  lda #$ff                   ;change the vertical speed
00ACF6  2  95 A0        SetNotW:   sta Enemy_Y_Speed,x        ;set vertical speed now
00ACF8  2  A0 01                   ldy #$01
00ACFA  2  20 EF AD                jsr PlayerEnemyDiff        ;get horizontal difference between player and enemy object
00ACFD  2  10 01                   bpl ChkBBill               ;branch if enemy is to the right of player
00ACFF  2  C8                      iny                        ;increment Y if not
00AD00  2  B5 16        ChkBBill:  lda Enemy_ID,x
00AD02  2  C9 33                   cmp #BulletBill_CannonVar  ;check for bullet bill (cannon variant)
00AD04  2  F0 06                   beq NoCDirF
00AD06  2  C9 08                   cmp #BulletBill_FrenzyVar  ;check for bullet bill (frenzy variant)
00AD08  2  F0 02                   beq NoCDirF                ;branch if either found, direction does not change
00AD0A  2  94 46                   sty Enemy_MovingDir,x      ;store as moving direction
00AD0C  2  88           NoCDirF:   dey                        ;decrement and use as offset
00AD0D  2  B9 5E AC                lda EnemyBGCXSpdData,y     ;get proper horizontal speed
00AD10  2  95 58                   sta Enemy_X_Speed,x        ;and store, then leave
00AD12  2  60           ExEBGChk:  rts
00AD13  2               
00AD13  2               ;--------------------------------
00AD13  2               ;$04 - low nybble of vertical coordinate from block buffer routine
00AD13  2               
00AD13  2               LandEnemyProperly:
00AD13  2  A5 04               lda $04                 ;check lower nybble of vertical coordinate saved earlier
00AD15  2  38                  sec
00AD16  2  E9 08               sbc #$08                ;subtract eight pixels
00AD18  2  C9 05               cmp #$05                ;used to determine whether enemy landed from falling
00AD1A  2  B0 72               bcs ChkForRedKoopa      ;branch if lower nybble in range of $0d-$0f before subtract
00AD1C  2  B5 1E               lda Enemy_State,x
00AD1E  2  29 40               and #%01000000          ;branch if d6 in enemy state is set
00AD20  2  D0 57               bne LandEnemyInitState
00AD22  2  B5 1E               lda Enemy_State,x
00AD24  2  0A                  asl                     ;branch if d7 in enemy state is not set
00AD25  2  90 03               bcc ChkLandedEnemyState
00AD27  2  4C AA AD     SChkA: jmp DoEnemySideCheck    ;if lower nybble < $0d, d7 set but d6 not set, jump here
00AD2A  2               
00AD2A  2               ChkLandedEnemyState:
00AD2A  2  B5 1E                   lda Enemy_State,x         ;if enemy in normal state, branch back to jump here
00AD2C  2  F0 F9                   beq SChkA
00AD2E  2  C9 05                   cmp #$05                  ;if in state used by spiny's egg
00AD30  2  F0 1F                   beq ProcEnemyDirection    ;then branch elsewhere
00AD32  2  C9 03                   cmp #$03                  ;if already in state used by koopas and buzzy beetles
00AD34  2  B0 1A                   bcs ExSteChk              ;or in higher numbered state, branch to leave
00AD36  2  B5 1E                   lda Enemy_State,x         ;load enemy state again (why?)
00AD38  2  C9 02                   cmp #$02                  ;if not in $02 state (used by koopas and buzzy beetles)
00AD3A  2  D0 15                   bne ProcEnemyDirection    ;then branch elsewhere
00AD3C  2  A9 10                   lda #$10                  ;load default timer here
00AD3E  2  B4 16                   ldy Enemy_ID,x            ;check enemy identifier for spiny
00AD40  2  C0 12                   cpy #Spiny
00AD42  2  D0 02                   bne SetForStn             ;branch if not found
00AD44  2  A9 00                   lda #$00                  ;set timer for $00 if spiny
00AD46  2  9D 96 07     SetForStn: sta EnemyIntervalTimer,x  ;set timer here
00AD49  2  A9 03                   lda #$03                  ;set state here, apparently used to render
00AD4B  2  95 1E                   sta Enemy_State,x         ;upside-down koopas and buzzy beetles
00AD4D  2  20 FB AD                jsr EnemyLanding          ;then land it properly
00AD50  2  60           ExSteChk:  rts                       ;then leave
00AD51  2               
00AD51  2               ProcEnemyDirection:
00AD51  2  B5 16                 lda Enemy_ID,x            ;check enemy identifier for goomba
00AD53  2  C9 06                 cmp #Goomba               ;branch if found
00AD55  2  F0 22                 beq LandEnemyInitState
00AD57  2  C9 12                 cmp #Spiny                ;check for spiny
00AD59  2  D0 0E                 bne InvtD                 ;branch if not found
00AD5B  2  A9 01                 lda #$01
00AD5D  2  95 46                 sta Enemy_MovingDir,x     ;send enemy moving to the right by default
00AD5F  2  A9 08                 lda #$08
00AD61  2  95 58                 sta Enemy_X_Speed,x       ;set horizontal speed accordingly
00AD63  2  A5 09                 lda FrameCounter
00AD65  2  29 07                 and #%00000111            ;if timed appropriately, spiny will skip over
00AD67  2  F0 10                 beq LandEnemyInitState    ;trying to face the player
00AD69  2  A0 01        InvtD:   ldy #$01                  ;load 1 for enemy to face the left (inverted here)
00AD6B  2  20 EF AD              jsr PlayerEnemyDiff       ;get horizontal difference between player and enemy
00AD6E  2  10 01                 bpl CNwCDir               ;if enemy to the right of player, branch
00AD70  2  C8                    iny                       ;if to the left, increment by one for enemy to face right (inverted)
00AD71  2  98           CNwCDir: tya
00AD72  2  D5 46                 cmp Enemy_MovingDir,x     ;compare direction in A with current direction in memory
00AD74  2  D0 03                 bne LandEnemyInitState
00AD76  2  20 D0 AD              jsr ChkForBump_HammerBroJ ;if equal, not facing in correct dir, do sub to turn around
00AD79  2               
00AD79  2               LandEnemyInitState:
00AD79  2  20 FB AD           jsr EnemyLanding       ;land enemy properly
00AD7C  2  B5 1E              lda Enemy_State,x
00AD7E  2  29 80              and #%10000000         ;if d7 of enemy state is set, branch
00AD80  2  D0 05              bne NMovShellFallBit
00AD82  2  A9 00              lda #$00               ;otherwise initialize enemy state and leave
00AD84  2  95 1E              sta Enemy_State,x      ;note this will also turn spiny's egg into spiny
00AD86  2  60                 rts
00AD87  2               
00AD87  2               NMovShellFallBit:
00AD87  2  B5 1E              lda Enemy_State,x   ;nullify d6 of enemy state, save other bits
00AD89  2  29 BF              and #%10111111      ;and store, then leave
00AD8B  2  95 1E              sta Enemy_State,x
00AD8D  2  60                 rts
00AD8E  2               
00AD8E  2               ;--------------------------------
00AD8E  2               
00AD8E  2               ChkForRedKoopa:
00AD8E  2  B5 16                     lda Enemy_ID,x            ;check for red koopa troopa $03
00AD90  2  C9 03                     cmp #RedKoopa
00AD92  2  D0 04                     bne Chk2MSBSt             ;branch if not found
00AD94  2  B5 1E                     lda Enemy_State,x
00AD96  2  F0 38                     beq ChkForBump_HammerBroJ ;if enemy found and in normal state, branch
00AD98  2  B5 1E        Chk2MSBSt:   lda Enemy_State,x         ;save enemy state into Y
00AD9A  2  A8                        tay
00AD9B  2  0A                        asl                       ;check for d7 set
00AD9C  2  90 07                     bcc GetSteFromD           ;branch if not set
00AD9E  2  B5 1E                     lda Enemy_State,x
00ADA0  2  09 40                     ora #%01000000            ;set d6
00ADA2  2  4C A8 AD                  jmp SetD6Ste              ;jump ahead of this part
00ADA5  2  B9 58 AC     GetSteFromD: lda EnemyBGCStateData,y   ;load new enemy state with old as offset
00ADA8  2  95 1E        SetD6Ste:    sta Enemy_State,x         ;set as new state
00ADAA  2               
00ADAA  2               ;--------------------------------
00ADAA  2               ;$00 - used to store bitmask (not used but initialized here)
00ADAA  2               ;$eb - used in DoEnemySideCheck as counter and to compare moving directions
00ADAA  2               
00ADAA  2               DoEnemySideCheck:
00ADAA  2  B5 CF                  lda Enemy_Y_Position,x     ;if enemy within status bar, branch to leave
00ADAC  2  C9 20                  cmp #$20                   ;because there's nothing there that impedes movement
00ADAE  2  90 1F                  bcc ExESdeC
00ADB0  2  A0 16                  ldy #$16                   ;start by finding block to the left of enemy ($00,$14)
00ADB2  2  A9 02                  lda #$02                   ;set value here in what is also used as
00ADB4  2  85 EB                  sta $eb                    ;OAM data offset
00ADB6  2  A5 EB        SdeCLoop: lda $eb                    ;check value
00ADB8  2  D5 46                  cmp Enemy_MovingDir,x      ;compare value against moving direction
00ADBA  2  D0 0C                  bne NextSdeC               ;branch if different and do not seek block there
00ADBC  2  A9 01                  lda #$01                   ;set flag in A for save horizontal coordinate
00ADBE  2  20 38 B0               jsr BlockBufferChk_Enemy   ;find block to left or right of enemy object
00ADC1  2  F0 05                  beq NextSdeC               ;if nothing found, branch
00ADC3  2  20 61 AE               jsr ChkForNonSolids        ;check for non-solid blocks
00ADC6  2  D0 08                  bne ChkForBump_HammerBroJ  ;branch if not found
00ADC8  2  C6 EB        NextSdeC: dec $eb                    ;move to the next direction
00ADCA  2  C8                     iny
00ADCB  2  C0 18                  cpy #$18                   ;increment Y, loop only if Y < $18, thus we check
00ADCD  2  90 E7                  bcc SdeCLoop               ;enemy ($00, $14) and ($10, $14) pixel coordinates
00ADCF  2  60           ExESdeC:  rts
00ADD0  2               
00ADD0  2               ChkForBump_HammerBroJ:
00ADD0  2  E0 05                cpx #$05               ;check if we're on the special use slot
00ADD2  2  F0 09                beq NoBump             ;and if so, branch ahead and do not play sound
00ADD4  2  B5 1E                lda Enemy_State,x      ;if enemy state d7 not set, branch
00ADD6  2  0A                   asl                    ;ahead and do not play sound
00ADD7  2  90 04                bcc NoBump
00ADD9  2  A9 02                lda #Sfx_Bump          ;otherwise, play bump sound
00ADDB  2  85 FF                sta Square1SoundQueue  ;sound will never be played if branching from ChkForRedKoopa
00ADDD  2  B5 16        NoBump: lda Enemy_ID,x         ;check for hammer bro
00ADDF  2  C9 05                cmp #$05
00ADE1  2  D0 09                bne InvEnemyDir        ;branch if not found
00ADE3  2  A9 00                lda #$00
00ADE5  2  85 00                sta $00                ;initialize value here for bitmask
00ADE7  2  A0 FA                ldy #$fa               ;load default vertical speed for jumping
00ADE9  2  4C 6B 96             jmp SetHJ              ;jump to code that makes hammer bro jump
00ADEC  2               
00ADEC  2               InvEnemyDir:
00ADEC  2  4C A7 A7           jmp RXSpd     ;jump to turn the enemy around
00ADEF  2               
00ADEF  2               ;--------------------------------
00ADEF  2               ;$00 - used to hold horizontal difference between player and enemy
00ADEF  2               
00ADEF  2               PlayerEnemyDiff:
00ADEF  2  B5 87              lda Enemy_X_Position,x  ;get distance between enemy object's
00ADF1  2  38                 sec                     ;horizontal coordinate and the player's
00ADF2  2  E5 86              sbc Player_X_Position   ;horizontal coordinate
00ADF4  2  85 00              sta $00                 ;and store here
00ADF6  2  B5 6E              lda Enemy_PageLoc,x
00ADF8  2  E5 6D              sbc Player_PageLoc      ;subtract borrow, then leave
00ADFA  2  60                 rts
00ADFB  2               
00ADFB  2               ;--------------------------------
00ADFB  2               
00ADFB  2               EnemyLanding:
00ADFB  2  20 77 8F           jsr InitVStf            ;do something here to vertical speed and something else
00ADFE  2  B5 CF              lda Enemy_Y_Position,x
00AE00  2  29 F0              and #%11110000          ;save high nybble of vertical coordinate, and
00AE02  2  09 08              ora #%00001000          ;set d3, then store, probably used to set enemy object
00AE04  2  95 CF              sta Enemy_Y_Position,x  ;neatly on whatever it's landing on
00AE06  2  60                 rts
00AE07  2               
00AE07  2               SubtEnemyYPos:
00AE07  2  B5 CF              lda Enemy_Y_Position,x  ;add 62 pixels to enemy object's
00AE09  2  18                 clc                     ;vertical coordinate
00AE0A  2  69 3E              adc #$3e
00AE0C  2  C9 44              cmp #$44                ;compare against a certain range
00AE0E  2  60                 rts                     ;and leave with flags set for conditional branch
00AE0F  2               
00AE0F  2               EnemyJump:
00AE0F  2  20 07 AE             jsr SubtEnemyYPos     ;do a sub here
00AE12  2  90 1A                bcc DoSide            ;if enemy vertical coord + 62 < 68, branch to leave
00AE14  2  B5 A0                lda Enemy_Y_Speed,x
00AE16  2  18                   clc                   ;add two to vertical speed
00AE17  2  69 02                adc #$02
00AE19  2  C9 03                cmp #$03              ;if green paratroopa not falling, branch ahead
00AE1B  2  90 11                bcc DoSide
00AE1D  2  20 5A AE             jsr ChkUnderEnemy     ;otherwise, check to see if green paratroopa is
00AE20  2  F0 0C                beq DoSide            ;standing on anything, then branch to same place if not
00AE22  2  20 61 AE             jsr ChkForNonSolids   ;check for non-solid blocks
00AE25  2  F0 07                beq DoSide            ;branch if found
00AE27  2  20 FB AD             jsr EnemyLanding      ;change vertical coordinate and speed
00AE2A  2  A9 FD                lda #$fd
00AE2C  2  95 A0                sta Enemy_Y_Speed,x   ;make the paratroopa jump again
00AE2E  2  4C AA AD     DoSide: jmp DoEnemySideCheck  ;check for horizontal blockage, then leave
00AE31  2               
00AE31  2               ;--------------------------------
00AE31  2               
00AE31  2               HammerBroBGColl:
00AE31  2  20 5A AE           jsr ChkUnderEnemy    ;check to see if hammer bro is standing on anything
00AE34  2  F0 1D              beq NoUnderHammerBro
00AE36  2               .ifdef ANN
00AE36  2  C9 23              cmp #$23
00AE38  2               .else
00AE38  2                     cmp #$20             ;check for blank metatile $20 and branch if not found
00AE38  2               .endif
00AE38  2  D0 08              bne UnderHammerBro
00AE3A  2               
00AE3A  2               KillEnemyAboveBlock:
00AE3A  2  20 D2 A3           jsr ShellOrBlockDefeat  ;do this sub to kill enemy
00AE3D  2  A9 FC              lda #$fc                ;alter vertical speed of enemy and leave
00AE3F  2  95 A0              sta Enemy_Y_Speed,x
00AE41  2  60                 rts
00AE42  2               
00AE42  2               UnderHammerBro:
00AE42  2  BD 8A 07           lda EnemyFrameTimer,x ;check timer used by hammer bro
00AE45  2  D0 0C              bne NoUnderHammerBro  ;branch if not expired
00AE47  2  B5 1E              lda Enemy_State,x
00AE49  2  29 88              and #%10001000        ;save d7 and d3 from enemy state, nullify other bits
00AE4B  2  95 1E              sta Enemy_State,x     ;and store
00AE4D  2  20 FB AD           jsr EnemyLanding      ;modify vertical coordinate, speed and something else
00AE50  2  4C AA AD           jmp DoEnemySideCheck  ;then check for horizontal blockage and leave
00AE53  2               
00AE53  2               NoUnderHammerBro:
00AE53  2  B5 1E              lda Enemy_State,x  ;if hammer bro is not standing on anything, set d0
00AE55  2  09 01              ora #$01           ;in the enemy state to indicate jumping or falling, then leave
00AE57  2  95 1E              sta Enemy_State,x
00AE59  2  60                 rts
00AE5A  2               
00AE5A  2               ChkUnderEnemy:
00AE5A  2  A9 00              lda #$00                  ;set flag in A for save vertical coordinate
00AE5C  2  A0 15              ldy #$15                  ;set Y to check the bottom middle (8,18) of enemy object
00AE5E  2  4C 38 B0           jmp BlockBufferChk_Enemy  ;hop to it!
00AE61  2               
00AE61  2               ChkForNonSolids:
00AE61  2               .ifdef ANN
00AE61  2  C9 26               cmp #$26       ;blank metatile used for vines?
00AE63  2  F0 12               beq NSFnd
00AE65  2  C9 C2               cmp #$c2       ;regular coin?
00AE67  2  F0 0E               beq NSFnd
00AE69  2  C9 C3               cmp #$c3       ;underwater coin?
00AE6B  2  F0 0A               beq NSFnd
00AE6D  2  C9 5E               cmp #$5e       ;
00AE6F  2  F0 06               beq NSFnd
00AE71  2  C9 5F               cmp #$5f       ;hidden coin block?
00AE73  2  F0 02               beq NSFnd
00AE75  2  C9 60               cmp #$60       ;hidden 1-up block?
00AE77  2               .else
00AE77  2                      cmp #$23       ;blank metatile used for vines?
00AE77  2                      beq NSFnd
00AE77  2                      cmp #$c3       ;regular coin?
00AE77  2                      beq NSFnd
00AE77  2                      cmp #$c4       ;underwater coin?
00AE77  2                      beq NSFnd
00AE77  2                      cmp #$5e       ;hidden coin block?
00AE77  2                      beq NSFnd
00AE77  2                      cmp #$5f       ;hidden 1-up block?
00AE77  2                      beq NSFnd
00AE77  2                      cmp #$60       ;hidden poison shroom block?
00AE77  2                      beq NSFnd
00AE77  2                      cmp #$61       ;hidden power-up block?
00AE77  2               .endif
00AE77  2  60           NSFnd: rts
00AE78  2               
00AE78  2               ;-------------------------------------------------------------------------------------
00AE78  2               
00AE78  2               FireballBGCollision:
00AE78  2  B5 D5              lda Fireball_Y_Position,x   ;check fireball's vertical coordinate
00AE7A  2  C9 18              cmp #$18
00AE7C  2  90 21              bcc ClearBounceFlag         ;if within the status bar area of the screen, branch ahead
00AE7E  2  20 4C B0           jsr BlockBufferChk_FBall    ;do fireball to background collision detection on bottom of it
00AE81  2  F0 1C              beq ClearBounceFlag         ;if nothing underneath fireball, branch
00AE83  2  20 61 AE           jsr ChkForNonSolids         ;check for non-solid metatiles
00AE86  2  F0 17              beq ClearBounceFlag         ;branch if any found
00AE88  2  B5 A6              lda Fireball_Y_Speed,x      ;if fireball's vertical speed set to move upwards,
00AE8A  2  30 18              bmi InitFireballExplode     ;branch to set exploding bit in fireball's state
00AE8C  2  B5 3A              lda FireballBouncingFlag,x  ;if bouncing flag already set,
00AE8E  2  D0 14              bne InitFireballExplode     ;branch to set exploding bit in fireball's state
00AE90  2  A9 FD              lda #$fd
00AE92  2  95 A6              sta Fireball_Y_Speed,x      ;otherwise set vertical speed to move upwards (give it bounce)
00AE94  2  A9 01              lda #$01
00AE96  2  95 3A              sta FireballBouncingFlag,x  ;set bouncing flag
00AE98  2  B5 D5              lda Fireball_Y_Position,x
00AE9A  2  29 F8              and #$f8                    ;modify vertical coordinate to land it properly
00AE9C  2  95 D5              sta Fireball_Y_Position,x   ;store as new vertical coordinate
00AE9E  2  60                 rts                         ;leave
00AE9F  2               
00AE9F  2               ClearBounceFlag:
00AE9F  2  A9 00              lda #$00
00AEA1  2  95 3A              sta FireballBouncingFlag,x  ;clear bouncing flag by default
00AEA3  2  60                 rts                         ;leave
00AEA4  2               
00AEA4  2               InitFireballExplode:
00AEA4  2  A9 80              lda #$80
00AEA6  2  95 24              sta Fireball_State,x        ;set exploding flag in fireball's state
00AEA8  2  A9 02              lda #Sfx_Bump
00AEAA  2  85 FF              sta Square1SoundQueue       ;load bump sound
00AEAC  2  60                 rts                         ;leave
00AEAD  2               
00AEAD  2               ;-------------------------------------------------------------------------------------
00AEAD  2               ;$00 - used to hold one of bitmasks, or offset
00AEAD  2               ;$01 - used for relative X coordinate, also used to store middle screen page location
00AEAD  2               ;$02 - used for relative Y coordinate, also used to store middle screen coordinate
00AEAD  2               
00AEAD  2               ;this data added to relative coordinates of sprite objects
00AEAD  2               ;stored in order: left edge, top edge, right edge, bottom edge
00AEAD  2               BoundBoxCtrlData:
00AEAD  2  02 08 0E 20        .byte $02, $08, $0e, $20
00AEB1  2  03 14 0D 20        .byte $03, $14, $0d, $20
00AEB5  2  02 14 0E 20        .byte $02, $14, $0e, $20
00AEB9  2  02 09 0E 15        .byte $02, $09, $0e, $15
00AEBD  2  00 00 18 06        .byte $00, $00, $18, $06
00AEC1  2  00 00 20 0D        .byte $00, $00, $20, $0d
00AEC5  2  00 00 30 0D        .byte $00, $00, $30, $0d
00AEC9  2  00 00 08 08        .byte $00, $00, $08, $08
00AECD  2  06 04 0A 08        .byte $06, $04, $0a, $08
00AED1  2  03 0E 0D 16        .byte $03, $0e, $0d, $16
00AED5  2  00 02 10 15        .byte $00, $02, $10, $15
00AED9  2  04 04 0C 1C        .byte $04, $04, $0c, $1c
00AEDD  2               
00AEDD  2               GetFireballBoundBox:
00AEDD  2  8A                 txa         ;add seven bytes to offset
00AEDE  2  18                 clc         ;to use in routines as offset for fireball
00AEDF  2  69 07              adc #$07
00AEE1  2  AA                 tax
00AEE2  2  A0 02              ldy #$02    ;set offset for relative coordinates
00AEE4  2  D0 07              bne FBallB  ;unconditional branch
00AEE6  2               
00AEE6  2               GetMiscBoundBox:
00AEE6  2  8A                   txa                       ;add nine bytes to offset
00AEE7  2  18                   clc                       ;to use in routines as offset for misc object
00AEE8  2  69 09                adc #$09
00AEEA  2  AA                   tax
00AEEB  2  A0 06                ldy #$06                  ;set offset for relative coordinates
00AEED  2  20 4C AF     FBallB: jsr BoundingBoxCore       ;get bounding box coordinates
00AEF0  2  4C 8E AF             jmp CheckRightScreenBBox  ;jump to handle any offscreen coordinates
00AEF3  2               
00AEF3  2               GetEnemyBoundBox:
00AEF3  2  A0 48              ldy #$48                 ;store bitmask here for now
00AEF5  2  84 00              sty $00
00AEF7  2  A0 44              ldy #$44                 ;store another bitmask here for now and jump
00AEF9  2  4C 02 AF           jmp GetMaskedOffScrBits
00AEFC  2               
00AEFC  2               SmallPlatformBoundBox:
00AEFC  2  A0 08              ldy #$08                 ;store bitmask here for now
00AEFE  2  84 00              sty $00
00AF00  2  A0 04              ldy #$04                 ;store another bitmask here for now
00AF02  2               
00AF02  2               GetMaskedOffScrBits:
00AF02  2  B5 87                lda Enemy_X_Position,x      ;get enemy object position relative
00AF04  2  38                   sec                         ;to the left side of the screen
00AF05  2  ED 1C 07             sbc ScreenLeft_X_Pos
00AF08  2  85 01                sta $01                     ;store here
00AF0A  2  B5 6E                lda Enemy_PageLoc,x         ;subtract borrow from current page location
00AF0C  2  ED 1A 07             sbc ScreenLeft_PageLoc      ;of left side
00AF0F  2  30 06                bmi CMBits                  ;if enemy object is beyond left edge, branch
00AF11  2  05 01                ora $01
00AF13  2  F0 02                beq CMBits                  ;if precisely at the left edge, branch
00AF15  2  A4 00                ldy $00                     ;if to the right of left edge, use value in $00 for A
00AF17  2  98           CMBits: tya                         ;otherwise use contents of Y
00AF18  2  2D D1 03             and Enemy_OffscreenBits     ;preserve bitwise whatever's in here
00AF1B  2  9D D8 03             sta EnemyOffscrBitsMasked,x ;save masked offscreen bits here
00AF1E  2  D0 19                bne MoveBoundBoxOffscreen   ;if anything set here, branch
00AF20  2  4C 2C AF             jmp SetupEOffsetFBBox       ;otherwise, do something else
00AF23  2               
00AF23  2               LargePlatformBoundBox:
00AF23  2  E8                 inx                        ;increment X to get the proper offset
00AF24  2  20 EB BE           jsr GetXOffscreenBits      ;then jump directly to the sub for horizontal offscreen bits
00AF27  2  CA                 dex                        ;decrement to return to original offset
00AF28  2  C9 FE              cmp #$fe                   ;if completely offscreen, branch to put entire bounding
00AF2A  2  B0 0D              bcs MoveBoundBoxOffscreen  ;box offscreen, otherwise start getting coordinates
00AF2C  2               
00AF2C  2               SetupEOffsetFBBox:
00AF2C  2  8A                 txa                        ;add 1 to offset to properly address
00AF2D  2  18                 clc                        ;the enemy object memory locations
00AF2E  2  69 01              adc #$01
00AF30  2  AA                 tax
00AF31  2  A0 01              ldy #$01                   ;load 1 as offset here, same reason
00AF33  2  20 4C AF           jsr BoundingBoxCore        ;do a sub to get the coordinates of the bounding box
00AF36  2  4C 8E AF           jmp CheckRightScreenBBox   ;jump to handle offscreen coordinates of bounding box
00AF39  2               
00AF39  2               MoveBoundBoxOffscreen:
00AF39  2  8A                 txa                            ;multiply offset by 4
00AF3A  2  0A                 asl
00AF3B  2  0A                 asl
00AF3C  2  A8                 tay                            ;use as offset here
00AF3D  2  A9 FF              lda #$ff
00AF3F  2  99 B0 04           sta EnemyBoundingBoxCoord,y    ;load value into four locations here and leave
00AF42  2  99 B1 04           sta EnemyBoundingBoxCoord+1,y
00AF45  2  99 B2 04           sta EnemyBoundingBoxCoord+2,y
00AF48  2  99 B3 04           sta EnemyBoundingBoxCoord+3,y
00AF4B  2  60                 rts
00AF4C  2               
00AF4C  2               BoundingBoxCore:
00AF4C  2  86 00              stx $00                     ;save offset here
00AF4E  2  B9 B8 03           lda SprObject_Rel_YPos,y    ;store object coordinates relative to screen
00AF51  2  85 02              sta $02                     ;vertically and horizontally, respectively
00AF53  2  B9 AD 03           lda SprObject_Rel_XPos,y
00AF56  2  85 01              sta $01
00AF58  2  8A                 txa                         ;multiply offset by four and save to stack
00AF59  2  0A                 asl
00AF5A  2  0A                 asl
00AF5B  2  48                 pha
00AF5C  2  A8                 tay                         ;use as offset for Y, X is left alone
00AF5D  2  BD 99 04           lda SprObj_BoundBoxCtrl,x   ;load value here to be used as offset for X
00AF60  2  0A                 asl                         ;multiply that by four and use as X
00AF61  2  0A                 asl
00AF62  2  AA                 tax
00AF63  2  A5 01              lda $01                     ;add the first number in the bounding box data to the
00AF65  2  18                 clc                         ;relative horizontal coordinate using enemy object offset
00AF66  2  7D AD AE           adc BoundBoxCtrlData,x      ;and store somewhere using same offset * 4
00AF69  2  99 AC 04           sta BoundingBox_UL_Corner,y ;store here
00AF6C  2  A5 01              lda $01
00AF6E  2  18                 clc
00AF6F  2  7D AF AE           adc BoundBoxCtrlData+2,x    ;add the third number in the bounding box data to the
00AF72  2  99 AE 04           sta BoundingBox_LR_Corner,y ;relative horizontal coordinate and store
00AF75  2  E8                 inx                         ;increment both offsets
00AF76  2  C8                 iny
00AF77  2  A5 02              lda $02                     ;add the second number to the relative vertical coordinate
00AF79  2  18                 clc                         ;using incremented offset and store using the other
00AF7A  2  7D AD AE           adc BoundBoxCtrlData,x      ;incremented offset
00AF7D  2  99 AC 04           sta BoundingBox_UL_Corner,y
00AF80  2  A5 02              lda $02
00AF82  2  18                 clc
00AF83  2  7D AF AE           adc BoundBoxCtrlData+2,x    ;add the fourth number to the relative vertical coordinate
00AF86  2  99 AE 04           sta BoundingBox_LR_Corner,y ;and store
00AF89  2  68                 pla                         ;get original offset loaded into $00 * y from stack
00AF8A  2  A8                 tay                         ;use as Y
00AF8B  2  A6 00              ldx $00                     ;get original offset and use as X again
00AF8D  2  60                 rts
00AF8E  2               
00AF8E  2               CheckRightScreenBBox:
00AF8E  2  AD 1C 07            lda ScreenLeft_X_Pos       ;add 128 pixels to left side of screen
00AF91  2  18                  clc                        ;and store as horizontal coordinate of middle
00AF92  2  69 80               adc #$80
00AF94  2  85 02               sta $02
00AF96  2  AD 1A 07            lda ScreenLeft_PageLoc     ;add carry to page location of left side of screen
00AF99  2  69 00               adc #$00                   ;and store as page location of middle
00AF9B  2  85 01               sta $01
00AF9D  2  B5 86               lda SprObject_X_Position,x ;get horizontal coordinate
00AF9F  2  C5 02               cmp $02                    ;compare against middle horizontal coordinate
00AFA1  2  B5 6D               lda SprObject_PageLoc,x    ;get page location
00AFA3  2  E5 01               sbc $01                    ;subtract from middle page location
00AFA5  2  90 15               bcc CheckLeftScreenBBox    ;if object is on the left side of the screen, branch
00AFA7  2  B9 AE 04            lda BoundingBox_DR_XPos,y  ;check right-side edge of bounding box for offscreen
00AFAA  2  30 0D               bmi NoOfs                  ;coordinates, branch if still on the screen
00AFAC  2  A9 FF               lda #$ff                   ;load offscreen value here to use on one or both horizontal sides
00AFAE  2  BE AC 04            ldx BoundingBox_UL_XPos,y  ;check left-side edge of bounding box for offscreen
00AFB1  2  30 03               bmi SORte                  ;coordinates, and branch if still on the screen
00AFB3  2  99 AC 04            sta BoundingBox_UL_XPos,y  ;store offscreen value for left side
00AFB6  2  99 AE 04     SORte: sta BoundingBox_DR_XPos,y  ;store offscreen value for right side
00AFB9  2  A6 08        NoOfs: ldx ObjectOffset           ;get object offset and leave
00AFBB  2  60                  rts
00AFBC  2               
00AFBC  2               CheckLeftScreenBBox:
00AFBC  2  B9 AC 04             lda BoundingBox_UL_XPos,y  ;check left-side edge of bounding box for offscreen
00AFBF  2  10 11                bpl NoOfs2                 ;coordinates, and branch if still on the screen
00AFC1  2  C9 A0                cmp #$a0                   ;check to see if left-side edge is in the middle of the
00AFC3  2  90 0D                bcc NoOfs2                 ;screen or really offscreen, and branch if still on
00AFC5  2  A9 00                lda #$00
00AFC7  2  BE AE 04             ldx BoundingBox_DR_XPos,y  ;check right-side edge of bounding box for offscreen
00AFCA  2  10 03                bpl SOLft                  ;coordinates, branch if still onscreen
00AFCC  2  99 AE 04             sta BoundingBox_DR_XPos,y  ;store offscreen value for right side
00AFCF  2  99 AC 04     SOLft:  sta BoundingBox_UL_XPos,y  ;store offscreen value for left side
00AFD2  2  A6 08        NoOfs2: ldx ObjectOffset           ;get object offset and leave
00AFD4  2  60                   rts
00AFD5  2               
00AFD5  2               ;-------------------------------------------------------------------------------------
00AFD5  2               ;$06 - second object's offset
00AFD5  2               ;$07 - counter
00AFD5  2               
00AFD5  2               PlayerCollisionCore:
00AFD5  2  A2 00              ldx #$00     ;initialize X to use player's bounding box for comparison
00AFD7  2               
00AFD7  2               SprObjectCollisionCore:
00AFD7  2  84 06              sty $06      ;save contents of Y here
00AFD9  2  A9 01              lda #$01
00AFDB  2  85 07              sta $07      ;save value 1 here as counter, compare horizontal coordinates first
00AFDD  2               
00AFDD  2               CollisionCoreLoop:
00AFDD  2  B9 AC 04           lda BoundingBox_UL_Corner,y  ;compare left/top coordinates
00AFE0  2  DD AC 04           cmp BoundingBox_UL_Corner,x  ;of first and second objects' bounding boxes
00AFE3  2  B0 2A              bcs FirstBoxGreater          ;if first left/top => second, branch
00AFE5  2  DD AE 04           cmp BoundingBox_LR_Corner,x  ;otherwise compare to right/bottom of second
00AFE8  2  90 12              bcc SecondBoxVerticalChk     ;if first left/top < second right/bottom, branch elsewhere
00AFEA  2  F0 42              beq CollisionFound           ;if somehow equal, collision, thus branch
00AFEC  2  B9 AE 04           lda BoundingBox_LR_Corner,y  ;if somehow greater, check to see if bottom of
00AFEF  2  D9 AC 04           cmp BoundingBox_UL_Corner,y  ;first object's bounding box is greater than its top
00AFF2  2  90 3A              bcc CollisionFound           ;if somehow less, vertical wrap collision, thus branch
00AFF4  2  DD AC 04           cmp BoundingBox_UL_Corner,x  ;otherwise compare bottom of first bounding box to the top
00AFF7  2  B0 35              bcs CollisionFound           ;of second box, and if equal or greater, collision, thus branch
00AFF9  2  A4 06              ldy $06                      ;otherwise return with carry clear and Y = $0006
00AFFB  2  60                 rts                          ;note horizontal wrapping never occurs
00AFFC  2               
00AFFC  2               SecondBoxVerticalChk:
00AFFC  2  BD AE 04           lda BoundingBox_LR_Corner,x  ;check to see if the vertical bottom of the box
00AFFF  2  DD AC 04           cmp BoundingBox_UL_Corner,x  ;is greater than the vertical top
00B002  2  90 2A              bcc CollisionFound           ;if somehow less, vertical wrap collision, thus branch
00B004  2  B9 AE 04           lda BoundingBox_LR_Corner,y  ;otherwise compare horizontal right or vertical bottom
00B007  2  DD AC 04           cmp BoundingBox_UL_Corner,x  ;of first box with horizontal left or vertical top of second box
00B00A  2  B0 22              bcs CollisionFound           ;if equal or greater, collision, thus branch
00B00C  2  A4 06              ldy $06                      ;otherwise return with carry clear and Y = $0006
00B00E  2  60                 rts
00B00F  2               
00B00F  2               FirstBoxGreater:
00B00F  2  DD AC 04           cmp BoundingBox_UL_Corner,x  ;compare first and second box horizontal left/vertical top again
00B012  2  F0 1A              beq CollisionFound           ;if first coordinate = second, collision, thus branch
00B014  2  DD AE 04           cmp BoundingBox_LR_Corner,x  ;if not, compare with second object right or bottom edge
00B017  2  90 15              bcc CollisionFound           ;if left/top of first less than or equal to right/bottom of second
00B019  2  F0 13              beq CollisionFound           ;then collision, thus branch
00B01B  2  D9 AE 04           cmp BoundingBox_LR_Corner,y  ;otherwise check to see if top of first box is greater than bottom
00B01E  2  90 0A              bcc NoCollisionFound         ;if less than or equal, no collision, branch to end
00B020  2  F0 08              beq NoCollisionFound
00B022  2  B9 AE 04           lda BoundingBox_LR_Corner,y  ;otherwise compare bottom of first to top of second
00B025  2  DD AC 04           cmp BoundingBox_UL_Corner,x  ;if bottom of first is greater than top of second, vertical wrap
00B028  2  B0 04              bcs CollisionFound           ;collision, and branch, otherwise, proceed onwards here
00B02A  2               
00B02A  2               NoCollisionFound:
00B02A  2  18                 clc          ;clear carry, then load value set earlier, then leave
00B02B  2  A4 06              ldy $06      ;like previous ones, if horizontal coordinates do not collide, we do
00B02D  2  60                 rts          ;not bother checking vertical ones, because what's the point?
00B02E  2               
00B02E  2               CollisionFound:
00B02E  2  E8                 inx                    ;increment offsets on both objects to check
00B02F  2  C8                 iny                    ;the vertical coordinates
00B030  2  C6 07              dec $07                ;decrement counter to reflect this
00B032  2  10 A9              bpl CollisionCoreLoop  ;if counter not expired, branch to loop
00B034  2  38                 sec                    ;otherwise we already did both sets, therefore collision, so set carry
00B035  2  A4 06              ldy $06                ;load original value set here earlier, then leave
00B037  2  60                 rts
00B038  2               
00B038  2               ;-------------------------------------------------------------------------------------
00B038  2               ;$02 - modified y coordinate
00B038  2               ;$03 - stores metatile involved in block buffer collisions
00B038  2               ;$04 - comes in with offset to block buffer adder data, goes out with low nybble x/y coordinate
00B038  2               ;$05 - modified x coordinate
00B038  2               ;$06-$07 - block buffer address
00B038  2               
00B038  2               BlockBufferChk_Enemy:
00B038  2  48                 pha        ;save contents of A to stack
00B039  2  8A                 txa
00B03A  2  18                 clc        ;add 1 to X to run sub with enemy offset in mind
00B03B  2  69 01              adc #$01
00B03D  2  AA                 tax
00B03E  2  68                 pla        ;pull A from stack and jump elsewhere
00B03F  2  4C 55 B0           jmp BBChk_E
00B042  2               
00B042  2               ResidualMiscObjectCode:
00B042  2  8A                 txa
00B043  2  18                 clc           ;supposedly used once to set offset for
00B044  2  69 0D              adc #$0d      ;miscellaneous objects
00B046  2  AA                 tax
00B047  2  A0 1B              ldy #$1b      ;supposedly used once to set offset for block buffer data
00B049  2  4C 53 B0           jmp ResJmpM   ;probably used in early stages to do misc to bg collision detection
00B04C  2               
00B04C  2               BlockBufferChk_FBall:
00B04C  2  A0 1A                 ldy #$1a                  ;set offset for block buffer adder data
00B04E  2  8A                    txa
00B04F  2  18                    clc
00B050  2  69 07                 adc #$07                  ;add seven bytes to use
00B052  2  AA                    tax
00B053  2  A9 00        ResJmpM: lda #$00                  ;set A to return vertical coordinate
00B055  2  20 A0 B0     BBChk_E: jsr BlockBufferCollision  ;do collision detection subroutine for sprite object
00B058  2  A6 08                 ldx ObjectOffset          ;get object offset
00B05A  2  C9 00                 cmp #$00                  ;check to see if object bumped into anything
00B05C  2  60                    rts
00B05D  2               
00B05D  2               BlockBufferAdderData:
00B05D  2  00 07 0E           .byte $00, $07, $0e
00B060  2               
00B060  2               BlockBuffer_X_Adder:
00B060  2  08 03 0C 02        .byte $08, $03, $0c, $02, $02, $0d, $0d, $08
00B064  2  02 0D 0D 08  
00B068  2  03 0C 02 02        .byte $03, $0c, $02, $02, $0d, $0d, $08, $03
00B06C  2  0D 0D 08 03  
00B070  2  0C 02 02 0D        .byte $0c, $02, $02, $0d, $0d, $08, $00, $10
00B074  2  0D 08 00 10  
00B078  2  04 14 04 04        .byte $04, $14, $04, $04
00B07C  2               
00B07C  2               BlockBuffer_Y_Adder:
00B07C  2  04 20 20 08        .byte $04, $20, $20, $08, $18, $08, $18, $02
00B080  2  18 08 18 02  
00B084  2  20 20 08 18        .byte $20, $20, $08, $18, $08, $18, $12, $20
00B088  2  08 18 12 20  
00B08C  2  20 18 18 18        .byte $20, $18, $18, $18, $18, $18, $14, $14
00B090  2  18 18 14 14  
00B094  2  06 06 08 10        .byte $06, $06, $08, $10
00B098  2               
00B098  2               BlockBufferColli_Feet:
00B098  2  C8                  iny            ;if branched here, increment to next set of adders
00B099  2               
00B099  2               BlockBufferColli_Head:
00B099  2  A9 00               lda #$00       ;set flag to return vertical coordinate
00B09B  2  2C                  .byte $2c        ;BIT instruction opcode
00B09C  2               
00B09C  2               BlockBufferColli_Side:
00B09C  2  A9 01               lda #$01       ;set flag to return horizontal coordinate
00B09E  2  A2 00               ldx #$00       ;set offset for player object
00B0A0  2               
00B0A0  2               BlockBufferCollision:
00B0A0  2  48                  pha                         ;save contents of A to stack
00B0A1  2  84 04               sty $04                     ;save contents of Y here
00B0A3  2  B9 60 B0            lda BlockBuffer_X_Adder,y   ;add horizontal coordinate
00B0A6  2  18                  clc                         ;of object to value obtained using Y as offset
00B0A7  2  75 86               adc SprObject_X_Position,x
00B0A9  2  85 05               sta $05                     ;store here
00B0AB  2  B5 6D               lda SprObject_PageLoc,x
00B0AD  2  69 00               adc #$00                    ;add carry to page location
00B0AF  2  29 01               and #$01                    ;get LSB, mask out all other bits
00B0B1  2  4A                  lsr                         ;move to carry
00B0B2  2  05 05               ora $05                     ;get stored value
00B0B4  2  6A                  ror                         ;rotate carry to MSB of A
00B0B5  2  4A                  lsr                         ;and effectively move high nybble to
00B0B6  2  4A                  lsr                         ;lower, LSB which became MSB will be
00B0B7  2  4A                  lsr                         ;d4 at this point
00B0B8  2  20 92 7A            jsr GetBlockBufferAddr      ;get address of block buffer into $06, $07
00B0BB  2  A4 04               ldy $04                     ;get old contents of Y
00B0BD  2  B5 CE               lda SprObject_Y_Position,x  ;get vertical coordinate of object
00B0BF  2  18                  clc
00B0C0  2  79 7C B0            adc BlockBuffer_Y_Adder,y   ;add it to value obtained using Y as offset
00B0C3  2  29 F0               and #%11110000              ;mask out low nybble
00B0C5  2  38                  sec
00B0C6  2  E9 20               sbc #$20                    ;subtract 32 pixels for the status bar
00B0C8  2  85 02               sta $02                     ;store result here
00B0CA  2  A8                  tay                         ;use as offset for block buffer
00B0CB  2  B1 06               lda ($06),y                 ;check current content of block buffer
00B0CD  2  85 03               sta $03                     ;and store here
00B0CF  2  A4 04               ldy $04                     ;get old contents of Y again
00B0D1  2  68                  pla                         ;pull A from stack
00B0D2  2  D0 05               bne RetXC                   ;if A = 1, branch
00B0D4  2  B5 CE               lda SprObject_Y_Position,x  ;if A = 0, load vertical coordinate
00B0D6  2  4C DB B0            jmp RetYC                   ;and jump
00B0D9  2  B5 86        RetXC: lda SprObject_X_Position,x  ;otherwise load horizontal coordinate
00B0DB  2  29 0F        RetYC: and #%00001111              ;and mask out high nybble
00B0DD  2  85 04               sta $04                     ;store masked out result here
00B0DF  2  A5 03               lda $03                     ;get saved content of block buffer
00B0E1  2  60                  rts                         ;and leave
00B0E2  2               
00B0E2  2               ;-------------------------------------------------------------------------------------
00B0E2  2               
00B0E2  2               .ifndef ANN
00B0E2  2               ;unused bytes
00B0E2  2                     .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff
00B0E2  2               .endif
00B0E2  2               
00B0E2  2               ;-------------------------------------------------------------------------------------
00B0E2  2               ;$00 - offset to vine Y coordinate adder
00B0E2  2               ;$02 - offset to sprite data
00B0E2  2               
00B0E2  2               VineYPosAdder:
00B0E2  2  00 30              .byte $00, $30
00B0E4  2               
00B0E4  2               DrawVine:
00B0E4  2  84 00                 sty $00                    ;save offset here
00B0E6  2  AD B9 03              lda Enemy_Rel_YPos         ;get relative vertical coordinate
00B0E9  2  18                    clc
00B0EA  2  79 E2 B0              adc VineYPosAdder,y        ;add value using offset in Y to get value
00B0ED  2  BE 9A 03              ldx VineObjOffset,y        ;get offset to vine
00B0F0  2  BC E5 06              ldy Enemy_SprDataOffset,x  ;get sprite data offset
00B0F3  2  84 02                 sty $02                    ;store sprite data offset here
00B0F5  2  20 5D B1              jsr SixSpriteStacker       ;stack six sprites on top of each other vertically
00B0F8  2  AD AE 03              lda Enemy_Rel_XPos         ;get relative horizontal coordinate
00B0FB  2  99 03 02              sta Sprite_X_Position,y    ;store in first, third and fifth sprites
00B0FE  2  99 0B 02              sta Sprite_X_Position+8,y
00B101  2  99 13 02              sta Sprite_X_Position+16,y
00B104  2  18                    clc
00B105  2  69 06                 adc #$06                   ;add six pixels to second, fourth and sixth sprites
00B107  2  99 07 02              sta Sprite_X_Position+4,y  ;to give characteristic staggered vine shape to
00B10A  2  99 0F 02              sta Sprite_X_Position+12,y ;our vertical stack of sprites
00B10D  2  99 17 02              sta Sprite_X_Position+20,y
00B110  2  A9 21                 lda #%00100001             ;set bg priority and palette attribute bits
00B112  2  99 02 02              sta Sprite_Attributes,y    ;set in first, third and fifth sprites
00B115  2  99 0A 02              sta Sprite_Attributes+8,y
00B118  2  99 12 02              sta Sprite_Attributes+16,y
00B11B  2  09 40                 ora #%01000000             ;additionally, set horizontal flip bit
00B11D  2  99 06 02              sta Sprite_Attributes+4,y  ;for second, fourth and sixth sprites
00B120  2  99 0E 02              sta Sprite_Attributes+12,y
00B123  2  99 16 02              sta Sprite_Attributes+20,y
00B126  2  A2 05                 ldx #$05                   ;set tiles for six sprites
00B128  2  A9 E1        VineTL:  lda #$e1                   ;set tile number for sprite
00B12A  2  99 01 02              sta Sprite_Tilenumber,y
00B12D  2  C8                    iny                        ;move offset to next sprite data
00B12E  2  C8                    iny
00B12F  2  C8                    iny
00B130  2  C8                    iny
00B131  2  CA                    dex                        ;move onto next sprite
00B132  2  10 F4                 bpl VineTL                 ;loop until all sprites are done
00B134  2  A4 02                 ldy $02                    ;get original offset
00B136  2  A5 00                 lda $00                    ;get offset to vine adding data
00B138  2  D0 05                 bne SkpVTop                ;if offset not zero, skip this part
00B13A  2  A9 E0                 lda #$e0
00B13C  2  99 01 02              sta Sprite_Tilenumber,y    ;set other tile number for top of vine
00B13F  2  A2 00        SkpVTop: ldx #$00                   ;start with the first sprite again
00B141  2  AD 9D 03     ChkFTop: lda VineStart_Y_Position   ;get original starting vertical coordinate
00B144  2  38                    sec
00B145  2  F9 00 02              sbc Sprite_Y_Position,y    ;subtract top-most sprite's Y coordinate
00B148  2  C9 64                 cmp #$64                   ;if two coordinates are less than 100/$64 pixels
00B14A  2  90 05                 bcc NextVSp                ;apart, skip this to leave sprite alone
00B14C  2  A9 F8                 lda #$f8
00B14E  2  99 00 02              sta Sprite_Y_Position,y    ;otherwise move sprite offscreen
00B151  2  C8           NextVSp: iny                        ;move offset to next OAM data
00B152  2  C8                    iny
00B153  2  C8                    iny
00B154  2  C8                    iny
00B155  2  E8                    inx                        ;move onto next sprite
00B156  2  E0 06                 cpx #$06                   ;do this until all sprites are checked
00B158  2  D0 E7                 bne ChkFTop
00B15A  2  A4 00                 ldy $00                    ;return offset set earlier
00B15C  2  60                    rts
00B15D  2               
00B15D  2               SixSpriteStacker:
00B15D  2  A2 06               ldx #$06           ;do six sprites
00B15F  2  99 00 02     StkLp: sta Sprite_Data,y  ;store X or Y coordinate into OAM data
00B162  2  18                  clc
00B163  2  69 08               adc #$08           ;add eight pixels
00B165  2  C8                  iny
00B166  2  C8                  iny                ;move offset four bytes forward
00B167  2  C8                  iny
00B168  2  C8                  iny
00B169  2  CA                  dex                ;do another sprite
00B16A  2  D0 F3               bne StkLp          ;do this until all sprites are done
00B16C  2  A4 02               ldy $02            ;get saved OAM data offset and leave
00B16E  2  60                  rts
00B16F  2               
00B16F  2               ;-------------------------------------------------------------------------------------
00B16F  2               
00B16F  2               FirstSprXPos:
00B16F  2  04 00 04 00        .byte $04, $00, $04, $00
00B173  2               
00B173  2               FirstSprYPos:
00B173  2  00 04 00 04        .byte $00, $04, $00, $04
00B177  2               
00B177  2               SecondSprXPos:
00B177  2  00 08 00 08        .byte $00, $08, $00, $08
00B17B  2               
00B17B  2               SecondSprYPos:
00B17B  2  08 00 08 00        .byte $08, $00, $08, $00
00B17F  2               
00B17F  2               FirstSprTilenum:
00B17F  2  80 82 81 83        .byte $80, $82, $81, $83
00B183  2               
00B183  2               SecondSprTilenum:
00B183  2  81 83 80 82        .byte $81, $83, $80, $82
00B187  2               
00B187  2               HammerSprAttrib:
00B187  2  03 03 C3 C3        .byte $03, $03, $c3, $c3
00B18B  2               
00B18B  2               DrawHammer:
00B18B  2  BC F3 06                 ldy Misc_SprDataOffset,x    ;get misc object OAM data offset
00B18E  2  AD 47 07                 lda TimerControl
00B191  2  D0 08                    bne ForceHPose              ;if master timer control set, skip this part
00B193  2  B5 2A                    lda Misc_State,x            ;otherwise get hammer's state
00B195  2  29 7F                    and #%01111111              ;mask out d7
00B197  2  C9 01                    cmp #$01                    ;check to see if set to 1 yet
00B199  2  F0 04                    beq GetHPose                ;if so, branch
00B19B  2  A2 00        ForceHPose: ldx #$00                    ;reset offset here
00B19D  2  F0 07                    beq RenderH                 ;do unconditional branch to rendering part
00B19F  2  A5 09        GetHPose:   lda FrameCounter            ;get frame counter
00B1A1  2  4A                       lsr                         ;move d3-d2 to d1-d0
00B1A2  2  4A                       lsr
00B1A3  2  29 03                    and #%00000011              ;mask out all but d1-d0 (changes every four frames)
00B1A5  2  AA                       tax                         ;use as timing offset
00B1A6  2  AD BE 03     RenderH:    lda Misc_Rel_YPos           ;get relative vertical coordinate
00B1A9  2  18                       clc
00B1AA  2  7D 73 B1                 adc FirstSprYPos,x          ;add first sprite vertical adder based on offset
00B1AD  2  99 00 02                 sta Sprite_Y_Position,y     ;store as sprite Y coordinate for first sprite
00B1B0  2  18                       clc
00B1B1  2  7D 7B B1                 adc SecondSprYPos,x         ;add second sprite vertical adder based on offset
00B1B4  2  99 04 02                 sta Sprite_Y_Position+4,y   ;store as sprite Y coordinate for second sprite
00B1B7  2  AD B3 03                 lda Misc_Rel_XPos           ;get relative horizontal coordinate
00B1BA  2  18                       clc
00B1BB  2  7D 6F B1                 adc FirstSprXPos,x          ;add first sprite horizontal adder based on offset
00B1BE  2  99 03 02                 sta Sprite_X_Position,y     ;store as sprite X coordinate for first sprite
00B1C1  2  18                       clc
00B1C2  2  7D 77 B1                 adc SecondSprXPos,x         ;add second sprite horizontal adder based on offset
00B1C5  2  99 07 02                 sta Sprite_X_Position+4,y   ;store as sprite X coordinate for second sprite
00B1C8  2  BD 7F B1                 lda FirstSprTilenum,x
00B1CB  2  99 01 02                 sta Sprite_Tilenumber,y     ;get and store tile number of first sprite
00B1CE  2  BD 83 B1                 lda SecondSprTilenum,x
00B1D1  2  99 05 02                 sta Sprite_Tilenumber+4,y   ;get and store tile number of second sprite
00B1D4  2  BD 87 B1                 lda HammerSprAttrib,x
00B1D7  2  99 02 02                 sta Sprite_Attributes,y     ;get and store attribute bytes for both
00B1DA  2  99 06 02                 sta Sprite_Attributes+4,y   ;note in this case they use the same data
00B1DD  2  A6 08                    ldx ObjectOffset            ;get misc object offset
00B1DF  2  AD D6 03                 lda Misc_OffscreenBits
00B1E2  2  29 FC                    and #%11111100              ;check offscreen bits
00B1E4  2  F0 09                    beq NoHOffscr               ;if all bits clear, leave object alone
00B1E6  2  A9 00                    lda #$00
00B1E8  2  95 2A                    sta Misc_State,x            ;otherwise nullify misc object state
00B1EA  2  A9 F8                    lda #$f8
00B1EC  2  20 72 B2                 jsr DumpTwoSpr              ;do sub to move hammer sprites offscreen
00B1EF  2  60           NoHOffscr:  rts                         ;leave
00B1F0  2               
00B1F0  2               ;-------------------------------------------------------------------------------------
00B1F0  2               ;$00-$01 - used to hold tile numbers ($01 addressed in draw floatey number part)
00B1F0  2               ;$02 - used to hold Y coordinate for floatey number
00B1F0  2               ;$03 - residual byte used for flip (but value set here affects nothing)
00B1F0  2               ;$04 - attribute byte for floatey number
00B1F0  2               ;$05 - used as X coordinate for floatey number
00B1F0  2               
00B1F0  2               FlagpoleScoreNumTiles:
00B1F0  2  F9 50              .byte $f9, $50
00B1F2  2  F7 50              .byte $f7, $50
00B1F4  2  FA FB              .byte $fa, $fb
00B1F6  2  F8 FB              .byte $f8, $fb
00B1F8  2  F6 FB              .byte $f6, $fb
00B1FA  2  FD FE              .byte $fd, $fe
00B1FC  2               
00B1FC  2               FlagpoleGfxHandler:
00B1FC  2  BC E5 06           ldy Enemy_SprDataOffset,x      ;get sprite data offset for flagpole flag
00B1FF  2  AD AE 03           lda Enemy_Rel_XPos             ;get relative horizontal coordinate
00B202  2  99 03 02           sta Sprite_X_Position,y        ;store as X coordinate for first sprite
00B205  2  18                 clc
00B206  2  69 08              adc #$08                       ;add eight pixels and store
00B208  2  99 07 02           sta Sprite_X_Position+4,y      ;as X coordinate for second and third sprites
00B20B  2  99 0B 02           sta Sprite_X_Position+8,y
00B20E  2  18                 clc
00B20F  2  69 0C              adc #$0c                       ;add twelve more pixels and
00B211  2  85 05              sta $05                        ;store here to be used later by floatey number
00B213  2  B5 CF              lda Enemy_Y_Position,x         ;get vertical coordinate
00B215  2  20 72 B2           jsr DumpTwoSpr                 ;and do sub to dump into first and second sprites
00B218  2  69 08              adc #$08                       ;add eight pixels
00B21A  2  99 08 02           sta Sprite_Y_Position+8,y      ;and store into third sprite
00B21D  2  AD 0D 01           lda FlagpoleFNum_Y_Pos         ;get vertical coordinate for floatey number
00B220  2  85 02              sta $02                        ;store it here
00B222  2  A9 01              lda #$01
00B224  2  85 03              sta $03                        ;set value for flip which will not be used, and
00B226  2  85 04              sta $04                        ;attribute byte for floatey number
00B228  2  99 02 02           sta Sprite_Attributes,y        ;set attribute bytes for all three sprites
00B22B  2  99 06 02           sta Sprite_Attributes+4,y
00B22E  2  99 0A 02           sta Sprite_Attributes+8,y
00B231  2  A9 7E              lda #$7e
00B233  2  99 01 02           sta Sprite_Tilenumber,y        ;put triangle shaped tile
00B236  2  99 09 02           sta Sprite_Tilenumber+8,y      ;into first and third sprites
00B239  2  A9 7F              lda #$7f
00B23B  2  99 05 02           sta Sprite_Tilenumber+4,y      ;put skull tile into second sprite
00B23E  2  AD 0F 07           lda FlagpoleCollisionYPos      ;get vertical coordinate at time of collision
00B241  2  F0 15              beq ChkFlagOffscreen           ;if zero, branch ahead
00B243  2  98                 tya
00B244  2  18                 clc                            ;add 12 bytes to sprite data offset
00B245  2  69 0C              adc #$0c
00B247  2  A8                 tay                            ;put back in Y
00B248  2  AD 0F 01           lda FlagpoleScore              ;get offset used to award points for touching flagpole
00B24B  2  0A                 asl                            ;multiply by 2 to get proper offset here
00B24C  2  AA                 tax
00B24D  2  BD F0 B1           lda FlagpoleScoreNumTiles,x    ;get appropriate tile data
00B250  2  85 00              sta $00
00B252  2  BD F1 B1           lda FlagpoleScoreNumTiles+1,x
00B255  2  20 9D B8           jsr DrawOneSpriteRow           ;use it to render floatey number
00B258  2               
00B258  2               ChkFlagOffscreen:
00B258  2  A6 08              ldx ObjectOffset               ;get object offset for flag
00B25A  2  BC E5 06           ldy Enemy_SprDataOffset,x      ;get OAM data offset
00B25D  2  AD D1 03           lda Enemy_OffscreenBits        ;get offscreen bits
00B260  2  29 0E              and #%00001110                 ;mask out all but d3-d1
00B262  2  F0 14              beq ExitDumpSpr                ;if none of these bits set, branch to leave
00B264  2               
00B264  2               ;-------------------------------------------------------------------------------------
00B264  2               
00B264  2               MoveSixSpritesOffscreen:
00B264  2  A9 F8              lda #$f8                  ;set offscreen coordinate if jumping here
00B266  2               
00B266  2               DumpSixSpr:
00B266  2  99 14 02           sta Sprite_Data+20,y      ;dump A contents
00B269  2  99 10 02           sta Sprite_Data+16,y      ;into third row sprites
00B26C  2               
00B26C  2               DumpFourSpr:
00B26C  2  99 0C 02           sta Sprite_Data+12,y      ;into second row sprites
00B26F  2               
00B26F  2               DumpThreeSpr:
00B26F  2  99 08 02           sta Sprite_Data+8,y
00B272  2               
00B272  2               DumpTwoSpr:
00B272  2  99 04 02           sta Sprite_Data+4,y       ;and into first row sprites
00B275  2  99 00 02           sta Sprite_Data,y
00B278  2               
00B278  2               ExitDumpSpr:
00B278  2  60                 rts
00B279  2               
00B279  2               ;-------------------------------------------------------------------------------------
00B279  2               
00B279  2               DrawLargePlatform:
00B279  2  BC E5 06           ldy Enemy_SprDataOffset,x   ;get OAM data offset
00B27C  2  84 02              sty $02                     ;store here
00B27E  2  C8                 iny                         ;add 3 to it for offset
00B27F  2  C8                 iny                         ;to X coordinate
00B280  2  C8                 iny
00B281  2  AD AE 03           lda Enemy_Rel_XPos          ;get horizontal relative coordinate
00B284  2  20 5D B1           jsr SixSpriteStacker        ;store X coordinates using A as base, stack horizontally
00B287  2  A6 08              ldx ObjectOffset
00B289  2  B5 CF              lda Enemy_Y_Position,x      ;get vertical coordinate
00B28B  2  20 6C B2           jsr DumpFourSpr             ;dump into first four sprites as Y coordinate
00B28E  2  AC 4E 07           ldy AreaType
00B291  2  C0 03              cpy #$03                    ;check for castle-type level
00B293  2  F0 05              beq ShrinkPlatform
00B295  2  AC CC 06           ldy SecondaryHardMode       ;check for secondary hard mode flag set
00B298  2  F0 02              beq SetLast2Platform        ;branch if not set elsewhere
00B29A  2               
00B29A  2               ShrinkPlatform:
00B29A  2  A9 F8              lda #$f8                    ;load offscreen coordinate if flag set or castle-type level
00B29C  2               
00B29C  2               SetLast2Platform:
00B29C  2  BC E5 06           ldy Enemy_SprDataOffset,x   ;get OAM data offset
00B29F  2  99 10 02           sta Sprite_Y_Position+16,y  ;store vertical coordinate or offscreen
00B2A2  2  99 14 02           sta Sprite_Y_Position+20,y  ;coordinate into last two sprites as Y coordinate
00B2A5  2  A9 5B              lda #$5b                    ;load default tile for platform (mushroom)
00B2A7  2  AE 43 07           ldx CloudTypeOverride
00B2AA  2  F0 02              beq SetPlatformTilenum      ;if cloud level override flag not set, use
00B2AC  2  A9 75              lda #$75                    ;otherwise load other tile for platform (puff)
00B2AE  2               
00B2AE  2               SetPlatformTilenum:
00B2AE  2  A6 08                ldx ObjectOffset            ;get enemy object buffer offset
00B2B0  2  C8                   iny                         ;increment Y for tile offset
00B2B1  2  20 66 B2             jsr DumpSixSpr              ;dump tile number into all six sprites
00B2B4  2  A9 02                lda #$02                    ;set palette controls
00B2B6  2  C8                   iny                         ;increment Y for sprite attributes
00B2B7  2  20 66 B2             jsr DumpSixSpr              ;dump attributes into all six sprites
00B2BA  2  E8                   inx                         ;increment X for enemy objects
00B2BB  2  20 EB BE             jsr GetXOffscreenBits       ;get offscreen bits again
00B2BE  2  CA                   dex
00B2BF  2  BC E5 06             ldy Enemy_SprDataOffset,x   ;get OAM data offset
00B2C2  2  0A                   asl                         ;rotate d7 into carry, save remaining
00B2C3  2  48                   pha                         ;bits to the stack
00B2C4  2  90 05                bcc SChk2
00B2C6  2  A9 F8                lda #$f8                    ;if d7 was set, move first sprite offscreen
00B2C8  2  99 00 02             sta Sprite_Y_Position,y
00B2CB  2  68           SChk2:  pla                         ;get bits from stack
00B2CC  2  0A                   asl                         ;rotate d6 into carry
00B2CD  2  48                   pha                         ;save to stack
00B2CE  2  90 05                bcc SChk3
00B2D0  2  A9 F8                lda #$f8                    ;if d6 was set, move second sprite offscreen
00B2D2  2  99 04 02             sta Sprite_Y_Position+4,y
00B2D5  2  68           SChk3:  pla                         ;get bits from stack
00B2D6  2  0A                   asl                         ;rotate d5 into carry
00B2D7  2  48                   pha                         ;save to stack
00B2D8  2  90 05                bcc SChk4
00B2DA  2  A9 F8                lda #$f8                    ;if d5 was set, move third sprite offscreen
00B2DC  2  99 08 02             sta Sprite_Y_Position+8,y
00B2DF  2  68           SChk4:  pla                         ;get bits from stack
00B2E0  2  0A                   asl                         ;rotate d4 into carry
00B2E1  2  48                   pha                         ;save to stack
00B2E2  2  90 05                bcc SChk5
00B2E4  2  A9 F8                lda #$f8                    ;if d4 was set, move fourth sprite offscreen
00B2E6  2  99 0C 02             sta Sprite_Y_Position+12,y
00B2E9  2  68           SChk5:  pla                         ;get bits from stack
00B2EA  2  0A                   asl                         ;rotate d3 into carry
00B2EB  2  48                   pha                         ;save to stack
00B2EC  2  90 05                bcc SChk6
00B2EE  2  A9 F8                lda #$f8                    ;if d3 was set, move fifth sprite offscreen
00B2F0  2  99 10 02             sta Sprite_Y_Position+16,y
00B2F3  2  68           SChk6:  pla                         ;get bits from stack
00B2F4  2  0A                   asl                         ;rotate d2 into carry
00B2F5  2  90 05                bcc SLChk                   ;save to stack
00B2F7  2  A9 F8                lda #$f8
00B2F9  2  99 14 02             sta Sprite_Y_Position+20,y  ;if d2 was set, move sixth sprite offscreen
00B2FC  2  AD D1 03     SLChk:  lda Enemy_OffscreenBits     ;check d7 of offscreen bits
00B2FF  2  0A                   asl                         ;and if d7 is not set, skip sub
00B300  2  90 03                bcc ExDLPl
00B302  2  20 64 B2             jsr MoveSixSpritesOffscreen ;otherwise branch to move all sprites offscreen
00B305  2  60           ExDLPl: rts
00B306  2               
00B306  2               ;-------------------------------------------------------------------------------------
00B306  2               
00B306  2               DrawFloateyNumber_Coin:
00B306  2  A5 09                  lda FrameCounter          ;get frame counter
00B308  2  4A                     lsr                       ;divide by 2
00B309  2  B0 02                  bcs NotRsNum              ;branch if d0 not set to raise number every other frame
00B30B  2  D6 DB                  dec Misc_Y_Position,x     ;otherwise, decrement vertical coordinate
00B30D  2  B5 DB        NotRsNum: lda Misc_Y_Position,x     ;get vertical coordinate
00B30F  2  20 72 B2               jsr DumpTwoSpr            ;dump into both sprites
00B312  2  AD B3 03               lda Misc_Rel_XPos         ;get relative horizontal coordinate
00B315  2  99 03 02               sta Sprite_X_Position,y   ;store as X coordinate for first sprite
00B318  2  18                     clc
00B319  2  69 08                  adc #$08                  ;add eight pixels
00B31B  2  99 07 02               sta Sprite_X_Position+4,y ;store as X coordinate for second sprite
00B31E  2  A9 02                  lda #$02
00B320  2  99 02 02               sta Sprite_Attributes,y   ;store attribute byte in both sprites
00B323  2  99 06 02               sta Sprite_Attributes+4,y
00B326  2  A9 F7                  lda #$f7
00B328  2  99 01 02               sta Sprite_Tilenumber,y   ;put tile numbers into both sprites
00B32B  2  A9 FB                  lda #$fb                  ;that resemble "200"
00B32D  2  99 05 02               sta Sprite_Tilenumber+4,y
00B330  2  4C 6E B3               jmp ExJCGfx               ;then jump to leave (why not an rts here instead?)
00B333  2               
00B333  2               JumpingCoinTiles:
00B333  2  60 61 62 63        .byte $60, $61, $62, $63
00B337  2               
00B337  2               JCoinGfxHandler:
00B337  2  BC F3 06              ldy Misc_SprDataOffset,x    ;get coin/floatey number's OAM data offset
00B33A  2  B5 2A                 lda Misc_State,x            ;get state of misc object
00B33C  2  C9 02                 cmp #$02                    ;if 2 or greater,
00B33E  2  B0 C6                 bcs DrawFloateyNumber_Coin  ;branch to draw floatey number
00B340  2  B5 DB                 lda Misc_Y_Position,x       ;store vertical coordinate as
00B342  2  99 00 02              sta Sprite_Y_Position,y     ;Y coordinate for first sprite
00B345  2  18                    clc
00B346  2  69 08                 adc #$08                    ;add eight pixels
00B348  2  99 04 02              sta Sprite_Y_Position+4,y   ;store as Y coordinate for second sprite
00B34B  2  AD B3 03              lda Misc_Rel_XPos           ;get relative horizontal coordinate
00B34E  2  99 03 02              sta Sprite_X_Position,y
00B351  2  99 07 02              sta Sprite_X_Position+4,y   ;store as X coordinate for first and second sprites
00B354  2  A5 09                 lda FrameCounter            ;get frame counter
00B356  2  4A                    lsr                         ;divide by 2 to alter every other frame
00B357  2  29 03                 and #%00000011              ;mask out d2-d1
00B359  2  AA                    tax                         ;use as graphical offset
00B35A  2  BD 33 B3              lda JumpingCoinTiles,x      ;load tile number
00B35D  2  C8                    iny                         ;increment OAM data offset to write tile numbers
00B35E  2  20 72 B2              jsr DumpTwoSpr              ;do sub to dump tile number into both sprites
00B361  2  88                    dey                         ;decrement to get old offset
00B362  2  A9 02                 lda #$02
00B364  2  99 02 02              sta Sprite_Attributes,y     ;set attribute byte in first sprite
00B367  2  A9 82                 lda #$82
00B369  2  99 06 02              sta Sprite_Attributes+4,y   ;set attribute byte with vertical flip in second sprite
00B36C  2  A6 08                 ldx ObjectOffset            ;get misc object offset
00B36E  2  60           ExJCGfx: rts                         ;leave
00B36F  2               
00B36F  2               ;-------------------------------------------------------------------------------------
00B36F  2               ;$00-$01 - used to hold tiles for drawing the power-up, $00 also used to hold power-up type
00B36F  2               ;$02 - used to hold bottom row Y position
00B36F  2               ;$03 - used to hold flip control (not used here)
00B36F  2               ;$04 - used to hold sprite attributes
00B36F  2               ;$05 - used to hold X position
00B36F  2               ;$07 - counter
00B36F  2               
00B36F  2               ;tiles arranged in top left, right, bottom left, right order
00B36F  2               PowerUpGfxTable:
00B36F  2  D8 DA DB FF        .byte $d8, $da, $db, $ff ;regular mushroom
00B373  2  D6 D6 D9 D9        .byte $d6, $d6, $d9, $d9 ;fire flower
00B377  2  8D 8D E4 E4        .byte $8d, $8d, $e4, $e4 ;star
00B37B  2  D8 DA DB FF        .byte $d8, $da, $db, $ff ;1-up mushroom
00B37F  2  D8 DA DB FF        .byte $d8, $da, $db, $ff ;poison mushroom
00B383  2               
00B383  2               PowerUpAttributes:
00B383  2  02 01 02 01        .byte $02, $01, $02, $01, $03
00B387  2  03           
00B388  2               
00B388  2               DrawPowerUp:
00B388  2  AC EA 06           ldy Enemy_SprDataOffset+5  ;get power-up's sprite data offset
00B38B  2  AD B9 03           lda Enemy_Rel_YPos         ;get relative vertical coordinate
00B38E  2  18                 clc
00B38F  2  69 08              adc #$08                   ;add eight pixels
00B391  2  85 02              sta $02                    ;store result here
00B393  2  AD AE 03           lda Enemy_Rel_XPos         ;get relative horizontal coordinate
00B396  2  85 05              sta $05                    ;store here
00B398  2  A6 39              ldx PowerUpType            ;get power-up type
00B39A  2  BD 83 B3           lda PowerUpAttributes,x    ;get attribute data for power-up type
00B39D  2  0D CA 03           ora Enemy_SprAttrib+5      ;add background priority bit if set
00B3A0  2  85 04              sta $04                    ;store attributes here
00B3A2  2  8A                 txa
00B3A3  2  48                 pha                        ;save power-up type to the stack
00B3A4  2  0A                 asl
00B3A5  2  0A                 asl                        ;multiply by four to get proper offset
00B3A6  2  AA                 tax                        ;use as X
00B3A7  2  A9 01              lda #$01
00B3A9  2  85 07              sta $07                    ;set counter here to draw two rows of sprite object
00B3AB  2  85 03              sta $03                    ;init d1 of flip control
00B3AD  2               
00B3AD  2               PUpDrawLoop:
00B3AD  2  BD 6F B3             lda PowerUpGfxTable,x      ;load left tile of power-up object
00B3B0  2  85 00                sta $00
00B3B2  2  BD 70 B3             lda PowerUpGfxTable+1,x    ;load right tile
00B3B5  2  20 9D B8             jsr DrawOneSpriteRow       ;branch to draw one row of our power-up object
00B3B8  2  C6 07                dec $07                    ;decrement counter
00B3BA  2  10 F1                bpl PUpDrawLoop            ;branch until two rows are drawn
00B3BC  2  AC EA 06             ldy Enemy_SprDataOffset+5  ;get sprite data offset again
00B3BF  2  68                   pla                        ;pull saved power-up type from the stack
00B3C0  2  F0 33                beq PUpOfs                 ;if regular mushroom, 1-up mushroom
00B3C2  2  C9 03                cmp #$03                   ;or poison mushroom, branch
00B3C4  2  F0 2F                beq PUpOfs                 ;do not change colors or flip them
00B3C6  2  C9 04                cmp #$04
00B3C8  2  F0 2B                beq PUpOfs
00B3CA  2  85 00                sta $00                    ;store power-up type here now
00B3CC  2  A5 09                lda FrameCounter           ;get frame counter
00B3CE  2  4A                   lsr                        ;divide by 2 to change colors every two frames
00B3CF  2  29 03                and #%00000011             ;mask out all but d1 and d0 (previously d2 and d1)
00B3D1  2  0D CA 03             ora Enemy_SprAttrib+5      ;add background priority bit if any set
00B3D4  2  99 02 02             sta Sprite_Attributes,y    ;set as new palette bits for top left and
00B3D7  2  99 06 02             sta Sprite_Attributes+4,y  ;top right sprites for fire flower and star
00B3DA  2  A6 00                ldx $00
00B3DC  2  CA                   dex                        ;check power-up type for fire flower
00B3DD  2  F0 06                beq FlipPUpRightSide       ;if found, skip this part
00B3DF  2  99 0A 02             sta Sprite_Attributes+8,y  ;otherwise set new palette bits for bottom left
00B3E2  2  99 0E 02             sta Sprite_Attributes+12,y ;and bottom right sprites as well for star only
00B3E5  2               
00B3E5  2               FlipPUpRightSide:
00B3E5  2  B9 06 02             lda Sprite_Attributes+4,y
00B3E8  2  09 40                ora #%01000000             ;set horizontal flip bit for top right sprite
00B3EA  2  99 06 02             sta Sprite_Attributes+4,y
00B3ED  2  B9 0E 02             lda Sprite_Attributes+12,y
00B3F0  2  09 40                ora #%01000000             ;set horizontal flip bit for bottom right sprite
00B3F2  2  99 0E 02             sta Sprite_Attributes+12,y ;note these are only done for fire flower and star power-ups
00B3F5  2  4C 4F B8     PUpOfs: jmp SprObjectOffscrChk     ;jump to check to see if power-up is offscreen at all, then leave
00B3F8  2               
00B3F8  2               
00B3F8  2               ;-------------------------------------------------------------------------------------
00B3F8  2               ;$00-$01 - used in DrawEnemyObjRow to hold sprite tile numbers
00B3F8  2               ;$02 - used to store Y position
00B3F8  2               ;$03 - used to store moving direction, used to flip enemies horizontally
00B3F8  2               ;$04 - used to store enemy's sprite attributes
00B3F8  2               ;$05 - used to store X position
00B3F8  2               ;$eb - used to hold sprite data offset
00B3F8  2               ;$ec - used to hold either altered enemy state or special value used in gfx handler as condition
00B3F8  2               ;$ed - used to hold enemy state from buffer
00B3F8  2               ;$ef - used to hold enemy code used in gfx handler (may or may not resemble Enemy_ID values)
00B3F8  2               
00B3F8  2               ;tiles arranged in top left, right, middle left, right, bottom left, right order
00B3F8  2               ;most enemies use more than one frame, thus have more than 6 tiles
00B3F8  2               EnemyGraphicsTable:
00B3F8  2  FC FC AA AB        .byte $fc, $fc, $aa, $ab, $ac, $ad ;buzzy beetle
00B3FC  2  AC AD        
00B3FE  2  FC FC AE AF        .byte $fc, $fc, $ae, $af, $b0, $b1
00B402  2  B0 B1        
00B404  2  FC A5 A6 A7        .byte $fc, $a5, $a6, $a7, $a8, $a9 ;koopa troopa
00B408  2  A8 A9        
00B40A  2  FC A0 A1 A2        .byte $fc, $a0, $a1, $a2, $a3, $a4
00B40E  2  A3 A4        
00B410  2  69 A5 6A A7        .byte $69, $a5, $6a, $a7, $a8, $a9 ;koopa paratroopa
00B414  2  A8 A9        
00B416  2  6B A0 6C A2        .byte $6b, $a0, $6c, $a2, $a3, $a4
00B41A  2  A3 A4        
00B41C  2  FC FC 96 97        .byte $fc, $fc, $96, $97, $98, $99 ;spiny
00B420  2  98 99        
00B422  2  FC FC 9A 9B        .byte $fc, $fc, $9a, $9b, $9c, $9d
00B426  2  9C 9D        
00B428  2  FC FC 8F 8E        .byte $fc, $fc, $8f, $8e, $8e, $8f ;spiny egg
00B42C  2  8E 8F        
00B42E  2  FC FC 95 94        .byte $fc, $fc, $95, $94, $94, $95
00B432  2  94 95        
00B434  2  FC FC DC DC        .byte $fc, $fc, $dc, $dc, $df, $df ;bloober
00B438  2  DF DF        
00B43A  2  DC DC DD DD        .byte $dc, $dc, $dd, $dd, $de, $de
00B43E  2  DE DE        
00B440  2  FC FC B2 B3        .byte $fc, $fc, $b2, $b3, $b4, $b5 ;cheep-cheep
00B444  2  B4 B5        
00B446  2  FC FC B6 B3        .byte $fc, $fc, $b6, $b3, $b7, $b5
00B44A  2  B7 B5        
00B44C  2  FC FC 70 71        .byte $fc, $fc, $70, $71, $72, $73 ;goomba
00B450  2  72 73        
00B452  2  FC FC 6E 6E        .byte $fc, $fc, $6e, $6e, $6f, $6f ;koopa shell (upside-down)
00B456  2  6F 6F        
00B458  2  FC FC 6D 6D        .byte $fc, $fc, $6d, $6d, $6f, $6f
00B45C  2  6F 6F        
00B45E  2  FC FC 6F 6F        .byte $fc, $fc, $6f, $6f, $6e, $6e ;koopa shell
00B462  2  6E 6E        
00B464  2  FC FC 6F 6F        .byte $fc, $fc, $6f, $6f, $6d, $6d
00B468  2  6D 6D        
00B46A  2  FC FC F4 F4        .byte $fc, $fc, $f4, $f4, $f5, $f5 ;buzzy beetle shell (upside-down)
00B46E  2  F5 F5        
00B470  2  FC FC F4 F4        .byte $fc, $fc, $f4, $f4, $f5, $f5
00B474  2  F5 F5        
00B476  2  FC FC F5 F5        .byte $fc, $fc, $f5, $f5, $f4, $f4 ;buzzy beetle
00B47A  2  F4 F4        
00B47C  2  FC FC F5 F5        .byte $fc, $fc, $f5, $f5, $f4, $f4
00B480  2  F4 F4        
00B482  2  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $ef, $ef ;defeated goomba
00B486  2  EF EF        
00B488  2  B9 B8 BB BA        .byte $b9, $b8, $bb, $ba, $bc, $bc ;lakitu
00B48C  2  BC BC        
00B48E  2  FC FC BD BD        .byte $fc, $fc, $bd, $bd, $bc, $bc
00B492  2  BC BC        
00B494  2  76 79 77 77        .byte $76, $79, $77, $77, $78, $78 ;princess/door to princess's room
00B498  2  78 78        
00B49A  2               .ifdef ANN
00B49A  2  CD 7A CE 7B        .byte $cd, $7a, $ce, $7b, $cf, $ee ;ann retainer replacement
00B49E  2  CF EE        
00B4A0  2               .else
00B4A0  2                     .byte $cd, $cd, $ce, $ce, $cf, $cf ;mushroom retainer
00B4A0  2               .endif
00B4A0  2  7D 7C D1 8C        .byte $7d, $7c, $d1, $8c, $d3, $d2 ;hammer bro
00B4A4  2  D3 D2        
00B4A6  2  7D 7C 89 88        .byte $7d, $7c, $89, $88, $8b, $8a
00B4AA  2  8B 8A        
00B4AC  2  D5 D4 E3 E2        .byte $d5, $d4, $e3, $e2, $d3, $d2
00B4B0  2  D3 D2        
00B4B2  2  D5 D4 E3 E2        .byte $d5, $d4, $e3, $e2, $8b, $8a
00B4B6  2  8B 8A        
00B4B8  2  E5 E5 E6 E6        .byte $e5, $e5, $e6, $e6, $eb, $eb ;piranha plant
00B4BC  2  EB EB        
00B4BE  2               .ifdef ANN
00B4BE  2  EC EC ED ED        .byte $ec, $ec, $ed, $ed, $eb, $eb
00B4C2  2  EB EB        
00B4C4  2               .else
00B4C4  2                     .byte $ec, $ec, $ed, $ed, $ee, $ee
00B4C4  2               .endif
00B4C4  2  FC FC D0 D0        .byte $fc, $fc, $d0, $d0, $d7, $d7 ;podoboo
00B4C8  2  D7 D7        
00B4CA  2  BF BE C1 C0        .byte $bf, $be, $c1, $c0, $c2, $fc ;bowser front
00B4CE  2  C2 FC        
00B4D0  2  C4 C3 C6 C5        .byte $c4, $c3, $c6, $c5, $c8, $c7 ;bowser rear
00B4D4  2  C8 C7        
00B4D6  2  BF BE CA C9        .byte $bf, $be, $ca, $c9, $c2, $fc ;front frame 2
00B4DA  2  C2 FC        
00B4DC  2  C4 C3 C6 C5        .byte $c4, $c3, $c6, $c5, $cc, $cb ;rear frame 2
00B4E0  2  CC CB        
00B4E2  2  FC FC E8 E7        .byte $fc, $fc, $e8, $e7, $ea, $e9 ;bullet bill
00B4E6  2  EA E9        
00B4E8  2  F2 F2 F3 F3        .byte $f2, $f2, $f3, $f3, $f2, $f2 ;jumpspring
00B4EC  2  F2 F2        
00B4EE  2  F1 F1 F1 F1        .byte $f1, $f1, $f1, $f1, $fc, $fc
00B4F2  2  FC FC        
00B4F4  2  F0 F0 FC FC        .byte $f0, $f0, $fc, $fc, $fc, $fc
00B4F8  2  FC FC        
00B4FA  2               
00B4FA  2               EnemyGfxTableOffsets:
00B4FA  2  0C 0C 00 0C        .byte $0c, $0c, $00, $0c, $c0, $a8, $54, $3c
00B4FE  2  C0 A8 54 3C  
00B502  2  EA 18 48 48        .byte $ea, $18, $48, $48, $cc, $c0, $18, $18
00B506  2  CC C0 18 18  
00B50A  2  18 90 24 FF        .byte $18, $90, $24, $ff, $48, $9c, $d2, $d8
00B50E  2  48 9C D2 D8  
00B512  2  F0 F6 FC           .byte $f0, $f6, $fc
00B515  2               
00B515  2               EnemyAttributeData:
00B515  2  01 02 03 02        .byte $01, $02, $03, $02, $22, $01, $03, $03
00B519  2  22 01 03 03  
00B51D  2  03 01 01 02        .byte $03, $01, $01, $02, $02, $21, $01, $02
00B521  2  02 21 01 02  
00B525  2  01 01 02 FF        .byte $01, $01, $02, $ff, $02, $02, $01, $01
00B529  2  02 02 01 01  
00B52D  2  02 02 02           .byte $02, $02, $02
00B530  2               
00B530  2               EnemyAnimTimingBMask:
00B530  2  08 18              .byte $08, $18
00B532  2               
00B532  2               JumpspringFrameOffsets:
00B532  2  18 19 1A 19        .byte $18, $19, $1a, $19, $18
00B536  2  18           
00B537  2               
00B537  2               EnemyGfxHandler:
00B537  2               .ifdef ANN
00B537  2  A9 00               lda #$00
00B539  2  8D 7C 07            sta ANNMushroomRetainerGfxHandler
00B53C  2  A9 02               lda #$02
00B53E  2  AC FB 07            ldy HardWorldFlag
00B541  2  F0 03               beq RedJS
00B543  2  20 rr rr            jsr HardWorldEnemyGfxHandler
00B546  2               .else
00B546  2                      lda #$02
00B546  2                      ldy WorldNumber             ;if the world number is not 2, 3 or 7
00B546  2                      cpy #$01                    ;then use regular attributes for jumpsprings
00B546  2                      beq GrnJS                   ;which will paint them red
00B546  2                      cpy #$02
00B546  2                      beq GrnJS                   ;otherwise use alternate attributes
00B546  2                      cpy #$06                    ;to get the green superhigh jumpsprings
00B546  2                      bne RedJS
00B546  2               GrnJS: lsr
00B546  2               .endif
00B546  2  8D 2D B5     RedJS: sta EnemyAttributeData+$18  ;set jumpspring gfx attributes in the lookup table
00B549  2  8D 2E B5            sta EnemyAttributeData+$19
00B54C  2  8D 2F B5            sta EnemyAttributeData+$1a
00B54F  2  B5 CF               lda Enemy_Y_Position,x      ;get enemy object vertical position
00B551  2  85 02               sta $02
00B553  2  AD AE 03            lda Enemy_Rel_XPos          ;get enemy object horizontal position
00B556  2  85 05               sta $05                     ;relative to screen
00B558  2  BC E5 06            ldy Enemy_SprDataOffset,x
00B55B  2  84 EB               sty $eb                     ;get sprite data offset
00B55D  2  A9 00               lda #$00
00B55F  2  8D 09 01            sta VerticalFlipFlag        ;initialize vertical flip flag by default
00B562  2  B5 46               lda Enemy_MovingDir,x
00B564  2  85 03               sta $03                     ;get enemy object moving direction
00B566  2  BD C5 03            lda Enemy_SprAttrib,x
00B569  2  85 04               sta $04                     ;get enemy object sprite attributes
00B56B  2  B5 16               lda Enemy_ID,x
00B56D  2  C9 0D               cmp #PiranhaPlant           ;is enemy object piranha plant?
00B56F  2  D0 0A               bne CheckForRetainerObj     ;if not, branch
00B571  2  B4 58               ldy PiranhaPlant_Y_Speed,x
00B573  2  30 06               bmi CheckForRetainerObj     ;if piranha plant moving upwards, branch
00B575  2  BC 8A 07            ldy EnemyFrameTimer,x
00B578  2  F0 01               beq CheckForRetainerObj     ;if timer for movement expired, branch
00B57A  2  60                  rts                         ;if all conditions fail, leave
00B57B  2               
00B57B  2               CheckForRetainerObj:
00B57B  2  B5 1E              lda Enemy_State,x           ;store enemy state
00B57D  2  85 ED              sta $ed
00B57F  2  29 1F              and #%00011111              ;nullify all but 5 LSB and use as Y
00B581  2  A8                 tay
00B582  2  B5 16              lda Enemy_ID,x              ;check for mushroom retainer/princess object
00B584  2  C9 35              cmp #RetainerObject
00B586  2  D0 08              bne CheckForBulletBillCV    ;if not found, branch
00B588  2  A0 00              ldy #$00                    ;if found, nullify saved state in Y
00B58A  2  A9 01              lda #$01                    ;set value that will not be used
00B58C  2  85 03              sta $03
00B58E  2  A9 15              lda #$15                    ;set value $15 as code for mushroom retainer/princess object
00B590  2               
00B590  2               CheckForBulletBillCV:
00B590  2  C9 33               cmp #BulletBill_CannonVar   ;otherwise check for bullet bill object
00B592  2  D0 13               bne CheckForJumpspring      ;if not found, branch again
00B594  2  C6 02               dec $02                     ;decrement saved vertical position
00B596  2  A9 03               lda #$03
00B598  2  BC 8A 07            ldy EnemyFrameTimer,x       ;get timer for enemy object
00B59B  2  F0 02               beq SBBAt                   ;if expired, do not set priority bit
00B59D  2  09 20               ora #%00100000              ;otherwise do so
00B59F  2  85 04        SBBAt: sta $04                     ;set new sprite attributes
00B5A1  2  A0 00               ldy #$00                    ;nullify saved enemy state both in Y and in
00B5A3  2  84 ED               sty $ed                     ;memory location here
00B5A5  2  A9 08               lda #$08                    ;set specific value to unconditionally branch once
00B5A7  2               
00B5A7  2               CheckForJumpspring:
00B5A7  2  C9 32              cmp #JumpspringObject        ;check for jumpspring object
00B5A9  2  D0 08              bne CheckForPodoboo
00B5AB  2  A0 03              ldy #$03                     ;set enemy state -2 MSB here for jumpspring object
00B5AD  2  AE 0E 07           ldx JumpspringAnimCtrl       ;get current frame number for jumpspring object
00B5B0  2  BD 32 B5           lda JumpspringFrameOffsets,x ;load data using frame number as offset
00B5B3  2               
00B5B3  2               CheckForPodoboo:
00B5B3  2  85 EF              sta $ef                 ;store saved enemy object value here
00B5B5  2  84 EC              sty $ec                 ;and Y here (enemy state -2 MSB if not changed)
00B5B7  2  A6 08              ldx ObjectOffset        ;get enemy object offset
00B5B9  2  C9 0C              cmp #$0c                ;check for podoboo object
00B5BB  2  D0 07              bne CheckBowserGfxFlag  ;branch if not found
00B5BD  2  B5 A0              lda Enemy_Y_Speed,x     ;if moving upwards, branch
00B5BF  2  30 03              bmi CheckBowserGfxFlag
00B5C1  2  EE 09 01           inc VerticalFlipFlag    ;otherwise, set flag for vertical flip
00B5C4  2               
00B5C4  2               CheckBowserGfxFlag:
00B5C4  2  AD 6A 03                  lda BowserGfxFlag   ;if not drawing bowser at all, skip to something else
00B5C7  2  F0 09                     beq CheckForGoomba
00B5C9  2  A0 16                     ldy #$16            ;if set to 1, draw bowser's front
00B5CB  2  C9 01                     cmp #$01
00B5CD  2  F0 01                     beq SBwsrGfxOfs
00B5CF  2  C8                        iny                 ;otherwise draw bowser's rear
00B5D0  2  84 EF        SBwsrGfxOfs: sty $ef
00B5D2  2               
00B5D2  2               CheckForGoomba:
00B5D2  2  A4 EF                  ldy $ef               ;check value for goomba object
00B5D4  2  C0 06                  cpy #Goomba
00B5D6  2  D0 1D                  bne CheckBowserFront  ;branch if not found
00B5D8  2  B5 1E                  lda Enemy_State,x
00B5DA  2  C9 02                  cmp #$02              ;check for defeated state
00B5DC  2  90 04                  bcc GmbaAnim          ;if not defeated, go ahead and animate
00B5DE  2  A2 04                  ldx #$04              ;if defeated, write new value here
00B5E0  2  86 EC                  stx $ec
00B5E2  2  29 20        GmbaAnim: and #%00100000        ;check for d5 set in enemy object state
00B5E4  2  0D 47 07               ora TimerControl      ;or timer disable flag set
00B5E7  2  D0 0C                  bne CheckBowserFront  ;if either condition true, do not animate goomba
00B5E9  2  A5 09                  lda FrameCounter
00B5EB  2  29 08                  and #%00001000        ;check for every eighth frame
00B5ED  2  D0 06                  bne CheckBowserFront
00B5EF  2  A5 03                  lda $03
00B5F1  2  49 03                  eor #%00000011        ;invert bits to flip horizontally every eight frames
00B5F3  2  85 03                  sta $03               ;leave alone otherwise
00B5F5  2               
00B5F5  2               CheckBowserFront:
00B5F5  2  B9 15 B5                  lda EnemyAttributeData,y    ;load sprite attribute using enemy object
00B5F8  2  05 04                     ora $04                     ;as offset, and add to bits already loaded
00B5FA  2  85 04                     sta $04
00B5FC  2  B9 FA B4                  lda EnemyGfxTableOffsets,y  ;load value based on enemy object as offset
00B5FF  2  AA                        tax                         ;save as X
00B600  2  A4 EC                     ldy $ec                     ;get previously saved value
00B602  2  AD 6A 03                  lda BowserGfxFlag
00B605  2  F0 30                     beq CheckForSpiny           ;if not drawing bowser object at all, skip all of this
00B607  2  C9 01                     cmp #$01
00B609  2  D0 13                     bne CheckBowserRear         ;if not drawing front part, branch to draw the rear part
00B60B  2  AD 63 03                  lda BowserBodyControls      ;check bowser's body control bits
00B60E  2  10 02                     bpl ChkFrontSte             ;branch if d7 not set (control's bowser's mouth)
00B610  2  A2 DE                     ldx #$de                    ;otherwise load offset for second frame
00B612  2  A5 ED        ChkFrontSte: lda $ed                     ;check saved enemy state
00B614  2  29 20                     and #%00100000              ;if bowser not defeated, do not set flag
00B616  2  F0 03                     beq DrawBowser
00B618  2               
00B618  2               FlipBowserOver:
00B618  2  8E 09 01           stx VerticalFlipFlag  ;set vertical flip flag to nonzero
00B61B  2               
00B61B  2               DrawBowser:
00B61B  2  4C 26 B7           jmp DrawEnemyObject   ;draw bowser's graphics now
00B61E  2               
00B61E  2               
00B61E  2               CheckBowserRear:
00B61E  2  AD 63 03                 lda BowserBodyControls  ;check bowser's body control bits
00B621  2  29 01                    and #$01
00B623  2  F0 02                    beq ChkRearSte          ;branch if d0 not set (control's bowser's feet)
00B625  2  A2 E4                    ldx #$e4                ;otherwise load offset for second frame
00B627  2  A5 ED        ChkRearSte: lda $ed                 ;check saved enemy state
00B629  2  29 20                    and #%00100000          ;if bowser not defeated, do not set flag
00B62B  2  F0 EE                    beq DrawBowser
00B62D  2  A5 02                    lda $02                 ;subtract 16 pixels from
00B62F  2  38                       sec                     ;saved vertical coordinate
00B630  2  E9 10                    sbc #$10
00B632  2  85 02                    sta $02
00B634  2  4C 18 B6                 jmp FlipBowserOver      ;jump to set vertical flip flag
00B637  2               
00B637  2               CheckForSpiny:
00B637  2  E0 24                cpx #$24               ;check if value loaded is for spiny
00B639  2  D0 11                bne CheckForLakitu     ;if not found, branch
00B63B  2  C0 05                cpy #$05               ;if enemy state set to $05, do this,
00B63D  2  D0 0A                bne NotEgg             ;otherwise branch
00B63F  2  A2 30                ldx #$30               ;set to spiny egg offset
00B641  2  A9 02                lda #$02
00B643  2  85 03                sta $03                ;set enemy direction to reverse sprites horizontally
00B645  2  A9 05                lda #$05
00B647  2  85 EC                sta $ec                ;set enemy state
00B649  2  4C 9C B6     NotEgg: jmp CheckForHammerBro  ;skip a big chunk of this if we found spiny but not in egg
00B64C  2               
00B64C  2               CheckForLakitu:
00B64C  2  E0 90                cpx #$90                  ;check value for lakitu's offset loaded
00B64E  2  D0 12                bne CheckUpsideDownShell  ;branch if not loaded
00B650  2  A5 ED                lda $ed
00B652  2  29 20                and #%00100000            ;check for d5 set in enemy state
00B654  2  D0 09                bne NoLAFr                ;branch if set
00B656  2  AD 8F 07             lda FrenzyEnemyTimer
00B659  2  C9 10                cmp #$10                  ;check timer to see if we've reached a certain range
00B65B  2  B0 02                bcs NoLAFr                ;branch if not
00B65D  2  A2 96                ldx #$96                  ;if d6 not set and timer in range, load alt frame for lakitu
00B65F  2  4C 0C B7     NoLAFr: jmp CheckDefeatedState    ;skip this next part if we found lakitu but alt frame not needed
00B662  2               
00B662  2               CheckUpsideDownShell:
00B662  2  A5 EF              lda $ef                    ;check for enemy object => $04
00B664  2  C9 04              cmp #$04
00B666  2  B0 10              bcs CheckRightSideUpShell  ;branch if true
00B668  2  C0 02              cpy #$02
00B66A  2  90 0C              bcc CheckRightSideUpShell  ;branch if enemy state < $02
00B66C  2  A2 5A              ldx #$5a                   ;set for upside-down koopa shell by default
00B66E  2  A4 EF              ldy $ef
00B670  2  C0 02              cpy #BuzzyBeetle           ;check for buzzy beetle object
00B672  2  D0 04              bne CheckRightSideUpShell
00B674  2  A2 7E              ldx #$7e                   ;set for upside-down buzzy beetle shell if found
00B676  2  E6 02              inc $02                    ;increment vertical position by one pixel
00B678  2               
00B678  2               CheckRightSideUpShell:
00B678  2  A5 EC              lda $ec                ;check for value set here
00B67A  2  C9 04              cmp #$04               ;if enemy state < $02, do not change to shell, if
00B67C  2  D0 1E              bne CheckForHammerBro  ;enemy state => $02 but not = $04, leave shell upside-down
00B67E  2  A2 72              ldx #$72               ;set right-side up buzzy beetle shell by default
00B680  2  E6 02              inc $02                ;increment saved vertical position by one pixel
00B682  2  A4 EF              ldy $ef
00B684  2  C0 02              cpy #BuzzyBeetle       ;check for buzzy beetle object
00B686  2  F0 04              beq CheckForDefdGoomba ;branch if found
00B688  2  A2 66              ldx #$66               ;change to right-side up koopa shell if not found
00B68A  2  E6 02              inc $02                ;and increment saved vertical position again
00B68C  2               
00B68C  2               CheckForDefdGoomba:
00B68C  2  C0 06              cpy #Goomba            ;check for goomba object (necessary if previously
00B68E  2  D0 0C              bne CheckForHammerBro  ;failed buzzy beetle object test)
00B690  2  A2 54              ldx #$54               ;load for regular goomba
00B692  2  A5 ED              lda $ed                ;note that this only gets performed if enemy state => $02
00B694  2  29 20              and #%00100000         ;check saved enemy state for d5 set
00B696  2  D0 04              bne CheckForHammerBro  ;branch if set
00B698  2  A2 8A              ldx #$8a               ;load offset for defeated goomba
00B69A  2  C6 02              dec $02                ;set different value and decrement saved vertical position
00B69C  2               
00B69C  2               CheckForHammerBro:
00B69C  2  A4 08              ldy ObjectOffset
00B69E  2  A5 EF              lda $ef                  ;check for hammer bro object
00B6A0  2  C9 05              cmp #HammerBro
00B6A2  2  D0 0C              bne CheckForBloober      ;branch if not found
00B6A4  2  A5 ED              lda $ed
00B6A6  2  F0 24              beq CheckToAnimateEnemy  ;branch if not in normal enemy state
00B6A8  2  29 08              and #%00001000
00B6AA  2  F0 60              beq CheckDefeatedState   ;if d3 not set, branch further away
00B6AC  2  A2 B4              ldx #$b4                 ;otherwise load offset for different frame
00B6AE  2  D0 1C              bne CheckToAnimateEnemy  ;unconditional branch
00B6B0  2               
00B6B0  2               CheckForBloober:
00B6B0  2  E0 48              cpx #$48                 ;check for cheep-cheep offset loaded
00B6B2  2  F0 18              beq CheckToAnimateEnemy  ;branch if found
00B6B4  2  B9 96 07           lda EnemyIntervalTimer,y
00B6B7  2  C9 05              cmp #$05
00B6B9  2  B0 51              bcs CheckDefeatedState   ;branch if some timer is above a certain point
00B6BB  2  E0 3C              cpx #$3c                 ;check for bloober offset loaded
00B6BD  2  D0 0D              bne CheckToAnimateEnemy  ;branch if not found this time
00B6BF  2  C9 01              cmp #$01
00B6C1  2  F0 49              beq CheckDefeatedState   ;branch if timer is set to certain point
00B6C3  2  E6 02              inc $02                  ;increment saved vertical coordinate three pixels
00B6C5  2  E6 02              inc $02
00B6C7  2  E6 02              inc $02
00B6C9  2  4C FE B6           jmp CheckAnimationStop   ;and do something else
00B6CC  2               
00B6CC  2               CheckToAnimateEnemy:
00B6CC  2  A5 EF              lda $ef                  ;check for specific enemy objects
00B6CE  2  C9 06              cmp #Goomba
00B6D0  2  F0 3A              beq CheckDefeatedState   ;branch if goomba
00B6D2  2  C9 08              cmp #$08
00B6D4  2  F0 36              beq CheckDefeatedState   ;branch if bullet bill (note both variants use $08 here)
00B6D6  2  C9 0C              cmp #Podoboo
00B6D8  2  F0 32              beq CheckDefeatedState   ;branch if podoboo
00B6DA  2  C9 18              cmp #$18                 ;branch if => $18
00B6DC  2  B0 2E              bcs CheckDefeatedState
00B6DE  2  A0 00              ldy #$00
00B6E0  2  C9 15              cmp #$15                 ;check for mushroom retainer/princess object
00B6E2  2  D0 13              bne CheckForSecondFrame  ;which uses different code here, branch if not found
00B6E4  2  C8                 iny                      ;residual instruction
00B6E5  2  A9 03              lda #$03                 ;set state for mushroom retainer/princess object
00B6E7  2  85 EC              sta $ec
00B6E9  2  AD 5F 07           lda WorldNumber          ;are we on world 8?
00B6EC  2  C9 07              cmp #World8
00B6EE  2  B0 1C              bcs CheckDefeatedState   ;if so, leave the offset alone (use princess)
00B6F0  2               .ifdef ANN
00B6F0  2  EE 7C 07           inc ANNMushroomRetainerGfxHandler
00B6F3  2               .endif
00B6F3  2  A2 A2              ldx #$a2                 ;otherwise, set for mushroom retainer object instead
00B6F5  2  D0 15              bne CheckDefeatedState   ;unconditional branch
00B6F7  2               
00B6F7  2               CheckForSecondFrame:
00B6F7  2  A5 09              lda FrameCounter            ;load frame counter
00B6F9  2  39 30 B5           and EnemyAnimTimingBMask,y  ;mask it (partly residual, one byte not ever used)
00B6FC  2  D0 0E              bne CheckDefeatedState      ;branch if timing is off
00B6FE  2               
00B6FE  2               CheckAnimationStop:
00B6FE  2  A5 ED              lda $ed                 ;check saved enemy state
00B700  2  29 A0              and #%10100000          ;for d7 or d5, or check for timers stopped
00B702  2  0D 47 07           ora TimerControl
00B705  2  D0 05              bne CheckDefeatedState  ;if either condition true, branch
00B707  2  8A                 txa
00B708  2  18                 clc
00B709  2  69 06              adc #$06                ;add $06 to current enemy offset
00B70B  2  AA                 tax                     ;to animate various enemy objects
00B70C  2               
00B70C  2               CheckDefeatedState:
00B70C  2  A5 EF               lda $ef               ;check for upside-down piranha plant
00B70E  2  C9 04               cmp #$04              ;if found, branch to draw it upside-down
00B710  2  F0 0C               beq FlipV
00B712  2  A5 ED               lda $ed               ;check saved enemy state
00B714  2  29 20               and #%00100000        ;for d5 set
00B716  2  F0 0E               beq DrawEnemyObject   ;branch if not set
00B718  2  A5 EF               lda $ef
00B71A  2  C9 04               cmp #$04              ;check for saved enemy object => $04
00B71C  2  90 08               bcc DrawEnemyObject   ;branch if less
00B71E  2  A0 01        FlipV: ldy #$01
00B720  2  8C 09 01            sty VerticalFlipFlag  ;set vertical flip flag
00B723  2  88                  dey
00B724  2  84 EC               sty $ec               ;init saved value here
00B726  2               
00B726  2               DrawEnemyObject:
00B726  2  A4 EB              ldy $eb                    ;load sprite data offset
00B728  2  20 95 B8           jsr DrawEnemyObjRow        ;draw six tiles of data
00B72B  2  20 95 B8           jsr DrawEnemyObjRow        ;into sprite data
00B72E  2  20 95 B8           jsr DrawEnemyObjRow
00B731  2  A6 08              ldx ObjectOffset           ;get enemy object offset
00B733  2  BC E5 06           ldy Enemy_SprDataOffset,x  ;get sprite data offset
00B736  2  A5 EF              lda $ef
00B738  2  C9 08              cmp #$08                   ;get saved enemy object and check
00B73A  2  D0 03              bne CheckForVerticalFlip   ;for bullet bill, branch if not found
00B73C  2               
00B73C  2               SkipToOffScrChk:
00B73C  2  4C 4F B8           jmp SprObjectOffscrChk     ;jump if found
00B73F  2               
00B73F  2               CheckForVerticalFlip:
00B73F  2               .ifdef ANN
00B73F  2  AD 7C 07           lda ANNMushroomRetainerGfxHandler
00B742  2  D0 F8              bne SkipToOffScrChk
00B744  2               .endif
00B744  2  AD 09 01           lda VerticalFlipFlag       ;check if vertical flip flag is set here
00B747  2  F0 41              beq CheckForESymmetry      ;branch if not
00B749  2  B9 02 02           lda Sprite_Attributes,y    ;get attributes of first sprite we dealt with
00B74C  2  09 80              ora #%10000000             ;set bit for vertical flip
00B74E  2  C8                 iny
00B74F  2  C8                 iny                        ;increment two bytes so that we store the vertical flip
00B750  2  20 66 B2           jsr DumpSixSpr             ;in attribute bytes of enemy obj sprite data
00B753  2  88                 dey
00B754  2  88                 dey                        ;now go back to the Y coordinate offset
00B755  2  98                 tya
00B756  2  AA                 tax                        ;give offset to X
00B757  2  A5 EF              lda $ef
00B759  2  C9 05              cmp #HammerBro             ;check saved enemy object for hammer bro
00B75B  2  F0 11              beq FlipEnemyVertically
00B75D  2  C9 04              cmp #UpsideDownPiranhaP    ;check saved enemy object for upside-down piranha plant
00B75F  2  F0 0D              beq FlipEnemyVertically
00B761  2  C9 11              cmp #Lakitu                ;check saved enemy object for lakitu
00B763  2  F0 09              beq FlipEnemyVertically    ;branch for any of these objects
00B765  2  C9 15              cmp #$15
00B767  2  B0 05              bcs FlipEnemyVertically    ;also branch if enemy object => $15
00B769  2  8A                 txa
00B76A  2  18                 clc
00B76B  2  69 08              adc #$08                   ;if not selected objects or => $15, set
00B76D  2  AA                 tax                        ;offset in X for next row
00B76E  2               
00B76E  2               FlipEnemyVertically:
00B76E  2  BD 01 02           lda Sprite_Tilenumber,x     ;load first or second row tiles
00B771  2  48                 pha                         ;and save tiles to the stack
00B772  2  BD 05 02           lda Sprite_Tilenumber+4,x
00B775  2  48                 pha
00B776  2  B9 11 02           lda Sprite_Tilenumber+16,y  ;exchange third row tiles
00B779  2  9D 01 02           sta Sprite_Tilenumber,x     ;with first or second row tiles
00B77C  2  B9 15 02           lda Sprite_Tilenumber+20,y
00B77F  2  9D 05 02           sta Sprite_Tilenumber+4,x
00B782  2  68                 pla                         ;pull first or second row tiles from stack
00B783  2  99 15 02           sta Sprite_Tilenumber+20,y  ;and save in third row
00B786  2  68                 pla
00B787  2  99 11 02           sta Sprite_Tilenumber+16,y
00B78A  2               
00B78A  2               CheckForESymmetry:
00B78A  2  AD 6A 03             lda BowserGfxFlag           ;are we drawing bowser at all?
00B78D  2  D0 AD                bne SkipToOffScrChk         ;branch if so
00B78F  2  A5 EF                lda $ef
00B791  2  A6 EC                ldx $ec                     ;get alternate enemy state
00B793  2  C9 05                cmp #$05                    ;check for hammer bro object
00B795  2  D0 03                bne ContES
00B797  2  4C 4F B8             jmp SprObjectOffscrChk      ;jump if found
00B79A  2  C9 07        ContES: cmp #Bloober                ;check for bloober object
00B79C  2  F0 21                beq MirrorEnemyGfx
00B79E  2  C9 0D                cmp #PiranhaPlant           ;check for piranha plant object
00B7A0  2  F0 1D                beq MirrorEnemyGfx
00B7A2  2  C9 04                cmp #UpsideDownPiranhaP     ;check for upside-down piranha plant object
00B7A4  2  F0 19                beq MirrorEnemyGfx
00B7A6  2  C9 0C                cmp #Podoboo                ;check for podoboo object
00B7A8  2  F0 15                beq MirrorEnemyGfx          ;branch if either of three are found
00B7AA  2  C9 12                cmp #Spiny                  ;check for spiny object
00B7AC  2  D0 04                bne ESRtnr                  ;branch closer if not found
00B7AE  2  E0 05                cpx #$05                    ;check spiny's state
00B7B0  2  D0 48                bne CheckToMirrorLakitu     ;branch if not an egg, otherwise
00B7B2  2  C9 15        ESRtnr: cmp #$15                    ;check for princess/mushroom retainer object
00B7B4  2  D0 05                bne SpnySC
00B7B6  2  A9 42                lda #$42                    ;set horizontal flip on bottom right sprite
00B7B8  2  99 16 02             sta Sprite_Attributes+20,y  ;note that palette bits were already set earlier
00B7BB  2  E0 02        SpnySC: cpx #$02                    ;if alternate enemy state set to 1 or 0, branch
00B7BD  2  90 3B                bcc CheckToMirrorLakitu
00B7BF  2               
00B7BF  2               MirrorEnemyGfx:
00B7BF  2  AD 6A 03             lda BowserGfxFlag           ;if enemy object is bowser, skip all of this
00B7C2  2  D0 36                bne CheckToMirrorLakitu
00B7C4  2  B9 02 02             lda Sprite_Attributes,y     ;load attribute bits of first sprite
00B7C7  2  29 A3                and #%10100011
00B7C9  2  99 02 02             sta Sprite_Attributes,y     ;save vertical flip, priority, and palette bits
00B7CC  2  99 0A 02             sta Sprite_Attributes+8,y   ;in left sprite column of enemy object OAM data
00B7CF  2  99 12 02             sta Sprite_Attributes+16,y
00B7D2  2  09 40                ora #%01000000              ;set horizontal flip
00B7D4  2  E0 05                cpx #$05                    ;check for state used by spiny's egg
00B7D6  2  D0 02                bne EggExc                  ;if alternate state not set to $05, branch
00B7D8  2  09 80                ora #%10000000              ;otherwise set vertical flip
00B7DA  2  99 06 02     EggExc: sta Sprite_Attributes+4,y   ;set bits of right sprite column
00B7DD  2  99 0E 02             sta Sprite_Attributes+12,y  ;of enemy object sprite data
00B7E0  2  99 16 02             sta Sprite_Attributes+20,y
00B7E3  2  E0 04                cpx #$04                    ;check alternate enemy state
00B7E5  2  D0 13                bne CheckToMirrorLakitu     ;branch if not $04
00B7E7  2  B9 0A 02             lda Sprite_Attributes+8,y   ;get second row left sprite attributes
00B7EA  2  09 80                ora #%10000000
00B7EC  2  99 0A 02             sta Sprite_Attributes+8,y   ;store bits with vertical flip in
00B7EF  2  99 12 02             sta Sprite_Attributes+16,y  ;second and third row left sprites
00B7F2  2  09 40                ora #%01000000
00B7F4  2  99 0E 02             sta Sprite_Attributes+12,y  ;store with horizontal and vertical flip in
00B7F7  2  99 16 02             sta Sprite_Attributes+20,y  ;second and third row right sprites
00B7FA  2               
00B7FA  2               CheckToMirrorLakitu:
00B7FA  2  A5 EF                lda $ef                     ;check for lakitu enemy object
00B7FC  2  C9 11                cmp #Lakitu
00B7FE  2  D0 36                bne CheckToMirrorJSpring    ;branch if not found
00B800  2  AD 09 01             lda VerticalFlipFlag
00B803  2  D0 21                bne NVFLak                  ;branch if vertical flip flag set
00B805  2  B9 12 02             lda Sprite_Attributes+16,y  ;save vertical flip and palette bits
00B808  2  29 81                and #%10000001              ;in third row left sprite
00B80A  2  99 12 02             sta Sprite_Attributes+16,y
00B80D  2  B9 16 02             lda Sprite_Attributes+20,y  ;set horizontal flip and palette bits
00B810  2  09 41                ora #%01000001              ;in third row right sprite
00B812  2  99 16 02             sta Sprite_Attributes+20,y
00B815  2  AE 8F 07             ldx FrenzyEnemyTimer        ;check timer
00B818  2  E0 10                cpx #$10
00B81A  2  B0 33                bcs SprObjectOffscrChk      ;branch if timer has not reached a certain range
00B81C  2  99 0E 02             sta Sprite_Attributes+12,y  ;otherwise set same for second row right sprite
00B81F  2  29 81                and #%10000001
00B821  2  99 0A 02             sta Sprite_Attributes+8,y   ;preserve vertical flip and palette bits for left sprite
00B824  2  90 29                bcc SprObjectOffscrChk      ;unconditional branch
00B826  2  B9 02 02     NVFLak: lda Sprite_Attributes,y     ;get first row left sprite attributes
00B829  2  29 81                and #%10000001
00B82B  2  99 02 02             sta Sprite_Attributes,y     ;save vertical flip and palette bits
00B82E  2  B9 06 02             lda Sprite_Attributes+4,y   ;get first row right sprite attributes
00B831  2  09 41                ora #%01000001              ;set horizontal flip and palette bits
00B833  2  99 06 02             sta Sprite_Attributes+4,y   ;note that vertical flip is left as-is
00B836  2               
00B836  2               CheckToMirrorJSpring:
00B836  2  A5 EF              lda $ef                     ;check for jumpspring object (any frame)
00B838  2  C9 18              cmp #$18
00B83A  2  90 13              bcc SprObjectOffscrChk      ;branch if not jumpspring object at all
00B83C  2  A9 80              lda #$80
00B83E  2  0D 2D B5           ora EnemyAttributeData+$18
00B841  2  99 0A 02           sta Sprite_Attributes+8,y   ;set vertical flip and palette bits of
00B844  2  99 12 02           sta Sprite_Attributes+16,y  ;second and third row left sprites
00B847  2  09 40              ora #%01000000
00B849  2  99 0E 02           sta Sprite_Attributes+12,y  ;set, in addition to those, horizontal flip
00B84C  2  99 16 02           sta Sprite_Attributes+20,y  ;for second and third row right sprites
00B84F  2               
00B84F  2               SprObjectOffscrChk:
00B84F  2  A6 08                 ldx ObjectOffset          ;get enemy buffer offset
00B851  2  AD D1 03              lda Enemy_OffscreenBits   ;check offscreen information
00B854  2  4A                    lsr
00B855  2  4A                    lsr                       ;shift three times to the right
00B856  2  4A                    lsr                       ;which puts d2 into carry
00B857  2  48                    pha                       ;save to stack
00B858  2  90 05                 bcc LcChk                 ;branch if not set
00B85A  2  A9 04                 lda #$04                  ;set for right column sprites
00B85C  2  20 AC B8              jsr MoveESprColOffscreen  ;and move them offscreen
00B85F  2  68           LcChk:   pla                       ;get from stack
00B860  2  4A                    lsr                       ;move d3 to carry
00B861  2  48                    pha                       ;save to stack
00B862  2  90 05                 bcc Row3C                 ;branch if not set
00B864  2  A9 00                 lda #$00                  ;set for left column sprites,
00B866  2  20 AC B8              jsr MoveESprColOffscreen  ;move them offscreen
00B869  2  68           Row3C:   pla                       ;get from stack again
00B86A  2  4A                    lsr                       ;move d5 to carry this time
00B86B  2  4A                    lsr
00B86C  2  48                    pha                       ;save to stack again
00B86D  2  90 05                 bcc Row23C                ;branch if carry not set
00B86F  2  A9 10                 lda #$10                  ;set for third row of sprites
00B871  2  20 A2 B8              jsr MoveESprRowOffscreen  ;and move them offscreen
00B874  2  68           Row23C:  pla                       ;get from stack
00B875  2  4A                    lsr                       ;move d6 into carry
00B876  2  48                    pha                       ;save to stack
00B877  2  90 05                 bcc AllRowC
00B879  2  A9 08                 lda #$08                  ;set for second and third rows
00B87B  2  20 A2 B8              jsr MoveESprRowOffscreen  ;move them offscreen
00B87E  2  68           AllRowC: pla                       ;get from stack once more
00B87F  2  4A                    lsr                       ;move d7 into carry
00B880  2  90 12                 bcc ExEGHandler
00B882  2  20 A2 B8              jsr MoveESprRowOffscreen  ;move all sprites offscreen (A should be 0 by now)
00B885  2  B5 16                 lda Enemy_ID,x
00B887  2  C9 0C                 cmp #Podoboo              ;check enemy identifier for podoboo
00B889  2  F0 09                 beq ExEGHandler           ;skip this part if found, we do not want to erase podoboo!
00B88B  2  B5 B6                 lda Enemy_Y_HighPos,x     ;check high byte of vertical position
00B88D  2  C9 02                 cmp #$02                  ;if not yet past the bottom of the screen, branch
00B88F  2  D0 03                 bne ExEGHandler
00B891  2  20 CC 95              jsr EraseEnemyObject      ;what it says
00B894  2               
00B894  2               ExEGHandler:
00B894  2  60                 rts
00B895  2               
00B895  2               DrawEnemyObjRow:
00B895  2  BD F8 B3           lda EnemyGraphicsTable,x    ;load two tiles of enemy graphics
00B898  2  85 00              sta $00
00B89A  2  BD F9 B3           lda EnemyGraphicsTable+1,x
00B89D  2               
00B89D  2               DrawOneSpriteRow:
00B89D  2  85 01              sta $01
00B89F  2  4C 77 BF           jmp DrawSpriteObject        ;draw them
00B8A2  2               
00B8A2  2               MoveESprRowOffscreen:
00B8A2  2  18                 clc                         ;add A to enemy object OAM data offset
00B8A3  2  7D E5 06           adc Enemy_SprDataOffset,x
00B8A6  2  A8                 tay                         ;use as offset
00B8A7  2  A9 F8              lda #$f8
00B8A9  2  4C 72 B2           jmp DumpTwoSpr              ;move first row of sprites offscreen
00B8AC  2               
00B8AC  2               MoveESprColOffscreen:
00B8AC  2  18                 clc                         ;add A to enemy object OAM data offset
00B8AD  2  7D E5 06           adc Enemy_SprDataOffset,x
00B8B0  2  A8                 tay                         ;use as offset
00B8B1  2  20 35 B9           jsr MoveColOffscreen        ;move first and second row sprites in column offscreen
00B8B4  2  99 10 02           sta Sprite_Data+16,y        ;move third row sprite in column offscreen
00B8B7  2  60                 rts
00B8B8  2               
00B8B8  2               ;-------------------------------------------------------------------------------------
00B8B8  2               ;$00-$01 - tile numbers
00B8B8  2               ;$02 - relative Y position
00B8B8  2               ;$03 - horizontal flip flag (not used here)
00B8B8  2               ;$04 - attributes
00B8B8  2               ;$05 - relative X position
00B8B8  2               
00B8B8  2               DefaultBlockObjTiles:
00B8B8  2  85 85 86 86        .byte $85, $85, $86, $86             ;brick w/ line (these are sprite tiles, not BG!)
00B8BC  2               
00B8BC  2               DrawBlock:
00B8BC  2  AD BC 03                lda Block_Rel_YPos            ;get relative vertical coordinate of block object
00B8BF  2  85 02                   sta $02                       ;store here
00B8C1  2  AD B1 03                lda Block_Rel_XPos            ;get relative horizontal coordinate of block object
00B8C4  2  85 05                   sta $05                       ;store here
00B8C6  2  A9 03                   lda #$03
00B8C8  2  85 04                   sta $04                       ;set attribute byte here
00B8CA  2  4A                      lsr
00B8CB  2  85 03                   sta $03                       ;set horizontal flip bit here (will not be used)
00B8CD  2  BC EC 06                ldy Block_SprDataOffset,x     ;get sprite data offset
00B8D0  2  A2 00                   ldx #$00                      ;reset X for use as offset to tile data
00B8D2  2  BD B8 B8     DBlkLoop:  lda DefaultBlockObjTiles,x    ;get left tile number
00B8D5  2  85 00                   sta $00                       ;set here
00B8D7  2  BD B9 B8                lda DefaultBlockObjTiles+1,x  ;get right tile number
00B8DA  2  20 9D B8                jsr DrawOneSpriteRow          ;do sub to write tile numbers to first row of sprites
00B8DD  2  E0 04                   cpx #$04                      ;check incremented offset
00B8DF  2  D0 F1                   bne DBlkLoop                  ;and loop back until all four sprites are done
00B8E1  2  A6 08                   ldx ObjectOffset              ;get block object offset
00B8E3  2  BC EC 06                ldy Block_SprDataOffset,x     ;get sprite data offset
00B8E6  2  AD 4E 07                lda AreaType
00B8E9  2  C9 01                   cmp #$01                      ;check for ground level type area
00B8EB  2  F0 08                   beq ChkRep                    ;if found, branch to next part
00B8ED  2  A9 86                   lda #$86
00B8EF  2  99 01 02                sta Sprite_Tilenumber,y       ;otherwise remove brick tiles with lines
00B8F2  2  99 05 02                sta Sprite_Tilenumber+4,y     ;and replace then with lineless brick tiles
00B8F5  2  BD E8 03     ChkRep:    lda Block_Metatile,x          ;check replacement metatile
00B8F8  2               .ifdef ANN
00B8F8  2  C9 C4                   cmp #$c4                      ;if not used block metatile, then
00B8FA  2               .else
00B8FA  2                          cmp #$c5                      ;if not used block metatile, then
00B8FA  2               .endif
00B8FA  2  D0 24                   bne BlkOffscr                 ;branch ahead to use current graphics
00B8FC  2  A9 87                   lda #$87                      ;set A for used block tile
00B8FE  2  C8                      iny                           ;increment Y to write to tile bytes
00B8FF  2  20 6C B2                jsr DumpFourSpr               ;do sub to dump into all four sprites
00B902  2  88                      dey                           ;return Y to original offset
00B903  2  A9 03                   lda #$03                      ;set palette bits
00B905  2  AE 4E 07                ldx AreaType
00B908  2  CA                      dex                           ;check for ground level type area again
00B909  2  F0 01                   beq SetBFlip                  ;if found, use current palette bits
00B90B  2  4A                      lsr                           ;otherwise set to $01
00B90C  2  A6 08        SetBFlip:  ldx ObjectOffset              ;put block object offset back in X
00B90E  2  99 02 02                sta Sprite_Attributes,y       ;store attribute byte as-is in first sprite
00B911  2  09 40                   ora #%01000000
00B913  2  99 06 02                sta Sprite_Attributes+4,y     ;set horizontal flip bit for second sprite
00B916  2  09 80                   ora #%10000000
00B918  2  99 0E 02                sta Sprite_Attributes+12,y    ;set both flip bits for fourth sprite
00B91B  2  29 83                   and #%10000011
00B91D  2  99 0A 02                sta Sprite_Attributes+8,y     ;set vertical flip bit for third sprite
00B920  2  AD D4 03     BlkOffscr: lda Block_OffscreenBits       ;get offscreen bits for block object
00B923  2  48                      pha                           ;save to stack
00B924  2  29 04                   and #%00000100                ;check to see if d2 in offscreen bits are set
00B926  2  F0 08                   beq PullOfsB                  ;if not set, branch, otherwise move sprites offscreen
00B928  2  A9 F8                   lda #$f8                      ;move offscreen two OAMs
00B92A  2  99 04 02                sta Sprite_Y_Position+4,y     ;on the right side
00B92D  2  99 0C 02                sta Sprite_Y_Position+12,y
00B930  2  68           PullOfsB:  pla                           ;pull offscreen bits from stack
00B931  2  29 08        ChkLeftCo: and #%00001000                ;check to see if d3 in offscreen bits are set
00B933  2  F0 08                   beq ExDBlk                    ;if not set, branch, otherwise move sprites offscreen
00B935  2               
00B935  2               MoveColOffscreen:
00B935  2  A9 F8                lda #$f8                   ;move offscreen two OAMs
00B937  2  99 00 02             sta Sprite_Y_Position,y    ;on the left side (or two rows of enemy on either side
00B93A  2  99 08 02             sta Sprite_Y_Position+8,y  ;if branched here from enemy graphics handler)
00B93D  2  60           ExDBlk: rts
00B93E  2               
00B93E  2               ;-------------------------------------------------------------------------------------
00B93E  2               ;$00 - used to hold palette bits for attribute byte or relative X position
00B93E  2               
00B93E  2               DrawBrickChunks:
00B93E  2  A9 02                 lda #$02                   ;set palette bits here
00B940  2  85 00                 sta $00
00B942  2  A9 75                 lda #$75                   ;set tile number for ball (something residual, likely)
00B944  2  A4 0E                 ldy GameEngineSubroutine
00B946  2  C0 05                 cpy #$05                   ;if end-of-level routine running,
00B948  2  F0 06                 beq DChunks                ;use palette and tile number assigned
00B94A  2  A9 03                 lda #$03                   ;otherwise set different palette bits
00B94C  2  85 00                 sta $00
00B94E  2  A9 84                 lda #$84                   ;and set tile number for brick chunks
00B950  2  BC EC 06     DChunks: ldy Block_SprDataOffset,x  ;get OAM data offset
00B953  2  C8                    iny                        ;increment to start with tile bytes in OAM
00B954  2  20 6C B2              jsr DumpFourSpr            ;do sub to dump tile number into all four sprites
00B957  2  A5 09                 lda FrameCounter           ;get frame counter
00B959  2  0A                    asl
00B95A  2  0A                    asl
00B95B  2  0A                    asl                        ;move low nybble to high
00B95C  2  0A                    asl
00B95D  2  29 C0                 and #$c0                   ;get what was originally d3-d2 of low nybble
00B95F  2  05 00                 ora $00                    ;add palette bits
00B961  2  C8                    iny                        ;increment offset for attribute bytes
00B962  2  20 6C B2              jsr DumpFourSpr            ;do sub to dump attribute data into all four sprites
00B965  2  88                    dey
00B966  2  88                    dey                        ;decrement offset to Y coordinate
00B967  2  AD BC 03              lda Block_Rel_YPos         ;get first block object's relative vertical coordinate
00B96A  2  20 72 B2              jsr DumpTwoSpr             ;do sub to dump current Y coordinate into two sprites
00B96D  2  AD B1 03              lda Block_Rel_XPos         ;get first block object's relative horizontal coordinate
00B970  2  99 03 02              sta Sprite_X_Position,y    ;save into X coordinate of first sprite
00B973  2  BD F1 03              lda Block_Orig_XPos,x      ;get original horizontal coordinate
00B976  2  38                    sec
00B977  2  ED 1C 07              sbc ScreenLeft_X_Pos       ;subtract coordinate of left side from original coordinate
00B97A  2  85 00                 sta $00                    ;store result as relative horizontal coordinate of original
00B97C  2  38                    sec
00B97D  2  ED B1 03              sbc Block_Rel_XPos         ;get difference of relative positions of original - current
00B980  2  65 00                 adc $00                    ;add original relative position to result
00B982  2  69 06                 adc #$06                   ;plus 6 pixels to position second brick chunk correctly
00B984  2  99 07 02              sta Sprite_X_Position+4,y  ;save into X coordinate of second sprite
00B987  2  AD BD 03              lda Block_Rel_YPos+1       ;get second block object's relative vertical coordinate
00B98A  2  99 08 02              sta Sprite_Y_Position+8,y
00B98D  2  99 0C 02              sta Sprite_Y_Position+12,y ;dump into Y coordinates of third and fourth sprites
00B990  2  AD B2 03              lda Block_Rel_XPos+1       ;get second block object's relative horizontal coordinate
00B993  2  99 0B 02              sta Sprite_X_Position+8,y  ;save into X coordinate of third sprite
00B996  2  A5 00                 lda $00                    ;use original relative horizontal position
00B998  2  38                    sec
00B999  2  ED B2 03              sbc Block_Rel_XPos+1       ;get difference of relative positions of original - current
00B99C  2  65 00                 adc $00                    ;add original relative position to result
00B99E  2  69 06                 adc #$06                   ;plus 6 pixels to position fourth brick chunk correctly
00B9A0  2  99 0F 02              sta Sprite_X_Position+12,y ;save into X coordinate of fourth sprite
00B9A3  2  AD D4 03              lda Block_OffscreenBits    ;get offscreen bits for block object
00B9A6  2  20 31 B9              jsr ChkLeftCo              ;do sub to move left half of sprites offscreen if necessary
00B9A9  2  AD D4 03              lda Block_OffscreenBits    ;get offscreen bits again
00B9AC  2  0A                    asl                        ;shift d7 into carry
00B9AD  2  90 05                 bcc ChnkOfs                ;if d7 not set, branch to last part
00B9AF  2  A9 F8                 lda #$f8
00B9B1  2  20 72 B2              jsr DumpTwoSpr             ;otherwise move top sprites offscreen
00B9B4  2  A5 00        ChnkOfs: lda $00                    ;if relative position on left side of screen,
00B9B6  2  10 10                 bpl ExBCDr                 ;go ahead and leave
00B9B8  2  B9 03 02              lda Sprite_X_Position,y    ;otherwise compare left-side X coordinate
00B9BB  2  D9 07 02              cmp Sprite_X_Position+4,y  ;to right-side X coordinate
00B9BE  2  90 08                 bcc ExBCDr                 ;branch to leave if less
00B9C0  2  A9 F8                 lda #$f8                   ;otherwise move right half of sprites offscreen
00B9C2  2  99 04 02              sta Sprite_Y_Position+4,y
00B9C5  2  99 0C 02              sta Sprite_Y_Position+12,y
00B9C8  2  60           ExBCDr:  rts                        ;leave
00B9C9  2               
00B9C9  2               ;-------------------------------------------------------------------------------------
00B9C9  2               
00B9C9  2               DrawFireball:
00B9C9  2  BC F1 06           ldy FBall_SprDataOffset,x  ;get fireball's sprite data offset
00B9CC  2  AD BA 03           lda Fireball_Rel_YPos      ;get relative vertical coordinate
00B9CF  2  99 00 02           sta Sprite_Y_Position,y    ;store as sprite Y coordinate
00B9D2  2  AD AF 03           lda Fireball_Rel_XPos      ;get relative horizontal coordinate
00B9D5  2  99 03 02           sta Sprite_X_Position,y    ;store as sprite X coordinate, then do shared code
00B9D8  2               
00B9D8  2               DrawFirebar:
00B9D8  2  A5 09               lda FrameCounter         ;get frame counter
00B9DA  2  4A                  lsr                      ;divide by four
00B9DB  2  4A                  lsr
00B9DC  2  48                  pha                      ;save result to stack
00B9DD  2  29 01               and #$01                 ;mask out all but last bit
00B9DF  2  49 64               eor #$64                 ;set either tile $64 or $65 as fireball tile
00B9E1  2  99 01 02            sta Sprite_Tilenumber,y  ;thus tile changes every four frames
00B9E4  2  68                  pla                      ;get from stack
00B9E5  2  4A                  lsr                      ;divide by four again
00B9E6  2  4A                  lsr
00B9E7  2  A9 02               lda #$02                 ;load value $02 to set palette in attrib byte
00B9E9  2  90 02               bcc FireA                ;if last bit shifted out was not set, skip this
00B9EB  2  09 C0               ora #%11000000           ;otherwise flip both ways every eight frames
00B9ED  2  99 02 02     FireA: sta Sprite_Attributes,y  ;store attribute byte and leave
00B9F0  2  60                  rts
00B9F1  2               
00B9F1  2               ;-------------------------------------------------------------------------------------
00B9F1  2               
00B9F1  2               ExplosionTiles:
00B9F1  2  68 67 66           .byte $68, $67, $66
00B9F4  2               
00B9F4  2               DrawExplosion_Fireball:
00B9F4  2  BC EC 06           ldy Alt_SprDataOffset,x  ;get OAM data offset of alternate sort for fireball's explosion
00B9F7  2  B5 24              lda Fireball_State,x     ;load fireball state
00B9F9  2  F6 24              inc Fireball_State,x     ;increment state for next frame
00B9FB  2  4A                 lsr                      ;divide by 2
00B9FC  2  29 07              and #%00000111           ;mask out all but d3-d1
00B9FE  2  C9 03              cmp #$03                 ;check to see if time to kill fireball
00BA00  2  B0 4A              bcs KillFireBall         ;branch if so, otherwise continue to draw explosion
00BA02  2               
00BA02  2               DrawExplosion_Fireworks:
00BA02  2  AA                 tax                         ;use whatever's in A for offset
00BA03  2  BD F1 B9           lda ExplosionTiles,x        ;get tile number using offset
00BA06  2  C8                 iny                         ;increment Y (contains sprite data offset)
00BA07  2  20 6C B2           jsr DumpFourSpr             ;and dump into tile number part of sprite data
00BA0A  2  88                 dey                         ;decrement Y so we have the proper offset again
00BA0B  2  A6 08              ldx ObjectOffset            ;return enemy object buffer offset to X
00BA0D  2  AD BA 03           lda Fireball_Rel_YPos       ;get relative vertical coordinate
00BA10  2  38                 sec                         ;subtract four pixels vertically
00BA11  2  E9 04              sbc #$04                    ;for first and third sprites
00BA13  2  99 00 02           sta Sprite_Y_Position,y
00BA16  2  99 08 02           sta Sprite_Y_Position+8,y
00BA19  2  18                 clc                         ;add eight pixels vertically
00BA1A  2  69 08              adc #$08                    ;for second and fourth sprites
00BA1C  2  99 04 02           sta Sprite_Y_Position+4,y
00BA1F  2  99 0C 02           sta Sprite_Y_Position+12,y
00BA22  2  AD AF 03           lda Fireball_Rel_XPos       ;get relative horizontal coordinate
00BA25  2  38                 sec                         ;subtract four pixels horizontally
00BA26  2  E9 04              sbc #$04                    ;for first and second sprites
00BA28  2  99 03 02           sta Sprite_X_Position,y
00BA2B  2  99 07 02           sta Sprite_X_Position+4,y
00BA2E  2  18                 clc                         ;add eight pixels horizontally
00BA2F  2  69 08              adc #$08                    ;for third and fourth sprites
00BA31  2  99 0B 02           sta Sprite_X_Position+8,y
00BA34  2  99 0F 02           sta Sprite_X_Position+12,y
00BA37  2  A9 02              lda #$02                    ;set palette attributes for all sprites, but
00BA39  2  99 02 02           sta Sprite_Attributes,y     ;set no flip at all for first sprite
00BA3C  2  A9 82              lda #$82
00BA3E  2  99 06 02           sta Sprite_Attributes+4,y   ;set vertical flip for second sprite
00BA41  2  A9 42              lda #$42
00BA43  2  99 0A 02           sta Sprite_Attributes+8,y   ;set horizontal flip for third sprite
00BA46  2  A9 C2              lda #$c2
00BA48  2  99 0E 02           sta Sprite_Attributes+12,y  ;set both flips for fourth sprite
00BA4B  2  60                 rts                         ;we are done
00BA4C  2               
00BA4C  2               KillFireBall:
00BA4C  2  A9 00              lda #$00                    ;clear fireball state to kill it
00BA4E  2  95 24              sta Fireball_State,x
00BA50  2  60                 rts
00BA51  2               
00BA51  2               ;-------------------------------------------------------------------------------------
00BA51  2               
00BA51  2               DrawSmallPlatform:
00BA51  2  BC E5 06            ldy Enemy_SprDataOffset,x   ;get OAM data offset
00BA54  2  A9 5B               lda #$5b                    ;load tile number for small platforms
00BA56  2  C8                  iny                         ;increment offset for tile numbers
00BA57  2  20 66 B2            jsr DumpSixSpr              ;dump tile number into all six sprites
00BA5A  2  C8                  iny                         ;increment offset for attributes
00BA5B  2  A9 02               lda #$02                    ;load palette controls
00BA5D  2  20 66 B2            jsr DumpSixSpr              ;dump attributes into all six sprites
00BA60  2  88                  dey                         ;decrement for original offset
00BA61  2  88                  dey
00BA62  2  AD AE 03            lda Enemy_Rel_XPos          ;get relative horizontal coordinate
00BA65  2  99 03 02            sta Sprite_X_Position,y
00BA68  2  99 0F 02            sta Sprite_X_Position+12,y  ;dump as X coordinate into first and fourth sprites
00BA6B  2  18                  clc
00BA6C  2  69 08               adc #$08                    ;add eight pixels
00BA6E  2  99 07 02            sta Sprite_X_Position+4,y   ;dump into second and fifth sprites
00BA71  2  99 13 02            sta Sprite_X_Position+16,y
00BA74  2  18                  clc
00BA75  2  69 08               adc #$08                    ;add eight more pixels
00BA77  2  99 0B 02            sta Sprite_X_Position+8,y   ;dump into third and sixth sprites
00BA7A  2  99 17 02            sta Sprite_X_Position+20,y
00BA7D  2  B5 CF               lda Enemy_Y_Position,x      ;get vertical coordinate
00BA7F  2  AA                  tax
00BA80  2  48                  pha                         ;save to stack
00BA81  2  E0 20               cpx #$20                    ;if vertical coordinate below status bar,
00BA83  2  B0 02               bcs TopSP                   ;do not mess with it
00BA85  2  A9 F8               lda #$f8                    ;otherwise move first three sprites offscreen
00BA87  2  20 6F B2     TopSP: jsr DumpThreeSpr            ;dump vertical coordinate into Y coordinates
00BA8A  2  68                  pla                         ;pull from stack
00BA8B  2  18                  clc
00BA8C  2  69 80               adc #$80                    ;add 128 pixels
00BA8E  2  AA                  tax
00BA8F  2  E0 20               cpx #$20                    ;if below status bar (taking wrap into account)
00BA91  2  B0 02               bcs BotSP                   ;then do not change altered coordinate
00BA93  2  A9 F8               lda #$f8                    ;otherwise move last three sprites offscreen
00BA95  2  99 0C 02     BotSP: sta Sprite_Y_Position+12,y  ;dump vertical coordinate + 128 pixels
00BA98  2  99 10 02            sta Sprite_Y_Position+16,y  ;into Y coordinates
00BA9B  2  99 14 02            sta Sprite_Y_Position+20,y
00BA9E  2  AD D1 03            lda Enemy_OffscreenBits     ;get offscreen bits
00BAA1  2  48                  pha                         ;save to stack
00BAA2  2  29 08               and #%00001000              ;check d3
00BAA4  2  F0 08               beq SOfs
00BAA6  2  A9 F8               lda #$f8                    ;if d3 was set, move first and
00BAA8  2  99 00 02            sta Sprite_Y_Position,y     ;fourth sprites offscreen
00BAAB  2  99 0C 02            sta Sprite_Y_Position+12,y
00BAAE  2  68           SOfs:  pla                         ;move out and back into stack
00BAAF  2  48                  pha
00BAB0  2  29 04               and #%00000100              ;check d2
00BAB2  2  F0 08               beq SOfs2
00BAB4  2  A9 F8               lda #$f8                    ;if d2 was set, move second and
00BAB6  2  99 04 02            sta Sprite_Y_Position+4,y   ;fifth sprites offscreen
00BAB9  2  99 10 02            sta Sprite_Y_Position+16,y
00BABC  2  68           SOfs2: pla                         ;get from stack
00BABD  2  29 02               and #%00000010              ;check d1
00BABF  2  F0 08               beq ExSPl
00BAC1  2  A9 F8               lda #$f8                    ;if d1 was set, move third and
00BAC3  2  99 08 02            sta Sprite_Y_Position+8,y   ;sixth sprites offscreen
00BAC6  2  99 14 02            sta Sprite_Y_Position+20,y
00BAC9  2  A6 08        ExSPl: ldx ObjectOffset            ;get enemy object offset and leave
00BACB  2  60                  rts
00BACC  2               
00BACC  2               ;-------------------------------------------------------------------------------------
00BACC  2               
00BACC  2               DrawBubble:
00BACC  2  A4 B5                ldy Player_Y_HighPos        ;if player's vertical high position
00BACE  2  88                   dey                         ;not within screen, skip all of this
00BACF  2  D0 20                bne ExDBub
00BAD1  2  AD D3 03             lda Bubble_OffscreenBits    ;check air bubble's offscreen bits
00BAD4  2  29 08                and #%00001000
00BAD6  2  D0 19                bne ExDBub                  ;if bit set, branch to leave
00BAD8  2  BC EE 06             ldy Bubble_SprDataOffset,x  ;get air bubble's OAM data offset
00BADB  2  AD B0 03             lda Bubble_Rel_XPos         ;get relative horizontal coordinate
00BADE  2  99 03 02             sta Sprite_X_Position,y     ;store as X coordinate here
00BAE1  2  AD BB 03             lda Bubble_Rel_YPos         ;get relative vertical coordinate
00BAE4  2  99 00 02             sta Sprite_Y_Position,y     ;store as Y coordinate here
00BAE7  2  A9 74                lda #$74
00BAE9  2  99 01 02             sta Sprite_Tilenumber,y     ;put air bubble tile into OAM data
00BAEC  2  A9 02                lda #$02
00BAEE  2  99 02 02             sta Sprite_Attributes,y     ;set attribute byte
00BAF1  2  60           ExDBub: rts                         ;leave
00BAF2  2               
00BAF2  2               ;-------------------------------------------------------------------------------------
00BAF2  2               ;$00 - used to store player's vertical offscreen bits
00BAF2  2               
00BAF2  2               PlayerGfxTblOffsets:
00BAF2  2  20 28 C8 18        .byte $20, $28, $c8, $18, $00, $40, $50, $58
00BAF6  2  00 40 50 58  
00BAFA  2  80 88 B8 78        .byte $80, $88, $b8, $78, $60, $a0, $b0, $b8
00BAFE  2  60 A0 B0 B8  
00BB02  2               
00BB02  2               ;tiles arranged in order, 2 tiles per row, top to bottom
00BB02  2               
00BB02  2               PlayerGraphicsTable:
00BB02  2               ;big player table
00BB02  2  00 01 02 03        .byte $00, $01, $02, $03, $04, $05, $06, $07 ;walking frame 1
00BB06  2  04 05 06 07  
00BB0A  2  08 09 0A 0B        .byte $08, $09, $0a, $0b, $0c, $0d, $0e, $0f ;        frame 2
00BB0E  2  0C 0D 0E 0F  
00BB12  2  10 11 12 13        .byte $10, $11, $12, $13, $14, $15, $16, $17 ;        frame 3
00BB16  2  14 15 16 17  
00BB1A  2  18 19 1A 1B        .byte $18, $19, $1a, $1b, $1c, $1d, $1e, $1f ;skidding
00BB1E  2  1C 1D 1E 1F  
00BB22  2  20 21 22 23        .byte $20, $21, $22, $23, $24, $25, $26, $27 ;jumping
00BB26  2  24 25 26 27  
00BB2A  2  08 09 28 29        .byte $08, $09, $28, $29, $2a, $2b, $2c, $2d ;swimming frame 1
00BB2E  2  2A 2B 2C 2D  
00BB32  2  08 09 0A 0B        .byte $08, $09, $0a, $0b, $0c, $30, $2c, $2d ;         frame 2
00BB36  2  0C 30 2C 2D  
00BB3A  2  08 09 0A 0B        .byte $08, $09, $0a, $0b, $2e, $2f, $2c, $2d ;         frame 3
00BB3E  2  2E 2F 2C 2D  
00BB42  2  08 09 28 29        .byte $08, $09, $28, $29, $2a, $2b, $5c, $5d ;climbing frame 1
00BB46  2  2A 2B 5C 5D  
00BB4A  2  08 09 0A 0B        .byte $08, $09, $0a, $0b, $0c, $0d, $5e, $5f ;         frame 2
00BB4E  2  0C 0D 5E 5F  
00BB52  2  FC FC 08 09        .byte $fc, $fc, $08, $09, $58, $59, $5a, $5a ;crouching
00BB56  2  58 59 5A 5A  
00BB5A  2  08 09 28 29        .byte $08, $09, $28, $29, $2a, $2b, $0e, $0f ;fireball throwing
00BB5E  2  2A 2B 0E 0F  
00BB62  2               
00BB62  2               ;small player table
00BB62  2  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $32, $33, $34, $35 ;walking frame 1
00BB66  2  32 33 34 35  
00BB6A  2  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $36, $37, $38, $39 ;        frame 2
00BB6E  2  36 37 38 39  
00BB72  2  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $3a, $37, $3b, $3c ;        frame 3
00BB76  2  3A 37 3B 3C  
00BB7A  2  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $3d, $3e, $3f, $40 ;skidding
00BB7E  2  3D 3E 3F 40  
00BB82  2  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $32, $41, $42, $43 ;jumping
00BB86  2  32 41 42 43  
00BB8A  2  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $32, $33, $44, $45 ;swimming frame 1
00BB8E  2  32 33 44 45  
00BB92  2  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $32, $33, $44, $47 ;         frame 2
00BB96  2  32 33 44 47  
00BB9A  2  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $32, $33, $48, $49 ;         frame 3
00BB9E  2  32 33 48 49  
00BBA2  2  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $32, $33, $90, $91 ;climbing frame 1
00BBA6  2  32 33 90 91  
00BBAA  2  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $3a, $37, $92, $93 ;         frame 2
00BBAE  2  3A 37 92 93  
00BBB2  2  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $9e, $9e, $9f, $9f ;killed
00BBB6  2  9E 9E 9F 9F  
00BBBA  2               
00BBBA  2               ;used by both player sizes
00BBBA  2  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $3a, $37, $4f, $4f ;small player standing
00BBBE  2  3A 37 4F 4F  
00BBC2  2  FC FC 00 01        .byte $fc, $fc, $00, $01, $4c, $4d, $4e, $4e ;intermediate grow frame
00BBC6  2  4C 4D 4E 4E  
00BBCA  2  00 01 4C 4D        .byte $00, $01, $4c, $4d, $4a, $4a, $4b, $4b ;big player standing
00BBCE  2  4A 4A 4B 4B  
00BBD2  2               
00BBD2  2               SwimKickTileNum:
00BBD2  2  31 46              .byte $31, $46
00BBD4  2               
00BBD4  2               PlayerGfxHandler:
00BBD4  2  AD 9E 07             lda InjuryTimer             ;if player's injured invincibility timer
00BBD7  2  F0 05                beq CntPl                   ;not set, skip checkpoint and continue code
00BBD9  2  A5 09                lda FrameCounter
00BBDB  2  4A                   lsr                         ;otherwise check frame counter and branch
00BBDC  2  B0 40                bcs ExPGH                   ;to leave on every other frame (when d0 is set)
00BBDE  2  A5 0E        CntPl:  lda GameEngineSubroutine    ;if executing specific game engine routine,
00BBE0  2  C9 0B                cmp #$0b                    ;branch ahead to some other part
00BBE2  2  F0 47                beq PlayerKilled
00BBE4  2  AD 0B 07             lda PlayerChangeSizeFlag    ;if grow/shrink flag set
00BBE7  2  D0 3C                bne DoChangeSize            ;then branch to some other code
00BBE9  2  AC 04 07             ldy SwimmingFlag            ;if swimming flag set, branch to
00BBEC  2  F0 31                beq FindPlayerAction        ;different part, do not return
00BBEE  2  A5 1D                lda Player_State
00BBF0  2  C9 00                cmp #$00                    ;if player status normal,
00BBF2  2  F0 2B                beq FindPlayerAction        ;branch and do not return
00BBF4  2  20 1F BC             jsr FindPlayerAction        ;otherwise jump and return
00BBF7  2  A5 09                lda FrameCounter
00BBF9  2  29 04                and #%00000100              ;check frame counter for d2 set (8 frames every
00BBFB  2  D0 21                bne ExPGH                   ;eighth frame), and branch if set to leave
00BBFD  2  AA                   tax                         ;initialize X to zero
00BBFE  2  AC E4 06             ldy Player_SprDataOffset    ;get player sprite data offset
00BC01  2  A5 33                lda PlayerFacingDir         ;get player's facing direction
00BC03  2  4A                   lsr
00BC04  2  B0 04                bcs SwimKT                  ;if player facing to the right, use current offset
00BC06  2  C8                   iny
00BC07  2  C8                   iny                         ;otherwise move to next OAM data
00BC08  2  C8                   iny
00BC09  2  C8                   iny
00BC0A  2  AD 54 07     SwimKT: lda PlayerSize              ;check player's size
00BC0D  2  F0 09                beq BigKTS                  ;if big, use first tile
00BC0F  2  B9 19 02             lda Sprite_Tilenumber+24,y  ;check tile number of seventh/eighth sprite
00BC12  2  CD A0 BB             cmp SwimTileRepOffset       ;against tile number in player graphics table
00BC15  2  F0 07                beq ExPGH                   ;if spr7/spr8 tile number = value, branch to leave
00BC17  2  E8                   inx                         ;otherwise increment X for second tile
00BC18  2  BD D2 BB     BigKTS: lda SwimKickTileNum,x       ;overwrite tile number in sprite 7/8
00BC1B  2  99 19 02             sta Sprite_Tilenumber+24,y  ;to animate player's feet when swimming
00BC1E  2  60           ExPGH:  rts                         ;then leave
00BC1F  2               
00BC1F  2               FindPlayerAction:
00BC1F  2  20 D7 BC           jsr ProcessPlayerAction       ;find proper offset to graphics table by player's actions
00BC22  2  4C 30 BC           jmp PlayerGfxProcessing       ;draw player, then process for fireball throwing
00BC25  2               
00BC25  2               DoChangeSize:
00BC25  2  20 A5 BD           jsr HandleChangeSize          ;find proper offset to graphics table for grow/shrink
00BC28  2  4C 30 BC           jmp PlayerGfxProcessing       ;draw player, then process for fireball throwing
00BC2B  2               
00BC2B  2               PlayerKilled:
00BC2B  2  A0 0E              ldy #$0e                      ;load offset for player killed
00BC2D  2  B9 F2 BA           lda PlayerGfxTblOffsets,y     ;get offset to graphics table
00BC30  2               
00BC30  2               PlayerGfxProcessing:
00BC30  2  8D D5 06            sta PlayerGfxOffset           ;store offset to graphics table here
00BC33  2  A9 04               lda #$04
00BC35  2  20 A9 BC            jsr RenderPlayerSub           ;draw player based on offset loaded
00BC38  2  20 DE BD            jsr ChkForPlayerAttrib        ;set horizontal flip bits as necessary
00BC3B  2  AD 11 07            lda FireballThrowingTimer
00BC3E  2  F0 25               beq PlayerOffscreenChk        ;if fireball throw timer not set, skip to the end
00BC40  2  A0 00               ldy #$00                      ;set value to initialize by default
00BC42  2  AD 81 07            lda PlayerAnimTimer           ;get animation frame timer
00BC45  2  CD 11 07            cmp FireballThrowingTimer     ;compare to fireball throw timer
00BC48  2  8C 11 07            sty FireballThrowingTimer     ;initialize fireball throw timer
00BC4B  2  B0 18               bcs PlayerOffscreenChk        ;if animation frame timer => fireball throw timer skip to end
00BC4D  2  8D 11 07            sta FireballThrowingTimer     ;otherwise store animation timer into fireball throw timer
00BC50  2  A0 07               ldy #$07                      ;load offset for throwing
00BC52  2  B9 F2 BA            lda PlayerGfxTblOffsets,y     ;get offset to graphics table
00BC55  2  8D D5 06            sta PlayerGfxOffset           ;store it for use later
00BC58  2  A0 04               ldy #$04                      ;set to update four sprite rows by default
00BC5A  2  A5 57               lda Player_X_Speed
00BC5C  2  05 0C               ora Left_Right_Buttons        ;check for horizontal speed or left/right button press
00BC5E  2  F0 01               beq SUpdR                     ;if no speed or button press, branch using set value in Y
00BC60  2  88                  dey                           ;otherwise set to update only three sprite rows
00BC61  2  98           SUpdR: tya                           ;save in A for use
00BC62  2  20 A9 BC            jsr RenderPlayerSub           ;in sub, draw player object again
00BC65  2               
00BC65  2               PlayerOffscreenChk:
00BC65  2  AD D0 03                lda Player_OffscreenBits      ;get player's offscreen bits
00BC68  2  4A                      lsr
00BC69  2  4A                      lsr                           ;move vertical bits to low nybble
00BC6A  2  4A                      lsr
00BC6B  2  4A                      lsr
00BC6C  2  85 00                   sta $00                       ;store here
00BC6E  2  A2 03                   ldx #$03                      ;check all four rows of player sprites
00BC70  2  AD E4 06                lda Player_SprDataOffset      ;get player's sprite data offset
00BC73  2  18                      clc
00BC74  2  69 18                   adc #$18                      ;add 24 bytes to start at bottom row
00BC76  2  A8                      tay                           ;set as offset here
00BC77  2  A9 F8        PROfsLoop: lda #$f8                      ;load offscreen Y coordinate just in case
00BC79  2  46 00                   lsr $00                       ;shift bit into carry
00BC7B  2  90 03                   bcc NPROffscr                 ;if bit not set, skip, do not move sprites
00BC7D  2  20 72 B2                jsr DumpTwoSpr                ;otherwise dump offscreen Y coordinate into sprite data
00BC80  2  98           NPROffscr: tya
00BC81  2  38                      sec                           ;subtract eight bytes to do
00BC82  2  E9 08                   sbc #$08                      ;next row up
00BC84  2  A8                      tay
00BC85  2  CA                      dex                           ;decrement row counter
00BC86  2  10 EF                   bpl PROfsLoop                 ;do this until all sprite rows are checked
00BC88  2  60                      rts                           ;then we are done!
00BC89  2               
00BC89  2               IntermediatePlayerData:
00BC89  2  58 01 00 60          .byte $58, $01, $00, $60, $ff, $04
00BC8D  2  FF 04        
00BC8F  2               
00BC8F  2               DrawPlayer_Intermediate:
00BC8F  2  A2 05                  ldx #$05                       ;store data into zero page memory
00BC91  2  BD 89 BC     PIntLoop: lda IntermediatePlayerData,x   ;load data to display player as he always
00BC94  2  95 02                  sta $02,x                      ;appears on world/lives display
00BC96  2  CA                     dex
00BC97  2  10 F8                  bpl PIntLoop                   ;do this until all data is loaded
00BC99  2  A2 B8                  ldx #$b8                       ;load offset for small standing
00BC9B  2  A0 04                  ldy #$04                       ;load sprite data offset
00BC9D  2  20 C7 BC               jsr DrawPlayerLoop             ;draw player accordingly
00BCA0  2  AD 26 02               lda Sprite_Attributes+36       ;get empty sprite attributes
00BCA3  2  09 40                  ora #%01000000                 ;set horizontal flip bit for bottom-right sprite
00BCA5  2  8D 22 02               sta Sprite_Attributes+32       ;store and leave
00BCA8  2  60                     rts
00BCA9  2               
00BCA9  2               ;-------------------------------------------------------------------------------------
00BCA9  2               ;$00-$01 - used to hold tile numbers, $00 also used to hold upper extent of animation frames
00BCA9  2               ;$02 - vertical position
00BCA9  2               ;$03 - facing direction, used as horizontal flip control
00BCA9  2               ;$04 - attributes
00BCA9  2               ;$05 - horizontal position
00BCA9  2               ;$07 - number of rows to draw
00BCA9  2               ;these also used in IntermediatePlayerData
00BCA9  2               
00BCA9  2               RenderPlayerSub:
00BCA9  2  85 07                sta $07                      ;store number of rows of sprites to draw
00BCAB  2  AD AD 03             lda Player_Rel_XPos
00BCAE  2  8D 55 07             sta Player_Pos_ForScroll     ;store player's relative horizontal position
00BCB1  2  85 05                sta $05                      ;store it here also
00BCB3  2  AD B8 03             lda Player_Rel_YPos
00BCB6  2  85 02                sta $02                      ;store player's vertical position
00BCB8  2  A5 33                lda PlayerFacingDir
00BCBA  2  85 03                sta $03                      ;store player's facing direction
00BCBC  2  AD C4 03             lda Player_SprAttrib
00BCBF  2  85 04                sta $04                      ;store player's sprite attributes
00BCC1  2  AE D5 06             ldx PlayerGfxOffset          ;load graphics table offset
00BCC4  2  AC E4 06             ldy Player_SprDataOffset     ;get player's sprite data offset
00BCC7  2               
00BCC7  2               DrawPlayerLoop:
00BCC7  2  BD 02 BB             lda PlayerGraphicsTable,x    ;load player's left side
00BCCA  2  85 00                sta $00
00BCCC  2  BD 03 BB             lda PlayerGraphicsTable+1,x  ;now load right side
00BCCF  2  20 9D B8             jsr DrawOneSpriteRow
00BCD2  2  C6 07                dec $07                      ;decrement rows of sprites to draw
00BCD4  2  D0 F1                bne DrawPlayerLoop           ;do this until all rows are drawn
00BCD6  2  60                   rts
00BCD7  2               
00BCD7  2               ProcessPlayerAction:
00BCD7  2  A5 1D                lda Player_State      ;get player's state
00BCD9  2  C9 03                cmp #$03
00BCDB  2  F0 5C                beq ActionClimbing    ;if climbing, branch here
00BCDD  2  C9 02                cmp #$02
00BCDF  2  F0 48                beq ActionFalling     ;if falling, branch here
00BCE1  2  C9 01                cmp #$01
00BCE3  2  D0 11                bne ProcOnGroundActs  ;if not jumping, branch here
00BCE5  2  AD 04 07             lda SwimmingFlag
00BCE8  2  D0 5B                bne ActionSwimming    ;if swimming flag set, branch elsewhere
00BCEA  2  A0 06                ldy #$06              ;load offset for crouching
00BCEC  2  AD 14 07             lda CrouchingFlag     ;get crouching flag
00BCEF  2  D0 2C                bne NonAnimatedActs   ;if set, branch to get offset for graphics table
00BCF1  2  A0 00                ldy #$00              ;otherwise load offset for jumping
00BCF3  2  4C 1D BD             jmp NonAnimatedActs   ;go to get offset to graphics table
00BCF6  2               
00BCF6  2               ProcOnGroundActs:
00BCF6  2  A0 06                 ldy #$06                   ;load offset for crouching
00BCF8  2  AD 14 07              lda CrouchingFlag          ;get crouching flag
00BCFB  2  D0 20                 bne NonAnimatedActs        ;if set, branch to get offset for graphics table
00BCFD  2  A0 02                 ldy #$02                   ;load offset for standing
00BCFF  2  A5 57                 lda Player_X_Speed         ;check player's horizontal speed
00BD01  2  05 0C                 ora Left_Right_Buttons     ;and left/right controller bits
00BD03  2  F0 18                 beq NonAnimatedActs        ;if no speed or buttons pressed, use standing offset
00BD05  2  AD 00 07              lda Player_XSpeedAbsolute  ;load walking/running speed
00BD08  2  C9 09                 cmp #$09
00BD0A  2  90 25                 bcc ActionWalkRun          ;if less than a certain amount, branch, too slow to skid
00BD0C  2  A5 45                 lda Player_MovingDir       ;otherwise check to see if moving direction
00BD0E  2  25 33                 and PlayerFacingDir        ;and facing direction are the same
00BD10  2  D0 1F                 bne ActionWalkRun          ;if moving direction = facing direction, branch, don't skid
00BD12  2  A5 0E                 lda GameEngineSubroutine
00BD14  2  C9 09                 cmp #$09                   ;if running the change size, fire flower, injure
00BD16  2  B0 04                 bcs NoSkidS                ;or death game engine subroutines, skip this
00BD18  2  A9 80                 lda #$80                   ;otherwise play skid sound
00BD1A  2  85 FD                 sta NoiseSoundQueue
00BD1C  2  C8           NoSkidS: iny                        ;increment to skid offset ($03)
00BD1D  2               
00BD1D  2               NonAnimatedActs:
00BD1D  2  20 86 BD             jsr GetGfxOffsetAdder      ;do a sub here to get offset adder for graphics table
00BD20  2  A9 00                lda #$00
00BD22  2  8D 0D 07             sta PlayerAnimCtrl         ;initialize animation frame control
00BD25  2  B9 F2 BA             lda PlayerGfxTblOffsets,y  ;load offset to graphics table using size as offset
00BD28  2  60                   rts
00BD29  2               
00BD29  2               ActionFalling:
00BD29  2  A0 04                ldy #$04                  ;load offset for walking/running
00BD2B  2  20 86 BD             jsr GetGfxOffsetAdder     ;get offset to graphics table
00BD2E  2  4C 57 BD             jmp GetCurrentAnimOffset  ;execute instructions for falling state
00BD31  2               
00BD31  2               ActionWalkRun:
00BD31  2  A0 04                ldy #$04               ;load offset for walking/running
00BD33  2  20 86 BD             jsr GetGfxOffsetAdder  ;get offset to graphics table
00BD36  2  4C 5D BD             jmp FourFrameExtent    ;execute instructions for normal state
00BD39  2               
00BD39  2               ActionClimbing:
00BD39  2  A0 05                ldy #$05               ;load offset for climbing
00BD3B  2  A5 9F                lda Player_Y_Speed     ;check player's vertical speed
00BD3D  2  F0 DE                beq NonAnimatedActs    ;if no speed, branch, use offset as-is
00BD3F  2  20 86 BD             jsr GetGfxOffsetAdder  ;otherwise get offset for graphics table
00BD42  2  4C 62 BD             jmp ThreeFrameExtent   ;then skip ahead to more code
00BD45  2               
00BD45  2               ActionSwimming:
00BD45  2  A0 01                ldy #$01               ;load offset for swimming
00BD47  2  20 86 BD             jsr GetGfxOffsetAdder
00BD4A  2  AD 82 07             lda JumpSwimTimer      ;check jump/swim timer
00BD4D  2  0D 0D 07             ora PlayerAnimCtrl     ;and animation frame control
00BD50  2  D0 0B                bne FourFrameExtent    ;if any one of these set, branch ahead
00BD52  2  A5 0A                lda A_B_Buttons
00BD54  2  0A                   asl                    ;check for A button pressed
00BD55  2  B0 06                bcs FourFrameExtent    ;branch to same place if A button pressed
00BD57  2               
00BD57  2               GetCurrentAnimOffset:
00BD57  2  AD 0D 07             lda PlayerAnimCtrl         ;get animation frame control
00BD5A  2  4C C5 BD             jmp GetOffsetFromAnimCtrl  ;jump to get proper offset to graphics table
00BD5D  2               
00BD5D  2               FourFrameExtent:
00BD5D  2  A9 03                lda #$03              ;load upper extent for frame control
00BD5F  2  4C 64 BD             jmp AnimationControl  ;jump to get offset and animate player object
00BD62  2               
00BD62  2               ThreeFrameExtent:
00BD62  2  A9 02                lda #$02              ;load upper extent for frame control for climbing
00BD64  2               
00BD64  2               AnimationControl:
00BD64  2  85 00                  sta $00                   ;store upper extent here
00BD66  2  20 57 BD               jsr GetCurrentAnimOffset  ;get proper offset to graphics table
00BD69  2  48                     pha                       ;save offset to stack
00BD6A  2  AD 81 07               lda PlayerAnimTimer       ;load animation frame timer
00BD6D  2  D0 15                  bne ExAnimC               ;branch if not expired
00BD6F  2  AD 0C 07               lda PlayerAnimTimerSet    ;get animation frame timer amount
00BD72  2  8D 81 07               sta PlayerAnimTimer       ;and set timer accordingly
00BD75  2  AD 0D 07               lda PlayerAnimCtrl
00BD78  2  18                     clc                       ;add one to animation frame control
00BD79  2  69 01                  adc #$01
00BD7B  2  C5 00                  cmp $00                   ;compare to upper extent
00BD7D  2  90 02                  bcc SetAnimC              ;if frame control + 1 < upper extent, use as next
00BD7F  2  A9 00                  lda #$00                  ;otherwise initialize frame control
00BD81  2  8D 0D 07     SetAnimC: sta PlayerAnimCtrl        ;store as new animation frame control
00BD84  2  68           ExAnimC:  pla                       ;get offset to graphics table from stack and leave
00BD85  2  60                     rts
00BD86  2               
00BD86  2               GetGfxOffsetAdder:
00BD86  2  AD 54 07             lda PlayerSize  ;get player's size
00BD89  2  F0 05                beq SzOfs       ;if player big, use current offset as-is
00BD8B  2  98                   tya             ;for big player
00BD8C  2  18                   clc             ;otherwise add eight bytes to offset
00BD8D  2  69 08                adc #$08        ;for small player
00BD8F  2  A8                   tay
00BD90  2  60           SzOfs:  rts             ;go back
00BD91  2               
00BD91  2               ChangeSizeOffsetAdder:
00BD91  2  00 01 00 01          .byte $00, $01, $00, $01, $00, $01, $02, $00, $01, $02
00BD95  2  00 01 02 00  
00BD99  2  01 02        
00BD9B  2  02 00 02 00          .byte $02, $00, $02, $00, $02, $00, $02, $00, $02, $00
00BD9F  2  02 00 02 00  
00BDA3  2  02 00        
00BDA5  2               
00BDA5  2               HandleChangeSize:
00BDA5  2  AC 0D 07              ldy PlayerAnimCtrl           ;get animation frame control
00BDA8  2  A5 09                 lda FrameCounter
00BDAA  2  29 03                 and #%00000011               ;get frame counter and execute this code every
00BDAC  2  D0 0D                 bne GorSLog                  ;fourth frame, otherwise branch ahead
00BDAE  2  C8                    iny                          ;increment frame control
00BDAF  2  C0 0A                 cpy #$0a                     ;check for preset upper extent
00BDB1  2  90 05                 bcc CSzNext                  ;if not there yet, skip ahead to use
00BDB3  2  A0 00                 ldy #$00                     ;otherwise initialize both grow/shrink flag
00BDB5  2  8C 0B 07              sty PlayerChangeSizeFlag     ;and animation frame control
00BDB8  2  8C 0D 07     CSzNext: sty PlayerAnimCtrl           ;store proper frame control
00BDBB  2  AD 54 07     GorSLog: lda PlayerSize               ;get player's size
00BDBE  2  D0 0C                 bne ShrinkPlayer             ;if player small, skip ahead to next part
00BDC0  2  B9 91 BD              lda ChangeSizeOffsetAdder,y  ;get offset adder based on frame control as offset
00BDC3  2  A0 0F                 ldy #$0f                     ;load offset for player growing
00BDC5  2               
00BDC5  2               GetOffsetFromAnimCtrl:
00BDC5  2  0A                   asl                        ;multiply animation frame control
00BDC6  2  0A                   asl                        ;by eight to get proper amount
00BDC7  2  0A                   asl                        ;to add to our offset
00BDC8  2  79 F2 BA             adc PlayerGfxTblOffsets,y  ;add to offset to graphics table
00BDCB  2  60                   rts                        ;and return with result in A
00BDCC  2               
00BDCC  2               ShrinkPlayer:
00BDCC  2  98                   tya                          ;add ten bytes to frame control as offset
00BDCD  2  18                   clc
00BDCE  2  69 0A                adc #$0a                     ;this thing apparently uses two of the swimming frames
00BDD0  2  AA                   tax                          ;to draw the player shrinking
00BDD1  2  A0 09                ldy #$09                     ;load offset for small player swimming
00BDD3  2  BD 91 BD             lda ChangeSizeOffsetAdder,x  ;get what would normally be offset adder
00BDD6  2  D0 02                bne ShrPlF                   ;and branch to use offset if nonzero
00BDD8  2  A0 01                ldy #$01                     ;otherwise load offset for big player swimming
00BDDA  2  B9 F2 BA     ShrPlF: lda PlayerGfxTblOffsets,y    ;get offset to graphics table based on offset loaded
00BDDD  2  60                   rts                          ;and leave
00BDDE  2               
00BDDE  2               ChkForPlayerAttrib:
00BDDE  2  AC E4 06                ldy Player_SprDataOffset    ;get sprite data offset
00BDE1  2  A5 0E                   lda GameEngineSubroutine
00BDE3  2  C9 0B                   cmp #$0b                    ;if executing specific game engine routine,
00BDE5  2  F0 13                   beq KilledAtt               ;branch to change third and fourth row OAM attributes
00BDE7  2  AD D5 06                lda PlayerGfxOffset         ;get graphics table offset
00BDEA  2  C9 50                   cmp #$50
00BDEC  2  F0 1E                   beq C_S_IGAtt               ;if crouch offset, either standing offset,
00BDEE  2  C9 B8                   cmp #$b8                    ;or intermediate growing offset,
00BDF0  2  F0 1A                   beq C_S_IGAtt               ;go ahead and execute code to change
00BDF2  2  C9 C0                   cmp #$c0                    ;fourth row OAM attributes only
00BDF4  2  F0 16                   beq C_S_IGAtt
00BDF6  2  C9 C8                   cmp #$c8
00BDF8  2  D0 24                   bne ExPlyrAt                ;if none of these, branch to leave
00BDFA  2  B9 12 02     KilledAtt: lda Sprite_Attributes+16,y
00BDFD  2  29 3F                   and #%00111111              ;mask out horizontal and vertical flip bits
00BDFF  2  99 12 02                sta Sprite_Attributes+16,y  ;for third row sprites and save
00BE02  2  B9 16 02                lda Sprite_Attributes+20,y
00BE05  2  29 3F                   and #%00111111
00BE07  2  09 40                   ora #%01000000              ;set horizontal flip bit for second
00BE09  2  99 16 02                sta Sprite_Attributes+20,y  ;sprite in the third row
00BE0C  2  B9 1A 02     C_S_IGAtt: lda Sprite_Attributes+24,y
00BE0F  2  29 3F                   and #%00111111              ;mask out horizontal and vertical flip bits
00BE11  2  99 1A 02                sta Sprite_Attributes+24,y  ;for fourth row sprites and save
00BE14  2  B9 1E 02                lda Sprite_Attributes+28,y
00BE17  2  29 3F                   and #%00111111
00BE19  2  09 40                   ora #%01000000              ;set horizontal flip bit for second
00BE1B  2  99 1E 02                sta Sprite_Attributes+28,y  ;sprite in the fourth row
00BE1E  2  60           ExPlyrAt:  rts                         ;leave
00BE1F  2               
00BE1F  2               ;-------------------------------------------------------------------------------------
00BE1F  2               ;$00 - used in adding to get proper offset
00BE1F  2               
00BE1F  2               RelativePlayerPosition:
00BE1F  2  A2 00                ldx #$00      ;set offsets for relative cooordinates
00BE21  2  A0 00                ldy #$00      ;routine to correspond to player object
00BE23  2  4C 37 BE             jmp RelWOfs   ;get the coordinates
00BE26  2               
00BE26  2               RelativeBubblePosition:
00BE26  2  A0 01                ldy #$01                ;set for air bubble offsets
00BE28  2  20 9D BE             jsr GetProperObjOffset  ;modify X to get proper air bubble offset
00BE2B  2  A0 03                ldy #$03
00BE2D  2  4C 37 BE             jmp RelWOfs             ;get the coordinates
00BE30  2               
00BE30  2               RelativeFireballPosition:
00BE30  2  A0 00                 ldy #$00                    ;set for fireball offsets
00BE32  2  20 9D BE              jsr GetProperObjOffset      ;modify X to get proper fireball offset
00BE35  2  A0 02                 ldy #$02
00BE37  2  20 66 BE     RelWOfs: jsr GetObjRelativePosition  ;get the coordinates
00BE3A  2  A6 08                 ldx ObjectOffset            ;return original offset
00BE3C  2  60                    rts                         ;leave
00BE3D  2               
00BE3D  2               RelativeMiscPosition:
00BE3D  2  A0 02                ldy #$02                ;set for misc object offsets
00BE3F  2  20 9D BE             jsr GetProperObjOffset  ;modify X to get proper misc object offset
00BE42  2  A0 06                ldy #$06
00BE44  2  4C 37 BE             jmp RelWOfs             ;get the coordinates
00BE47  2               
00BE47  2               RelativeEnemyPosition:
00BE47  2  A9 01                lda #$01                     ;get coordinates of enemy object
00BE49  2  A0 01                ldy #$01                     ;relative to the screen
00BE4B  2  4C 5A BE             jmp VariableObjOfsRelPos
00BE4E  2               
00BE4E  2               RelativeBlockPosition:
00BE4E  2  A9 09                lda #$09                     ;get coordinates of one block object
00BE50  2  A0 04                ldy #$04                     ;relative to the screen
00BE52  2  20 5A BE             jsr VariableObjOfsRelPos
00BE55  2  E8                   inx                          ;adjust offset for other block object if any
00BE56  2  E8                   inx
00BE57  2  A9 09                lda #$09
00BE59  2  C8                   iny                          ;adjust other and get coordinates for other one
00BE5A  2               
00BE5A  2               VariableObjOfsRelPos:
00BE5A  2  86 00                stx $00                     ;store value to add to A here
00BE5C  2  18                   clc
00BE5D  2  65 00                adc $00                     ;add A to value stored
00BE5F  2  AA                   tax                         ;use as enemy offset
00BE60  2  20 66 BE             jsr GetObjRelativePosition
00BE63  2  A6 08                ldx ObjectOffset            ;reload old object offset and leave
00BE65  2  60                   rts
00BE66  2               
00BE66  2               GetObjRelativePosition:
00BE66  2  B5 CE                lda SprObject_Y_Position,x  ;load vertical coordinate low
00BE68  2  99 B8 03             sta SprObject_Rel_YPos,y    ;store here
00BE6B  2  B5 86                lda SprObject_X_Position,x  ;load horizontal coordinate
00BE6D  2  38                   sec                         ;subtract left edge coordinate
00BE6E  2  ED 1C 07             sbc ScreenLeft_X_Pos
00BE71  2  99 AD 03             sta SprObject_Rel_XPos,y    ;store result here
00BE74  2  60                   rts
00BE75  2               
00BE75  2               ;-------------------------------------------------------------------------------------
00BE75  2               ;$00 - used as temp variable to hold offscreen bits
00BE75  2               
00BE75  2               GetPlayerOffscreenBits:
00BE75  2  A2 00                ldx #$00                 ;set offsets for player-specific variables
00BE77  2  A0 00                ldy #$00                 ;and get offscreen information about player
00BE79  2  4C B5 BE             jmp GetOffScreenBitsSet
00BE7C  2               
00BE7C  2               GetFireballOffscreenBits:
00BE7C  2  A0 00                ldy #$00                 ;set for fireball offsets
00BE7E  2  20 9D BE             jsr GetProperObjOffset   ;modify X to get proper fireball offset
00BE81  2  A0 02                ldy #$02                 ;set other offset for fireball's offscreen bits
00BE83  2  4C B5 BE             jmp GetOffScreenBitsSet  ;and get offscreen information about fireball
00BE86  2               
00BE86  2               GetBubbleOffscreenBits:
00BE86  2  A0 01                ldy #$01                 ;set for air bubble offsets
00BE88  2  20 9D BE             jsr GetProperObjOffset   ;modify X to get proper air bubble offset
00BE8B  2  A0 03                ldy #$03                 ;set other offset for airbubble's offscreen bits
00BE8D  2  4C B5 BE             jmp GetOffScreenBitsSet  ;and get offscreen information about air bubble
00BE90  2               
00BE90  2               GetMiscOffscreenBits:
00BE90  2  A0 02                ldy #$02                 ;set for misc object offsets
00BE92  2  20 9D BE             jsr GetProperObjOffset   ;modify X to get proper misc object offset
00BE95  2  A0 06                ldy #$06                 ;set other offset for misc object's offscreen bits
00BE97  2  4C B5 BE             jmp GetOffScreenBitsSet  ;and get offscreen information about misc object
00BE9A  2               
00BE9A  2               ObjOffsetData:
00BE9A  2  07 16 0D             .byte $07, $16, $0d
00BE9D  2               
00BE9D  2               GetProperObjOffset:
00BE9D  2  8A                   txa                  ;move offset to A
00BE9E  2  18                   clc
00BE9F  2  79 9A BE             adc ObjOffsetData,y  ;add amount of bytes to offset depending on setting in Y
00BEA2  2  AA                   tax                  ;put back in X and leave
00BEA3  2  60                   rts
00BEA4  2               
00BEA4  2               GetEnemyOffscreenBits:
00BEA4  2  A9 01                lda #$01                 ;set A to add 1 byte in order to get enemy offset
00BEA6  2  A0 01                ldy #$01                 ;set Y to put offscreen bits in Enemy_OffscreenBits
00BEA8  2  4C AF BE             jmp SetOffscrBitsOffset
00BEAB  2               
00BEAB  2               GetBlockOffscreenBits:
00BEAB  2  A9 09                lda #$09       ;set A to add 9 bytes in order to get block obj offset
00BEAD  2  A0 04                ldy #$04       ;set Y to put offscreen bits in Block_OffscreenBits
00BEAF  2               
00BEAF  2               SetOffscrBitsOffset:
00BEAF  2  86 00                stx $00
00BEB1  2  18                   clc           ;add contents of X to A to get
00BEB2  2  65 00                adc $00       ;appropriate offset, then give back to X
00BEB4  2  AA                   tax
00BEB5  2               
00BEB5  2               GetOffScreenBitsSet:
00BEB5  2  98                   tya                         ;save offscreen bits offset to stack for now
00BEB6  2  48                   pha
00BEB7  2  20 CC BE             jsr RunOffscrBitsSubs
00BEBA  2  0A                   asl                         ;move low nybble to high nybble
00BEBB  2  0A                   asl
00BEBC  2  0A                   asl
00BEBD  2  0A                   asl
00BEBE  2  05 00                ora $00                     ;mask together with previously saved low nybble
00BEC0  2  85 00                sta $00                     ;store both here
00BEC2  2  68                   pla                         ;get offscreen bits offset from stack
00BEC3  2  A8                   tay
00BEC4  2  A5 00                lda $00                     ;get value here and store elsewhere
00BEC6  2  99 D0 03             sta SprObject_OffscrBits,y
00BEC9  2  A6 08                ldx ObjectOffset
00BECB  2  60                   rts
00BECC  2               
00BECC  2               RunOffscrBitsSubs:
00BECC  2  20 EB BE             jsr GetXOffscreenBits  ;do subroutine here
00BECF  2  4A                   lsr                    ;move high nybble to low
00BED0  2  4A                   lsr
00BED1  2  4A                   lsr
00BED2  2  4A                   lsr
00BED3  2  85 00                sta $00                ;store here
00BED5  2  4C 2E BF             jmp GetYOffscreenBits
00BED8  2               
00BED8  2               ;--------------------------------
00BED8  2               ;(these apply to these three subsections)
00BED8  2               ;$04 - used to store proper offset
00BED8  2               ;$05 - used as adder in DividePDiff
00BED8  2               ;$06 - used to store preset value used to compare to pixel difference in $07
00BED8  2               ;$07 - used to store difference between coordinates of object and screen edges
00BED8  2               
00BED8  2               XOffscreenBitsData:
00BED8  2  7F 3F 1F 0F          .byte $7f, $3f, $1f, $0f, $07, $03, $01, $00
00BEDC  2  07 03 01 00  
00BEE0  2  80 C0 E0 F0          .byte $80, $c0, $e0, $f0, $f8, $fc, $fe, $ff
00BEE4  2  F8 FC FE FF  
00BEE8  2               
00BEE8  2               DefaultXOnscreenOfs:
00BEE8  2  07 0F 07             .byte $07, $0f, $07
00BEEB  2               
00BEEB  2               GetXOffscreenBits:
00BEEB  2  86 04                  stx $04                     ;save position in buffer to here
00BEED  2  A0 01                  ldy #$01                    ;start with right side of screen
00BEEF  2  B9 1C 07     XOfsLoop: lda ScreenEdge_X_Pos,y      ;get pixel coordinate of edge
00BEF2  2  38                     sec                         ;get difference between pixel coordinate of edge
00BEF3  2  F5 86                  sbc SprObject_X_Position,x  ;and pixel coordinate of object position
00BEF5  2  85 07                  sta $07                     ;store here
00BEF7  2  B9 1A 07               lda ScreenEdge_PageLoc,y    ;get page location of edge
00BEFA  2  F5 6D                  sbc SprObject_PageLoc,x     ;subtract from page location of object position
00BEFC  2  BE E8 BE               ldx DefaultXOnscreenOfs,y   ;load offset value here
00BEFF  2  C9 00                  cmp #$00
00BF01  2  30 10                  bmi XLdBData                ;if beyond right edge or in front of left edge, branch
00BF03  2  BE E9 BE               ldx DefaultXOnscreenOfs+1,y ;if not, load alternate offset value here
00BF06  2  C9 01                  cmp #$01
00BF08  2  10 09                  bpl XLdBData                ;if one page or more to the left of either edge, branch
00BF0A  2  A9 38                  lda #$38                    ;if no branching, load value here and store
00BF0C  2  85 06                  sta $06
00BF0E  2  A9 08                  lda #$08                    ;load some other value and execute subroutine
00BF10  2  20 62 BF               jsr DividePDiff
00BF13  2  BD D8 BE     XLdBData: lda XOffscreenBitsData,x    ;get bits here
00BF16  2  A6 04                  ldx $04                     ;reobtain position in buffer
00BF18  2  C9 00                  cmp #$00                    ;if bits not zero, branch to leave
00BF1A  2  D0 03                  bne ExXOfsBS
00BF1C  2  88                     dey                         ;otherwise, do left side of screen now
00BF1D  2  10 D0                  bpl XOfsLoop                ;branch if not already done with left side
00BF1F  2  60           ExXOfsBS: rts
00BF20  2               
00BF20  2               ;--------------------------------
00BF20  2               
00BF20  2               YOffscreenBitsData:
00BF20  2  0F 07 03 01          .byte $0f, $07, $03, $01
00BF24  2  00 08 0C 0E          .byte $00, $08, $0c, $0e
00BF28  2  00                   .byte $00
00BF29  2               
00BF29  2               DefaultYOnscreenOfs:
00BF29  2  04 00 04             .byte $04, $00, $04
00BF2C  2               
00BF2C  2               HighPosUnitData:
00BF2C  2  00 FF                .byte $00, $ff
00BF2E  2               
00BF2E  2               GetYOffscreenBits:
00BF2E  2  86 04                  stx $04                      ;save position in buffer to here
00BF30  2  A0 01                  ldy #$01                     ;start with bottom of screen
00BF32  2  B9 2C BF     YOfsLoop: lda HighPosUnitData,y        ;load coordinate for edge of vertical unit
00BF35  2  38                     sec
00BF36  2  F5 CE                  sbc SprObject_Y_Position,x   ;subtract from vertical coordinate of object
00BF38  2  85 07                  sta $07                      ;store here
00BF3A  2  A9 01                  lda #$01                     ;subtract one from vertical high byte of object
00BF3C  2  F5 B5                  sbc SprObject_Y_HighPos,x
00BF3E  2  BE 29 BF               ldx DefaultYOnscreenOfs,y    ;load offset value here
00BF41  2  C9 00                  cmp #$00
00BF43  2  30 10                  bmi YLdBData                 ;if under top of the screen or beyond bottom, branch
00BF45  2  BE 2A BF               ldx DefaultYOnscreenOfs+1,y  ;if not, load alternate offset value here
00BF48  2  C9 01                  cmp #$01
00BF4A  2  10 09                  bpl YLdBData                 ;if one vertical unit or more above the screen, branch
00BF4C  2  A9 20                  lda #$20                     ;if no branching, load value here and store
00BF4E  2  85 06                  sta $06
00BF50  2  A9 04                  lda #$04                     ;load some other value and execute subroutine
00BF52  2  20 62 BF               jsr DividePDiff
00BF55  2  BD 20 BF     YLdBData: lda YOffscreenBitsData,x     ;get offscreen data bits using offset
00BF58  2  A6 04                  ldx $04                      ;reobtain position in buffer
00BF5A  2  C9 00                  cmp #$00
00BF5C  2  D0 03                  bne ExYOfsBS                 ;if bits not zero, branch to leave
00BF5E  2  88                     dey                          ;otherwise, do top of the screen now
00BF5F  2  10 D1                  bpl YOfsLoop
00BF61  2  60           ExYOfsBS: rts
00BF62  2               
00BF62  2               ;--------------------------------
00BF62  2               
00BF62  2               DividePDiff:
00BF62  2  85 05                  sta $05       ;store current value in A here
00BF64  2  A5 07                  lda $07       ;get pixel difference
00BF66  2  C5 06                  cmp $06       ;compare to preset value
00BF68  2  B0 0C                  bcs ExDivPD   ;if pixel difference >= preset value, branch
00BF6A  2  4A                     lsr           ;divide by eight
00BF6B  2  4A                     lsr
00BF6C  2  4A                     lsr
00BF6D  2  29 07                  and #$07      ;mask out all but 3 LSB
00BF6F  2  C0 01                  cpy #$01      ;right side of the screen or top?
00BF71  2  B0 02                  bcs SetOscrO  ;if so, branch, use difference / 8 as offset
00BF73  2  65 05                  adc $05       ;if not, add value to difference / 8
00BF75  2  AA           SetOscrO: tax           ;use as offset
00BF76  2  60           ExDivPD:  rts           ;leave
00BF77  2               
00BF77  2               ;-------------------------------------------------------------------------------------
00BF77  2               ;$00-$01 - tile numbers
00BF77  2               ;$02 - Y coordinate
00BF77  2               ;$03 - flip control
00BF77  2               ;$04 - sprite attributes
00BF77  2               ;$05 - X coordinate
00BF77  2               
00BF77  2               DrawSpriteObject:
00BF77  2  A5 03                 lda $03                    ;get saved flip control bits
00BF79  2  4A                    lsr
00BF7A  2  4A                    lsr                        ;move d1 into carry
00BF7B  2  A5 00                 lda $00
00BF7D  2  90 0C                 bcc NoHFlip                ;if d1 not set, branch
00BF7F  2  99 05 02              sta Sprite_Tilenumber+4,y  ;store first tile into second sprite
00BF82  2  A5 01                 lda $01                    ;and second into first sprite
00BF84  2  99 01 02              sta Sprite_Tilenumber,y
00BF87  2  A9 40                 lda #$40                   ;activate horizontal flip OAM attribute
00BF89  2  D0 0A                 bne SetHFAt                ;and unconditionally branch
00BF8B  2  99 01 02     NoHFlip: sta Sprite_Tilenumber,y    ;store first tile into first sprite
00BF8E  2  A5 01                 lda $01                    ;and second into second sprite
00BF90  2  99 05 02              sta Sprite_Tilenumber+4,y
00BF93  2  A9 00                 lda #$00                   ;clear bit for horizontal flip
00BF95  2  05 04        SetHFAt: ora $04                    ;add other OAM attributes if necessary
00BF97  2  99 02 02              sta Sprite_Attributes,y    ;store sprite attributes
00BF9A  2  99 06 02              sta Sprite_Attributes+4,y
00BF9D  2  A5 02                 lda $02                    ;now the y coordinates
00BF9F  2  99 00 02              sta Sprite_Y_Position,y    ;note because they are
00BFA2  2  99 04 02              sta Sprite_Y_Position+4,y  ;side by side, they are the same
00BFA5  2  A5 05                 lda $05
00BFA7  2  99 03 02              sta Sprite_X_Position,y    ;store x coordinate, then
00BFAA  2  18                    clc                        ;add 8 pixels and store another to
00BFAB  2  69 08                 adc #$08                   ;put them side by side
00BFAD  2  99 07 02              sta Sprite_X_Position+4,y
00BFB0  2  A5 02                 lda $02                    ;add eight pixels to the next y
00BFB2  2  18                    clc                        ;coordinate
00BFB3  2  69 08                 adc #$08
00BFB5  2  85 02                 sta $02
00BFB7  2  98                    tya                        ;add eight to the offset in Y to
00BFB8  2  18                    clc                        ;move to the next two sprites
00BFB9  2  69 08                 adc #$08
00BFBB  2  A8                    tay
00BFBC  2  E8                    inx                        ;increment offset to return it to the
00BFBD  2  E8                    inx                        ;routine that called this subroutine
00BFBE  2  60                    rts
00BFBF  2               
00BFBF  2               ;-------------------------------------------------------------------------------------
00BFBF  2               
00BFBF  2               .ifndef ANN
00BFBF  2               ;unused byte
00BFBF  2                .byte $ff
00BFBF  2               .endif
00BFBF  2               
00BFBF  2               ;-------------------------------------------------------------------------------------
00BFBF  2               
00BFBF  2               AttractModeSubs:
00BFBF  2  AD 72 07           lda OperMode_Task
00BFC2  2  20 0F 6D           jsr JumpEngine
00BFC5  2               
00BFC5  2  17 C0              .word AttractModeDiskRoutines
00BFC7  2  50 C5              .word InitializeGame
00BFC9  2               .ifdef ANN
00BFC9  2  8E C0              .word VMDelay
00BFCB  2               .endif
00BFCB  2  4C 65              .word ScreenRoutines
00BFCD  2  96 C5              .word PrimaryGameSetup
00BFCF  2  2B C4              .word GameMenuRoutine
00BFD1  2  D3 BF              .word HardWorldsCheckpoint
00BFD3  2               
00BFD3  2               HardWorldsCheckpoint:
00BFD3  2  AD FC 07           lda DiskIOTask
00BFD6  2  20 0F 6D           jsr JumpEngine
00BFD9  2               
00BFD9  2  29 C1              .word DiskScreen
00BFDB  2  E3 BF              .word LoadHardWorlds
00BFDD  2  3C C1              .word WaitForEject
00BFDF  2  4E C1              .word WaitForReinsert
00BFE1  2  56 C1              .word ResetDiskVars
00BFE3  2               
00BFE3  2               LoadHardWorlds:
00BFE3  2  AD FB 07              lda HardWorldFlag         ;if this is not set, skip this
00BFE6  2  F0 0F                 beq NoLoadHW
00BFE8  2  A9 03                 lda #$03
00BFEA  2  8D F7 07              sta FileListNumber        ;set filelist number to load SM2DATA4
00BFED  2  20 0A C1              jsr LoadFiles
00BFF0  2  D0 57                 bne ReturnedError         ;if returned with error number, branch
00BFF2  2  20 E0 C0              jsr CheckFileCount        ;check to see if loaded the correct number of files
00BFF5  2  D0 50                 bne BadFileCount          ;if not, branch to set error code
00BFF7  2               NoLoadHW:
00BFF7  2  20 86 C2              jsr LoadAreaPointer       ;update area pointer to get world 1 or A
00BFFA  2  AD FB 07              lda HardWorldFlag         ;if this is not set, skip this
00BFFD  2  F0 03                 beq NoCHWP                ;otherwise run sub in SM2DATA4 to change halfway pages
00BFFF  2  20 rr rr              jsr ChangeHalfwayPages    ;for worlds A thru D
00C002  2  EE 5D 07     NoCHWP:  inc Hidden1UpFlag
00C005  2  EE 57 07              inc FetchNewGameTimerFlag
00C008  2  EE 70 07              inc OperMode
00C00B  2  A9 00                 lda #$00
00C00D  2  8D FC 07              sta DiskIOTask
00C010  2  8D 72 07              sta OperMode_Task
00C013  2  8D A2 07              sta DemoTimer
00C016  2  60                    rts
00C017  2               
00C017  2               AttractModeDiskRoutines:
00C017  2  AD FC 07           lda DiskIOTask
00C01A  2  20 0F 6D           jsr JumpEngine
00C01D  2               
00C01D  2  29 C1              .word DiskScreen
00C01F  2  27 C0              .word LoadWorlds1Thru4
00C021  2  3C C1              .word WaitForEject
00C023  2  4E C1              .word WaitForReinsert
00C025  2  56 C1              .word ResetDiskVars
00C027  2               
00C027  2               LoadWorlds1Thru4:
00C027  2  AD FD 07                lda NotColdFlag       ;if not set, just cold booted, thus no need to check world info
00C02A  2  F0 23                   beq InitWorldPos
00C02C  2  AD FB 07                lda HardWorldFlag     ;if player was playing worlds A-D, skip ahead
00C02F  2  D0 07                   bne LW14Files         ;otherwise check the world number
00C031  2  AD 5F 07                lda WorldNumber
00C034  2  C9 04                   cmp #World5           ;if world number was less than 5, files still in memory
00C036  2  90 17                   bcc InitWorldPos      ;thus skip to the end, no need to load them again
00C038  2  A9 00        LW14Files: lda #$00              ;set filelist number to reload SM2MAIN, SM2CHAR1 and SM2SAVE
00C03A  2  8D F7 07                sta FileListNumber
00C03D  2  20 0A C1                jsr LoadFiles         ;now reload those files
00C040  2  D0 07                   bne ReturnedError     ;if returned with error number, branch
00C042  2  20 E0 C0                jsr CheckFileCount    ;check to see if loaded the correct number of files
00C045  2  F0 08                   beq InitWorldPos      ;if so, branch to init player's world info
00C047  2               
00C047  2               BadFileCount:
00C047  2  A9 40              lda #$40              ;otherwise, set error number
00C049  2               
00C049  2               ReturnedError:
00C049  2  EE FC 07           inc DiskIOTask        ;move on to next subtask
00C04C  2  4C 98 C1           jmp DiskErrorHandler
00C04F  2               
00C04F  2               InitWorldPos:
00C04F  2  A9 01              lda #$01              ;set flag to check player's world info
00C051  2  8D FD 07           sta NotColdFlag       ;before erasing it
00C054  2  4A                 lsr
00C055  2  8D 5F 07           sta WorldNumber       ;reset world number
00C058  2  8D FB 07           sta HardWorldFlag     ;force worlds 1-8 by default
00C05B  2  4C 89 C0           jmp ResetDiskIOTask   ;end disk subroutines
00C05E  2               
00C05E  2               
00C05E  2               GameModeDiskRoutines:
00C05E  2  AD FC 07           lda DiskIOTask
00C061  2  20 0F 6D           jsr JumpEngine
00C064  2               
00C064  2  29 C1              .word DiskScreen
00C066  2  6E C0              .word LoadWorlds5Thru8
00C068  2  3C C1              .word WaitForEject
00C06A  2  4E C1              .word WaitForReinsert
00C06C  2  56 C1              .word ResetDiskVars
00C06E  2               
00C06E  2               LoadWorlds5Thru8:
00C06E  2  AD 5F 07           lda WorldNumber       ;if in worlds 1-4 or A-D
00C071  2  C9 04              cmp #World5           ;then leave without loading anything
00C073  2  90 14              bcc ResetDiskIOTask
00C075  2  AD F7 07           lda FileListNumber    ;if worlds 5-8 were already loaded, leave
00C078  2  D0 0F              bne ResetDiskIOTask   ;as there's no need to load anything
00C07A  2  A9 01              lda #$01
00C07C  2  8D F7 07           sta FileListNumber    ;otherwise set filelist number to load SM2DATA2
00C07F  2  20 0A C1           jsr LoadFiles         ;and load it
00C082  2  D0 C5              bne ReturnedError     ;if returned with error number, branch
00C084  2  20 E0 C0           jsr CheckFileCount    ;check to see if loaded the correct number of files
00C087  2  D0 BE              bne BadFileCount      ;if not, branch to return error 40/$32
00C089  2               
00C089  2               ResetDiskIOTask:
00C089  2  A9 00              lda #$00              ;reset disk-related task number for next time
00C08B  2  8D FC 07           sta DiskIOTask
00C08E  2               VMDelay:
00C08E  2  EE 72 07           inc OperMode_Task     ;move on to next task in the current mode
00C091  2  60                 rts
00C092  2               
00C092  2               StartVMDelay:
00C092  2  A9 10              lda #$10           ;start world end delay
00C094  2  8D A1 07           sta WorldEndTimer
00C097  2  D0 F5              bne VMDelay
00C099  2               
00C099  2               ContinueVMDelay:
00C099  2  AD A1 07           lda WorldEndTimer  ;wait for delay to end, then move on
00C09C  2  F0 F0              beq VMDelay
00C09E  2  60                 rts
00C09F  2               
00C09F  2               VictoryModeDiskRoutines:
00C09F  2  AD FC 07           lda DiskIOTask
00C0A2  2  20 0F 6D           jsr JumpEngine
00C0A5  2               
00C0A5  2  29 C1              .word DiskScreen
00C0A7  2  AF C0              .word LoadEnding
00C0A9  2  3C C1              .word WaitForEject
00C0AB  2  4E C1              .word WaitForReinsert
00C0AD  2  56 C1              .word ResetDiskVars
00C0AF  2               
00C0AF  2               LoadEnding:
00C0AF  2  A9 02                lda #$02                 ;set filelist number to load SM2DATA3, SM2CHAR2 and SM2SAVE
00C0B1  2  8D F7 07             sta FileListNumber
00C0B4  2  20 0A C1             jsr LoadFiles            ;load them now
00C0B7  2  D0 90                bne ReturnedError
00C0B9  2  20 E0 C0             jsr CheckFileCount       ;check to see if loaded the correct number of files
00C0BC  2  F0 05                beq AddBeatenGame        ;if so, continue
00C0BE  2  A9 00                lda #$00                 ;otherwise reset count of games beaten
00C0C0  2  8D E3 D2             sta GamesBeatenCount
00C0C3  2               AddBeatenGame:
00C0C3  2  AD E3 D2             lda GamesBeatenCount     ;get the new count of games beaten we loaded (or reset)
00C0C6  2  18                   clc                      ;add one to it, to a maximum of 24/$18
00C0C7  2  69 01                adc #$01
00C0C9  2               .ifdef ANN
00C0C9  2  C9 15                cmp #21
00C0CB  2               .else
00C0CB  2                       cmp #25
00C0CB  2               .endif
00C0CB  2  90 02                bcc SetS2S
00C0CD  2               .ifdef ANN
00C0CD  2  A9 14                lda #20                  ;sorry, only 20 stars allowed
00C0CF  2               .else
00C0CF  2                       lda #24                  ;sorry, only 24 stars allowed
00C0CF  2               .endif
00C0CF  2  8D E3 D2     SetS2S: sta GamesBeatenCount
00C0D2  2               .ifdef ANN
00C0D2  2  A9 01                lda #$01
00C0D4  2  8D 7D 07             sta PrimaryHardMode
00C0D7  2               .endif
00C0D7  2  20 24 6D             jsr InitializeNameTables
00C0DA  2  20 89 C0             jsr ResetDiskIOTask      ;end disk subroutines
00C0DD  2  4C rr rr             jmp WriteNameToVictoryMsg
00C0E0  2               
00C0E0  2               CheckFileCount:
00C0E0  2  98                 tya                      ;save number of files loaded to A
00C0E1  2  AC F7 07           ldy FileListNumber       ;use file list number as offset
00C0E4  2  D9 06 C1           cmp FileCount,y          ;compare to number of files supposed to be loaded
00C0E7  2  60                 rts
00C0E8  2               
00C0E8  2               ;disk ID string copy used in FDS BIOS load routine
00C0E8  2               ;to compare to original at the disk info block
00C0E8  2               DiskIDString:
00C0E8  2               .ifdef ANN
00C0E8  2  01 4E 53 4D        .byte $01, $4E, $53, $4d, $20
00C0EC  2  20           
00C0ED  2  00 00 00 00        .byte $00, $00, $00, $00, $00
00C0F1  2  00           
00C0F2  2               .else
00C0F2  2                     .byte $01, $53, $4d, $42, $20
00C0F2  2                     .byte $00, $00, $00, $00, $00
00C0F2  2               .endif
00C0F2  2               
00C0F2  2               FileListAddrLow:
00C0F2  2  FA FE 00 04        .byte <World14List, <World58List, <EndingList, <WorldADList
00C0F6  2               FileListAddrHigh:
00C0F6  2  C0 C0 C1 C1        .byte >World14List, >World58List, >EndingList, >WorldADList
00C0FA  2               
00C0FA  2               ;file lists used by FDS bios to load files
00C0FA  2               ;value $ff is end terminator
00C0FA  2               World14List:
00C0FA  2  01 05 0F FF        .byte $01, $05, $0f, $ff
00C0FE  2               World58List:
00C0FE  2  20 FF              .byte $20, $ff
00C100  2               EndingList:
00C100  2  10 30 0F FF        .byte $10, $30, $0f, $ff
00C104  2               WorldADList:
00C104  2  40 FF              .byte $40, $ff
00C106  2               
00C106  2               FileCount:
00C106  2  03 01 03 01        .byte $03, $01, $03, $01
00C10A  2               
00C10A  2               LoadFiles:
00C10A  2  AE F7 07           ldx FileListNumber      ;get address to file list
00C10D  2  BD F2 C0           lda FileListAddrLow,x
00C110  2  8D 1E C1           sta ListPointer
00C113  2  BD F6 C0           lda FileListAddrHigh,x
00C116  2  8D 1F C1           sta ListPointer+1
00C119  2  20 F8 E1           jsr FDSBIOS_LOADFILES   ;now load the files
00C11C  2               
00C11C  2               ;used by FDS BIOS routine
00C11C  2  E8 C0                     .word DiskIDString
00C11E  2  FA C0        ListPointer: .word World14List  ;overwritten in RAM
00C120  2               
00C120  2               ;execution continues here
00C120  2  60                 rts
00C121  2               
00C121  2               DiskScreenPalette:
00C121  2  3F 00 04       .byte $3f, $00, $04
00C124  2  0F 30 30 0F    .byte $0f, $30, $30, $0f
00C128  2  00             .byte $00
00C129  2               
00C129  2               DiskScreen:
00C129  2  A9 00              lda #$00
00C12B  2  8D 79 07           sta Mirror_PPU_MASK
00C12E  2  8D 01 20           sta PPU_MASK
00C131  2  EE 74 07           inc DisableScreenFlag
00C134  2  A9 1A              lda #$1a
00C136  2  8D 73 07           sta VRAM_Buffer_AddrCtrl
00C139  2  4C 4A C1           jmp NextDiskIOTask
00C13C  2               
00C13C  2               WaitForEject:
00C13C  2  A9 00              lda #$00
00C13E  2  8D 7A 07           sta NameTableSelect
00C141  2  8D 74 07           sta DisableScreenFlag
00C144  2  AD 32 40           lda FDS_DRIVE_STATUS  ;check disk inserted flag
00C147  2  4A                 lsr                   ;execute this routine until disk is ejected
00C148  2  90 03              bcc ThisDiskIOTask    ;note this routine is run on an error
00C14A  2               
00C14A  2               NextDiskIOTask:
00C14A  2  EE FC 07           inc DiskIOTask        ;move on to next subtask involving the disk drive
00C14D  2               ThisDiskIOTask:
00C14D  2  60                 rts                   ;or not, if branched here
00C14E  2               
00C14E  2               WaitForReinsert:
00C14E  2  AD 32 40           lda FDS_DRIVE_STATUS  ;check disk inserted flag
00C151  2  4A                 lsr                   ;execute this routine until disk is reinserted
00C152  2  90 F6              bcc NextDiskIOTask    ;note this routine is run after the one
00C154  2  B0 F7              bcs ThisDiskIOTask    ;that checks for an ejected disk
00C156  2               
00C156  2               ResetDiskVars:
00C156  2  A9 00              lda #$00
00C158  2  8D FC 07           sta DiskIOTask        ;reset disk-related variables
00C15B  2  8D F7 07           sta FileListNumber
00C15E  2  60                 rts
00C15F  2               
00C15F  2               DiskErrorMainMsg:
00C15F  2  21 E6 08       .byte $21, $e6, $08
00C162  2  24 24 24 24    .byte $24, $24, $24, $24, $24, $24, $24, $24
00C166  2  24 24 24 24  
00C16A  2  21 F4 06       .byte $21, $f4, $06
00C16D  2  0E 1B 1B 24    .byte $0e, $1b, $1b, $24, $00, $01
00C171  2  00 01        
00C173  2  00             .byte $00
00C174  2               
00C174  2               ;disk error message offsets
00C174  2               ;note these actually point to the last byte
00C174  2               DiskErrorMsgOffsets:
00C174  2  07 0F 17 1F    .byte $07, $0f, $17, $1f
00C178  2               
00C178  2               DiskErrorMsgs:
00C178  2               ;"        "
00C178  2  24 24 24 24    .byte $24, $24, $24, $24, $24, $24, $24, $24
00C17C  2  24 24 24 24  
00C180  2               ;"DISK SET"
00C180  2  0D 12 1C 14    .byte $0d, $12, $1c, $14, $24, $1c, $0e, $1d
00C184  2  24 1C 0E 1D  
00C188  2               ;"BATTERY "
00C188  2  0B 0A 1D 1D    .byte $0b, $0a, $1d, $1d, $0e, $1b, $22, $24
00C18C  2  0E 1B 22 24  
00C190  2               ;"A B SIDE"
00C190  2  0A 24 0B 24    .byte $0a, $24, $0b, $24, $1c, $12, $0d, $0e
00C194  2  1C 12 0D 0E  
00C198  2               
00C198  2               DiskErrorHandler:
00C198  2  48             pha
00C199  2  29 0F          and #$0f
00C19B  2  8D 72 C1       sta DiskErrorMainMsg+$13  ;write lower nybble of error number as digit
00C19E  2  68             pla
00C19F  2  48             pha
00C1A0  2  4A             lsr
00C1A1  2  4A             lsr
00C1A2  2  4A             lsr
00C1A3  2  4A             lsr
00C1A4  2  8D 71 C1       sta DiskErrorMainMsg+$12  ;now write the upper nybble of error number
00C1A7  2  A0 03          ldy #$03
00C1A9  2  68             pla
00C1AA  2  C9 07          cmp #$07                  ;if a/b side error was found, branch
00C1AC  2  F0 0B          beq LoadError
00C1AE  2  88             dey
00C1AF  2  C9 02          cmp #$02                  ;if battery low error was found, branch
00C1B1  2  F0 06          beq LoadError
00C1B3  2  88             dey
00C1B4  2  C9 01          cmp #$01                  ;if disk not set error was found, branch
00C1B6  2  F0 01          beq LoadError
00C1B8  2  88             dey                       ;otherwise print blank for any other error or no error
00C1B9  2               LoadError:
00C1B9  2  BE 74 C1       ldx DiskErrorMsgOffsets,y ;get offset to error message
00C1BC  2  A0 07          ldy #$07                  ;use to load error message to vram string
00C1BE  2               LELoop:
00C1BE  2  BD 78 C1       lda DiskErrorMsgs,x
00C1C1  2  99 62 C1       sta DiskErrorMainMsg+3,y
00C1C4  2  CA             dex
00C1C5  2  88             dey
00C1C6  2  10 F6          bpl LELoop
00C1C8  2  A9 19          lda #$19
00C1CA  2  8D 73 07       sta VRAM_Buffer_AddrCtrl     ;print error message on next NMI
00C1CD  2  20 8A 62       jsr MoveAllSpritesOffscreen  ;init the screen
00C1D0  2  4C 24 6D       jmp InitializeNameTables
00C1D3  2               
00C1D3  2               GameOverCursorData:
00C1D3  2  5B 02 48       .byte $5b, $02, $48
00C1D6  2               
00C1D6  2               GameOverCursorY:
00C1D6  2  77 8F          .byte $77, $8f
00C1D8  2               
00C1D8  2               GameOverMenu:
00C1D8  2  AD FC 06                 lda SavedJoypadBits          ;if player pressed the start button
00C1DB  2  29 10                    and #Start_Button            ;then either continue or start over
00C1DD  2  D0 2D                    bne ContinueOrRetry
00C1DF  2  AD FC 06                 lda SavedJoypadBits
00C1E2  2  29 20                    and #Select_Button           ;if player pressed the select button
00C1E4  2  F0 11                    beq ChgSel                   ;then branch to select "continue" or "retry"
00C1E6  2  AE 80 07                 ldx SelectTimer              ;if select timer not expired while
00C1E9  2  D0 0C                    bne ChgSel                   ;pressing select, skip this
00C1EB  2  4A                       lsr
00C1EC  2  8D 80 07                 sta SelectTimer              ;otherwise set the select timer
00C1EF  2  AD F8 07                 lda ContinueMenuSelect
00C1F2  2  49 01                    eor #$01                     ;and toggle between the two choices
00C1F4  2  8D F8 07                 sta ContinueMenuSelect
00C1F7  2  A0 02        ChgSel:     ldy #$02
00C1F9  2  B9 D3 C1     ChgSelLoop: lda GameOverCursorData,y     ;set up cursor sprite tile, attribute
00C1FC  2  99 01 02                 sta Sprite_Data+1,y          ;and X position in sprite OAM data
00C1FF  2  88                       dey
00C200  2  10 F7                    bpl ChgSelLoop
00C202  2  AC F8 07                 ldy ContinueMenuSelect
00C205  2  B9 D6 C1                 lda GameOverCursorY,y        ;set Y position based on the selection
00C208  2  8D 00 02                 sta Sprite_Data
00C20B  2  60                       rts
00C20C  2               
00C20C  2               ContinueOrRetry:
00C20C  2  AD F8 07       lda ContinueMenuSelect       ;if player selected "continue"
00C20F  2  F0 03          beq Continue                 ;then branch to continue
00C211  2               .ifndef ANN
00C211  2                 lda #$00
00C211  2                 sta CompletedWorlds          ;otherwise init completed worlds flags
00C211  2               .endif
00C211  2  4C 09 71       jmp TerminateGame            ;and end the game
00C214  2               
00C214  2               Continue:
00C214  2  A0 02                ldy #$02
00C216  2  8C 5A 07             sty NumberofLives           ;give three lives
00C219  2  8D 5C 07             sta LevelNumber
00C21C  2  8D 60 07             sta AreaNumber              ;put at x-1 of the current world
00C21F  2  8D 5E 07             sta CoinTally
00C222  2  A0 0B                ldy #$0b
00C224  2  99 DD 07     ISCont: sta ScoreAndCoinDisplay,y   ;reset score
00C227  2  88                   dey
00C228  2  10 FA                bpl ISCont
00C22A  2  EE 5D 07             inc Hidden1UpFlag           ;allow 1-up to be found again
00C22D  2  4C 19 71             jmp ContinueGame
00C230  2               
00C230  2               ;-------------------------------------------------------------------------------------
00C230  2               
00C230  2               ;jump, fall and friction physics data used with mario and luigi
00C230  2               ;note luigi's higher jump, but with lesser friction
00C230  2               JumpFrictionData:
00C230  2  20 20 1E 28    .byte $20, $20, $1e, $28, $28, $0d, $04
00C234  2  28 0D 04     
00C237  2  70 70 60 90    .byte $70, $70, $60, $90, $90, $0a, $09
00C23B  2  90 0A 09     
00C23E  2               
00C23E  2  E4 98 D0       .byte $e4, $98, $d0
00C241  2               
00C241  2  18 18 18 22    .byte $18, $18, $18, $22, $22, $0d, $04
00C245  2  22 0D 04     
00C248  2  42 42 3E 5D    .byte $42, $42, $3e, $5d, $5d, $0a, $09
00C24C  2  5D 0A 09     
00C24F  2               
00C24F  2  B4 68 A0       .byte $b4, $68, $a0
00C252  2               
00C252  2               LoadPhysicsData:
00C252  2  A2 60          ldx #$60               ;use luigi's offsets and RTS opcode
00C254  2  A0 21          ldy #$21
00C256  2  AD 53 07       lda SelectedPlayer     ;if selected luigi, branch to continue
00C259  2  D0 04          bne ModifyPhysics
00C25B  2               LoadMarioPhysics:
00C25B  2  A2 0E          ldx #$0e               ;otherwise use mario's offsets and ASL opcode
00C25D  2  A0 10          ldy #$10
00C25F  2               ModifyPhysics:
00C25F  2  8E 45 81       stx PhyOpcode          ;load opcode into friction code to modify it
00C262  2  A2 10          ldx #$10
00C264  2               MPhyLoop:
00C264  2  B9 30 C2       lda JumpFrictionData,y ;load physics data for the selected player
00C267  2  9D E4 7F       sta JumpMForceData,x
00C26A  2  88             dey
00C26B  2  CA             dex
00C26C  2  10 F6          bpl MPhyLoop
00C26E  2  60             rts
00C26F  2               
00C26F  2               .ifndef ANN
00C26F  2               ;unused bytes
00C26F  2                 .byte $ff, $ff
00C26F  2               
00C26F  2               ;-------------------------------------------------------------------------------------
00C26F  2               
00C26F  2               ;enemy data used by pipe intro area, warp zone area and exit area
00C26F  2               E_GroundArea10:
00C26F  2               E_GroundArea21:
00C26F  2               E_GroundArea28:
00C26F  2                 .byte $ff
00C26F  2               
00C26F  2               ;exit area used in levels 1-2, 3-2, 5-2, 6-2, A-2 and B-2
00C26F  2               L_GroundArea28:
00C26F  2                 .byte $90, $31, $39, $f1, $bf, $37, $33, $e7, $a3, $03, $a7, $03, $cd, $41, $0f, $a6
00C26F  2                 .byte $ed, $47, $fd
00C26F  2               
00C26F  2               ;pipe intro area
00C26F  2               L_GroundArea10:
00C26F  2                 .byte $38, $11, $0f, $26, $ad, $40, $3d, $c7, $fd
00C26F  2               
00C26F  2               ;warp zone area used in levels 1-2 and 5-2
00C26F  2               L_GroundArea21:
00C26F  2                 .byte $10, $00, $0b, $13, $5b, $14, $6a, $42, $c7, $12, $c6, $42, $1b, $94, $2a, $42
00C26F  2                 .byte $53, $13, $62, $41, $97, $17, $a6, $45, $6e, $81, $8f, $37, $02, $e8, $12, $3a
00C26F  2                 .byte $68, $7a, $de, $0f, $6d, $c5, $fd
00C26F  2               .else
00C26F  2               E_Area11:
00C26F  2               E_Area20:
00C26F  2               E_Area2C:
00C26F  2               E_HArea10:
00C26F  2               E_HArea11:
00C26F  2  FF           .byte $FF
00C270  2               
00C270  2               L_Area11:
00C270  2               L_HArea10:
00C270  2  38 11 0F 26  .byte $38,$11,$0F,$26,$AD,$40,$3D,$C7,$FD
00C274  2  AD 40 3D C7  
00C278  2  FD           
00C279  2               
00C279  2               L_Area20:
00C279  2               L_HArea11:
00C279  2  90 31 39 F1  .byte $90,$31,$39,$F1,$5F,$38,$6D,$C1,$AF,$26,$8D,$C7
00C27D  2  5F 38 6D C1  
00C281  2  AF 26 8D C7  
00C285  2               L_Area2C:
00C285  2  FD           .byte $FD
00C286  2               .endif
00C286  2               
00C286  2               
00C286  2               LoadAreaPointer:
00C286  2  20 96 C2                  jsr FindAreaPointer  ;find it and store it here
00C289  2  8D 50 07                  sta AreaPointer
00C28C  2  29 60        GetAreaType: and #%01100000       ;mask out all but d6 and d5
00C28E  2  0A                        asl
00C28F  2  2A                        rol
00C290  2  2A                        rol
00C291  2  2A                        rol                  ;make %0xx00000 into %000000xx
00C292  2  8D 4E 07                  sta AreaType         ;save 2 MSB as area type
00C295  2  60                        rts
00C296  2               
00C296  2               FindAreaPointer:
00C296  2  AC 5F 07           ldy WorldNumber        ;load offset from world variable
00C299  2  B9 39 C3           lda WorldAddrOffsets,y
00C29C  2  18                 clc                    ;add area number used to find data
00C29D  2  6D 60 07           adc AreaNumber
00C2A0  2  A8                 tay
00C2A1  2  B9 41 C3           lda AreaAddrOffsets,y  ;from there we have our area pointer
00C2A4  2  60                 rts
00C2A5  2               
00C2A5  2               GetAreaDataAddrs:
00C2A5  2  AD 50 07                 lda AreaPointer          ;use 2 MSB for Y
00C2A8  2  20 8C C2                 jsr GetAreaType
00C2AB  2  A8                       tay
00C2AC  2  AD 50 07                 lda AreaPointer          ;mask out all but 5 LSB
00C2AF  2  29 1F                    and #%00011111
00C2B1  2  8D 4F 07                 sta AreaAddrsLOffset     ;save as low offset
00C2B4  2  B9 6F C3                 lda EnemyAddrHOffsets,y  ;load base value with 2 altered MSB,
00C2B7  2  18                       clc                      ;then add base value to 5 LSB, result
00C2B8  2  6D 4F 07                 adc AreaAddrsLOffset     ;becomes offset for level data
00C2BB  2  0A                       asl
00C2BC  2  A8                       tay
00C2BD  2  B9 74 C3                 lda EnemyDataAddrs+1,y   ;use offset to load pointer
00C2C0  2  85 EA                    sta EnemyDataHigh
00C2C2  2  B9 73 C3                 lda EnemyDataAddrs,y
00C2C5  2  85 E9                    sta EnemyDataLow
00C2C7  2  AC 4E 07                 ldy AreaType             ;use area type as offset
00C2CA  2  B9 CD C3                 lda AreaDataHOffsets,y   ;do the same thing but with different base value
00C2CD  2  18                       clc
00C2CE  2  6D 4F 07                 adc AreaAddrsLOffset
00C2D1  2  0A                       asl
00C2D2  2  A8                       tay
00C2D3  2  B9 D2 C3                 lda AreaDataAddrs+1,y    ;use this offset to load another pointer
00C2D6  2  85 E8                    sta AreaDataHigh
00C2D8  2  B9 D1 C3                 lda AreaDataAddrs,y
00C2DB  2  85 E7                    sta AreaDataLow
00C2DD  2  A0 00                    ldy #$00                 ;load first byte of header
00C2DF  2  B1 E7                    lda (AreaData),y
00C2E1  2  48                       pha                      ;save it to the stack for now
00C2E2  2  29 07                    and #%00000111           ;save 3 LSB for foreground scenery or bg color control
00C2E4  2  C9 04                    cmp #$04
00C2E6  2  90 05                    bcc StoreFore
00C2E8  2  8D 44 07                 sta BackgroundColorCtrl  ;if 4 or greater, save value here as bg color control
00C2EB  2  A9 00                    lda #$00
00C2ED  2  8D 41 07     StoreFore:  sta ForegroundScenery    ;if less, save value here as foreground scenery
00C2F0  2  68                       pla                      ;pull byte from stack and push it back
00C2F1  2  48                       pha
00C2F2  2  29 38                    and #%00111000           ;save player entrance control bits
00C2F4  2  4A                       lsr                      ;shift bits over to LSBs
00C2F5  2  4A                       lsr
00C2F6  2  4A                       lsr
00C2F7  2  8D 10 07                 sta PlayerEntranceCtrl       ;save value here as player entrance control
00C2FA  2  68                       pla                      ;pull byte again but do not push it back
00C2FB  2  29 C0                    and #%11000000           ;save 2 MSB for game timer setting
00C2FD  2  18                       clc
00C2FE  2  2A                       rol                      ;rotate bits over to LSBs
00C2FF  2  2A                       rol
00C300  2  2A                       rol
00C301  2  8D 15 07                 sta GameTimerSetting     ;save value here as game timer setting
00C304  2  C8                       iny
00C305  2  B1 E7                    lda (AreaData),y         ;load second byte of header
00C307  2  48                       pha                      ;save to stack
00C308  2  29 0F                    and #%00001111           ;mask out all but lower nybble
00C30A  2  8D 27 07                 sta TerrainControl
00C30D  2  68                       pla                      ;pull and push byte to copy it to A
00C30E  2  48                       pha
00C30F  2  29 30                    and #%00110000           ;save 2 MSB for background scenery type
00C311  2  4A                       lsr
00C312  2  4A                       lsr                      ;shift bits to LSBs
00C313  2  4A                       lsr
00C314  2  4A                       lsr
00C315  2  8D 42 07                 sta BackgroundScenery    ;save as background scenery
00C318  2  68                       pla
00C319  2  29 C0                    and #%11000000
00C31B  2  18                       clc
00C31C  2  2A                       rol                      ;rotate bits over to LSBs
00C31D  2  2A                       rol
00C31E  2  2A                       rol
00C31F  2  C9 03                    cmp #%00000011           ;if set to 3, store here
00C321  2  D0 05                    bne StoreStyle           ;and nullify other value
00C323  2  8D 43 07                 sta CloudTypeOverride    ;otherwise store value in other place
00C326  2  A9 00                    lda #$00
00C328  2  8D 33 07     StoreStyle: sta AreaStyle
00C32B  2  A5 E7                    lda AreaDataLow          ;increment area data address by 2 bytes
00C32D  2  18                       clc
00C32E  2  69 02                    adc #$02
00C330  2  85 E7                    sta AreaDataLow
00C332  2  A5 E8                    lda AreaDataHigh
00C334  2  69 00                    adc #$00
00C336  2  85 E8                    sta AreaDataHigh
00C338  2  60                       rts
00C339  2               
00C339  2               ;-------------------------------------------------------------------------------------
00C339  2               
00C339  2               WorldAddrOffsets:
00C339  2  00 05          .byte World1Areas-AreaAddrOffsets, World2Areas-AreaAddrOffsets
00C33B  2  0A 0E          .byte World3Areas-AreaAddrOffsets, World4Areas-AreaAddrOffsets
00C33D  2  13 17          .byte World5Areas-AreaAddrOffsets, World6Areas-AreaAddrOffsets
00C33F  2  1B 20          .byte World7Areas-AreaAddrOffsets, World8Areas-AreaAddrOffsets
00C341  2               .ifndef ANN
00C341  2                 .byte World9Areas-AreaAddrOffsets
00C341  2               .endif
00C341  2               
00C341  2               AreaAddrOffsets:
00C341  2               .ifdef ANN
00C341  2  25 3B C0 26  World1Areas: .byte $25, $3B, $C0, $26, $60
00C345  2  60           
00C346  2  28 29 01 27  World2Areas: .byte $28, $29, $01, $27, $62
00C34A  2  62           
00C34B  2  24 35 20 63  World3Areas: .byte $24, $35, $20, $63
00C34F  2  22 29 41 2C  World4Areas: .byte $22, $29, $41, $2C, $61
00C353  2  61           
00C354  2  2A 31 36 67  World5Areas: .byte $2A, $31, $36, $67
00C358  2  2E 23 2D 66  World6Areas: .byte $2E, $23, $2D, $66
00C35C  2  33 29 03 37  World7Areas: .byte $33, $29, $03, $37, $64
00C360  2  64           
00C361  2  30 32 21 65  World8Areas: .byte $30, $32, $21, $65
00C365  2               .else
00C365  2               World1Areas: .byte $20, $29, $40, $21, $60
00C365  2               World2Areas: .byte $22, $23, $24, $61
00C365  2               World3Areas: .byte $25, $29, $00, $26, $62
00C365  2               World4Areas: .byte $27, $28, $2a, $63
00C365  2               World5Areas: .byte $2b, $29, $43, $2c, $64
00C365  2               World6Areas: .byte $2d, $29, $01, $2e, $65
00C365  2               World7Areas: .byte $2f, $30, $31, $66
00C365  2               World8Areas: .byte $32, $35, $36, $67
00C365  2               World9Areas: .byte $38, $06, $68, $07
00C365  2               .endif
00C365  2               
00C365  2               AreaDataOfsLoopback:
00C365  2               .ifdef ANN
00C365  2  12 36 0E 0E    .byte $12, $36, $0E, $0E, $0E, $32, $32, $32, $0C, $54
00C369  2  0E 32 32 32  
00C36D  2  0C 54        
00C36F  2               .else
00C36F  2                 .byte $0c, $0c, $42, $42, $10, $10, $30, $30, $06, $0c, $54, $06
00C36F  2               .endif
00C36F  2               
00C36F  2               EnemyAddrHOffsets:
00C36F  2               .ifdef ANN
00C36F  2  28 08 24 00    .byte $28, $08, $24, $00
00C373  2               .else
00C373  2                 .byte $2c, $0a, $27, $00
00C373  2               .endif
00C373  2               
00C373  2               EnemyDataAddrs:
00C373  2               .ifdef ANN
00C373  2  45 C7 62 C7  .addr E_Area00, E_Area01, E_Area02, E_Area03, E_Area04, E_Area05, E_Area06, E_Area07
00C377  2  7B C7 9E C7  
00C37B  2  rr rr rr rr  
00C383  2  C7 C7 rr rr  .addr E_Area08, E_Area09, E_Area0A, E_Area0B, E_Area0C, E_Area0D, E_Area0E, E_Area0F
00C387  2  E8 C7 rr rr  
00C38B  2  F8 C7 29 C8  
00C393  2  67 C8 6F C2  .addr E_Area10, E_Area11, E_Area12, E_Area13, E_Area14, E_Area15, E_Area16, E_Area17
00C397  2  rr rr 96 C8  
00C39B  2  9C C8 rr rr  
00C3A3  2  rr rr rr rr  .addr E_Area18, E_Area19, E_Area1A, E_Area1B, E_Area1C, E_Area1D, E_Area1E, E_Area1F
00C3A7  2  rr rr rr rr  
00C3AB  2  C1 C8 C7 C8  
00C3B3  2  6F C2 rr rr  .addr E_Area20, E_Area21, E_Area22, E_Area23, E_Area24, E_Area25, E_Area26, E_Area27
00C3B7  2  rr rr EB C8  
00C3BB  2  EC C8 19 C9  
00C3C3  2  rr rr 62 C9  .addr E_Area28, E_Area29, E_Area2A, E_Area2B, E_Area11
00C3C7  2  rr rr rr rr  
00C3CB  2  6F C2        
00C3CD  2               .else
00C3CD  2                 .word E_CastleArea1, E_CastleArea2, E_CastleArea3, E_CastleArea4, E_CastleArea5, E_CastleArea6
00C3CD  2                 .word E_CastleArea7, E_CastleArea8, E_CastleArea9, E_CastleArea10, E_GroundArea1, E_GroundArea2
00C3CD  2                 .word E_GroundArea3, E_GroundArea4, E_GroundArea5, E_GroundArea6, E_GroundArea7, E_GroundArea8
00C3CD  2                 .word E_GroundArea9, E_GroundArea10, E_GroundArea11, E_GroundArea12, E_GroundArea13, E_GroundArea14
00C3CD  2                 .word E_GroundArea15, E_GroundArea16, E_GroundArea17, E_GroundArea18, E_GroundArea19, E_GroundArea20
00C3CD  2                 .word E_GroundArea21, E_GroundArea22, E_GroundArea23, E_GroundArea24, E_GroundArea25, E_GroundArea26
00C3CD  2                 .word E_GroundArea27, E_GroundArea28, E_GroundArea29, E_UndergroundArea1, E_UndergroundArea2
00C3CD  2                 .word E_UndergroundArea3, E_UndergroundArea4, E_UndergroundArea5, E_WaterArea1, E_WaterArea2
00C3CD  2                 .word E_WaterArea3, E_WaterArea4, E_WaterArea5, E_WaterArea6, E_WaterArea7, E_WaterArea8
00C3CD  2               .endif
00C3CD  2               
00C3CD  2               AreaDataHOffsets:
00C3CD  2               .ifdef ANN
00C3CD  2  28 08 24 00    .byte $28, $08, $24, $00
00C3D1  2               .else
00C3D1  2                 .byte $2c, $0a, $27, $00
00C3D1  2               .endif
00C3D1  2               
00C3D1  2               AreaDataAddrs:
00C3D1  2               .ifdef ANN
00C3D1  2  7B C9 D2 C9  .addr L_Area00, L_Area01, L_Area02, L_Area03, L_Area04, L_Area05, L_Area06, L_Area07
00C3D5  2  53 CA C2 CA  
00C3D9  2  rr rr rr rr  
00C3E1  2  2D CB rr rr  .addr L_Area08, L_Area09, L_Area0A, L_Area0B, L_Area0C, L_Area0D, L_Area0E, L_Area0F
00C3E5  2  8A CB rr rr  
00C3E9  2  DD CB 4E CC  
00C3F1  2  85 CD 70 C2  .addr L_Area10, L_Area11, L_Area12, L_Area13, L_Area14, L_Area15, L_Area16, L_Area17
00C3F5  2  rr rr E8 CD  
00C3F9  2  FD CD rr rr  
00C401  2  rr rr rr rr  .addr L_Area18, L_Area19, L_Area1A, L_Area1B, L_Area1C, L_Area1D, L_Area1E, L_Area1F
00C405  2  rr rr rr rr  
00C409  2  85 CE B0 CE  
00C411  2  79 C2 rr rr  .addr L_Area20, L_Area21, L_Area22, L_Area23, L_Area24, L_Area25, L_Area26, L_Area27
00C415  2  rr rr E7 CE  
00C419  2  F0 CE 91 CF  
00C421  2  rr rr C3 D0  .addr L_Area28, L_Area29, L_Area2A, L_Area2B, L_Area2C
00C425  2  rr rr rr rr  
00C429  2  85 C2        
00C42B  2               .else
00C42B  2                 .word L_CastleArea1, L_CastleArea2, L_CastleArea3, L_CastleArea4, L_CastleArea5, L_CastleArea6
00C42B  2                 .word L_CastleArea7, L_CastleArea8, L_CastleArea9, L_CastleArea10, L_GroundArea1, L_GroundArea2
00C42B  2                 .word L_GroundArea3, L_GroundArea4, L_GroundArea5, L_GroundArea6, L_GroundArea7, L_GroundArea8
00C42B  2                 .word L_GroundArea9, L_GroundArea10, L_GroundArea11, L_GroundArea12, L_GroundArea13, L_GroundArea14
00C42B  2                 .word L_GroundArea15, L_GroundArea16, L_GroundArea17, L_GroundArea18, L_GroundArea19, L_GroundArea20
00C42B  2                 .word L_GroundArea21, L_GroundArea22, L_GroundArea23, L_GroundArea24, L_GroundArea25, L_GroundArea26
00C42B  2                 .word L_GroundArea27, L_GroundArea28, L_GroundArea29, L_UndergroundArea1, L_UndergroundArea2
00C42B  2                 .word L_UndergroundArea3, L_UndergroundArea4, L_UndergroundArea5, L_WaterArea1, L_WaterArea2
00C42B  2                 .word L_WaterArea3, L_WaterArea4, L_WaterArea5, L_WaterArea6, L_WaterArea7, L_WaterArea8
00C42B  2               ;some unused bytes
00C42B  2                 .byte $ff, $ff
00C42B  2               .endif
00C42B  2               
00C42B  2               GameMenuRoutine:
00C42B  2  AD FC 06                   lda SavedJoypadBits         ;check to see if the player pressed start
00C42E  2  29 10                      and #Start_Button
00C430  2  F0 1C                      beq ChkSelect               ;if not, branch to check other buttons
00C432  2  A9 00                      lda #$00
00C434  2               .ifndef ANN
00C434  2                             sta CompletedWorlds
00C434  2               .endif
00C434  2  8D FC 07                   sta DiskIOTask
00C437  2  8D FB 07                   sta HardWorldFlag
00C43A  2  AD E3 D2                   lda GamesBeatenCount        ;check to see if player has beaten
00C43D  2  C9 08                      cmp #$08                    ;the game at least 8 times
00C43F  2  90 0A                      bcc StG                     ;if not, start the game as usual at world 1
00C441  2  AD FC 06                   lda SavedJoypadBits
00C444  2  29 80                      and #A_Button               ;check if the player pressed A + start
00C446  2  F0 03                      beq StG                     ;if not, start the game as usual at world 1
00C448  2  EE FB 07                   inc HardWorldFlag           ;otherwise start playing the letter worlds
00C44B  2  4C A6 C4     StG:          jmp StartGame
00C44E  2  AD FC 06     ChkSelect:    lda SavedJoypadBits
00C451  2  C9 20                      cmp #Select_Button          ;branch if pressing select
00C453  2  F0 0F                      beq SelectLogic
00C455  2  AE A2 07                   ldx DemoTimer
00C458  2  D0 2F                      bne NullJoypad
00C45A  2  8D 80 07                   sta SelectTimer             ;run demo after a certain period of time
00C45D  2  20 11 C5                   jsr DemoEngine
00C460  2  B0 35                      bcs ResetTitle
00C462  2  90 2A                      bcc RunDemo
00C464  2  AD A2 07     SelectLogic:  lda DemoTimer               ;if select pressed, check demo timer one last time
00C467  2  F0 2E                      beq ResetTitle              ;if demo timer expired, branch to reset attract mode
00C469  2  A9 18                      lda #$18                    ;otherwise reset demo timer
00C46B  2  8D A2 07                   sta DemoTimer
00C46E  2  A5 09                      lda FrameCounter            ;erase LSB of frame counter
00C470  2  29 FE                      and #$fe
00C472  2  85 09                      sta FrameCounter
00C474  2  AD 80 07                   lda SelectTimer             ;if select timer not expired, skip to slow select down
00C477  2  D0 10                      bne NullJoypad
00C479  2  A9 10                      lda #$10                    ;reset select button timer
00C47B  2  8D 80 07                   sta SelectTimer
00C47E  2  AD 53 07                   lda SelectedPlayer          ;switch between the two players to select one
00C481  2  49 01                      eor #$01
00C483  2  8D 53 07                   sta SelectedPlayer
00C486  2  20 D5 C4                   jsr DrawMenuCursor
00C489  2  A9 00        NullJoypad:   lda #$00
00C48B  2  8D FC 06                   sta SavedJoypadBits
00C48E  2  20 B9 7A     RunDemo:      jsr GameCoreRoutine         ;run game engine
00C491  2  A5 0E                      lda GameEngineSubroutine    ;check to see if we're running lose life routine
00C493  2  C9 06                      cmp #$06
00C495  2  D0 33                      bne ExitMenu                ;if not, do not do all the resetting below
00C497  2  A9 00        ResetTitle:   lda #$00                    ;reset game modes, disable
00C499  2  8D 70 07                   sta OperMode                ;IRQ update and screen output
00C49C  2  8D 72 07                   sta OperMode_Task           ;screen output
00C49F  2  8D 22 07                   sta IRQUpdateFlag
00C4A2  2  EE 74 07                   inc DisableScreenFlag
00C4A5  2  60                         rts
00C4A6  2               
00C4A6  2               StartGame:
00C4A6  2  AD A2 07                   lda DemoTimer
00C4A9  2  F0 EC                      beq ResetTitle
00C4AB  2  EE 72 07                   inc OperMode_Task
00C4AE  2  20 BA C5                   jsr PatchPlayerNamePal      ;patch data over based on selected player
00C4B1  2  A9 00                      lda #$00
00C4B3  2  8D 5F 07                   sta WorldNumber
00C4B6  2  A9 00                      lda #$00
00C4B8  2  8D 5C 07                   sta LevelNumber
00C4BB  2  A9 00                      lda #$00
00C4BD  2  8D 60 07                   sta AreaNumber
00C4C0  2  A2 0B                      ldx #$0b
00C4C2  2  A9 00                      lda #$00
00C4C4  2  9D DD 07     InitScore:    sta ScoreAndCoinDisplay,x   ;clear player score and coin display
00C4C7  2  CA                         dex
00C4C8  2  10 FA                      bpl InitScore
00C4CA  2  60           ExitMenu:     rts
00C4CB  2               
00C4CB  2               MenuCursorTemplate:
00C4CB  2  22 4B 83       .byte $22, $4b, $83
00C4CE  2  CE 24 24       .byte $ce, $24, $24
00C4D1  2  00             .byte $00
00C4D2  2               
00C4D2  2               MenuCursorTiles:
00C4D2  2  CE 24 CE       .byte $ce, $24, $ce
00C4D5  2               
00C4D5  2               DrawMenuCursor:
00C4D5  2  A9 1C          lda #$1c                 ;set up VRAM address controller to draw cursor
00C4D7  2  8D 73 07       sta VRAM_Buffer_AddrCtrl
00C4DA  2               
00C4DA  2               SetupMenuCursor:
00C4DA  2  AC 53 07       ldy SelectedPlayer       ;write blank and mushroom icon to template
00C4DD  2  B9 D2 C4       lda MenuCursorTiles,y    ;in the order based on selected player
00C4E0  2  8D CE C4       sta MenuCursorTemplate+3
00C4E3  2  B9 D3 C4       lda MenuCursorTiles+1,y  ;e.g. if mario, write mushroom, then blank
00C4E6  2  8D D0 C4       sta MenuCursorTemplate+5 ;and if luigi, write blank, then mushroom
00C4E9  2  60             rts
00C4EA  2               
00C4EA  2               .ifdef ANN
00C4EA  2               DemoActionData:
00C4EA  2  01 00 81 01    .byte $01, $00, $81, $01, $81, $42, $C2, $01
00C4EE  2  81 42 C2 01  
00C4F2  2  81 00 C1 41    .byte $81, $00, $C1, $41, $C1, $C2, $41, $C1
00C4F6  2  C1 C2 41 C1  
00C4FA  2  42 C2 00       .byte $42, $C2, $00
00C4FD  2               
00C4FD  2               DemoTimingData:
00C4FD  2  90 70 40 18    .byte $90, $70, $40, $18, $20, $10, $2C, $10
00C501  2  20 10 2C 10  
00C505  2  1C 70 78 08    .byte $1C, $70, $78, $08, $40, $20, $20, $40
00C509  2  40 20 20 40  
00C50D  2  40 20 B0 00    .byte $40, $20, $B0 ,$00
00C511  2               .else
00C511  2               DemoActionData:
00C511  2                 .byte $01, $81, $01, $81, $01, $81, $02, $01
00C511  2                 .byte $81, $00, $81, $00, $80, $01, $81, $01
00C511  2                 .byte $00
00C511  2               
00C511  2               DemoTimingData:
00C511  2                 .byte $b0, $10, $10, $10, $28, $10, $28, $06
00C511  2                 .byte $10, $10, $0c, $80, $10, $28, $08, $90
00C511  2                 .byte $ff, $00
00C511  2               .endif
00C511  2               
00C511  2               DemoEngine:
00C511  2  AE 17 07               ldx DemoAction         ;load current demo action
00C514  2  AD 18 07               lda DemoActionTimer    ;load current action timer
00C517  2  D0 0D                  bne DoAction           ;if timer still counting down, skip
00C519  2  E8                     inx
00C51A  2  EE 17 07               inc DemoAction         ;if expired, increment action, X, and
00C51D  2  38                     sec                    ;set carry by default for demo over
00C51E  2  BD FC C4               lda DemoTimingData-1,x ;get next timer
00C521  2  8D 18 07               sta DemoActionTimer    ;store as current timer
00C524  2  F0 0A                  beq DemoOver           ;if timer already at zero, skip
00C526  2  BD E9 C4     DoAction: lda DemoActionData-1,x ;get and perform action (current or next)
00C529  2  8D FC 06               sta SavedJoypad1Bits
00C52C  2  CE 18 07               dec DemoActionTimer    ;decrement action timer
00C52F  2  18                     clc                    ;clear carry if demo still going
00C530  2  60           DemoOver: rts
00C531  2               
00C531  2               ClearBuffersDrawIcon:
00C531  2  AD 70 07                  lda OperMode               ;check game mode
00C534  2  D0 17                     bne IncModeTask_B          ;if not attract mode, leave
00C536  2  A2 00                     ldx #$00                   ;otherwise, clear buffer space
00C538  2  9D 00 03     TScrClear:   sta VRAM_Buffer1-1,x
00C53B  2  9D 00 04                  sta VRAM_Buffer1-1+$100,x
00C53E  2  CA                        dex
00C53F  2  D0 F7                     bne TScrClear
00C541  2  20 D5 C4                  jsr DrawMenuCursor         ;draw player select cursor
00C544  2  EE 3C 07                  inc ScreenRoutineTask      ;move onto next task
00C547  2  60                        rts
00C548  2               
00C548  2               WriteTopScore:
00C548  2  A9 FA                       lda #$fa                    ;run display routine to display top score on title
00C54A  2  20 3A 88                    jsr WriteDigits
00C54D  2  4C B9 63     IncModeTask_B: jmp IncModeTask
00C550  2               
00C550  2               InitializeGame:
00C550  2  A9 00                    lda #$00
00C552  2               .ifndef ANN
00C552  2                           sta CompletedWorlds      ;clean slate player's progress (except for games beaten)
00C552  2               .endif
00C552  2  8D FB 07                 sta HardWorldFlag
00C555  2  8D 53 07                 sta SelectedPlayer
00C558  2  20 BA C5                 jsr PatchPlayerNamePal   ;set up mario's/luigi's name and palette
00C55B  2  20 DA C4                 jsr SetupMenuCursor      ;put menu cursor next to mario's name
00C55E  2               .ifdef ANN
00C55E  2  A0 47                    ldy #$47                 ;set up offset in the title screen tiles
00C560  2  A9 0A                    lda #$0a                 ;set up counter to print up to 10 stars per row
00C562  2               .else
00C562  2                           ldy #$33                 ;set up offset in the title screen tiles
00C562  2                           lda #$0c                 ;set up counter to print up to 12 stars per row
00C562  2               .endif
00C562  2  85 00                    sta $00
00C564  2  A2 00                    ldx #$00                 ;init star counter
00C566  2  A9 26        PrintStars: lda #$26                 ;print blank by default
00C568  2  EC E3 D2                 cpx GamesBeatenCount     ;check star counter against games beaten
00C56B  2  B0 02                    bcs PrintToTS            ;if counted up to games beaten, print the blank
00C56D  2  A9 F1                    lda #$f1                 ;otherwise print a star for a beaten game
00C56F  2  99 E6 C5     PrintToTS:  sta TitleScreenGfxData,y ;print to title screen
00C572  2  C8                       iny
00C573  2  C6 00                    dec $00                  ;decrement until done printing a row
00C575  2  D0 02                    bne NextStarR
00C577  2               .ifdef ANN
00C577  2  A0 2F                    ldy #$2F                 ;set up offset in title screen tiles for next row
00C579  2               .else
00C579  2                           ldy #$4d                 ;set up offset in title screen tiles for next row
00C579  2               .endif
00C579  2  E8           NextStarR:  inx
00C57A  2               .ifdef ANN
00C57A  2  E0 14                    cpx #$14                 ;printed 20 tiles yet?  if not, go back
00C57C  2               .else
00C57C  2                           cpx #$18                 ;printed 24 tiles yet?  if not, go back
00C57C  2               .endif
00C57C  2  D0 E8                    bne PrintStars
00C57E  2  A0 6F                    ldy #$6f                 ;clear all memory as in initialization procedure,
00C580  2  20 93 6F                 jsr InitializeMemory     ;but this time, clear only as far as $076f
00C583  2  A0 1F                    ldy #$1f
00C585  2  99 B0 07     ClrSndLoop: sta SoundMemory,y        ;clear out memory used
00C588  2  88                       dey                      ;by the sound engines
00C589  2  10 FA                    bpl ClrSndLoop
00C58B  2               
00C58B  2               DemoReset:
00C58B  2  A9 18                    lda #$18             ;set demo timer
00C58D  2  8D A2 07                 sta DemoTimer
00C590  2  20 86 C2                 jsr LoadAreaPointer
00C593  2  4C C9 6E                 jmp InitializeArea
00C596  2               
00C596  2               PrimaryGameSetup:
00C596  2  A9 01              lda #$01
00C598  2  8D 57 07           sta FetchNewGameTimerFlag   ;set flag to load game timer from header
00C59B  2  8D 54 07           sta PlayerSize              ;set player's size to small
00C59E  2  A9 02              lda #$02
00C5A0  2  8D 5A 07           sta NumberofLives           ;give each player three lives
00C5A3  2  4C 48 6F           jmp SecondaryGameSetup
00C5A6  2               
00C5A6  2               ;-------------------------------------------------------------------------------------
00C5A6  2               
00C5A6  2               PlayerNameData:
00C5A6  2  16 0A 1B 12    .byte $16, $0a, $1b, $12, $18 ;"MARIO"
00C5AA  2  18           
00C5AB  2  15 1E 12 10    .byte $15, $1e, $12, $10, $12 ;"LUIGI"
00C5AF  2  12           
00C5B0  2               
00C5B0  2               PlayerPaletteData:
00C5B0  2  22 16 27 18    .byte $22, $16, $27, $18
00C5B4  2  22 30 27 19    .byte $22, $30, $27, $19
00C5B8  2               
00C5B8  2               PlayerNameOffsets:
00C5B8  2  04 09          .byte $04, $09                       ;note that offsets point to last byte
00C5BA  2               
00C5BA  2               PatchPlayerNamePal:
00C5BA  2  AC 53 07                ldy SelectedPlayer        ;get offset based on selected player
00C5BD  2  B9 B8 C5                lda PlayerNameOffsets,y
00C5C0  2  48                      pha
00C5C1  2  C8                      iny
00C5C2  2  84 00                   sty $00                   ;save player + 1 temporarily (mario = 1, luigi = 2)
00C5C4  2  A8                      tay
00C5C5  2  A2 04                   ldx #$04
00C5C7  2  B9 A6 C5     NamePatch: lda PlayerNameData,y      ;get name of selected player
00C5CA  2  9D ED 66                sta TopStatusBarLine+3,x  ;patch to top status bar and victory message
00C5CD  2  9D DC 6C                sta ThankYouMessage+$d,x
00C5D0  2  88                      dey
00C5D1  2  CA                      dex
00C5D2  2  10 F3                   bpl NamePatch
00C5D4  2  68                      pla                       ;subtract player + 1 from offset loaded earlier
00C5D5  2  38                      sec                       ;to get proper offset for palette loading
00C5D6  2  E5 00                   sbc $00
00C5D8  2  A8                      tay
00C5D9  2  A2 03                   ldx #$03
00C5DB  2  B9 B0 C5     PalPatch:  lda PlayerPaletteData,y   ;overwrite palette with the appropriate one
00C5DE  2  9D BE 65                sta PlayerColors,x
00C5E1  2  88                      dey
00C5E2  2  CA                      dex
00C5E3  2  10 F6                   bpl PalPatch
00C5E5  2  60                      rts
00C5E6  2               
00C5E6  2               ;-------------------------------------------------------------------------------------
00C5E6  2               
00C5E6  2               TitleScreenGfxData:
00C5E6  2               .ifdef ANN
00C5E6  2  20 85 01 44        .byte $20,$85,$01,$44
00C5EA  2  20 86 55 48        .byte $20,$86,$55,$48
00C5EE  2  20 9B 01 49        .byte $20,$9B,$01,$49
00C5F2  2  20 A5 C9 46        .byte $20,$A5,$C9,$46
00C5F6  2  20 BB C9 4A        .byte $20,$BB,$C9,$4A
00C5FA  2  20 A6 15 EC        .byte $20,$A6,$15,$EC,$ED,$EE,$EF,$F3,$F4,$F5,$F6,$F7,$F8,$D0,$D1,$D8,$D8,$DE,$D1,$D0,$DA,$DE,$D1,$26
00C5FE  2  ED EE EF F3  
00C602  2  F4 F5 F6 F7  
00C612  2  20 C6 15 26        .byte $20,$C6,$15,$26,$26,$26,$26,$26,$26,$26,$26,$26,$26,$D2,$D3,$DB,$DB,$DB,$D9,$DB,$DC,$DB,$DF,$26
00C616  2  26 26 26 26  
00C61A  2  26 26 26 26  
00C62A  2  20 E6 15 26        .byte $20,$E6,$15,$26,$26,$26,$26,$26,$26,$26,$26,$26,$26,$D4,$D5,$D4,$D9,$DB,$E2,$D4,$DA,$DB,$E0,$26
00C62E  2  26 26 26 26  
00C632  2  26 26 26 26  
00C642  2  21 06 55 26        .byte $21,$06,$55,$26
00C646  2  21 10 0A D6        .byte $21,$10,$0A,$D6,$D7,$D6,$D7,$E1,$26,$D6,$DD,$E1,$E1
00C64A  2  D7 D6 D7 E1  
00C64E  2  26 D6 DD E1  
00C653  2  21 26 15 D0        .byte $21,$26,$15,$D0,$E8,$D1,$D0,$D1,$DE,$D1,$D8,$D0,$D1,$26,$DE,$D1,$DE,$D1,$D0,$D1,$D0,$D1,$26,$26
00C657  2  E8 D1 D0 D1  
00C65B  2  DE D1 D8 D0  
00C66B  2  21 46 15 DB        .byte $21,$46,$15,$DB,$42,$42,$DB,$E3,$DB,$E3,$DB,$DB,$E3,$26,$DB,$E3,$DB,$E3,$DB,$E3,$DB,$E3,$26,$26
00C66F  2  42 42 DB E3  
00C673  2  DB E3 DB DB  
00C683  2  21 66 46 DB        .byte $21,$66,$46,$DB
00C687  2  21 6C 0F DF        .byte $21,$6C,$0F,$DF,$DB,$DB,$DB,$26,$DB,$DF,$DB,$DF,$DB,$DB,$D2,$E5,$26,$26
00C68B  2  DB DB DB 26  
00C68F  2  DB DF DB DF  
00C699  2  21 86 15 DB        .byte $21,$86,$15,$DB,$DB,$DB,$DE,$43,$DB,$DB,$DB,$DB,$DB,$26,$DB,$E3,$DB,$E3,$DB,$DB,$DB,$E3,$26,$26
00C69D  2  DB DB DE 43  
00C6A1  2  DB DB DB DB  
00C6B1  2  21 A6 15 DB        .byte $21,$A6,$15,$DB,$DB,$DB,$DB,$DB,$DB,$DB,$DB,$D4,$D9,$26,$DB,$D9,$DB,$DB,$D4,$D9,$D4,$D9,$DA,$26
00C6B5  2  DB DB DB DB  
00C6B9  2  DB DB DB D4  
00C6C9  2  21 C5 17 5F        .byte $21,$C5,$17,$5F,$95,$95,$95,$95,$95,$95,$95,$95,$97,$98,$78,$95,$96,$95,$95,$97,$98,$97,$98,$95,$78,$7A
00C6CD  2  95 95 95 95  
00C6D1  2  95 95 95 95  
00C6E3  2  21 EE 0E CF        .byte $21,$EE,$0E,$CF,$01,$09,$08,$06,$24,$17,$12,$17,$1D,$0E,$17,$0D,$18
00C6E7  2  01 09 08 06  
00C6EB  2  24 17 12 17  
00C6F4  2  22 4D 0A 16        .byte $22,$4D,$0A,$16,$0A,$1B,$12,$18,$24,$10,$0A,$16,$0E
00C6F8  2  0A 1B 12 18  
00C6FC  2  24 10 0A 16  
00C701  2  22 8D 0A 15        .byte $22,$8D,$0A,$15,$1E,$12,$10,$12,$24,$10,$0A,$16,$0E
00C705  2  1E 12 10 12  
00C709  2  24 10 0A 16  
00C70E  2  22 ED 04 1D        .byte $22,$ED,$04,$1D,$18,$19,$28
00C712  2  18 19 28     
00C715  2  22 F7 01 00        .byte $22,$F7,$01,$00
00C719  2  23 C9 01 D5        .byte $23,$C9,$01,$D5
00C71D  2  23 CA 46 F5        .byte $23,$CA,$46,$F5
00C721  2  23 D1 47 55        .byte $23,$D1,$47,$55
00C725  2  23 D9 47 55        .byte $23,$D9,$47,$55
00C729  2  23 CC 43 55        .byte $23,$CC,$43,$55
00C72D  2  23 D6 01 DD        .byte $23,$D6,$01,$DD
00C731  2  23 DE 01 5D        .byte $23,$DE,$01,$5D
00C735  2  23 E2 04 55        .byte $23,$E2,$04,$55,$AA,$AA,$AA
00C739  2  AA AA AA     
00C73C  2  23 EA 05 95        .byte $23,$EA,$05,$95,$AA,$AA,$AA
00C740  2  AA AA AA     
00C743  2  2A                 .byte $2A
00C744  2  00                 .byte $00
00C745  2               .else
00C745  2                      .byte $20, $84, $01, $44
00C745  2                      .byte $20, $85, $57, $48
00C745  2                      .byte $20, $9c, $01, $49
00C745  2                      .byte $20, $a4, $c9, $46
00C745  2                      .byte $20, $a5, $57, $26
00C745  2                      .byte $20, $bc, $c9, $4a
00C745  2                      .byte $20, $a5, $0a, $d0, $d1, $d8, $d8, $de, $d1, $d0, $da, $de, $d1
00C745  2                      .byte $20, $c5, $17, $d2, $d3, $db, $db, $db, $d9, $db, $dc, $db, $df
00C745  2                      .byte $26, $26, $26, $26, $26, $26, $26, $26, $26, $26, $26, $26, $26
00C745  2                      .byte $20, $e5, $17, $d4, $d5, $d4, $d9, $db, $e2, $d4, $da, $db, $e0
00C745  2                      .byte $26, $26, $26, $26, $26, $26, $26, $26, $26, $26, $26, $26, $26
00C745  2                      .byte $21, $05, $57, $26
00C745  2                      .byte $21, $05, $0a, $d6, $d7, $d6, $d7, $e1, $26, $d6, $dd, $e1, $e1
00C745  2                      .byte $21, $25, $17, $d0, $e8, $d1, $d0, $d1, $de, $d1, $d8, $d0, $d1
00C745  2                      .byte $26, $de, $d1, $de, $d1, $d0, $d1, $d0, $d1, $26, $26, $d0, $d1
00C745  2                      .byte $21, $45, $17, $db, $42, $42, $db, $42, $db, $42, $db, $db, $42
00C745  2                      .byte $26, $db, $42, $db, $42, $db, $42, $db, $42, $26, $26, $db, $42
00C745  2                      .byte $21, $65, $46, $db
00C745  2                      .byte $21, $6b, $11, $df, $db, $db, $db, $26, $db, $df, $db, $df, $db
00C745  2                      .byte $db, $e4, $e5, $26, $26, $ec, $ed
00C745  2                      .byte $21, $85, $17, $db, $db, $db, $de, $43, $db, $e0, $db, $db, $db
00C745  2                      .byte $26, $db, $e3, $db, $e0, $db, $db, $e6, $e3, $26, $26, $ee, $ef
00C745  2                      .byte $21, $a5, $17, $db, $db, $db, $db, $42, $db, $db, $db, $d4, $d9
00C745  2                      .byte $26, $db, $d9, $db, $db, $d4, $d9, $d4, $d9, $e7, $26, $de, $da
00C745  2                      .byte $21, $c4, $19, $5f, $95, $95, $95, $95, $95, $95, $95, $95, $97
00C745  2                      .byte $98, $78, $95, $96, $95, $95, $97, $98, $97, $98, $95, $78, $95
00C745  2                      .byte $f0, $7a
00C745  2                      .byte $21, $ef, $0e, $cf, $01, $09, $08, $06, $24, $17, $12, $17, $1d
00C745  2                      .byte $0e, $17, $0d, $18
00C745  2                      .byte $22, $4d, $0a, $16, $0a, $1b, $12, $18, $24, $10, $0a, $16, $0e
00C745  2                      .byte $22, $8d, $0a, $15, $1e, $12, $10, $12, $24, $10, $0a, $16, $0e
00C745  2                      .byte $22, $eb, $04, $1d, $18, $19, $28
00C745  2                      .byte $22, $f5, $01, $00
00C745  2                      .byte $23, $c9, $47, $55
00C745  2                      .byte $23, $d1, $47, $55
00C745  2                      .byte $23, $d9, $47, $55
00C745  2                      .byte $23, $cc, $43, $f5
00C745  2                      .byte $23, $d6, $01, $dd
00C745  2                      .byte $23, $de, $01, $5d
00C745  2                      .byte $23, $e2, $04, $55, $aa, $aa, $aa
00C745  2                      .byte $23, $ea, $04, $95, $aa, $aa, $2a
00C745  2                      .byte $00, $ff, $ff
00C745  2               .endif
00C745  2               
00C745  2               ;-------------------------------------------------------------------------------------
00C745  2               
00C745  2               ;GAME LEVELS DATA
00C745  2               .ifdef ANN
00C745  2               E_Area00:
00C745  2  EA 9D 0F 03  .byte $ea,$9d,$0f,$03,$16,$1d,$c6,$1d,$36,$9d,$c9,$1d,$49,$9d,$84,$1b
00C749  2  16 1D C6 1D  
00C74D  2  36 9D C9 1D  
00C755  2  C9 1D 88 95  .byte $c9,$1d,$88,$95,$0f,$08,$78,$2d,$a6,$28,$90,$b5,$ff
00C759  2  0F 08 78 2D  
00C75D  2  A6 28 90 B5  
00C762  2               E_Area01:
00C762  2  0F 03 56 1B  .byte $0f,$03,$56,$1b,$c9,$1b,$0f,$07,$36,$1b,$aa,$1b,$48,$95,$0f,$0a
00C766  2  C9 1B 0F 07  
00C76A  2  36 1B AA 1B  
00C772  2  2A 1B 5B 0C  .byte $2a,$1b,$5b,$0c,$78,$2d,$90,$b5,$ff
00C776  2  78 2D 90 B5  
00C77A  2  FF           
00C77B  2               E_Area02:
00C77B  2  0B 8C 77 1B  .byte $0b,$8c,$77,$1b,$eb,$0c,$0f,$03,$19,$1d,$75,$1d,$d9,$1d,$99,$9d
00C77F  2  EB 0C 0F 03  
00C783  2  19 1D 75 1D  
00C78B  2  26 9D 5A 2B  .byte $26,$9d,$5a,$2b,$8a,$2c,$ca,$1b,$20,$95,$0f,$08,$78,$2d,$a6,$28
00C78F  2  8A 2C CA 1B  
00C793  2  20 95 0F 08  
00C79B  2  90 B5 FF     .byte $90,$b5,$ff
00C79E  2               E_Area03:
00C79E  2  0B 8C 3B 1D  .byte $0b,$8c,$3b,$1d,$8b,$1d,$ab,$0c,$db,$1d,$b5,$9b,$65,$9d,$6b,$1b
00C7A2  2  8B 1D AB 0C  
00C7A6  2  DB 1D B5 9B  
00C7AE  2  0B 9B 05 9D  .byte $0b,$9b,$05,$9d,$0b,$1b,$8b,$0c,$1b,$8c,$70,$15,$7b,$0c,$db,$0c
00C7B2  2  0B 1B 8B 0C  
00C7B6  2  1B 8C 70 15  
00C7BE  2  0F 08 78 2D  .byte $0f,$08,$78,$2d,$a6,$28,$90,$b5,$ff
00C7C2  2  A6 28 90 B5  
00C7C6  2  FF           
00C7C7  2               E_Area08:
00C7C7  2  A5 86 E4 28  .byte $a5,$86,$e4,$28,$18,$a8,$45,$83,$69,$03,$c6,$29,$9b,$83,$16,$a9
00C7CB  2  18 A8 45 83  
00C7CF  2  69 03 C6 29  
00C7D7  2  88 29 7B A8  .byte $88,$29,$7b,$a8,$24,$8f,$c8,$03,$e8,$03,$46,$a8,$85,$24,$c8,$24
00C7DB  2  24 8F C8 03  
00C7DF  2  E8 03 46 A8  
00C7E7  2  FF           .byte $ff
00C7E8  2               E_Area0A:
00C7E8  2  2E C2 66 E2  .byte $2e,$c2,$66,$e2,$11,$0f,$07,$02,$11,$0f,$0c,$12,$11,$18,$10,$ff
00C7EC  2  11 0F 07 02  
00C7F0  2  11 0F 0C 12  
00C7F8  2               E_Area0C:
00C7F8  2  9B 8E CA 0E  .byte $9b,$8e,$ca,$0e,$ee,$42,$44,$5b,$86,$80,$b8,$1b,$80,$50,$ba,$10
00C7FC  2  EE 42 44 5B  
00C800  2  86 80 B8 1B  
00C808  2  B7 5B 00 17  .byte $b7,$5b,$00,$17,$85,$4b,$05,$fe,$34,$40,$b7,$86,$c6,$06,$5b,$80
00C80C  2  85 4B 05 FE  
00C810  2  34 40 B7 86  
00C818  2  83 00 D0 38  .byte $83,$00,$d0,$38,$5b,$8e,$8a,$0e,$a6,$00,$bb,$0e,$c5,$80,$f3,$00
00C81C  2  5B 8E 8A 0E  
00C820  2  A6 00 BB 0E  
00C828  2  FF           .byte $ff
00C829  2               E_Area0D:
00C829  2  1E C2 00 6B  .byte $1e,$c2,$00,$6b,$06,$8b,$86,$63,$b7,$0f,$05,$03,$06,$23,$06,$4b
00C82D  2  06 8B 86 63  
00C831  2  B7 0F 05 03  
00C839  2  B7 BB 00 5B  .byte $b7,$bb,$00,$5b,$b7,$fb,$37,$3b,$b7,$0f,$0b,$1b,$37,$ff
00C83D  2  B7 FB 37 3B  
00C841  2  B7 0F 0B 1B  
00C847  2               E_Area0E:
00C847  2  E3 83 C2 86  .byte $e3,$83,$c2,$86,$e2,$06,$76,$a5,$a3,$8f,$03,$86,$68,$28,$e9,$28
00C84B  2  E2 06 76 A5  
00C84F  2  A3 8F 03 86  
00C857  2  E5 83 24 8F  .byte $e5,$83,$24,$8f,$36,$a8,$5b,$03,$ff
00C85B  2  36 A8 5B 03  
00C85F  2  FF           
00C860  2               E_Area0F:
00C860  2  B8 80 0F 03  .byte $b8,$80,$0f,$03,$08,$0e,$ff
00C864  2  08 0E FF     
00C867  2               E_Area10:
00C867  2  85 86 0B 80  .byte $85,$86,$0b,$80,$1b,$00,$db,$37,$77,$80,$eb,$37,$fe,$2b,$20,$2b
00C86B  2  1B 00 DB 37  
00C86F  2  77 80 EB 37  
00C877  2  80 7B 38 AB  .byte $80,$7b,$38,$ab,$b8,$77,$86,$fe,$42,$20,$49,$86,$8b,$06,$53,$8f
00C87B  2  B8 77 86 FE  
00C87F  2  42 20 49 86  
00C887  2  9B 03 07 90  .byte $9b,$03,$07,$90,$5b,$03,$5b,$b7,$9b,$0e,$bb,$0e,$9b,$80,$ff
00C88B  2  5B 03 5B B7  
00C88F  2  9B 0E BB 0E  
00C896  2               E_Area13:
00C896  2  0A AA 0E 28  .byte $0a,$aa,$0e,$28,$2a,$ff
00C89A  2  2A FF        
00C89C  2               E_Area14:
00C89C  2  C7 83 D7 03  .byte $c7,$83,$d7,$03,$42,$8f,$7a,$03,$05,$a4,$78,$24,$a6,$25,$e4,$25
00C8A0  2  42 8F 7A 03  
00C8A4  2  05 A4 78 24  
00C8AC  2  4B 83 E3 03  .byte $4b,$83,$e3,$03,$06,$a9,$89,$29,$b6,$29,$09,$a9,$66,$29,$c9,$29
00C8B0  2  06 A9 89 29  
00C8B4  2  B6 29 09 A9  
00C8BC  2  0F 08 85 25  .byte $0f,$08,$85,$25
00C8C0  2               E_Area17:
00C8C0  2  FF           .byte $ff
00C8C1  2               E_Area1C:
00C8C1  2  0A AA 0E 24  .byte $0a,$aa,$0e,$24,$4a,$ff
00C8C5  2  4A FF        
00C8C7  2               E_Area1D:
00C8C7  2  1B 80 BB 38  .byte $1b,$80,$bb,$38,$4b,$bc,$eb,$3b,$0f,$04,$2b,$00,$ab,$38,$eb,$00
00C8CB  2  4B BC EB 3B  
00C8CF  2  0F 04 2B 00  
00C8D7  2  CB 8E FB 80  .byte $cb,$8e,$fb,$80,$9b,$b8,$6b,$80,$fb,$3c,$9b,$bb,$5b,$bc,$fb,$00
00C8DB  2  9B B8 6B 80  
00C8DF  2  FB 3C 9B BB  
00C8E7  2  6B B8 FB 38  .byte $6b,$b8,$fb,$38
00C8EB  2               E_Area23:
00C8EB  2  FF           .byte $ff
00C8EC  2               E_Area24:
00C8EC  2  0B 86 1A 06  .byte $0b,$86,$1a,$06,$db,$06,$de,$c2,$02,$f0,$3b,$bb,$80,$eb,$06,$0b
00C8F0  2  DB 06 DE C2  
00C8F4  2  02 F0 3B BB  
00C8FC  2  86 93 06 F0  .byte $86,$93,$06,$f0,$39,$0f,$06,$60,$b8,$1b,$86,$a0,$b9,$b7,$27,$bd
00C900  2  39 0F 06 60  
00C904  2  B8 1B 86 A0  
00C90C  2  27 2B 83 A1  .byte $27,$2b,$83,$a1,$26,$a9,$26,$ee,$25,$0b,$27,$b4,$ff
00C910  2  26 A9 26 EE  
00C914  2  25 0B 27 B4  
00C919  2               E_Area25:
00C919  2  F7 80 1E AF  .byte $f7,$80,$1e,$af,$60,$e0,$3a,$a5,$a7,$db,$80,$3b,$82,$8b,$02,$fe
00C91D  2  60 E0 3A A5  
00C921  2  A7 DB 80 3B  
00C929  2  42 68 70 BB  .byte $42,$68,$70,$bb,$25,$a7,$2c,$27,$b2,$26,$b9,$26,$9b,$80,$a8,$82
00C92D  2  25 A7 2C 27  
00C931  2  B2 26 B9 26  
00C939  2  B5 27 BC 27  .byte $b5,$27,$bc,$27,$bb,$83,$3b,$82,$87,$34,$ee,$38,$61,$ff
00C93D  2  BB 83 3B 82  
00C941  2  87 34 EE 38  
00C947  2               E_Area26:
00C947  2  1E A5 0A 2E  .byte $1e,$a5,$0a,$2e,$28,$27,$0f,$03,$1e,$40,$07,$0f,$05,$1e,$24,$44
00C94B  2  28 27 0F 03  
00C94F  2  1E 40 07 0F  
00C957  2  0F 07 1E 22  .byte $0f,$07,$1e,$22,$6a,$0f,$09,$1e,$41,$68,$ff
00C95B  2  6A 0F 09 1E  
00C95F  2  41 68 FF     
00C962  2               E_Area29:
00C962  2  2E B8 21 2E  .byte $2e,$b8,$21,$2e,$38,$41,$6b,$07,$97,$47,$e9,$87,$7a,$87,$0f,$05
00C966  2  38 41 6B 07  
00C96A  2  97 47 E9 87  
00C972  2  78 07 38 87  .byte $78,$07,$38,$87,$e3,$07,$9b,$87,$ff
00C976  2  E3 07 9B 87  
00C97A  2  FF           
00C97B  2               L_Area00:
00C97B  2  9B 07 05 32  .byte $9b,$07,$05,$32,$06,$33,$07,$34,$ce,$03,$dc,$51,$ee,$07,$7e,$86
00C97F  2  06 33 07 34  
00C983  2  CE 03 DC 51  
00C98B  2  9E 0A CE 06  .byte $9e,$0a,$ce,$06,$e4,$00,$e8,$0b,$fe,$0a,$2e,$89,$4e,$0b,$14,$8b
00C98F  2  E4 00 E8 0B  
00C993  2  FE 0A 2E 89  
00C99B  2  C4 0B 34 8B  .byte $c4,$0b,$34,$8b,$7e,$06,$c7,$0b,$47,$8b,$81,$60,$82,$0b,$c7,$0b
00C99F  2  7E 06 C7 0B  
00C9A3  2  47 8B 81 60  
00C9AB  2  0E 87 7E 02  .byte $0e,$87,$7e,$02,$a7,$02,$b3,$02,$d7,$02,$e3,$02,$07,$82,$13,$02
00C9AF  2  A7 02 B3 02  
00C9B3  2  D7 02 E3 02  
00C9BB  2  3E 06 7E 02  .byte $3e,$06,$7e,$02,$ae,$07,$fe,$0a,$0d,$c4,$cd,$43,$ce,$09,$de,$0b
00C9BF  2  AE 07 FE 0A  
00C9C3  2  0D C4 CD 43  
00C9CB  2  DD 42 FE 02  .byte $dd,$42,$fe,$02,$5d,$c7,$fd
00C9CF  2  5D C7 FD     
00C9D2  2               L_Area01:
00C9D2  2  5B 07 05 32  .byte $5b,$07,$05,$32,$06,$33,$07,$34,$5e,$0a,$68,$64,$98,$64,$a8,$64
00C9D6  2  06 33 07 34  
00C9DA  2  5E 0A 68 64  
00C9E2  2  CE 06 FE 02  .byte $ce,$06,$fe,$02,$0d,$01,$1e,$0e,$7e,$02,$94,$63,$b4,$63,$d4,$63
00C9E6  2  0D 01 1E 0E  
00C9EA  2  7E 02 94 63  
00C9F2  2  F4 63 14 E3  .byte $f4,$63,$14,$e3,$2e,$0e,$5e,$02,$64,$35,$88,$72,$be,$0e,$0d,$04
00C9F6  2  2E 0E 5E 02  
00C9FA  2  64 35 88 72  
00CA02  2  AE 02 CE 08  .byte $ae,$02,$ce,$08,$cd,$4b,$fe,$02,$0d,$05,$68,$31,$7e,$0a,$96,$31
00CA06  2  CD 4B FE 02  
00CA0A  2  0D 05 68 31  
00CA12  2  A9 63 A8 33  .byte $a9,$63,$a8,$33,$d5,$30,$ee,$02,$e6,$62,$f4,$61,$04,$b0,$54,$32
00CA16  2  D5 30 EE 02  
00CA1A  2  E6 62 F4 61  
00CA22  2  78 02 93 64  .byte $78,$02,$93,$64,$98,$36,$a4,$31,$e4,$31,$04,$bf,$08,$3f,$04,$bf
00CA26  2  98 36 A4 31  
00CA2A  2  E4 31 04 BF  
00CA32  2  08 3F CD 4B  .byte $08,$3f,$cd,$4b,$04,$e3,$0e,$03,$2e,$01,$7e,$06,$be,$02,$de,$06
00CA36  2  04 E3 0E 03  
00CA3A  2  2E 01 7E 06  
00CA42  2  FE 0A 0D C4  .byte $fe,$0a,$0d,$c4,$cd,$43,$ce,$09,$de,$0b,$dd,$42,$fe,$02,$5d,$c7
00CA46  2  CD 43 CE 09  
00CA4A  2  DE 0B DD 42  
00CA52  2  FD           .byte $fd
00CA53  2               L_Area02:
00CA53  2  9B 07 05 32  .byte $9b,$07,$05,$32,$06,$33,$07,$34,$fe,$00,$27,$b1,$65,$32,$75,$0b
00CA57  2  06 33 07 34  
00CA5B  2  FE 00 27 B1  
00CA63  2  71 00 B7 31  .byte $71,$00,$b7,$31,$08,$e4,$18,$64,$1e,$04,$57,$3b,$17,$8b,$27,$3a
00CA67  2  08 E4 18 64  
00CA6B  2  1E 04 57 3B  
00CA73  2  73 0B D7 0B  .byte $73,$0b,$d7,$0b,$e7,$3a,$97,$8b,$fe,$08,$24,$8b,$2e,$00,$3e,$40
00CA77  2  E7 3A 97 8B  
00CA7B  2  FE 08 24 8B  
00CA83  2  38 64 6F 00  .byte $38,$64,$6f,$00,$9f,$00,$be,$43,$c8,$0b,$c9,$63,$ce,$07,$fe,$07
00CA87  2  9F 00 BE 43  
00CA8B  2  C8 0B C9 63  
00CA93  2  2E 81 66 42  .byte $2e,$81,$66,$42,$6a,$42,$79,$08,$be,$00,$c8,$64,$f8,$64,$08,$e4
00CA97  2  6A 42 79 08  
00CA9B  2  BE 00 C8 64  
00CAA3  2  2E 07 7E 03  .byte $2e,$07,$7e,$03,$9e,$07,$be,$03,$de,$07,$fe,$0a,$03,$88,$0d,$44
00CAA7  2  9E 07 BE 03  
00CAAB  2  DE 07 FE 0A  
00CAB3  2  13 24 CD 43  .byte $13,$24,$cd,$43,$ce,$09,$dd,$42,$de,$0b,$fe,$02,$5d,$c7,$fd
00CAB7  2  CE 09 DD 42  
00CABB  2  DE 0B FE 02  
00CAC2  2               L_Area03:
00CAC2  2  9B 07 05 32  .byte $9b,$07,$05,$32,$06,$33,$07,$34,$fe,$06,$0c,$81,$39,$0b,$5c,$01
00CAC6  2  06 33 07 34  
00CACA  2  FE 06 0C 81  
00CAD2  2  89 0B AC 01  .byte $89,$0b,$ac,$01,$d9,$0b,$fc,$01,$2e,$83,$a6,$42,$a7,$01,$b3,$0b
00CAD6  2  D9 0B FC 01  
00CADA  2  2E 83 A6 42  
00CAE2  2  B7 00 C7 01  .byte $b7,$00,$c7,$01,$de,$0a,$fe,$02,$4e,$83,$5a,$32,$63,$0b,$69,$0b
00CAE6  2  DE 0A FE 02  
00CAEA  2  4E 83 5A 32  
00CAF2  2  7E 02 EE 03  .byte $7e,$02,$ee,$03,$fa,$32,$09,$8b,$1e,$02,$ee,$03,$fa,$32,$03,$8b
00CAF6  2  FA 32 09 8B  
00CAFA  2  1E 02 EE 03  
00CB02  2  09 0B 14 42  .byte $09,$0b,$14,$42,$1e,$02,$7e,$0a,$9e,$07,$fe,$0a,$2e,$86,$5e,$0a
00CB06  2  1E 02 7E 0A  
00CB0A  2  9E 07 FE 0A  
00CB12  2  8E 06 BE 0A  .byte $8e,$06,$be,$0a,$ee,$07,$fe,$8a,$0d,$c4,$41,$52,$51,$52,$cd,$43
00CB16  2  EE 07 FE 8A  
00CB1A  2  0D C4 41 52  
00CB22  2  CE 09 DE 0B  .byte $ce,$09,$de,$0b,$dd,$42,$fe,$02,$5d,$c7,$fd
00CB26  2  DD 42 FE 02  
00CB2A  2  5D C7 FD     
00CB2D  2               L_Area08:
00CB2D  2  94 11 0F 26  .byte $94,$11,$0f,$26,$fe,$10,$28,$94,$65,$15,$eb,$12,$fa,$41,$4a,$96
00CB31  2  FE 10 28 94  
00CB35  2  65 15 EB 12  
00CB3D  2  54 40 A4 42  .byte $54,$40,$a4,$42,$b7,$13,$e9,$19,$f5,$15,$11,$80,$47,$42,$71,$13
00CB41  2  B7 13 E9 19  
00CB45  2  F5 15 11 80  
00CB4D  2  15 92 1B 1F  .byte $15,$92,$1b,$1f,$24,$40,$55,$12,$64,$40,$95,$12,$a4,$40,$d2,$12
00CB51  2  24 40 55 12  
00CB55  2  64 40 95 12  
00CB5D  2  E1 40 13 C0  .byte $e1,$40,$13,$c0,$49,$13,$83,$40,$a3,$40,$17,$92,$83,$13,$92,$41
00CB61  2  49 13 83 40  
00CB65  2  A3 40 17 92  
00CB6D  2  B9 14 C5 12  .byte $b9,$14,$c5,$12,$c8,$40,$d4,$40,$4b,$92,$78,$1b,$9c,$94,$9f,$11
00CB71  2  C8 40 D4 40  
00CB75  2  4B 92 78 1B  
00CB7D  2  DF 14 FE 11  .byte $df,$14,$fe,$11,$7d,$c1,$9e,$42,$cf,$20,$9d,$c7,$fd
00CB81  2  7D C1 9E 42  
00CB85  2  CF 20 9D C7  
00CB8A  2               L_Area0A:
00CB8A  2  52 21 0F 20  .byte $52,$21,$0f,$20,$6e,$40,$58,$f2,$93,$00,$97,$01,$0c,$81,$97,$40
00CB8E  2  6E 40 58 F2  
00CB92  2  93 00 97 01  
00CB9A  2  A6 41 C7 40  .byte $a6,$41,$c7,$40,$0d,$04,$03,$01,$07,$01,$23,$01,$27,$01,$ec,$03
00CB9E  2  0D 04 03 01  
00CBA2  2  07 01 23 01  
00CBAA  2  AC F3 C3 03  .byte $ac,$f3,$c3,$03,$78,$e2,$94,$43,$47,$f3,$74,$43,$47,$fb,$74,$43
00CBAE  2  78 E2 94 43  
00CBB2  2  47 F3 74 43  
00CBBA  2  2C F1 4C 63  .byte $2c,$f1,$4c,$63,$47,$00,$57,$21,$5c,$01,$7c,$72,$39,$f1,$ec,$02
00CBBE  2  47 00 57 21  
00CBC2  2  5C 01 7C 72  
00CBCA  2  4C 81 EC 01  .byte $4c,$81,$ec,$01,$0d,$0d,$0f,$38,$c7,$08,$ed,$4a,$1d,$c1,$5f,$26
00CBCE  2  0D 0D 0F 38  
00CBD2  2  C7 08 ED 4A  
00CBDA  2  3D C7 FD     .byte $3d,$c7,$fd
00CBDD  2               L_Area0C:
00CBDD  2  52 31 0F 20  .byte $52,$31,$0f,$20,$6e,$66,$07,$81,$36,$01,$66,$00,$a7,$21,$c7,$08
00CBE1  2  6E 66 07 81  
00CBE5  2  36 01 66 00  
00CBED  2  C9 20 EC 01  .byte $c9,$20,$ec,$01,$08,$f2,$67,$7b,$98,$f2,$39,$f1,$9f,$33,$dc,$27
00CBF1  2  08 F2 67 7B  
00CBF5  2  98 F2 39 F1  
00CBFD  2  DC 57 23 83  .byte $dc,$57,$23,$83,$57,$63,$6c,$51,$87,$63,$99,$61,$a3,$07,$b3,$21
00CC01  2  57 63 6C 51  
00CC05  2  87 63 99 61  
00CC0D  2  77 F3 F3 29  .byte $77,$f3,$f3,$29,$f7,$2a,$13,$81,$53,$00,$e9,$0c,$0c,$83,$13,$21
00CC11  2  F7 2A 13 81  
00CC15  2  53 00 E9 0C  
00CC1D  2  16 22 33 06  .byte $16,$22,$33,$06,$8f,$35,$ec,$01,$63,$a2,$67,$20,$73,$01,$77,$01
00CC21  2  8F 35 EC 01  
00CC25  2  63 A2 67 20  
00CC2D  2  87 20 B3 22  .byte $87,$20,$b3,$22,$b7,$20,$c3,$00,$c7,$01,$d7,$20,$67,$a0,$77,$08
00CC31  2  B7 20 C3 00  
00CC35  2  C7 01 D7 20  
00CC3D  2  87 22 E8 62  .byte $87,$22,$e8,$62,$f5,$65,$1c,$82,$7f,$38,$8d,$c1,$cf,$26,$ad,$c7
00CC41  2  F5 65 1C 82  
00CC45  2  7F 38 8D C1  
00CC4D  2  FD           .byte $fd
00CC4E  2               L_Area0D:
00CC4E  2  54 21 07 81  .byte $54,$21,$07,$81,$47,$24,$57,$01,$63,$00,$77,$01,$c9,$71,$68,$f2
00CC52  2  47 24 57 01  
00CC56  2  63 00 77 01  
00CC5E  2  E7 73 97 FB  .byte $e7,$73,$97,$fb,$06,$83,$5c,$01,$d7,$22,$03,$80,$13,$26,$6c,$02
00CC62  2  06 83 5C 01  
00CC66  2  D7 22 03 80  
00CC6E  2  B3 22 E3 01  .byte $b3,$22,$e3,$01,$e7,$08,$47,$a1,$a7,$01,$d3,$07,$d7,$01,$07,$80
00CC72  2  E7 08 47 A1  
00CC76  2  A7 01 D3 07  
00CC7E  2  67 20 93 22  .byte $67,$20,$93,$22,$03,$a3,$1c,$61,$17,$21,$6f,$33,$c7,$63,$d8,$62
00CC82  2  03 A3 1C 61  
00CC86  2  17 21 6F 33  
00CC8E  2  E9 61 FA 60  .byte $e9,$61,$fa,$60,$4f,$b3,$87,$63,$9c,$01,$b7,$63,$c8,$62,$d9,$61
00CC92  2  4F B3 87 63  
00CC96  2  9C 01 B7 63  
00CC9E  2  EA 60 39 F1  .byte $ea,$60,$39,$f1,$87,$21,$a7,$01,$b7,$20,$39,$f1,$5f,$38,$6d,$c1
00CCA2  2  87 21 A7 01  
00CCA6  2  B7 20 39 F1  
00CCAE  2  AF 26 8D C7  .byte $af,$26,$8d,$c7,$fd
00CCB2  2  FD           
00CCB3  2               L_Area0E:
00CCB3  2  94 11 0F 26  .byte $94,$11,$0f,$26,$fe,$10,$2a,$93,$87,$17,$a3,$14,$b2,$42,$0a,$92
00CCB7  2  FE 10 2A 93  
00CCBB  2  87 17 A3 14  
00CCC3  2  36 14 50 41  .byte $36,$14,$50,$41,$82,$16,$2b,$93,$24,$41,$bb,$14,$b8,$00,$c3,$13
00CCC7  2  82 16 2B 93  
00CCCB  2  24 41 BB 14  
00CCD3  2  D2 41 1B 94  .byte $d2,$41,$1b,$94,$67,$12,$c4,$15,$53,$c1,$d2,$41,$12,$c1,$29,$13
00CCD7  2  67 12 C4 15  
00CCDB  2  53 C1 D2 41  
00CCE3  2  85 17 1B 92  .byte $85,$17,$1b,$92,$1a,$42,$47,$13,$83,$41,$a7,$13,$0e,$91,$a7,$63
00CCE7  2  1A 42 47 13  
00CCEB  2  83 41 A7 13  
00CCF3  2  B7 63 C5 65  .byte $b7,$63,$c5,$65,$d5,$65,$dd,$4a,$e3,$67,$f3,$67,$8d,$c1,$ae,$42
00CCF7  2  D5 65 DD 4A  
00CCFB  2  E3 67 F3 67  
00CD03  2  DF 20 AD C7  .byte $df,$20,$ad,$c7,$fd
00CD07  2  FD           
00CD08  2               L_Area0F:
00CD08  2  90 11 0F 26  .byte $90,$11,$0f,$26,$6e,$10,$8b,$17,$af,$32,$d8,$62,$e8,$62,$fc,$3f
00CD0C  2  6E 10 8B 17  
00CD10  2  AF 32 D8 62  
00CD18  2  AD C8 F8 64  .byte $ad,$c8,$f8,$64,$0c,$be,$43,$43,$f8,$64,$0c,$bf,$f8,$64,$48,$e4
00CD1C  2  0C BE 43 43  
00CD20  2  F8 64 0C BF  
00CD28  2  5C 39 83 40  .byte $5c,$39,$83,$40,$92,$41,$b3,$40,$f8,$64,$48,$e4,$5c,$39,$f8,$64
00CD2C  2  92 41 B3 40  
00CD30  2  F8 64 48 E4  
00CD38  2  13 C2 37 65  .byte $13,$c2,$37,$65,$4c,$24,$63,$00,$97,$65,$c3,$42,$0b,$97,$ac,$32
00CD3C  2  4C 24 63 00  
00CD40  2  97 65 C3 42  
00CD48  2  F8 64 0C BE  .byte $f8,$64,$0c,$be,$53,$45,$9d,$48,$f8,$64,$2a,$e2,$3c,$47,$56,$43
00CD4C  2  53 45 9D 48  
00CD50  2  F8 64 2A E2  
00CD58  2  BA 62 F8 64  .byte $ba,$62,$f8,$64,$0c,$b7,$88,$64,$bc,$31,$d4,$45,$fc,$31,$3c,$b1
00CD5C  2  0C B7 88 64  
00CD60  2  BC 31 D4 45  
00CD68  2  78 64 8C 38  .byte $78,$64,$8c,$38,$0b,$9c,$1a,$33,$18,$61,$28,$61,$39,$60,$5d,$4a
00CD6C  2  0B 9C 1A 33  
00CD70  2  18 61 28 61  
00CD78  2  EE 11 0F B8  .byte $ee,$11,$0f,$b8,$1d,$c1,$3e,$42,$6f,$20,$3d,$c7,$fd
00CD7C  2  1D C1 3E 42  
00CD80  2  6F 20 3D C7  
00CD85  2               L_Area10:
00CD85  2  52 31 0F 20  .byte $52,$31,$0f,$20,$6e,$40,$f7,$20,$07,$85,$17,$20,$4f,$34,$c3,$03
00CD89  2  6E 40 F7 20  
00CD8D  2  07 85 17 20  
00CD95  2  C7 02 D3 22  .byte $c7,$02,$d3,$22,$27,$e3,$39,$61,$e7,$73,$5c,$f4,$53,$00,$6c,$63
00CD99  2  27 E3 39 61  
00CD9D  2  E7 73 5C F4  
00CDA5  2  47 A0 53 06  .byte $47,$a0,$53,$06,$63,$22,$a7,$73,$fc,$73,$13,$a1,$33,$07,$43,$21
00CDA9  2  63 22 A7 73  
00CDAD  2  FC 73 13 A1  
00CDB5  2  5C 72 C3 23  .byte $5c,$72,$c3,$23,$cc,$03,$77,$fb,$39,$f1,$a7,$73,$d3,$05,$e8,$72
00CDB9  2  CC 03 77 FB  
00CDBD  2  39 F1 A7 73  
00CDC5  2  E3 22 26 F4  .byte $e3,$22,$26,$f4,$bc,$02,$00,$89,$09,$0c,$17,$88,$43,$24,$a7,$01
00CDC9  2  BC 02 00 89  
00CDCD  2  09 0C 17 88  
00CDD5  2  C3 05 08 F2  .byte $c3,$05,$08,$f2,$97,$31,$a3,$02,$e1,$69,$f1,$69,$8d,$c1,$cf,$26
00CDD9  2  97 31 A3 02  
00CDDD  2  E1 69 F1 69  
00CDE5  2  AD C7 FD     .byte $ad,$c7,$fd
00CDE8  2               L_Area13:
00CDE8  2  00 C1 4C 00  .byte $00,$c1,$4c,$00,$f4,$4f,$0d,$02,$02,$42,$43,$4f,$52,$c2,$de,$00
00CDEC  2  F4 4F 0D 02  
00CDF0  2  02 42 43 4F  
00CDF8  2  5A C2 4D C7  .byte $5a,$c2,$4d,$c7,$fd
00CDFC  2  FD           
00CDFD  2               L_Area14:
00CDFD  2  90 51 0F 26  .byte $90,$51,$0f,$26,$ee,$10,$0b,$94,$33,$14,$42,$42,$77,$16,$86,$44
00CE01  2  EE 10 0B 94  
00CE05  2  33 14 42 42  
00CE0D  2  02 92 4A 16  .byte $02,$92,$4a,$16,$69,$42,$73,$14,$b0,$00,$c7,$12,$05,$c0,$1c,$17
00CE11  2  69 42 73 14  
00CE15  2  B0 00 C7 12  
00CE1D  2  1F 11 36 12  .byte $1f,$11,$36,$12,$8f,$14,$91,$40,$1b,$94,$35,$12,$34,$42,$60,$42
00CE21  2  8F 14 91 40  
00CE25  2  1B 94 35 12  
00CE2D  2  61 12 87 12  .byte $61,$12,$87,$12,$96,$40,$a3,$14,$47,$92,$05,$c0,$39,$12,$82,$40
00CE31  2  96 40 A3 14  
00CE35  2  47 92 05 C0  
00CE3D  2  98 12 16 C4  .byte $98,$12,$16,$c4,$17,$14,$54,$12,$9b,$16,$28,$94,$ce,$01,$3d,$c1
00CE41  2  17 14 54 12  
00CE45  2  9B 16 28 94  
00CE4D  2  5E 42 8F 20  .byte $5e,$42,$8f,$20,$5d,$c7,$fd
00CE51  2  5D C7 FD     
00CE54  2               L_Area17:
00CE54  2  10 51 4C 00  .byte $10,$51,$4c,$00,$c7,$12,$c6,$42,$03,$92,$02,$42,$29,$12,$63,$12
00CE58  2  C7 12 C6 42  
00CE5C  2  03 92 02 42  
00CE64  2  62 42 69 14  .byte $62,$42,$69,$14,$a5,$12,$a4,$42,$e2,$14,$e1,$44,$f8,$16,$37,$c1
00CE68  2  A5 12 A4 42  
00CE6C  2  E2 14 E1 44  
00CE74  2  8F 38 02 BB  .byte $8f,$38,$02,$bb,$28,$7a,$68,$7a,$a8,$7a,$e0,$6a,$f0,$6a,$6d,$c5
00CE78  2  28 7A 68 7A  
00CE7C  2  A8 7A E0 6A  
00CE84  2  FD           .byte $fd
00CE85  2               L_Area1C:
00CE85  2  06 C1 4C 00  .byte $06,$c1,$4c,$00,$f4,$4f,$0d,$02,$06,$20,$24,$4f,$35,$a0,$36,$20
00CE89  2  F4 4F 0D 02  
00CE8D  2  06 20 24 4F  
00CE95  2  53 46 D5 20  .byte $53,$46,$d5,$20,$d6,$20,$34,$a1,$73,$49,$74,$20,$94,$20,$b4,$20
00CE99  2  D6 20 34 A1  
00CE9D  2  73 49 74 20  
00CEA5  2  D4 20 F4 20  .byte $d4,$20,$f4,$20,$2e,$80,$59,$42,$4d,$c7,$fd
00CEA9  2  2E 80 59 42  
00CEAD  2  4D C7 FD     
00CEB0  2               L_Area1D:
00CEB0  2  96 31 0F 26  .byte $96,$31,$0f,$26,$0d,$03,$1a,$60,$77,$42,$c4,$00,$c8,$62,$b9,$e1
00CEB4  2  0D 03 1A 60  
00CEB8  2  77 42 C4 00  
00CEC0  2  D3 07 D7 08  .byte $d3,$07,$d7,$08,$f9,$61,$0c,$81,$4e,$b1,$8e,$b1,$aa,$30,$bc,$01
00CEC4  2  F9 61 0C 81  
00CEC8  2  4E B1 8E B1  
00CED0  2  E4 50 E9 61  .byte $e4,$50,$e9,$61,$0c,$81,$0d,$0a,$84,$43,$98,$72,$0d,$0c,$0f,$38
00CED4  2  0C 81 0D 0A  
00CED8  2  84 43 98 72  
00CEE0  2  1D C1 5F 26  .byte $1d,$c1,$5f,$26,$3d,$c7,$fd
00CEE4  2  3D C7 FD     
00CEE7  2               L_Area23:
00CEE7  2  3C 11 0F 26  .byte $3c,$11,$0f,$26,$ad,$40,$3d,$c7,$fd
00CEEB  2  AD 40 3D C7  
00CEEF  2  FD           
00CEF0  2               L_Area24:
00CEF0  2  48 0F 0E 01  .byte $48,$0f,$0e,$01,$5e,$02,$a7,$00,$bc,$73,$1a,$e0,$39,$61,$58,$62
00CEF4  2  5E 02 A7 00  
00CEF8  2  BC 73 1A E0  
00CF00  2  77 63 97 63  .byte $77,$63,$97,$63,$b8,$62,$d6,$08,$f8,$62,$19,$e1,$75,$52,$86,$40
00CF04  2  B8 62 D6 08  
00CF08  2  F8 62 19 E1  
00CF10  2  87 07 95 52  .byte $87,$07,$95,$52,$93,$43,$a5,$21,$c5,$52,$d6,$40,$d7,$20,$e5,$52
00CF14  2  93 43 A5 21  
00CF18  2  C5 52 D6 40  
00CF20  2  3E 8D 5E 03  .byte $3e,$8d,$5e,$03,$67,$52,$77,$52,$7e,$02,$9e,$03,$a6,$43,$a7,$23
00CF24  2  67 52 77 52  
00CF28  2  7E 02 9E 03  
00CF30  2  DE 05 FE 02  .byte $de,$05,$fe,$02,$1e,$83,$33,$54,$46,$40,$47,$21,$56,$05,$5e,$02
00CF34  2  1E 83 33 54  
00CF38  2  46 40 47 21  
00CF40  2  83 54 93 54  .byte $83,$54,$93,$54,$96,$08,$90,$09,$be,$03,$c7,$23,$fe,$02,$0c,$82
00CF44  2  96 08 90 09  
00CF48  2  BE 03 C7 23  
00CF50  2  43 45 45 24  .byte $43,$45,$45,$24,$46,$24,$90,$05,$95,$51,$78,$fa,$d7,$73,$39,$f1
00CF54  2  46 24 90 05  
00CF58  2  95 51 78 FA  
00CF60  2  8C 01 A8 52  .byte $8c,$01,$a8,$52,$b8,$52,$cc,$01,$5f,$b3,$97,$63,$9e,$00,$0e,$81
00CF64  2  B8 52 CC 01  
00CF68  2  5F B3 97 63  
00CF70  2  16 24 66 05  .byte $16,$24,$66,$05,$8e,$00,$fe,$01,$08,$d2,$0e,$06,$6f,$47,$9e,$0f
00CF74  2  8E 00 FE 01  
00CF78  2  08 D2 0E 06  
00CF80  2  0E 82 2D 47  .byte $0e,$82,$2d,$47,$28,$7a,$68,$7a,$a8,$7a,$ae,$01,$de,$0f,$6d,$c5
00CF84  2  28 7A 68 7A  
00CF88  2  A8 7A AE 01  
00CF90  2  FD           .byte $fd
00CF91  2               L_Area25:
00CF91  2  48 0F 0E 01  .byte $48,$0f,$0e,$01,$5e,$02,$bc,$01,$fc,$01,$2c,$82,$41,$52,$4e,$04
00CF95  2  5E 02 BC 01  
00CF99  2  FC 01 2C 82  
00CFA1  2  67 25 68 24  .byte $67,$25,$68,$24,$69,$21,$89,$08,$99,$21,$ba,$42,$c7,$05,$de,$0b
00CFA5  2  69 21 89 08  
00CFA9  2  99 21 BA 42  
00CFB1  2  B2 88 FE 02  .byte $b2,$88,$fe,$02,$2c,$e1,$2c,$71,$67,$01,$77,$00,$87,$01,$8e,$00
00CFB5  2  2C E1 2C 71  
00CFB9  2  67 01 77 00  
00CFC1  2  EE 01 F6 02  .byte $ee,$01,$f6,$02,$03,$86,$05,$02,$13,$21,$16,$02,$27,$02,$2e,$02
00CFC5  2  03 86 05 02  
00CFC9  2  13 21 16 02  
00CFD1  2  88 72 C7 20  .byte $88,$72,$c7,$20,$d7,$08,$e4,$76,$07,$a0,$17,$07,$48,$7a,$76,$20
00CFD5  2  D7 08 E4 76  
00CFD9  2  07 A0 17 07  
00CFE1  2  98 72 79 E1  .byte $98,$72,$79,$e1,$88,$62,$9c,$01,$b7,$73,$dc,$01,$f8,$62,$fe,$01
00CFE5  2  88 62 9C 01  
00CFE9  2  B7 73 DC 01  
00CFF1  2  08 E2 0E 00  .byte $08,$e2,$0e,$00,$6e,$02,$73,$20,$77,$23,$83,$05,$93,$20,$ae,$00
00CFF5  2  6E 02 73 20  
00CFF9  2  77 23 83 05  
00D001  2  FE 0A 0E 82  .byte $fe,$0a,$0e,$82,$39,$71,$a8,$72,$e7,$73,$0c,$81,$8f,$32,$ae,$00
00D005  2  39 71 A8 72  
00D009  2  E7 73 0C 81  
00D011  2  FE 04 04 D1  .byte $fe,$04,$04,$d1,$17,$05,$26,$49,$27,$29,$df,$33,$fe,$02,$44,$f6
00D015  2  17 05 26 49  
00D019  2  27 29 DF 33  
00D021  2  7C 01 8E 06  .byte $7c,$01,$8e,$06,$bf,$47,$ee,$0f,$4d,$c7,$0e,$82,$68,$7a,$ae,$01
00D025  2  BF 47 EE 0F  
00D029  2  4D C7 0E 82  
00D031  2  DE 0F 6D C5  .byte $de,$0f,$6d,$c5,$fd
00D035  2  FD           
00D036  2               L_Area26:
00D036  2  48 01 0E 01  .byte $48,$01,$0e,$01,$00,$5a,$3e,$06,$45,$46,$47,$46,$53,$44,$ae,$01
00D03A  2  00 5A 3E 06  
00D03E  2  45 46 47 46  
00D046  2  DF 4A 4D C7  .byte $df,$4a,$4d,$c7,$0e,$81,$00,$5a,$2e,$04,$37,$28,$3a,$48,$46,$47
00D04A  2  0E 81 00 5A  
00D04E  2  2E 04 37 28  
00D056  2  C7 08 CE 0F  .byte $c7,$08,$ce,$0f,$df,$4a,$4d,$c7,$0e,$81,$00,$5a,$33,$53,$43,$51
00D05A  2  DF 4A 4D C7  
00D05E  2  0E 81 00 5A  
00D066  2  46 40 47 50  .byte $46,$40,$47,$50,$53,$05,$55,$40,$56,$50,$62,$43,$64,$40,$65,$50
00D06A  2  53 05 55 40  
00D06E  2  56 50 62 43  
00D076  2  71 41 73 51  .byte $71,$41,$73,$51,$83,$51,$94,$40,$95,$50,$a3,$50,$a5,$40,$a6,$50
00D07A  2  83 51 94 40  
00D07E  2  95 50 A3 50  
00D086  2  B3 51 B6 40  .byte $b3,$51,$b6,$40,$b7,$50,$c3,$53,$df,$4a,$4d,$c7,$0e,$81,$00,$5a
00D08A  2  B7 50 C3 53  
00D08E  2  DF 4A 4D C7  
00D096  2  2E 02 36 47  .byte $2e,$02,$36,$47,$37,$52,$3a,$49,$47,$25,$a7,$52,$d7,$05,$df,$4a
00D09A  2  37 52 3A 49  
00D09E  2  47 25 A7 52  
00D0A6  2  4D C7 0E 81  .byte $4d,$c7,$0e,$81,$00,$5a,$3e,$02,$44,$51,$53,$44,$54,$44,$55,$24
00D0AA  2  00 5A 3E 02  
00D0AE  2  44 51 53 44  
00D0B6  2  A1 54 AE 01  .byte $a1,$54,$ae,$01,$b4,$21,$df,$4a,$e5,$08,$4d,$c7,$fd
00D0BA  2  B4 21 DF 4A  
00D0BE  2  E5 08 4D C7  
00D0C3  2               L_Area29:
00D0C3  2  41 01 B8 52  .byte $41,$01,$b8,$52,$ea,$41,$27,$b2,$b3,$42,$16,$d4,$4a,$42,$a5,$51
00D0C7  2  EA 41 27 B2  
00D0CB  2  B3 42 16 D4  
00D0D3  2  A7 31 27 D3  .byte $a7,$31,$27,$d3,$08,$e2,$16,$64,$2c,$04,$38,$42,$76,$64,$88,$62
00D0D7  2  08 E2 16 64  
00D0DB  2  2C 04 38 42  
00D0E3  2  DE 07 FE 01  .byte $de,$07,$fe,$01,$0d,$c9,$23,$32,$31,$51,$98,$52,$0d,$c9,$59,$42
00D0E7  2  0D C9 23 32  
00D0EB  2  31 51 98 52  
00D0F3  2  63 53 67 31  .byte $63,$53,$67,$31,$14,$c2,$36,$31,$87,$53,$17,$e3,$29,$61,$30,$62
00D0F7  2  14 C2 36 31  
00D0FB  2  87 53 17 E3  
00D103  2  3C 08 42 37  .byte $3c,$08,$42,$37,$59,$40,$6a,$42,$99,$40,$c9,$61,$d7,$63,$58,$d2
00D107  2  59 40 6A 42  
00D10B  2  99 40 C9 61  
00D113  2  C3 67 D3 31  .byte $c3,$67,$d3,$31,$dc,$06,$f7,$42,$fa,$42,$23,$b1,$43,$67,$c3,$34
00D117  2  DC 06 F7 42  
00D11B  2  FA 42 23 B1  
00D123  2  C7 34 D1 51  .byte $c7,$34,$d1,$51,$43,$b3,$47,$33,$9a,$30,$a9,$61,$b8,$62,$be,$0b
00D127  2  43 B3 47 33  
00D12B  2  9A 30 A9 61  
00D133  2  C4 31 D5 0A  .byte $c4,$31,$d5,$0a,$de,$0f,$0d,$ca,$7d,$47,$fd
00D137  2  DE 0F 0D CA  
00D13B  2  7D 47 FD     
00D13E  2               
00D13E  2               MRetainerCHRWorld1:
00D13E  2  00 03 1F 3F  .byte $00,$03,$1f,$3f,$3f,$7f,$7f,$7f
00D142  2  3F 7F 7F 7F  
00D146  2  00 03 1F 3F  .byte $00,$03,$1f,$3f,$3f,$7f,$7f,$7f
00D14A  2  3F 7F 7F 7F  
00D14E  2  7F 3F 3B 33  .byte $7f,$3f,$3b,$33,$7f,$7e,$7f,$7f
00D152  2  7F 7E 7F 7F  
00D156  2  5F 18 0F 3F  .byte $5f,$18,$0f,$3f,$70,$53,$19,$1c
00D15A  2  70 53 19 1C  
00D15E  2  00 00 03 34  .byte $00,$00,$03,$34,$79,$7f,$3f,$1c
00D162  2  79 7F 3F 1C  
00D166  2  3F 3F 0F 0F  .byte $3f,$3f,$0f,$0f,$07,$03,$03,$00
00D16A  2  07 03 03 00  
00D16E  2  E0 F0 F8 F8  .byte $e0,$f0,$f8,$f8,$fc,$fe,$fe,$fe
00D172  2  FC FE FE FE  
00D176  2  E0 F0 F8 F8  .byte $e0,$f0,$f8,$f8,$fc,$fe,$fe,$fe
00D17A  2  FC FE FE FE  
00D17E  2  FE FE EE E6  .byte $fe,$fe,$ee,$e6,$ff,$3f,$ff,$ff
00D182  2  FF 3F FF FF  
00D186  2  8C 04 70 7E  .byte $8c,$04,$70,$7e,$07,$e5,$cc,$1c
00D18A  2  07 E5 CC 1C  
00D18E  2  80 00 E0 06  .byte $80,$00,$e0,$06,$cf,$ff,$fe,$1c
00D192  2  CF FF FE 1C  
00D196  2  7E FE F8 F8  .byte $7e,$fe,$f8,$f8,$f0,$e0,$e0,$00
00D19A  2  F0 E0 E0 00  
00D19E  2               
00D19E  2               MRetainerCHRWorld2:
00D19E  2  1F 3F 3F 1F  .byte $1f,$3f,$3f,$1f,$1f,$1f,$1f,$1f
00D1A2  2  1F 1F 1F 1F  
00D1A6  2  1F 3F 30 04  .byte $1f,$3f,$30,$04,$03,$02,$00,$00
00D1AA  2  03 02 00 00  
00D1AE  2  1F 1F 1F 1F  .byte $1f,$1f,$1f,$1f,$1e,$0f,$0f,$07
00D1B2  2  1E 0F 0F 07  
00D1B6  2  00 01 00 01  .byte $00,$01,$00,$01,$00,$01,$00,$00
00D1BA  2  00 01 00 00  
00D1BE  2  74 42 E3 E1  .byte $74,$42,$e3,$e1,$00,$60,$38,$0c
00D1C2  2  00 60 38 0C  
00D1C6  2  0E 03 03 01  .byte $0e,$03,$03,$01,$0f,$e8,$78,$3c
00D1CA  2  0F E8 78 3C  
00D1CE  2  00 F8 FC FC  .byte $00,$f8,$fc,$fc,$fc,$fc,$fc,$fc
00D1D2  2  FC FC FC FC  
00D1D6  2  00 F8 1C 4C  .byte $00,$f8,$1c,$4c,$8c,$84,$04,$04
00D1DA  2  8C 84 04 04  
00D1DE  2  F8 F8 F8 F8  .byte $f8,$f8,$f8,$f8,$f8,$f0,$f0,$e0
00D1E2  2  F8 F0 F0 E0  
00D1E6  2  00 00 00 00  .byte $00,$00,$00,$00,$00,$00,$00,$00
00D1EA  2  00 00 00 00  
00D1EE  2  2E 62 C7 C7  .byte $2e,$62,$c7,$c7,$00,$18,$0c,$06
00D1F2  2  00 18 0C 06  
00D1F6  2  70 E0 C0 C0  .byte $70,$e0,$c0,$c0,$c0,$dc,$fe,$07
00D1FA  2  C0 DC FE 07  
00D1FE  2               
00D1FE  2               MRetainerCHRWorld3:
00D1FE  2  00 0E 3F 7F  .byte $00,$0e,$3f,$7f,$7f,$ff,$ff,$ff
00D202  2  7F FF FF FF  
00D206  2  00 0E 3F 7F  .byte $00,$0e,$3f,$7f,$7e,$fc,$f0,$ec
00D20A  2  7E FC F0 EC  
00D20E  2  7F 7F 7F 7F  .byte $7f,$7f,$7f,$7f,$3c,$1f,$47,$c1
00D212  2  3C 1F 47 C1  
00D216  2  50 4E 00 00  .byte $50,$4e,$00,$00,$0f,$00,$00,$00
00D21A  2  0F 00 00 00  
00D21E  2  E1 35 06 07  .byte $e1,$35,$06,$07,$63,$70,$30,$10
00D222  2  63 70 30 10  
00D226  2  02 0F 0F 07  .byte $02,$0f,$0f,$07,$e3,$f7,$fc,$70
00D22A  2  E3 F7 FC 70  
00D22E  2  00 70 FC FE  .byte $00,$70,$fc,$fe,$fe,$ff,$ff,$ff
00D232  2  FE FF FF FF  
00D236  2  00 70 FC FE  .byte $00,$70,$fc,$fe,$7e,$3f,$0f,$37
00D23A  2  7E 3F 0F 37  
00D23E  2  FE FE FE FE  .byte $fe,$fe,$fe,$fe,$3c,$f8,$e2,$83
00D242  2  3C F8 E2 83  
00D246  2  0A 72 00 00  .byte $0a,$72,$00,$00,$f0,$00,$00,$00
00D24A  2  F0 00 00 00  
00D24E  2  87 AC 60 E0  .byte $87,$ac,$60,$e0,$60,$0e,$0c,$08
00D252  2  60 0E 0C 08  
00D256  2  40 F0 F0 E0  .byte $40,$f0,$f0,$e0,$c7,$ef,$3f,$0e
00D25A  2  C7 EF 3F 0E  
00D25E  2               
00D25E  2               MRetainerCHRWorld4:
00D25E  2  0F 3F 7F 7F  .byte $0f,$3f,$7f,$7f,$ff,$ff,$ff,$ff
00D262  2  FF FF FF FF  
00D266  2  0F 3F 7F 7F  .byte $0f,$3f,$7f,$7f,$fe,$fc,$ee,$e0
00D26A  2  FE FC EE E0  
00D26E  2  E1 F1 7F 1F  .byte $e1,$f1,$7f,$1f,$0c,$66,$73,$21
00D272  2  0C 66 73 21  
00D276  2  C4 00 00 00  .byte $c4,$00,$00,$00,$01,$00,$00,$00
00D27A  2  01 00 00 00  
00D27E  2  3D 06 07 0E  .byte $3d,$06,$07,$0e,$1c,$18,$00,$00
00D282  2  1C 18 00 00  
00D286  2  07 07 03 00  .byte $07,$07,$03,$00,$58,$78,$70,$31
00D28A  2  58 78 70 31  
00D28E  2  F0 FC FE FE  .byte $f0,$fc,$fe,$fe,$fe,$ff,$ff,$ff
00D292  2  FE FF FF FF  
00D296  2  F0 FC FE FE  .byte $f0,$fc,$fe,$fe,$7e,$7f,$3f,$07
00D29A  2  7E 7F 3F 07  
00D29E  2  87 8F FE F8  .byte $87,$8f,$fe,$f8,$30,$64,$c6,$86
00D2A2  2  30 64 C6 86  
00D2A6  2  21 00 00 00  .byte $21,$00,$00,$00,$80,$00,$00,$00
00D2AA  2  80 00 00 00  
00D2AE  2  BC 60 C0 C0  .byte $bc,$60,$c0,$c0,$c0,$c0,$c0,$00
00D2B2  2  C0 C0 C0 00  
00D2B6  2  E0 E0 C0 00  .byte $e0,$e0,$c0,$00,$00,$c0,$c0,$f0
00D2BA  2  00 C0 C0 F0  
00D2BE  2               
00D2BE  2               ;; unused bytes
00D2BE  2  FF FF FF FF  .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
00D2C2  2  FF FF FF FF  
00D2C6  2  FF FF FF FF  
00D2CE  2  FF FF FF FF  .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
00D2D2  2  FF FF FF FF  
00D2D6  2  FF FF FF FF  
00D2DE  2  FF FF FF FF  .byte $ff,$ff,$ff,$ff,$ff
00D2E2  2  FF           
00D2E3  2               
00D2E3  2               .else
00D2E3  2               
00D2E3  2               ;level 1-4
00D2E3  2               E_CastleArea1:
00D2E3  2                 .byte $35, $9d, $55, $9b, $c9, $1b, $59, $9d, $45, $9b, $c5, $1b, $26, $80, $45, $1b
00D2E3  2                 .byte $b9, $1d, $f0, $15, $59, $9d, $0f, $08, $78, $2d, $96, $28, $90, $b5, $ff
00D2E3  2               
00D2E3  2               ;level 2-4
00D2E3  2               E_CastleArea2:
00D2E3  2                 .byte $74, $80, $f0, $38, $a0, $bb, $40, $bc, $8c, $1d, $c9, $9d, $05, $9b, $1c, $0c
00D2E3  2                 .byte $59, $1b, $b5, $1d, $2c, $8c, $40, $15, $7c, $1b, $dc, $1d, $6c, $8c, $bc, $0c
00D2E3  2                 .byte $78, $ad, $a5, $28, $90, $b5, $ff
00D2E3  2               
00D2E3  2               ;level 3-4
00D2E3  2               E_CastleArea3:
00D2E3  2                 .byte $0f, $04, $9c, $0c, $0f, $07, $c5, $1b, $65, $9d, $49, $9d, $5c, $8c, $78, $2d
00D2E3  2                 .byte $90, $b5, $ff
00D2E3  2               
00D2E3  2               ;level 4-4
00D2E3  2               E_CastleArea4:
00D2E3  2                 .byte $49, $9f, $67, $03, $79, $9d, $a0, $3a, $57, $9f, $bb, $1d, $d5, $25, $0f, $05
00D2E3  2                 .byte $18, $1d, $74, $00, $84, $00, $94, $00, $c6, $29, $49, $9d, $db, $05, $0f, $08
00D2E3  2                 .byte $05, $9b, $09, $1d, $b0, $38, $80, $95, $c0, $3c, $ec, $a8, $cc, $8c, $4a, $9b
00D2E3  2                 .byte $78, $2d, $90, $b5, $ff
00D2E3  2               
00D2E3  2               ;level 1-1
00D2E3  2               E_GroundArea1:
00D2E3  2                 .byte $07, $8e, $47, $03, $0f, $03, $10, $38, $1b, $80, $53, $06, $77, $0e, $83, $83
00D2E3  2                 .byte $a0, $3d, $90, $3b, $90, $b7, $60, $bc, $b7, $0e, $ee, $42, $00, $f7, $80, $6b
00D2E3  2                 .byte $83, $1b, $83, $ab, $06, $ff
00D2E3  2               
00D2E3  2               ;level 1-3
00D2E3  2               E_GroundArea2:
00D2E3  2                 .byte $96, $a4, $f9, $24, $d3, $83, $3a, $83, $5a, $03, $95, $07, $f4, $0f, $69, $a8
00D2E3  2                 .byte $33, $87, $86, $24, $c9, $24, $4b, $83, $67, $83, $17, $83, $56, $28, $95, $24
00D2E3  2                 .byte $0a, $a4, $ff
00D2E3  2               
00D2E3  2               ;level 2-1
00D2E3  2               E_GroundArea3:
00D2E3  2                 .byte $0f, $02, $47, $0e, $87, $0e, $c7, $0e, $f7, $0e, $27, $8e, $ee, $42, $25, $0f
00D2E3  2                 .byte $06, $ac, $28, $8c, $a8, $4e, $b3, $20, $8b, $8e, $f7, $90, $36, $90, $e5, $8e
00D2E3  2                 .byte $32, $8e, $c2, $06, $d2, $06, $e2, $06, $ff
00D2E3  2               
00D2E3  2               ;level 2-2
00D2E3  2               E_GroundArea4:
00D2E3  2                 .byte $15, $8e, $9b, $06, $e0, $37, $80, $bc, $0f, $04, $2b, $3b, $ab, $0e, $eb, $0e
00D2E3  2                 .byte $0f, $06, $f0, $37, $4b, $8e, $6b, $80, $bb, $3c, $4b, $bb, $ee, $42, $20, $1b
00D2E3  2                 .byte $bc, $cb, $00, $ab, $83, $eb, $bb, $0f, $0e, $1b, $03, $9b, $37, $d4, $0e, $a3
00D2E3  2                 .byte $86, $b3, $06, $c3, $06, $ff
00D2E3  2               
00D2E3  2               ;level 2-3
00D2E3  2               E_GroundArea5:
00D2E3  2                 .byte $c0, $be, $0f, $03, $38, $0e, $15, $8f, $aa, $83, $f8, $07, $0f, $07, $96, $10
00D2E3  2                 .byte $0f, $09, $48, $10, $ba, $03, $ff
00D2E3  2               
00D2E3  2               ;level 3-1
00D2E3  2               E_GroundArea6:
00D2E3  2                 .byte $87, $85, $a3, $05, $db, $83, $fb, $03, $93, $8f, $bb, $03, $ce, $42, $42, $9b
00D2E3  2                 .byte $83, $ae, $b3, $40, $db, $00, $f4, $0f, $33, $8f, $74, $0f, $10, $bc, $f5, $0f
00D2E3  2                 .byte $2e, $c2, $45, $b7, $03, $f7, $03, $c8, $90, $ff
00D2E3  2               
00D2E3  2               ;level 3-3
00D2E3  2               E_GroundArea7:
00D2E3  2                 .byte $80, $be, $83, $03, $92, $10, $4b, $80, $b0, $3c, $07, $80, $b7, $24, $0c, $a4
00D2E3  2                 .byte $96, $a9, $1b, $83, $7b, $24, $b7, $24, $97, $83, $e2, $0f, $a9, $a9, $38, $a9
00D2E3  2                 .byte $0f, $0b, $74, $8f, $ff
00D2E3  2               
00D2E3  2               ;level 4-1
00D2E3  2               E_GroundArea8:
00D2E3  2                 .byte $e2, $91, $0f, $03, $42, $11, $0f, $06, $72, $11, $0f, $08, $ee, $02, $60, $02
00D2E3  2                 .byte $91, $ee, $b3, $60, $d3, $86, $ff
00D2E3  2               
00D2E3  2               ;level 4-2
00D2E3  2               E_GroundArea9:
00D2E3  2                 .byte $0f, $02, $9b, $02, $ab, $02, $0f, $04, $13, $03, $92, $11, $60, $b7, $00, $bc
00D2E3  2                 .byte $00, $bb, $0b, $83, $cb, $03, $7b, $85, $9e, $c2, $60, $e6, $05, $0f, $0c, $62
00D2E3  2                 .byte $10, $ff
00D2E3  2               
00D2E3  2               ;level 4-3
00D2E3  2               E_GroundArea11:
00D2E3  2                 .byte $e6, $a9, $57, $a8, $b5, $24, $19, $a4, $76, $28, $a2, $0f, $95, $8f, $9d, $a8
00D2E3  2                 .byte $0f, $07, $09, $29, $55, $24, $8b, $17, $a9, $24, $db, $83, $04, $a9, $24, $8f
00D2E3  2                 .byte $65, $0f, $ff
00D2E3  2               
00D2E3  2               ;cloud level used in levels 2-1, 3-1 and 4-1
00D2E3  2               E_GroundArea20:
00D2E3  2                 .byte $0a, $aa, $1e, $22, $29, $1e, $25, $49, $2e, $27, $66, $ff
00D2E3  2               
00D2E3  2               ;level 1-2
00D2E3  2               E_UndergroundArea1:
00D2E3  2                 .byte $0a, $8e, $de, $b4, $00, $e0, $37, $5b, $82, $2b, $a9, $aa, $29, $29, $a9, $a8
00D2E3  2                 .byte $29, $0f, $08, $f0, $3c, $79, $a9, $c5, $26, $cd, $26, $ee, $3b, $01, $67, $b4
00D2E3  2                 .byte $0f, $0c, $2e, $c1, $00, $ff
00D2E3  2               
00D2E3  2               ;warp zone area used by level 1-2
00D2E3  2               E_UndergroundArea2:
00D2E3  2                 .byte $09, $a9, $19, $a9, $de, $42, $02, $7b, $83, $ff
00D2E3  2               
00D2E3  2               ;underground bonus rooms used in many levels
00D2E3  2               E_UndergroundArea3:
00D2E3  2                 .byte $1e, $a0, $0a, $1e, $23, $2b, $1e, $28, $6b, $0f, $03, $1e, $40, $08, $1e, $25
00D2E3  2                 .byte $4e, $0f, $06, $1e, $22, $25, $1e, $25, $45, $ff
00D2E3  2               
00D2E3  2               ;level 3-2
00D2E3  2               E_WaterArea1:
00D2E3  2                 .byte $0f, $01, $2a, $07, $2e, $3b, $41, $e9, $07, $0f, $03, $6b, $07, $f9, $07, $b8
00D2E3  2                 .byte $80, $2a, $87, $4a, $87, $b3, $0f, $84, $87, $47, $83, $87, $07, $0a, $87, $42
00D2E3  2                 .byte $87, $1b, $87, $6b, $03, $ff
00D2E3  2               
00D2E3  2               ;water area used by level 4-1
00D2E3  2               E_WaterArea3:
00D2E3  2                 .byte $1e, $a7, $6a, $5b, $82, $74, $07, $d8, $07, $e8, $02, $0f, $04, $26, $07, $ff
00D2E3  2               
00D2E3  2               ;level 1-4
00D2E3  2               L_CastleArea1:
00D2E3  2                 .byte $9b, $07, $05, $32, $06, $33, $07, $34, $33, $8e, $4e, $0a, $7e, $06, $9e, $0a
00D2E3  2                 .byte $ce, $06, $e3, $00, $ee, $0a, $1e, $87, $53, $0e, $8e, $02, $9c, $00, $c7, $0e
00D2E3  2                 .byte $d7, $37, $57, $8e, $6c, $05, $da, $60, $e9, $61, $f8, $62, $fe, $0b, $43, $8e
00D2E3  2                 .byte $c3, $0e, $43, $8e, $b7, $0e, $ee, $09, $fe, $0a, $3e, $86, $57, $0e, $6e, $0a
00D2E3  2                 .byte $7e, $06, $ae, $0a, $be, $06, $fe, $07, $15, $e2, $55, $62, $95, $62, $fe, $0a
00D2E3  2                 .byte $0d, $c4, $cd, $43, $ce, $09, $de, $0b, $dd, $42, $fe, $02, $5d, $c7, $fd
00D2E3  2               
00D2E3  2               ;level 2-4
00D2E3  2               L_CastleArea2:
00D2E3  2                 .byte $9b, $07, $05, $32, $06, $33, $07, $34, $03, $e2, $0e, $06, $1e, $0c, $7e, $0a
00D2E3  2                 .byte $8e, $05, $8e, $82, $8a, $8e, $8e, $0a, $ee, $02, $0a, $e0, $19, $61, $23, $06
00D2E3  2                 .byte $28, $62, $2e, $0b, $7e, $0a, $81, $62, $87, $30, $8e, $04, $a7, $31, $c7, $0e
00D2E3  2                 .byte $d7, $33, $fe, $03, $03, $8e, $0e, $0a, $11, $62, $1e, $04, $27, $32, $4e, $0a
00D2E3  2                 .byte $51, $62, $57, $0e, $5e, $04, $67, $34, $9e, $0a, $a1, $62, $ae, $03, $b3, $0e
00D2E3  2                 .byte $be, $0b, $ee, $09, $fe, $0a, $2e, $82, $7a, $0e, $7e, $0a, $97, $31, $be, $04
00D2E3  2                 .byte $da, $0e, $ee, $0a, $f1, $62, $fe, $02, $3e, $8a, $7e, $06, $ae, $0a, $ce, $06
00D2E3  2                 .byte $fe, $0a, $0d, $c4, $11, $53, $21, $52, $24, $0b, $51, $52, $61, $52, $cd, $43
00D2E3  2                 .byte $ce, $09, $dd, $42, $de, $0b, $fe, $02, $5d, $c7, $fd
00D2E3  2               
00D2E3  2               ;level 3-4
00D2E3  2               L_CastleArea3:
00D2E3  2                 .byte $5b, $09, $05, $34, $06, $35, $6e, $06, $7e, $0a, $ae, $02, $fe, $02, $0d, $01
00D2E3  2                 .byte $0e, $0e, $2e, $0a, $6e, $09, $be, $0a, $ed, $4b, $e4, $60, $ee, $0d, $5e, $82
00D2E3  2                 .byte $78, $72, $a4, $3d, $a5, $3e, $a6, $3f, $a3, $be, $a6, $3e, $a9, $32, $e9, $3a
00D2E3  2                 .byte $9c, $80, $a3, $33, $a6, $33, $a9, $33, $e5, $06, $ed, $4b, $f3, $30, $f6, $30
00D2E3  2                 .byte $f9, $30, $fe, $02, $0d, $05, $3c, $01, $57, $73, $7c, $02, $93, $30, $a7, $73
00D2E3  2                 .byte $b3, $37, $cc, $01, $07, $83, $17, $03, $27, $03, $37, $03, $64, $3b, $77, $3a
00D2E3  2                 .byte $0c, $80, $2e, $0e, $9e, $02, $a5, $62, $b6, $61, $cc, $02, $c3, $33, $ed, $4b
00D2E3  2                 .byte $03, $b7, $07, $37, $83, $37, $87, $37, $dd, $4b, $03, $b5, $07, $35, $5e, $0a
00D2E3  2                 .byte $8e, $02, $ae, $0a, $de, $06, $fe, $0a, $0d, $c4, $cd, $43, $ce, $09, $dd, $42
00D2E3  2                 .byte $de, $0b, $fe, $02, $5d, $c7, $fd
00D2E3  2               
00D2E3  2               ;level 4-4
00D2E3  2               L_CastleArea4:
00D2E3  2                 .byte $9b, $07, $05, $32, $06, $33, $07, $34, $4e, $03, $5c, $02, $0c, $f1, $27, $00
00D2E3  2                 .byte $3c, $74, $47, $0e, $fc, $00, $fe, $0b, $77, $8e, $ee, $09, $fe, $0a, $45, $b2
00D2E3  2                 .byte $55, $0e, $99, $32, $b9, $0e, $fe, $02, $0e, $85, $fe, $02, $16, $8e, $2e, $0c
00D2E3  2                 .byte $ae, $0a, $ee, $05, $1e, $82, $47, $0e, $07, $bd, $c4, $72, $de, $0a, $fe, $02
00D2E3  2                 .byte $03, $8e, $07, $0e, $13, $3c, $17, $3d, $e3, $03, $ee, $0a, $f3, $06, $f7, $03
00D2E3  2                 .byte $fe, $0e, $fe, $8a, $38, $e4, $4a, $72, $68, $64, $37, $b0, $98, $64, $a8, $64
00D2E3  2                 .byte $e8, $64, $f8, $64, $0d, $c4, $71, $64, $cd, $43, $ce, $09, $dd, $42, $de, $0b
00D2E3  2                 .byte $fe, $02, $5d, $c7, $fd
00D2E3  2               
00D2E3  2               ;level 1-1
00D2E3  2               L_GroundArea1:
00D2E3  2                 .byte $50, $31, $0f, $26, $13, $e4, $23, $24, $27, $23, $37, $07, $66, $61, $ac, $74
00D2E3  2                 .byte $c7, $01, $0b, $f1, $77, $73, $b6, $04, $db, $71, $5c, $82, $83, $2d, $a2, $47
00D2E3  2                 .byte $a7, $0a, $b7, $29, $4f, $b3, $87, $0b, $93, $23, $cc, $06, $e3, $2c, $3a, $e0
00D2E3  2                 .byte $7c, $71, $97, $01, $ac, $73, $e6, $61, $0e, $b1, $b7, $f3, $dc, $02, $d3, $25
00D2E3  2                 .byte $07, $fb, $2c, $01, $e7, $73, $2c, $f2, $34, $72, $57, $00, $7c, $02, $39, $f1
00D2E3  2                 .byte $bf, $37, $33, $e7, $cd, $41, $0f, $a6, $ed, $47, $fd
00D2E3  2               
00D2E3  2               ;level 1-3
00D2E3  2               L_GroundArea2:
00D2E3  2                 .byte $50, $11, $0f, $26, $fe, $10, $47, $92, $56, $40, $ac, $16, $af, $12, $0f, $95
00D2E3  2                 .byte $73, $16, $82, $44, $ec, $48, $bc, $c2, $1c, $b1, $b3, $16, $c2, $44, $86, $c0
00D2E3  2                 .byte $9c, $14, $9f, $12, $a6, $40, $df, $15, $0b, $96, $43, $12, $97, $31, $d3, $12
00D2E3  2                 .byte $03, $92, $27, $14, $63, $00, $c7, $15, $d6, $43, $ac, $97, $af, $11, $1f, $96
00D2E3  2                 .byte $64, $13, $e3, $12, $2e, $91, $9d, $41, $ae, $42, $df, $20, $cd, $c7, $fd
00D2E3  2               
00D2E3  2               ;level 2-1
00D2E3  2               L_GroundArea3:
00D2E3  2                 .byte $52, $21, $0f, $20, $6e, $64, $4f, $b2, $7c, $5f, $7c, $3f, $7c, $d8, $7c, $38
00D2E3  2                 .byte $83, $02, $a3, $00, $c3, $02, $f7, $16, $5c, $d6, $cf, $35, $d3, $20, $e3, $0a
00D2E3  2                 .byte $f3, $20, $25, $b5, $2c, $53, $6a, $7a, $8c, $54, $da, $72, $fc, $50, $0c, $d2
00D2E3  2                 .byte $39, $73, $5c, $54, $aa, $72, $cc, $53, $f7, $16, $33, $83, $40, $06, $5c, $5b
00D2E3  2                 .byte $09, $93, $27, $0f, $3c, $5c, $0a, $b0, $63, $27, $78, $72, $93, $09, $97, $03
00D2E3  2                 .byte $a7, $03, $b7, $22, $47, $81, $5c, $72, $2a, $b0, $28, $0f, $3c, $5f, $58, $31
00D2E3  2                 .byte $b8, $31, $28, $b1, $3c, $5b, $98, $31, $fa, $30, $03, $b2, $20, $04, $7f, $b7
00D2E3  2                 .byte $f3, $67, $8d, $c1, $bf, $26, $ad, $c7, $fd
00D2E3  2               
00D2E3  2               ;level 2-2
00D2E3  2               L_GroundArea4:
00D2E3  2                 .byte $54, $11, $0f, $26, $38, $f2, $ab, $71, $0b, $f1, $96, $42, $ce, $10, $1e, $91
00D2E3  2                 .byte $29, $61, $3a, $60, $4e, $10, $78, $74, $8e, $11, $06, $c3, $1a, $e0, $1e, $10
00D2E3  2                 .byte $5e, $11, $67, $63, $77, $63, $88, $62, $99, $61, $aa, $60, $be, $10, $0a, $f2
00D2E3  2                 .byte $15, $45, $7e, $11, $7a, $31, $9a, $e0, $ac, $02, $d9, $61, $d4, $0a, $ec, $01
00D2E3  2                 .byte $d6, $c2, $84, $c3, $98, $fa, $d3, $07, $d7, $0b, $e9, $61, $ee, $10, $2e, $91
00D2E3  2                 .byte $39, $71, $93, $03, $a6, $03, $be, $10, $e1, $71, $e3, $31, $5e, $91, $69, $61
00D2E3  2                 .byte $e6, $41, $28, $e2, $99, $71, $ae, $10, $ce, $11, $be, $90, $d6, $32, $3e, $91
00D2E3  2                 .byte $5f, $37, $66, $60, $d3, $67, $6d, $c1, $af, $26, $9d, $c7, $fd
00D2E3  2               
00D2E3  2               ;level 2-3
00D2E3  2               L_GroundArea5:
00D2E3  2                 .byte $54, $11, $0f, $26, $af, $32, $d8, $62, $e8, $62, $f8, $62, $fe, $10, $0c, $be
00D2E3  2                 .byte $f8, $64, $0d, $c8, $2c, $43, $98, $64, $ac, $39, $48, $e4, $6a, $62, $7c, $47
00D2E3  2                 .byte $fa, $62, $3c, $b7, $ea, $62, $fc, $4d, $f6, $02, $03, $80, $06, $02, $13, $02
00D2E3  2                 .byte $da, $62, $0d, $c8, $0b, $17, $97, $16, $2c, $b1, $33, $43, $6c, $31, $ac, $31
00D2E3  2                 .byte $17, $93, $73, $12, $cc, $31, $1a, $e2, $2c, $4b, $67, $48, $ea, $62, $0d, $ca
00D2E3  2                 .byte $17, $12, $53, $12, $be, $11, $1d, $c1, $3e, $42, $6f, $20, $4d, $c7, $fd
00D2E3  2               
00D2E3  2               ;level 3-1
00D2E3  2               L_GroundArea6:
00D2E3  2                 .byte $52, $b1, $0f, $20, $6e, $75, $53, $aa, $57, $25, $b7, $0a, $c7, $23, $0c, $83
00D2E3  2                 .byte $5c, $72, $87, $01, $c3, $00, $c7, $20, $dc, $65, $0c, $87, $c3, $22, $f3, $03
00D2E3  2                 .byte $03, $a2, $27, $7b, $33, $03, $43, $23, $52, $42, $9c, $06, $a7, $20, $c3, $23
00D2E3  2                 .byte $03, $a2, $0c, $02, $33, $09, $39, $71, $43, $23, $77, $06, $83, $67, $a7, $73
00D2E3  2                 .byte $5c, $82, $c9, $11, $07, $80, $1c, $71, $98, $11, $9a, $10, $f3, $04, $16, $f4
00D2E3  2                 .byte $3c, $02, $68, $7a, $8c, $01, $a7, $73, $e7, $73, $ac, $83, $09, $8f, $1c, $03
00D2E3  2                 .byte $9f, $37, $13, $e7, $7c, $02, $ad, $41, $ef, $26, $0d, $0e, $39, $71, $7f, $37
00D2E3  2                 .byte $f2, $68, $02, $e8, $12, $3a, $1c, $00, $68, $7a, $de, $3f, $6d, $c5, $fd
00D2E3  2               
00D2E3  2               ;level 3-3
00D2E3  2               L_GroundArea7:
00D2E3  2                 .byte $55, $10, $0b, $1f, $0f, $26, $d6, $12, $07, $9f, $33, $1a, $fb, $1f, $f7, $94
00D2E3  2                 .byte $53, $94, $71, $71, $cc, $15, $cf, $13, $1f, $98, $63, $12, $9b, $13, $a9, $71
00D2E3  2                 .byte $fb, $17, $09, $f1, $13, $13, $21, $42, $59, $0f, $eb, $13, $33, $93, $40, $06
00D2E3  2                 .byte $8c, $14, $8f, $17, $93, $40, $cf, $13, $0b, $94, $57, $15, $07, $93, $19, $f3
00D2E3  2                 .byte $c6, $43, $c7, $13, $d3, $03, $e3, $03, $33, $b0, $4a, $72, $55, $46, $73, $31
00D2E3  2                 .byte $a8, $74, $e3, $12, $8e, $91, $ad, $41, $ce, $42, $ef, $20, $dd, $c7, $fd
00D2E3  2               
00D2E3  2               ;level 4-1
00D2E3  2               L_GroundArea8:
00D2E3  2                 .byte $52, $21, $0f, $20, $6e, $63, $a9, $f1, $fb, $71, $22, $83, $37, $0b, $36, $50
00D2E3  2                 .byte $39, $51, $b8, $62, $57, $f3, $e8, $02, $f8, $02, $08, $82, $18, $02, $2d, $4a
00D2E3  2                 .byte $28, $02, $38, $02, $48, $00, $a8, $0f, $aa, $30, $bc, $5a, $6a, $b0, $4f, $b6
00D2E3  2                 .byte $b7, $04, $9a, $b0, $ac, $71, $c7, $01, $e6, $74, $0d, $09, $46, $02, $56, $00
00D2E3  2                 .byte $6c, $01, $84, $79, $86, $02, $96, $02, $a4, $71, $a6, $02, $b6, $02, $c4, $71
00D2E3  2                 .byte $c6, $02, $d6, $02, $39, $f1, $6c, $00, $77, $02, $a3, $09, $ac, $00, $b8, $72
00D2E3  2                 .byte $dc, $01, $07, $f3, $4c, $00, $6f, $37, $e3, $03, $e6, $03, $5d, $ca, $6c, $00
00D2E3  2                 .byte $7d, $41, $cf, $26, $9d, $c7, $fd
00D2E3  2               
00D2E3  2               ;level 4-2
00D2E3  2               L_GroundArea9:
00D2E3  2                 .byte $50, $a1, $0f, $26, $17, $91, $19, $11, $48, $00, $68, $11, $6a, $10, $96, $14
00D2E3  2                 .byte $d8, $0a, $e8, $02, $f8, $02, $dc, $81, $6c, $81, $89, $0f, $9c, $00, $c3, $29
00D2E3  2                 .byte $f8, $62, $47, $a7, $c6, $61, $0d, $07, $56, $74, $b7, $00, $b9, $11, $cc, $76
00D2E3  2                 .byte $ed, $4a, $1c, $80, $37, $01, $3a, $10, $de, $20, $e9, $0b, $ee, $21, $c8, $bc
00D2E3  2                 .byte $9c, $f6, $bc, $00, $cb, $7a, $eb, $72, $0c, $82, $39, $71, $b7, $63, $cc, $03
00D2E3  2                 .byte $e6, $60, $26, $e0, $4a, $30, $53, $31, $5c, $58, $ed, $41, $2f, $a6, $1d, $c7
00D2E3  2                 .byte $fd
00D2E3  2               
00D2E3  2               ;level 4-3
00D2E3  2               L_GroundArea11:
00D2E3  2                 .byte $50, $11, $0f, $26, $fe, $10, $8b, $93, $a9, $0f, $14, $c1, $cc, $16, $cf, $11
00D2E3  2                 .byte $2f, $95, $b7, $14, $c7, $96, $d6, $44, $2b, $92, $39, $0f, $72, $41, $a7, $00
00D2E3  2                 .byte $1b, $95, $97, $13, $6c, $95, $6f, $11, $a2, $40, $bf, $15, $c2, $40, $0b, $9f
00D2E3  2                 .byte $53, $16, $62, $44, $72, $c2, $9b, $1d, $b7, $e0, $ed, $4a, $03, $e0, $8e, $11
00D2E3  2                 .byte $9d, $41, $be, $42, $ef, $20, $cd, $c7, $fd
00D2E3  2               
00D2E3  2               ;cloud level used in levels 2-1, 3-1 and 4-1
00D2E3  2               L_GroundArea20:
00D2E3  2                 .byte $00, $c1, $4c, $00, $03, $cf, $00, $d7, $23, $4d, $07, $af, $2a, $4c, $03, $cf
00D2E3  2                 .byte $3e, $80, $f3, $4a, $bb, $c2, $bd, $c7, $fd
00D2E3  2               
00D2E3  2               ;level 1-2
00D2E3  2               L_UndergroundArea1:
00D2E3  2                 .byte $48, $0f, $0e, $01, $5e, $02, $0a, $b0, $1c, $54, $6a, $30, $7f, $34, $c6, $64
00D2E3  2                 .byte $d6, $64, $e6, $64, $f6, $64, $fe, $00, $f0, $07, $00, $a1, $1e, $02, $47, $73
00D2E3  2                 .byte $7e, $04, $84, $52, $94, $50, $95, $0b, $96, $50, $a4, $52, $ae, $05, $b8, $51
00D2E3  2                 .byte $c8, $51, $ce, $01, $17, $f3, $45, $03, $52, $09, $62, $21, $6f, $34, $81, $21
00D2E3  2                 .byte $9e, $02, $b6, $64, $c6, $64, $c0, $0c, $d6, $64, $d0, $07, $e6, $64, $e0, $0c
00D2E3  2                 .byte $f0, $07, $fe, $0a, $0d, $06, $0e, $01, $4e, $04, $67, $73, $8e, $02, $b7, $0a
00D2E3  2                 .byte $bc, $03, $c4, $72, $c7, $22, $08, $f2, $2c, $02, $59, $71, $7c, $01, $96, $74
00D2E3  2                 .byte $bc, $01, $d8, $72, $fc, $01, $39, $f1, $4e, $01, $9e, $04, $a7, $52, $b7, $0b
00D2E3  2                 .byte $b8, $51, $c7, $51, $d7, $50, $de, $02, $3a, $e0, $3e, $0a, $9e, $00, $08, $d4
00D2E3  2                 .byte $18, $54, $28, $54, $48, $54, $6e, $06, $9e, $01, $a8, $52, $af, $47, $b8, $52
00D2E3  2                 .byte $c8, $52, $d8, $52, $de, $0f, $4d, $c7, $ce, $01, $dc, $01, $f9, $79, $1c, $82
00D2E3  2                 .byte $48, $72, $7f, $37, $f2, $68, $01, $e9, $11, $3a, $68, $7a, $de, $0f, $6d, $c5
00D2E3  2                 .byte $fd
00D2E3  2               
00D2E3  2               ;warp zone area used by level 1-2
00D2E3  2               L_UndergroundArea2:
00D2E3  2                 .byte $0b, $0f, $0e, $01, $9c, $71, $b7, $00, $be, $00, $3e, $81, $47, $73, $5e, $00
00D2E3  2                 .byte $63, $42, $8e, $01, $a7, $73, $be, $00, $7e, $81, $88, $72, $f0, $59, $fe, $00
00D2E3  2                 .byte $00, $d9, $0e, $01, $39, $79, $a7, $03, $ae, $00, $b4, $03, $de, $0f, $0d, $05
00D2E3  2                 .byte $0e, $02, $68, $7a, $be, $01, $de, $0f, $6d, $c5, $fd
00D2E3  2               
00D2E3  2               ;underground bonus rooms used with worlds 1-4
00D2E3  2               L_UndergroundArea3:
00D2E3  2                 .byte $08, $8f, $0e, $01, $17, $05, $2e, $02, $30, $07, $37, $03, $3a, $49, $44, $03
00D2E3  2                 .byte $58, $47, $df, $4a, $6d, $c7, $0e, $81, $00, $5a, $2e, $02, $87, $52, $97, $2f
00D2E3  2                 .byte $99, $4f, $0a, $90, $93, $56, $a3, $0b, $a7, $50, $b3, $55, $df, $4a, $6d, $c7
00D2E3  2                 .byte $0e, $81, $00, $5a, $2e, $00, $3e, $02, $41, $56, $57, $25, $56, $45, $68, $51
00D2E3  2                 .byte $7a, $43, $b7, $0b, $b8, $51, $df, $4a, $6d, $c7, $fd
00D2E3  2               
00D2E3  2               ;level 3-2
00D2E3  2               L_WaterArea1:
00D2E3  2                 .byte $41, $01, $03, $b4, $04, $34, $05, $34, $5c, $02, $83, $37, $84, $37, $85, $37
00D2E3  2                 .byte $09, $c2, $0c, $02, $1d, $49, $fa, $60, $09, $e1, $18, $62, $20, $63, $27, $63
00D2E3  2                 .byte $33, $37, $37, $63, $47, $63, $5c, $05, $79, $43, $fe, $06, $35, $d2, $46, $48
00D2E3  2                 .byte $91, $53, $d6, $51, $fe, $01, $0c, $83, $6c, $04, $b4, $62, $c4, $62, $d4, $62
00D2E3  2                 .byte $e4, $62, $f4, $62, $18, $d2, $79, $51, $f4, $66, $fe, $02, $0c, $8a, $1d, $49
00D2E3  2                 .byte $31, $55, $56, $41, $77, $41, $98, $41, $c5, $55, $fe, $01, $07, $e3, $17, $63
00D2E3  2                 .byte $27, $63, $37, $63, $47, $63, $57, $63, $67, $63, $78, $62, $89, $61, $9a, $60
00D2E3  2                 .byte $bc, $07, $ca, $42, $3a, $b3, $46, $53, $63, $34, $66, $44, $7c, $01, $9a, $33
00D2E3  2                 .byte $b7, $52, $dc, $01, $fa, $32, $05, $d4, $2c, $0d, $43, $37, $47, $35, $b7, $30
00D2E3  2                 .byte $c3, $64, $23, $e4, $29, $45, $33, $64, $43, $64, $53, $64, $63, $64, $73, $64
00D2E3  2                 .byte $9a, $60, $a9, $61, $b8, $62, $be, $0b, $d4, $31, $d5, $0d, $de, $0f, $0d, $ca
00D2E3  2                 .byte $7d, $47, $fd
00D2E3  2               
00D2E3  2               ;water area used by level 4-1
00D2E3  2               L_WaterArea3:
00D2E3  2                 .byte $01, $01, $78, $52, $b5, $55, $da, $60, $e9, $61, $f8, $62, $fe, $0b, $fe, $81
00D2E3  2                 .byte $0a, $cf, $36, $49, $62, $43, $fe, $07, $36, $c9, $fe, $01, $0c, $84, $65, $55
00D2E3  2                 .byte $97, $52, $9a, $32, $a9, $31, $b8, $30, $c7, $63, $ce, $0f, $d5, $0d, $7d, $c7
00D2E3  2                 .byte $fd
00D2E3  2               
00D2E3  2               ;a bunch of unused space
00D2E3  2                 .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D2E3  2                 .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D2E3  2                 .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D2E3  2                 .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D2E3  2                 .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D2E3  2                 .byte $ff, $ff, $ff
00D2E3  2               .endif
00D2E3  2               
00D2E3  2               ;-------------------------------------------------------------------------------------
00D2E3  2               
00D2E3  2               ;this is overwritten by the contents of SM2SAVE
00D2E3  2               GamesBeatenCount:
00D2E3  2  00                  .byte $00
00D2E4  2               .ifdef ANN
00D2E4  2  FF                  .byte $FF
00D2E5  2               .endif
00D2E5  2               
00D2E5  2               ;-------------------------------------------------------------------------------------
00D2E5  2               
00D2E5  2               SoundEngine:
00D2E5  2  AD 70 07              lda OperMode              ;are we in attract mode?
00D2E8  2  D0 04                 bne SndOn
00D2EA  2  8D 15 40              sta SND_MASTERCTRL_REG    ;if so, disable sound and leave
00D2ED  2  60                    rts
00D2EE  2  A9 FF        SndOn:   lda #$ff
00D2F0  2  8D 17 40              sta JOYPAD_PORT2          ;disable irqs from apu and set frame counter mode
00D2F3  2  A9 0F                 lda #$0f
00D2F5  2  8D 15 40              sta SND_MASTERCTRL_REG    ;enable first four channels
00D2F8  2  AD C6 07              lda PauseModeFlag         ;is sound already in pause mode?
00D2FB  2  D0 06                 bne InPause
00D2FD  2  A5 FA                 lda PauseSoundQueue       ;if not, check pause sfx queue
00D2FF  2  C9 01                 cmp #$01
00D301  2  D0 5D                 bne RunSoundSubroutines   ;if queue is empty, skip pause mode routine
00D303  2  AD B2 07     InPause: lda PauseSoundBuffer      ;check pause sfx buffer
00D306  2  D0 23                 bne ContPau
00D308  2  A5 FA                 lda PauseSoundQueue       ;check pause queue
00D30A  2  F0 66                 beq SkipSoundSubroutines
00D30C  2  8D B2 07              sta PauseSoundBuffer      ;if queue full, store in buffer and activate
00D30F  2  8D C6 07              sta PauseModeFlag         ;pause mode to interrupt game sounds
00D312  2  A9 00                 lda #$00                  ;disable sound and clear sfx buffers
00D314  2  8D 15 40              sta SND_MASTERCTRL_REG
00D317  2  85 F1                 sta Square1SoundBuffer
00D319  2  85 F2                 sta Square2SoundBuffer
00D31B  2  85 F3                 sta NoiseSoundBuffer
00D31D  2  A9 0F                 lda #$0f
00D31F  2  8D 15 40              sta SND_MASTERCTRL_REG    ;enable sound again
00D322  2  A9 2A                 lda #$2a                  ;store length of sound in pause counter
00D324  2  8D BB 07              sta Squ1_SfxLenCounter
00D327  2  A9 44        PTone1F: lda #$44                  ;play first tone
00D329  2  D0 11                 bne PTRegC                ;unconditional branch
00D32B  2  AD BB 07     ContPau: lda Squ1_SfxLenCounter    ;check pause length left
00D32E  2  C9 24                 cmp #$24                  ;time to play second?
00D330  2  F0 08                 beq PTone2F
00D332  2  C9 1E                 cmp #$1e                  ;time to play first again?
00D334  2  F0 F1                 beq PTone1F
00D336  2  C9 18                 cmp #$18                  ;time to play second again?
00D338  2  D0 09                 bne DecPauC               ;only load regs during times, otherwise skip
00D33A  2  A9 64        PTone2F: lda #$64                  ;store reg contents and play the pause sfx
00D33C  2  A2 84        PTRegC:  ldx #$84
00D33E  2  A0 7F                 ldy #$7f
00D340  2  20 9D D3              jsr PlaySqu1Sfx
00D343  2  CE BB 07     DecPauC: dec Squ1_SfxLenCounter    ;decrement pause sfx counter
00D346  2  D0 2A                 bne SkipSoundSubroutines
00D348  2  A9 00                 lda #$00                  ;disable sound if in pause mode and
00D34A  2  8D 15 40              sta SND_MASTERCTRL_REG    ;not currently playing the pause sfx
00D34D  2  AD B2 07              lda PauseSoundBuffer      ;if no longer playing pause sfx, check to see
00D350  2  C9 02                 cmp #$02                  ;if we need to be playing sound again
00D352  2  D0 05                 bne SkipPIn
00D354  2  A9 00                 lda #$00                  ;clear pause mode to allow game sounds again
00D356  2  8D C6 07              sta PauseModeFlag
00D359  2  A9 00        SkipPIn: lda #$00                  ;clear pause sfx buffer
00D35B  2  8D B2 07              sta PauseSoundBuffer
00D35E  2  F0 12                 beq SkipSoundSubroutines
00D360  2               
00D360  2               RunSoundSubroutines:
00D360  2  20 30 D4              jsr Square1SfxHandler  ;play sfx on square channel 1
00D363  2  20 91 D5              jsr Square2SfxHandler  ; ''  ''  '' square channel 2
00D366  2  20 A4 D6              jsr NoiseSfxHandler    ; ''  ''  '' noise channel
00D369  2  20 D1 D6              jsr MusicHandler       ;play music on all channels
00D36C  2  A9 00                 lda #$00               ;clear the music queues
00D36E  2  85 FB                 sta AreaMusicQueue
00D370  2  85 FC                 sta EventMusicQueue
00D372  2               
00D372  2               SkipSoundSubroutines:
00D372  2  A9 00                  lda #$00               ;clear the sound effects queues
00D374  2  85 FF                  sta Square1SoundQueue
00D376  2  85 FE                  sta Square2SoundQueue
00D378  2  85 FD                  sta NoiseSoundQueue
00D37A  2  85 FA                  sta PauseSoundQueue
00D37C  2  AC C0 07               ldy DAC_Counter        ;load some sort of counter
00D37F  2  A5 F4                  lda AreaMusicBuffer
00D381  2  29 03                  and #%00000011         ;check for specific music
00D383  2  F0 07                  beq NoIncDAC
00D385  2  EE C0 07               inc DAC_Counter        ;increment and check counter
00D388  2  C0 30                  cpy #$30
00D38A  2  90 06                  bcc StrWave            ;if not there yet, just store it
00D38C  2  98           NoIncDAC: tya
00D38D  2  F0 03                  beq StrWave            ;if we are at zero, do not decrement
00D38F  2  CE C0 07               dec DAC_Counter        ;decrement counter
00D392  2  8C 11 40     StrWave:  sty SND_DELTA_REG+1    ;store into DMC load register (??)
00D395  2  60                     rts                    ;we are done here
00D396  2               
00D396  2               
00D396  2               ;--------------------------------
00D396  2               
00D396  2               Dump_Squ1_Regs:
00D396  2  8C 01 40           sty SND_SQUARE1_REG+1  ;dump the contents of X and Y into square 1's control regs
00D399  2  8E 00 40           stx SND_SQUARE1_REG
00D39C  2  60                 rts
00D39D  2               
00D39D  2               PlaySqu1Sfx:
00D39D  2  20 96 D3           jsr Dump_Squ1_Regs     ;do sub to set ctrl regs for square 1, then set frequency regs
00D3A0  2               
00D3A0  2               SetFreq_Squ1:
00D3A0  2  A2 00              ldx #$00               ;set frequency reg offset for square 1 sound channel
00D3A2  2               
00D3A2  2               Dump_Freq_Regs:
00D3A2  2  A8                   tay
00D3A3  2  B9 01 DF             lda FreqRegLookupTbl+1,y  ;use previous contents of A for sound reg offset
00D3A6  2  F0 0B                beq NoTone                ;if zero, then do not load
00D3A8  2  9D 02 40             sta SND_REGISTER+2,x      ;first byte goes into LSB of frequency divider
00D3AB  2  B9 00 DF             lda FreqRegLookupTbl,y    ;second byte goes into 3 MSB plus extra bit for
00D3AE  2  09 08                ora #%00001000            ;length counter
00D3B0  2  9D 03 40             sta SND_REGISTER+3,x
00D3B3  2  60           NoTone: rts
00D3B4  2               
00D3B4  2               Dump_Sq2_Regs:
00D3B4  2  8E 04 40           stx SND_SQUARE2_REG    ;dump the contents of X and Y into square 2's control regs
00D3B7  2  8C 05 40           sty SND_SQUARE2_REG+1
00D3BA  2  60                 rts
00D3BB  2               
00D3BB  2               PlaySqu2Sfx:
00D3BB  2  20 B4 D3           jsr Dump_Sq2_Regs      ;do sub to set ctrl regs for square 2, then set frequency regs
00D3BE  2               
00D3BE  2               SetFreq_Squ2:
00D3BE  2  A2 04              ldx #$04               ;set frequency reg offset for square 2 sound channel
00D3C0  2  D0 E0              bne Dump_Freq_Regs     ;unconditional branch
00D3C2  2               
00D3C2  2               SetFreq_Tri:
00D3C2  2  A2 08              ldx #$08               ;set frequency reg offset for triangle sound channel
00D3C4  2  D0 DC              bne Dump_Freq_Regs     ;unconditional branch
00D3C6  2               
00D3C6  2               ;--------------------------------
00D3C6  2               
00D3C6  2               SwimStompEnvelopeData:
00D3C6  2  9F 9B 98 96        .byte $9f, $9b, $98, $96, $95, $94, $92, $90
00D3CA  2  95 94 92 90  
00D3CE  2  90 9A 97 95        .byte $90, $9a, $97, $95, $93, $92
00D3D2  2  93 92        
00D3D4  2               
00D3D4  2               PlayFlagpoleSlide:
00D3D4  2  A9 40               lda #$40               ;store length of flagpole sound
00D3D6  2  8D BB 07            sta Squ1_SfxLenCounter
00D3D9  2  A9 62               lda #$62               ;load part of reg contents for flagpole sound
00D3DB  2  20 A0 D3            jsr SetFreq_Squ1
00D3DE  2  A2 99               ldx #$99               ;now load the rest
00D3E0  2  D0 25               bne FPS2nd
00D3E2  2               
00D3E2  2               PlaySmallJump:
00D3E2  2  A9 26               lda #$26               ;branch here for small mario jumping sound
00D3E4  2  D0 02               bne JumpRegContents
00D3E6  2               
00D3E6  2               PlayBigJump:
00D3E6  2  A9 18               lda #$18               ;branch here for big mario jumping sound
00D3E8  2               
00D3E8  2               JumpRegContents:
00D3E8  2  A2 82               ldx #$82               ;note that small and big jump borrow each others' reg contents
00D3EA  2  A0 A7               ldy #$a7               ;anyway, this loads the first part of mario's jumping sound
00D3EC  2  20 9D D3            jsr PlaySqu1Sfx
00D3EF  2  A9 28               lda #$28               ;store length of sfx for both jumping sounds
00D3F1  2  8D BB 07            sta Squ1_SfxLenCounter ;then continue on here
00D3F4  2               
00D3F4  2               ContinueSndJump:
00D3F4  2  AD BB 07               lda Squ1_SfxLenCounter ;jumping sounds seem to be composed of three parts
00D3F7  2  C9 25                  cmp #$25               ;check for time to play second part yet
00D3F9  2  D0 06                  bne N2Prt
00D3FB  2  A2 5F                  ldx #$5f               ;load second part
00D3FD  2  A0 F6                  ldy #$f6
00D3FF  2  D0 08                  bne DmpJpFPS           ;unconditional branch
00D401  2  C9 20        N2Prt:    cmp #$20               ;check for third part
00D403  2  D0 29                  bne DecJpFPS
00D405  2  A2 48                  ldx #$48               ;load third part
00D407  2  A0 BC        FPS2nd:   ldy #$bc               ;the flagpole slide sound shares part of third part
00D409  2  20 96 D3     DmpJpFPS: jsr Dump_Squ1_Regs
00D40C  2  D0 20                  bne DecJpFPS           ;unconditional branch outta here
00D40E  2               
00D40E  2               PlayFireballThrow:
00D40E  2  A9 05                lda #$05
00D410  2  A0 99                ldy #$99                 ;load reg contents for fireball throw sound
00D412  2  D0 04                bne Fthrow               ;unconditional branch
00D414  2               
00D414  2               PlayBump:
00D414  2  A9 0A                  lda #$0a                ;load length of sfx and reg contents for bump sound
00D416  2  A0 93                  ldy #$93
00D418  2  A2 9E        Fthrow:   ldx #$9e                ;the fireball sound shares reg contents with the bump sound
00D41A  2  8D BB 07               sta Squ1_SfxLenCounter
00D41D  2  A9 0C                  lda #$0c                ;load offset for bump sound
00D41F  2  20 9D D3               jsr PlaySqu1Sfx
00D422  2               
00D422  2               ContinueBumpThrow:
00D422  2  AD BB 07               lda Squ1_SfxLenCounter  ;check for second part of bump sound
00D425  2  C9 06                  cmp #$06
00D427  2  D0 05                  bne DecJpFPS
00D429  2  A9 BB                  lda #$bb                ;load second part directly
00D42B  2  8D 01 40               sta SND_SQUARE1_REG+1
00D42E  2  D0 60        DecJpFPS: bne BranchToDecLength1  ;unconditional branch
00D430  2               
00D430  2               
00D430  2               Square1SfxHandler:
00D430  2  A4 FF               ldy Square1SoundQueue   ;check for sfx in queue
00D432  2  F0 20               beq CheckSfx1Buffer
00D434  2  84 F1               sty Square1SoundBuffer  ;if found, put in buffer
00D436  2  30 AA               bmi PlaySmallJump       ;small jump
00D438  2  46 FF               lsr Square1SoundQueue
00D43A  2  B0 AA               bcs PlayBigJump         ;big jump
00D43C  2  46 FF               lsr Square1SoundQueue
00D43E  2  B0 D4               bcs PlayBump            ;bump
00D440  2  46 FF               lsr Square1SoundQueue
00D442  2  B0 2C               bcs PlaySwimStomp       ;swim/stomp
00D444  2  46 FF               lsr Square1SoundQueue
00D446  2  B0 4A               bcs PlaySmackEnemy      ;smack enemy
00D448  2  46 FF               lsr Square1SoundQueue
00D44A  2  B0 7F               bcs PlayPipeDownInj     ;pipedown/injury
00D44C  2  46 FF               lsr Square1SoundQueue
00D44E  2  B0 BE               bcs PlayFireballThrow   ;fireball throw
00D450  2  46 FF               lsr Square1SoundQueue
00D452  2  B0 80               bcs PlayFlagpoleSlide   ;slide flagpole
00D454  2               
00D454  2               CheckSfx1Buffer:
00D454  2  A5 F1               lda Square1SoundBuffer   ;check for sfx in buffer
00D456  2  F0 17               beq ExS1H                ;if not found, exit sub
00D458  2  30 9A               bmi ContinueSndJump      ;small mario jump
00D45A  2  4A                  lsr
00D45B  2  B0 97               bcs ContinueSndJump      ;big mario jump
00D45D  2  4A                  lsr
00D45E  2  B0 C2               bcs ContinueBumpThrow    ;bump
00D460  2  4A                  lsr
00D461  2  B0 1B               bcs ContinueSwimStomp    ;swim/stomp
00D463  2  4A                  lsr
00D464  2  B0 3C               bcs ContinueSmackEnemy   ;smack enemy
00D466  2  4A                  lsr
00D467  2  B0 67               bcs ContinuePipeDownInj  ;pipedown/injury
00D469  2  4A                  lsr
00D46A  2  B0 B6               bcs ContinueBumpThrow    ;fireball throw
00D46C  2  4A                  lsr
00D46D  2  B0 48               bcs DecrementSfx1Length  ;slide flagpole
00D46F  2  60           ExS1H: rts
00D470  2               
00D470  2               
00D470  2               PlaySwimStomp:
00D470  2  A9 0E              lda #$0e               ;store length of swim/stomp sound
00D472  2  8D BB 07           sta Squ1_SfxLenCounter
00D475  2  A0 9C              ldy #$9c               ;store reg contents for swim/stomp sound
00D477  2  A2 9E              ldx #$9e
00D479  2  A9 26              lda #$26
00D47B  2  20 9D D3           jsr PlaySqu1Sfx
00D47E  2               
00D47E  2               ContinueSwimStomp:
00D47E  2  AC BB 07           ldy Squ1_SfxLenCounter        ;look up reg contents in data section based on
00D481  2  B9 C5 D3           lda SwimStompEnvelopeData-1,y ;length of sound left, used to control sound's
00D484  2  8D 00 40           sta SND_SQUARE1_REG           ;envelope
00D487  2  C0 06              cpy #$06
00D489  2  D0 05              bne BranchToDecLength1
00D48B  2  A9 9E              lda #$9e                      ;when the length counts down to a certain point, put this
00D48D  2  8D 02 40           sta SND_SQUARE1_REG+2         ;directly into the LSB of square 1's frequency divider
00D490  2               
00D490  2               BranchToDecLength1:
00D490  2  D0 25              bne DecrementSfx1Length  ;unconditional branch (regardless of how we got here)
00D492  2               
00D492  2               PlaySmackEnemy:
00D492  2  A9 0E              lda #$0e                 ;store length of smack enemy sound
00D494  2  A0 CB              ldy #$cb
00D496  2  A2 9F              ldx #$9f
00D498  2  8D BB 07           sta Squ1_SfxLenCounter
00D49B  2  A9 28              lda #$28                 ;store reg contents for smack enemy sound
00D49D  2  20 9D D3           jsr PlaySqu1Sfx
00D4A0  2  D0 15              bne DecrementSfx1Length  ;unconditional branch
00D4A2  2               
00D4A2  2               ContinueSmackEnemy:
00D4A2  2  AC BB 07             ldy Squ1_SfxLenCounter  ;check about halfway through
00D4A5  2  C0 08                cpy #$08
00D4A7  2  D0 09                bne SmSpc
00D4A9  2  A9 A0                lda #$a0                ;if we're at the about-halfway point, make the second tone
00D4AB  2  8D 02 40             sta SND_SQUARE1_REG+2   ;in the smack enemy sound
00D4AE  2  A9 9F                lda #$9f
00D4B0  2  D0 02                bne SmTick
00D4B2  2  A9 90        SmSpc:  lda #$90                ;this creates spaces in the sound, giving it its distinct noise
00D4B4  2  8D 00 40     SmTick: sta SND_SQUARE1_REG
00D4B7  2               
00D4B7  2               DecrementSfx1Length:
00D4B7  2  CE BB 07           dec Squ1_SfxLenCounter    ;decrement length of sfx
00D4BA  2  D0 0E              bne ExSfx1
00D4BC  2               
00D4BC  2               StopSquare1Sfx:
00D4BC  2  A2 00                ldx #$00                ;if end of sfx reached, clear buffer
00D4BE  2  86 F1                stx $f1                 ;and stop making the sfx
00D4C0  2  A2 0E                ldx #$0e
00D4C2  2  8E 15 40             stx SND_MASTERCTRL_REG
00D4C5  2  A2 0F                ldx #$0f
00D4C7  2  8E 15 40             stx SND_MASTERCTRL_REG
00D4CA  2  60           ExSfx1: rts
00D4CB  2               
00D4CB  2               PlayPipeDownInj:
00D4CB  2  A9 2F              lda #$2f                ;load length of pipedown sound
00D4CD  2  8D BB 07           sta Squ1_SfxLenCounter
00D4D0  2               
00D4D0  2               ContinuePipeDownInj:
00D4D0  2  AD BB 07              lda Squ1_SfxLenCounter  ;some bitwise logic, forces the regs
00D4D3  2  4A                    lsr                     ;to be written to only during six specific times
00D4D4  2  B0 10                 bcs NoPDwnL             ;during which d3 must be set and d1-0 must be clear
00D4D6  2  4A                    lsr
00D4D7  2  B0 0D                 bcs NoPDwnL
00D4D9  2  29 02                 and #%00000010
00D4DB  2  F0 09                 beq NoPDwnL
00D4DD  2  A0 91                 ldy #$91                ;and this is where it actually gets written in
00D4DF  2  A2 9A                 ldx #$9a
00D4E1  2  A9 44                 lda #$44
00D4E3  2  20 9D D3              jsr PlaySqu1Sfx
00D4E6  2  4C B7 D4     NoPDwnL: jmp DecrementSfx1Length
00D4E9  2               
00D4E9  2               ;--------------------------------
00D4E9  2               
00D4E9  2               ExtraLifeFreqData:
00D4E9  2  58 02 54 56        .byte $58, $02, $54, $56, $4e, $44
00D4ED  2  4E 44        
00D4EF  2               
00D4EF  2               PowerUpGrabFreqData:
00D4EF  2  4C 52 4C 48        .byte $4c, $52, $4c, $48, $3e, $36, $3e, $36, $30
00D4F3  2  3E 36 3E 36  
00D4F7  2  30           
00D4F8  2  28 4A 50 4A        .byte $28, $4a, $50, $4a, $64, $3c, $32, $3c, $32
00D4FC  2  64 3C 32 3C  
00D500  2  32           
00D501  2  2C 24 3A 64        .byte $2c, $24, $3a, $64, $3a, $34, $2c, $22, $2c
00D505  2  3A 34 2C 22  
00D509  2  2C           
00D50A  2               
00D50A  2               ;residual frequency data
00D50A  2  22 1C 14           .byte $22, $1c, $14
00D50D  2               
00D50D  2               PUp_VGrow_FreqData:
00D50D  2  14 04 22 24        .byte $14, $04, $22, $24, $16, $04, $24, $26 ;used by both
00D511  2  16 04 24 26  
00D515  2  18 04 26 28        .byte $18, $04, $26, $28, $1a, $04, $28, $2a
00D519  2  1A 04 28 2A  
00D51D  2  1C 04 2A 2C        .byte $1c, $04, $2a, $2c, $1e, $04, $2c, $2e ;used by vinegrow
00D521  2  1E 04 2C 2E  
00D525  2  20 04 2E 30        .byte $20, $04, $2e, $30, $22, $04, $30, $32
00D529  2  22 04 30 32  
00D52D  2               
00D52D  2               PlayCoinGrab:
00D52D  2  A9 35                lda #$35             ;load length of coin grab sound
00D52F  2  A2 8D                ldx #$8d             ;and part of reg contents
00D531  2  D0 04                bne CGrab_TTickRegL
00D533  2               
00D533  2               PlayTimerTick:
00D533  2  A9 06                lda #$06             ;load length of timer tick sound
00D535  2  A2 98                ldx #$98             ;and part of reg contents
00D537  2               
00D537  2               CGrab_TTickRegL:
00D537  2  8D BD 07             sta Squ2_SfxLenCounter
00D53A  2  A0 7F                ldy #$7f                ;load the rest of reg contents
00D53C  2  A9 42                lda #$42                ;of coin grab and timer tick sound
00D53E  2  20 BB D3             jsr PlaySqu2Sfx
00D541  2               
00D541  2               ContinueCGrabTTick:
00D541  2  AD BD 07             lda Squ2_SfxLenCounter  ;check for time to play second tone yet
00D544  2  C9 30                cmp #$30                ;timer tick sound also executes this, not sure why
00D546  2  D0 05                bne N2Tone
00D548  2  A9 54                lda #$54                ;if so, load the tone directly into the reg
00D54A  2  8D 06 40             sta SND_SQUARE2_REG+2
00D54D  2  D0 2E        N2Tone: bne DecrementSfx2Length
00D54F  2               
00D54F  2               PlayBlast:
00D54F  2  A9 20                lda #$20                ;load length of fireworks/gunfire sound
00D551  2  8D BD 07             sta Squ2_SfxLenCounter
00D554  2  A0 94                ldy #$94                ;load reg contents of fireworks/gunfire sound
00D556  2  A9 5E                lda #$5e
00D558  2  D0 0B                bne SBlasJ
00D55A  2               
00D55A  2               ContinueBlast:
00D55A  2  AD BD 07             lda Squ2_SfxLenCounter  ;check for time to play second part
00D55D  2  C9 18                cmp #$18
00D55F  2  D0 1C                bne DecrementSfx2Length
00D561  2  A0 93                ldy #$93                ;load second part reg contents then
00D563  2  A9 18                lda #$18
00D565  2  D0 7F        SBlasJ: bne BlstSJp             ;unconditional branch to load rest of reg contents
00D567  2               
00D567  2               PlayPowerUpGrab:
00D567  2  A9 36                lda #$36                    ;load length of power-up grab sound
00D569  2  8D BD 07             sta Squ2_SfxLenCounter
00D56C  2               
00D56C  2               ContinuePowerUpGrab:
00D56C  2  AD BD 07             lda Squ2_SfxLenCounter      ;load frequency reg based on length left over
00D56F  2  4A                   lsr                         ;divide by 2
00D570  2  B0 0B                bcs DecrementSfx2Length     ;alter frequency every other frame
00D572  2  A8                   tay
00D573  2  B9 EE D4             lda PowerUpGrabFreqData-1,y ;use length left over / 2 for frequency offset
00D576  2  A2 5D                ldx #$5d                    ;store reg contents of power-up grab sound
00D578  2  A0 7F                ldy #$7f
00D57A  2               
00D57A  2               LoadSqu2Regs:
00D57A  2  20 BB D3             jsr PlaySqu2Sfx
00D57D  2               
00D57D  2               DecrementSfx2Length:
00D57D  2  CE BD 07             dec Squ2_SfxLenCounter   ;decrement length of sfx
00D580  2  D0 0E                bne ExSfx2
00D582  2               
00D582  2               EmptySfx2Buffer:
00D582  2  A2 00                ldx #$00                ;initialize square 2's sound effects buffer
00D584  2  86 F2                stx Square2SoundBuffer
00D586  2               
00D586  2               StopSquare2Sfx:
00D586  2  A2 0D                ldx #$0d                ;stop playing the sfx
00D588  2  8E 15 40             stx SND_MASTERCTRL_REG
00D58B  2  A2 0F                ldx #$0f
00D58D  2  8E 15 40             stx SND_MASTERCTRL_REG
00D590  2  60           ExSfx2: rts
00D591  2               
00D591  2               Square2SfxHandler:
00D591  2  A5 F2                lda Square2SoundBuffer ;special handling for the 1-up sound to keep it
00D593  2  29 40                and #Sfx_ExtraLife     ;from being interrupted by other sounds on square 2
00D595  2  D0 65                bne ContinueExtraLife
00D597  2  A4 FE                ldy Square2SoundQueue  ;check for sfx in queue
00D599  2  F0 20                beq CheckSfx2Buffer
00D59B  2  84 F2                sty Square2SoundBuffer ;if found, put in buffer and check for the following
00D59D  2  30 3E                bmi PlayBowserFall     ;bowser fall
00D59F  2  46 FE                lsr Square2SoundQueue
00D5A1  2  B0 8A                bcs PlayCoinGrab       ;coin grab
00D5A3  2  46 FE                lsr Square2SoundQueue
00D5A5  2  B0 6A                bcs PlayGrowPowerUp    ;power-up reveal
00D5A7  2  46 FE                lsr Square2SoundQueue
00D5A9  2  B0 6A                bcs PlayGrowVine       ;vine grow
00D5AB  2  46 FE                lsr Square2SoundQueue
00D5AD  2  B0 A0                bcs PlayBlast          ;fireworks/gunfire
00D5AF  2  46 FE                lsr Square2SoundQueue
00D5B1  2  B0 80                bcs PlayTimerTick      ;timer tick
00D5B3  2  46 FE                lsr Square2SoundQueue
00D5B5  2  B0 B0                bcs PlayPowerUpGrab    ;power-up grab
00D5B7  2  46 FE                lsr Square2SoundQueue
00D5B9  2  B0 3C                bcs PlayExtraLife      ;1-up
00D5BB  2               
00D5BB  2               CheckSfx2Buffer:
00D5BB  2  A5 F2                lda Square2SoundBuffer   ;check for sfx in buffer
00D5BD  2  F0 17                beq ExS2H                ;if not found, exit sub
00D5BF  2  30 27                bmi ContinueBowserFall   ;bowser fall
00D5C1  2  4A                   lsr
00D5C2  2  B0 13                bcs Cont_CGrab_TTick     ;coin grab
00D5C4  2  4A                   lsr
00D5C5  2  B0 5D                bcs ContinueGrowItems    ;power-up reveal
00D5C7  2  4A                   lsr
00D5C8  2  B0 5A                bcs ContinueGrowItems    ;vine grow
00D5CA  2  4A                   lsr
00D5CB  2  B0 8D                bcs ContinueBlast        ;fireworks/gunfire
00D5CD  2  4A                   lsr
00D5CE  2  B0 07                bcs Cont_CGrab_TTick     ;timer tick
00D5D0  2  4A                   lsr
00D5D1  2  B0 99                bcs ContinuePowerUpGrab  ;power-up grab
00D5D3  2  4A                   lsr
00D5D4  2  B0 26                bcs ContinueExtraLife    ;1-up
00D5D6  2  60           ExS2H:  rts
00D5D7  2               
00D5D7  2               Cont_CGrab_TTick:
00D5D7  2  4C 41 D5             jmp ContinueCGrabTTick
00D5DA  2               
00D5DA  2               JumpToDecLength2:
00D5DA  2  4C 7D D5             jmp DecrementSfx2Length
00D5DD  2               
00D5DD  2               PlayBowserFall:
00D5DD  2  A9 38                 lda #$38                ;load length of bowser defeat sound
00D5DF  2  8D BD 07              sta Squ2_SfxLenCounter
00D5E2  2  A0 C4                 ldy #$c4                ;load contents of reg for bowser defeat sound
00D5E4  2  A9 18                 lda #$18
00D5E6  2  D0 0B        BlstSJp: bne PBFRegs
00D5E8  2               
00D5E8  2               ContinueBowserFall:
00D5E8  2  AD BD 07               lda Squ2_SfxLenCounter   ;check for almost near the end
00D5EB  2  C9 08                  cmp #$08
00D5ED  2  D0 8E                  bne DecrementSfx2Length
00D5EF  2  A0 A4                  ldy #$a4                 ;if so, load the rest of reg contents for bowser defeat sound
00D5F1  2  A9 5A                  lda #$5a
00D5F3  2  A2 9F        PBFRegs:  ldx #$9f                 ;the fireworks/gunfire sound shares part of reg contents here
00D5F5  2  D0 83        EL_LRegs: bne LoadSqu2Regs         ;this is an unconditional branch outta here
00D5F7  2               
00D5F7  2               PlayExtraLife:
00D5F7  2  A9 30                lda #$30                  ;load length of 1-up sound
00D5F9  2  8D BD 07             sta Squ2_SfxLenCounter
00D5FC  2               
00D5FC  2               ContinueExtraLife:
00D5FC  2  AD BD 07               lda Squ2_SfxLenCounter
00D5FF  2  A2 03                  ldx #$03                  ;load new tones only every eight frames
00D601  2  4A           DivLLoop: lsr
00D602  2  B0 D6                  bcs JumpToDecLength2      ;if any bits set here, branch to dec the length
00D604  2  CA                     dex
00D605  2  D0 FA                  bne DivLLoop              ;do this until all bits checked, if none set, continue
00D607  2  A8                     tay
00D608  2  B9 E8 D4               lda ExtraLifeFreqData-1,y ;load our reg contents
00D60B  2  A2 82                  ldx #$82
00D60D  2  A0 7F                  ldy #$7f
00D60F  2  D0 E4                  bne EL_LRegs              ;unconditional branch
00D611  2               
00D611  2               PlayGrowPowerUp:
00D611  2  A9 10                lda #$10                ;load length of power-up reveal sound
00D613  2  D0 02                bne GrowItemRegs
00D615  2               
00D615  2               PlayGrowVine:
00D615  2  A9 20                lda #$20                ;load length of vine grow sound
00D617  2               
00D617  2               GrowItemRegs:
00D617  2  8D BD 07             sta Squ2_SfxLenCounter
00D61A  2  A9 7F                lda #$7f                  ;load contents of reg for both sounds directly
00D61C  2  8D 05 40             sta SND_SQUARE2_REG+1
00D61F  2  A9 00                lda #$00                  ;start secondary counter for both sounds
00D621  2  8D BE 07             sta Sfx_SecondaryCounter
00D624  2               
00D624  2               ContinueGrowItems:
00D624  2  EE BE 07             inc Sfx_SecondaryCounter  ;increment secondary counter for both sounds
00D627  2  AD BE 07             lda Sfx_SecondaryCounter  ;this sound doesn't decrement the usual counter
00D62A  2  4A                   lsr                       ;divide by 2 to get the offset
00D62B  2  A8                   tay
00D62C  2  CC BD 07             cpy Squ2_SfxLenCounter    ;have we reached the end yet?
00D62F  2  F0 0C                beq StopGrowItems         ;if so, branch to jump, and stop playing sounds
00D631  2  A9 9D                lda #$9d                  ;load contents of other reg directly
00D633  2  8D 04 40             sta SND_SQUARE2_REG
00D636  2  B9 0D D5             lda PUp_VGrow_FreqData,y  ;use secondary counter / 2 as offset for frequency regs
00D639  2  20 BE D3             jsr SetFreq_Squ2
00D63C  2  60                   rts
00D63D  2               
00D63D  2               StopGrowItems:
00D63D  2  4C 82 D5             jmp EmptySfx2Buffer       ;branch to stop playing sounds
00D640  2               
00D640  2               .ifndef ANN
00D640  2               WindFreqEnvData:
00D640  2                       .byte $37, $46, $55, $64, $74, $83, $93, $a2
00D640  2                       .byte $b1, $c0, $d0, $e0, $f1, $f1, $f2, $e2
00D640  2                       .byte $e2, $c3, $a3, $84, $64, $44, $35, $25
00D640  2               .endif
00D640  2               
00D640  2               BrickShatterFreqData:
00D640  2  01 0E 0E 0D          .byte $01, $0e, $0e, $0d, $0b, $06, $0c, $0f
00D644  2  0B 06 0C 0F  
00D648  2  0A 09 03 0D          .byte $0a, $09, $03, $0d, $08, $0d, $06, $0c
00D64C  2  08 0D 06 0C  
00D650  2               
00D650  2               SkidSfxFreqData:
00D650  2  47 49 42 4A          .byte $47, $49, $42, $4a, $43, $4b
00D654  2  43 4B        
00D656  2               
00D656  2               PlaySkidSfx:
00D656  2  84 F3                sty NoiseSoundBuffer
00D658  2  A9 06                lda #$06
00D65A  2  8D BF 07             sta Noise_SfxLenCounter
00D65D  2               
00D65D  2               ContinueSkidSfx:
00D65D  2  AD BF 07             lda Noise_SfxLenCounter
00D660  2  A8                   tay
00D661  2  B9 4F D6             lda SkidSfxFreqData-1,y
00D664  2  8D 0A 40             sta SND_TRIANGLE_REG+2
00D667  2  A9 18                lda #$18
00D669  2  8D 08 40             sta SND_TRIANGLE_REG
00D66C  2  8D 0B 40             sta SND_TRIANGLE_REG+3
00D66F  2  D0 1F                bne DecrementSfx3Length
00D671  2               
00D671  2               PlayBrickShatter:
00D671  2  84 F3                sty NoiseSoundBuffer
00D673  2  A9 20                lda #$20                 ;load length of brick shatter sound
00D675  2  8D BF 07             sta Noise_SfxLenCounter
00D678  2               
00D678  2               ContinueBrickShatter:
00D678  2  AD BF 07             lda Noise_SfxLenCounter
00D67B  2  4A                   lsr                         ;divide by 2 and check for bit set to use offset
00D67C  2  90 12                bcc DecrementSfx3Length
00D67E  2  A8                   tay
00D67F  2  BE 40 D6             ldx BrickShatterFreqData,y  ;load reg contents of brick shatter sound
00D682  2  B9 EA DF             lda BrickShatterEnvData,y
00D685  2               
00D685  2               PlayNoiseSfx:
00D685  2  8D 0C 40             sta SND_NOISE_REG        ;play the sfx
00D688  2  8E 0E 40             stx SND_NOISE_REG+2
00D68B  2  A9 18                lda #$18
00D68D  2  8D 0F 40             sta SND_NOISE_REG+3
00D690  2               
00D690  2               DecrementSfx3Length:
00D690  2  CE BF 07             dec Noise_SfxLenCounter  ;decrement length of sfx
00D693  2  D0 0E                bne ExSfx3
00D695  2  A9 F0                lda #$f0                 ;if done, stop playing the sfx
00D697  2  8D 0C 40             sta SND_NOISE_REG
00D69A  2  A9 00                lda #$00
00D69C  2  8D 08 40             sta SND_TRIANGLE_REG
00D69F  2  A9 00                lda #$00
00D6A1  2  85 F3                sta NoiseSoundBuffer
00D6A3  2  60           ExSfx3: rts
00D6A4  2               
00D6A4  2               NoiseSfxHandler:
00D6A4  2  A5 F3                lda NoiseSoundBuffer
00D6A6  2  30 B5                bmi ContinueSkidSfx
00D6A8  2  A4 FD                ldy NoiseSoundQueue
00D6AA  2  30 AA                bmi PlaySkidSfx
00D6AC  2  46 FD                lsr NoiseSoundQueue
00D6AE  2  B0 C1                bcs PlayBrickShatter
00D6B0  2  4A                   lsr
00D6B1  2  B0 C5                bcs ContinueBrickShatter
00D6B3  2  46 FD                lsr NoiseSoundQueue
00D6B5  2  B0 04                bcs PlayBowserFlame
00D6B7  2  4A                   lsr
00D6B8  2  B0 08                bcs ContinueBowserFlame
00D6BA  2               .ifndef ANN
00D6BA  2                       lsr
00D6BA  2                       bcs ContinueWindSfx
00D6BA  2                       lsr NoiseSoundQueue
00D6BA  2                       bcs PlayWindSfx
00D6BA  2               .endif
00D6BA  2  60                   rts
00D6BB  2               
00D6BB  2               PlayBowserFlame:
00D6BB  2  84 F3                sty NoiseSoundBuffer
00D6BD  2  A9 40                lda #$40                    ;load length of bowser flame sound
00D6BF  2  8D BF 07             sta Noise_SfxLenCounter
00D6C2  2               
00D6C2  2               ContinueBowserFlame:
00D6C2  2  AD BF 07             lda Noise_SfxLenCounter
00D6C5  2  4A                   lsr
00D6C6  2  A8                   tay
00D6C7  2  A2 0F                ldx #$0f                    ;load reg contents of bowser flame sound
00D6C9  2  B9 C9 DF             lda BowserFlameEnvData-1,y
00D6CC  2               WindBranch:
00D6CC  2  D0 B7                bne PlayNoiseSfx            ;unconditional branch here
00D6CE  2               
00D6CE  2               .ifndef ANN
00D6CE  2               PlayWindSfx:
00D6CE  2                       sty NoiseSoundBuffer
00D6CE  2                       lda #$c0
00D6CE  2                       sta Noise_SfxLenCounter
00D6CE  2               ContinueWindSfx:
00D6CE  2                       lsr NoiseSoundQueue         ;get bit for the wind sfx, note that it must
00D6CE  2                       bcc ExSfx3                  ;be continuously set in order for it to play
00D6CE  2                       lda Noise_SfxLenCounter
00D6CE  2                       lsr
00D6CE  2                       lsr                         ;divide length counter by 8
00D6CE  2                       lsr
00D6CE  2                       tay
00D6CE  2                       lda WindFreqEnvData,y
00D6CE  2                       and #$0f                    ;use lower nybble as frequency data
00D6CE  2                       ora #$10
00D6CE  2                       tax
00D6CE  2                       lda WindFreqEnvData,y       ;use upper nybble as envelope data
00D6CE  2                       lsr
00D6CE  2                       lsr
00D6CE  2                       lsr
00D6CE  2                       lsr
00D6CE  2                       ora #$10
00D6CE  2                       bne WindBranch              ;unconditional branch
00D6CE  2               .endif
00D6CE  2               
00D6CE  2               ;--------------------------------
00D6CE  2               
00D6CE  2               ContinueMusic:
00D6CE  2  4C 77 D7             jmp HandleSquare2Music  ;if we have music, start with square 2 channel
00D6D1  2               
00D6D1  2               MusicHandler:
00D6D1  2  A5 FC                lda EventMusicQueue     ;check event music queue
00D6D3  2  D0 0C                bne LoadEventMusic
00D6D5  2  A5 FB                lda AreaMusicQueue      ;check area music queue
00D6D7  2  D0 2C                bne LoadAreaMusic
00D6D9  2  AD B1 07             lda EventMusicBuffer    ;check both buffers
00D6DC  2  05 F4                ora AreaMusicBuffer
00D6DE  2  D0 EE                bne ContinueMusic
00D6E0  2  60                   rts                     ;no music, then leave
00D6E1  2               
00D6E1  2               LoadEventMusic:
00D6E1  2  8D B1 07                sta EventMusicBuffer      ;copy event music queue contents to buffer
00D6E4  2  C9 01                   cmp #DeathMusic           ;is it death music?
00D6E6  2  D0 06                   bne NoStopSfx             ;if not, jump elsewhere
00D6E8  2  20 BC D4                jsr StopSquare1Sfx        ;stop sfx in square 1 and 2
00D6EB  2  20 86 D5                jsr StopSquare2Sfx        ;but clear only square 1's sfx buffer
00D6EE  2  A6 F4        NoStopSfx: ldx AreaMusicBuffer
00D6F0  2  8E C5 07                stx AreaMusicBuffer_Alt   ;save current area music buffer to be re-obtained later
00D6F3  2  A0 00                   ldy #$00
00D6F5  2  8C C4 07                sty NoteLengthTblAdder    ;default value for additional length byte offset
00D6F8  2  84 F4                   sty AreaMusicBuffer       ;clear area music buffer
00D6FA  2  C9 40                   cmp #TimeRunningOutMusic  ;is it time running out music?
00D6FC  2  D0 30                   bne FindEventMusicHeader
00D6FE  2  A2 08                   ldx #$08                  ;load offset to be added to length byte of header
00D700  2  8E C4 07                stx NoteLengthTblAdder
00D703  2  D0 29                   bne FindEventMusicHeader  ;unconditional branch
00D705  2               
00D705  2               LoadAreaMusic:
00D705  2  C9 04                 cmp #$04                  ;is it underground music?
00D707  2  D0 03                 bne NoStop1               ;no, do not stop square 1 sfx
00D709  2  20 BC D4              jsr StopSquare1Sfx
00D70C  2  A0 10        NoStop1: ldy #$10                  ;start counter used only by ground level music
00D70E  2  8C C7 07     GMLoopB: sty GroundMusicHeaderOfs
00D711  2               
00D711  2               HandleAreaMusicLoopB:
00D711  2  A0 00                 ldy #$00                  ;clear event music buffer
00D713  2  8C B1 07              sty EventMusicBuffer
00D716  2  85 F4                 sta AreaMusicBuffer       ;copy area music queue contents to buffer
00D718  2  C9 01                 cmp #$01                  ;is it ground level music?
00D71A  2  D0 0E                 bne FindAreaMusicHeader
00D71C  2  EE C7 07              inc GroundMusicHeaderOfs  ;increment but only if playing ground level music
00D71F  2  AC C7 07              ldy GroundMusicHeaderOfs  ;is it time to loopback ground level music?
00D722  2  C0 32                 cpy #$32
00D724  2  D0 0C                 bne LoadHeader            ;branch ahead with alternate offset
00D726  2  A0 11                 ldy #$11
00D728  2  D0 E4                 bne GMLoopB               ;unconditional branch
00D72A  2               
00D72A  2               FindAreaMusicHeader:
00D72A  2  A0 08                ldy #$08                   ;load Y for offset of area music
00D72C  2  84 F7                sty MusicOffset_Square2    ;residual instruction here
00D72E  2               
00D72E  2               FindEventMusicHeader:
00D72E  2  C8                   iny                       ;increment Y pointer based on previously loaded queue contents
00D72F  2  4A                   lsr                       ;bit shift and increment until we find a set bit for music
00D730  2  90 FC                bcc FindEventMusicHeader
00D732  2               
00D732  2               LoadHeader:
00D732  2  B9 49 D9             lda MusicHeaderOffsetData,y  ;load offset for header
00D735  2  A8                   tay
00D736  2  B9 4A D9             lda MusicHeaderData,y        ;now load the header
00D739  2  85 F0                sta NoteLenLookupTblOfs
00D73B  2  B9 4B D9             lda MusicHeaderData+1,y
00D73E  2  85 F5                sta MusicDataLow
00D740  2  B9 4C D9             lda MusicHeaderData+2,y
00D743  2  85 F6                sta MusicDataHigh
00D745  2  B9 4D D9             lda MusicHeaderData+3,y
00D748  2  85 F9                sta MusicOffset_Triangle
00D74A  2  B9 4E D9             lda MusicHeaderData+4,y
00D74D  2  85 F8                sta MusicOffset_Square1
00D74F  2  B9 4F D9             lda MusicHeaderData+5,y
00D752  2  8D B0 07             sta MusicOffset_Noise
00D755  2  8D C1 07             sta NoiseDataLoopbackOfs
00D758  2  A9 01                lda #$01                     ;initialize music note counters
00D75A  2  8D B4 07             sta Squ2_NoteLenCounter
00D75D  2  8D B6 07             sta Squ1_NoteLenCounter
00D760  2  8D B9 07             sta Tri_NoteLenCounter
00D763  2  8D BA 07             sta Noise_BeatLenCounter
00D766  2  A9 00                lda #$00                     ;initialize music data offset for square 2
00D768  2  85 F7                sta MusicOffset_Square2
00D76A  2  8D CA 07             sta AltRegContentFlag        ;initialize alternate control reg data used by square 1
00D76D  2  A9 0B                lda #$0b                     ;disable triangle channel and reenable it
00D76F  2  8D 15 40             sta SND_MASTERCTRL_REG
00D772  2  A9 0F                lda #$0f
00D774  2  8D 15 40             sta SND_MASTERCTRL_REG
00D777  2               
00D777  2               HandleSquare2Music:
00D777  2  CE B4 07             dec Squ2_NoteLenCounter  ;decrement square 2 note length
00D77A  2  D0 5F                bne MiscSqu2MusicTasks   ;is it time for more data?  if not, branch to end tasks
00D77C  2  A4 F7                ldy MusicOffset_Square2  ;increment square 2 music offset and fetch data
00D77E  2  E6 F7                inc MusicOffset_Square2
00D780  2  B1 F5                lda (MusicData),y
00D782  2  F0 04                beq EndOfMusicData       ;if zero, the data is a null terminator
00D784  2  10 3D                bpl Squ2NoteHandler      ;if non-negative, data is a note
00D786  2  D0 2F                bne Squ2LengthHandler    ;otherwise it is length data
00D788  2               
00D788  2               EndOfMusicData:
00D788  2  AD B1 07             lda EventMusicBuffer     ;check secondary buffer for time running out music
00D78B  2  C9 40                cmp #TimeRunningOutMusic
00D78D  2  D0 05                bne NotTRO
00D78F  2  AD C5 07             lda AreaMusicBuffer_Alt  ;load previously saved contents of primary buffer
00D792  2  D0 1D                bne MusicLoopBack        ;and start playing the song again if there is one
00D794  2  29 04        NotTRO: and #VictoryMusic        ;check for victory music (the only secondary that loops)
00D796  2  D0 1C                bne VictoryMLoopBack
00D798  2  A5 F4                lda AreaMusicBuffer      ;check primary buffer for any music except pipe intro
00D79A  2  29 5F                and #%01011111
00D79C  2  D0 13                bne MusicLoopBack        ;if any area music except pipe intro, music loops
00D79E  2  A9 00                lda #$00                 ;clear primary and secondary buffers and initialize
00D7A0  2  85 F4                sta AreaMusicBuffer      ;control regs of square and triangle channels
00D7A2  2  8D B1 07             sta EventMusicBuffer
00D7A5  2  8D 08 40             sta SND_TRIANGLE_REG
00D7A8  2  A9 90                lda #$90
00D7AA  2  8D 00 40             sta SND_SQUARE1_REG
00D7AD  2  8D 04 40             sta SND_SQUARE2_REG
00D7B0  2  60                   rts
00D7B1  2               
00D7B1  2               MusicLoopBack:
00D7B1  2  4C 11 D7             jmp HandleAreaMusicLoopB
00D7B4  2               
00D7B4  2               VictoryMLoopBack:
00D7B4  2  4C E1 D6             jmp LoadEventMusic
00D7B7  2               
00D7B7  2               Squ2LengthHandler:
00D7B7  2  20 08 D9             jsr ProcessLengthData    ;store length of note
00D7BA  2  8D B3 07             sta Squ2_NoteLenBuffer
00D7BD  2  A4 F7                ldy MusicOffset_Square2  ;fetch another byte (MUST NOT BE LENGTH BYTE!)
00D7BF  2  E6 F7                inc MusicOffset_Square2
00D7C1  2  B1 F5                lda (MusicData),y
00D7C3  2               
00D7C3  2               Squ2NoteHandler:
00D7C3  2  A6 F2                  ldx Square2SoundBuffer     ;is there a sound playing on this channel?
00D7C5  2  D0 0E                  bne SkipFqL1
00D7C7  2  20 BE D3               jsr SetFreq_Squ2           ;no, then play the note
00D7CA  2  F0 03                  beq Rest                   ;check to see if note is rest
00D7CC  2  20 15 D9               jsr LoadControlRegs        ;if not, load control regs for square 2
00D7CF  2  8D B5 07     Rest:     sta Squ2_EnvelopeDataCtrl  ;save contents of A
00D7D2  2  20 B4 D3               jsr Dump_Sq2_Regs          ;dump X and Y into square 2 control regs
00D7D5  2  AD B3 07     SkipFqL1: lda Squ2_NoteLenBuffer     ;save length in square 2 note counter
00D7D8  2  8D B4 07               sta Squ2_NoteLenCounter
00D7DB  2               
00D7DB  2               MiscSqu2MusicTasks:
00D7DB  2  A5 F2                   lda Square2SoundBuffer     ;is there a sound playing on square 2?
00D7DD  2  D0 1A                   bne HandleSquare1Music
00D7DF  2  AD B1 07                lda EventMusicBuffer       ;check for death music or d4 set on secondary buffer
00D7E2  2  29 91                   and #%10010001             ;note that regs for death music or d4 are loaded by default
00D7E4  2  D0 13                   bne HandleSquare1Music
00D7E6  2  AC B5 07                ldy Squ2_EnvelopeDataCtrl  ;check for contents saved from LoadControlRegs
00D7E9  2  F0 03                   beq NoDecEnv1
00D7EB  2  CE B5 07                dec Squ2_EnvelopeDataCtrl  ;decrement unless already zero
00D7EE  2  20 31 D9     NoDecEnv1: jsr LoadEnvelopeData       ;do a load of envelope data to replace default
00D7F1  2  8D 04 40                sta SND_SQUARE2_REG        ;based on offset set by first load unless playing
00D7F4  2  A2 7F                   ldx #$7f                   ;death music or d4 set on secondary buffer
00D7F6  2  8E 05 40                stx SND_SQUARE2_REG+1
00D7F9  2               
00D7F9  2               HandleSquare1Music:
00D7F9  2  A4 F8                ldy MusicOffset_Square1    ;is there a nonzero offset here?
00D7FB  2  F0 5A                beq HandleTriangleMusic    ;if not, skip ahead to the triangle channel
00D7FD  2  CE B6 07             dec Squ1_NoteLenCounter    ;decrement square 1 note length
00D800  2  D0 32                bne MiscSqu1MusicTasks     ;is it time for more data?
00D802  2               
00D802  2               FetchSqu1MusicData:
00D802  2  A4 F8                ldy MusicOffset_Square1    ;increment square 1 music offset and fetch data
00D804  2  E6 F8                inc MusicOffset_Square1
00D806  2  B1 F5                lda (MusicData),y
00D808  2  D0 0F                bne Squ1NoteHandler        ;if nonzero, then skip this part
00D80A  2  A9 83                lda #$83
00D80C  2  8D 00 40             sta SND_SQUARE1_REG        ;store some data into control regs for square 1
00D80F  2  A9 94                lda #$94                   ;and fetch another byte of data, used to give
00D811  2  8D 01 40             sta SND_SQUARE1_REG+1      ;death music its unique sound
00D814  2  8D CA 07             sta AltRegContentFlag
00D817  2  D0 E9                bne FetchSqu1MusicData     ;unconditional branch
00D819  2               
00D819  2               Squ1NoteHandler:
00D819  2  20 02 D9                jsr AlternateLengthHandler
00D81C  2  8D B6 07                sta Squ1_NoteLenCounter    ;save contents of A in square 1 note counter
00D81F  2  A4 F1                   ldy Square1SoundBuffer     ;is there a sound playing on square 1?
00D821  2  D0 34                   bne HandleTriangleMusic
00D823  2  8A                      txa
00D824  2  29 3E                   and #%00111110             ;change saved data to appropriate note format
00D826  2  20 A0 D3                jsr SetFreq_Squ1           ;play the note
00D829  2  F0 03                   beq SkipCtrlL
00D82B  2  20 15 D9                jsr LoadControlRegs
00D82E  2  8D B7 07     SkipCtrlL: sta Squ1_EnvelopeDataCtrl  ;save envelope offset
00D831  2  20 96 D3                jsr Dump_Squ1_Regs
00D834  2               
00D834  2               MiscSqu1MusicTasks:
00D834  2  A5 F1                      lda Square1SoundBuffer     ;is there a sound playing on square 1?
00D836  2  D0 1F                      bne HandleTriangleMusic
00D838  2  AD B1 07                   lda EventMusicBuffer       ;check for death music or d4 set on secondary buffer
00D83B  2  29 91                      and #%10010001
00D83D  2  D0 0E                      bne DeathMAltReg
00D83F  2  AC B7 07                   ldy Squ1_EnvelopeDataCtrl  ;check saved envelope offset
00D842  2  F0 03                      beq NoDecEnv2
00D844  2  CE B7 07                   dec Squ1_EnvelopeDataCtrl  ;decrement unless already zero
00D847  2  20 31 D9     NoDecEnv2:    jsr LoadEnvelopeData       ;do a load of envelope data
00D84A  2  8D 00 40                   sta SND_SQUARE1_REG        ;based on offset set by first load
00D84D  2  AD CA 07     DeathMAltReg: lda AltRegContentFlag      ;check for alternate control reg data
00D850  2  D0 02                      bne DoAltLoad
00D852  2  A9 7F                      lda #$7f                   ;load this value if zero, the alternate value
00D854  2  8D 01 40     DoAltLoad:    sta SND_SQUARE1_REG+1      ;if nonzero, and let's move on
00D857  2               
00D857  2               HandleTriangleMusic:
00D857  2  A5 F9                lda MusicOffset_Triangle
00D859  2  CE B9 07             dec Tri_NoteLenCounter    ;decrement triangle note length
00D85C  2  D0 4C                bne HandleNoiseMusic      ;is it time for more data?
00D85E  2  A4 F9                ldy MusicOffset_Triangle  ;increment triangle music offset and fetch data
00D860  2  E6 F9                inc MusicOffset_Triangle
00D862  2  B1 F5                lda (MusicData),y
00D864  2  F0 41                beq LoadTriCtrlReg        ;if zero, skip all this and move on to noise
00D866  2  10 13                bpl TriNoteHandler        ;if non-negative, data is note
00D868  2  20 08 D9             jsr ProcessLengthData     ;otherwise, it is length data
00D86B  2  8D B8 07             sta Tri_NoteLenBuffer     ;save contents of A
00D86E  2  A9 1F                lda #$1f
00D870  2  8D 08 40             sta SND_TRIANGLE_REG      ;load some default data for triangle control reg
00D873  2  A4 F9                ldy MusicOffset_Triangle  ;fetch another byte
00D875  2  E6 F9                inc MusicOffset_Triangle
00D877  2  B1 F5                lda (MusicData),y
00D879  2  F0 2C                beq LoadTriCtrlReg        ;check once more for nonzero data
00D87B  2               
00D87B  2               TriNoteHandler:
00D87B  2  20 C2 D3               jsr SetFreq_Tri
00D87E  2  AE B8 07               ldx Tri_NoteLenBuffer   ;save length in triangle note counter
00D881  2  8E B9 07               stx Tri_NoteLenCounter
00D884  2  AD B1 07               lda EventMusicBuffer
00D887  2  29 6E                  and #%01101110          ;check for death music or d4 set on secondary buffer
00D889  2  D0 06                  bne NotDOrD4            ;if playing any other secondary, skip primary buffer check
00D88B  2  A5 F4                  lda AreaMusicBuffer     ;check primary buffer for water or castle level music
00D88D  2  29 0A                  and #%00001010
00D88F  2  F0 19                  beq HandleNoiseMusic    ;if playing any other primary, or death or d4, go on to noise routine
00D891  2  8A           NotDOrD4: txa                     ;if playing water or castle music or any secondary
00D892  2  C9 12                  cmp #$12                ;besides death music or d4 set, check length of note
00D894  2  B0 0F                  bcs LongN
00D896  2  AD B1 07               lda EventMusicBuffer    ;check for win castle music again if not playing a long note
00D899  2  29 08                  and #EndOfCastleMusic
00D89B  2  F0 04                  beq MediN
00D89D  2  A9 0F                  lda #$0f                ;load value $0f if playing the win castle music and playing a short
00D89F  2  D0 06                  bne LoadTriCtrlReg      ;note, load value $1f if playing water or castle level music or any
00D8A1  2  A9 1F        MediN:    lda #$1f                ;secondary besides death and d4 except win castle or win castle and playing
00D8A3  2  D0 02                  bne LoadTriCtrlReg      ;a short note, and load value $ff if playing a long note on water, castle
00D8A5  2  A9 FF        LongN:    lda #$ff                ;or any secondary (including win castle) except death and d4
00D8A7  2               
00D8A7  2               LoadTriCtrlReg:
00D8A7  2  8D 08 40             sta SND_TRIANGLE_REG      ;save final contents of A into control reg for triangle
00D8AA  2               
00D8AA  2               HandleNoiseMusic:
00D8AA  2  A5 F4                lda AreaMusicBuffer       ;check if playing underground or castle music
00D8AC  2  29 F3                and #%11110011
00D8AE  2  F0 51                beq ExitMusicHandler      ;if so, skip the noise routine
00D8B0  2  CE BA 07             dec Noise_BeatLenCounter  ;decrement noise beat length
00D8B3  2  D0 4C                bne ExitMusicHandler      ;is it time for more data?
00D8B5  2               
00D8B5  2               FetchNoiseBeatData:
00D8B5  2  AC B0 07             ldy MusicOffset_Noise       ;increment noise beat offset and fetch data
00D8B8  2  EE B0 07             inc MusicOffset_Noise
00D8BB  2  B1 F5                lda (MusicData),y           ;get noise beat data, if nonzero, branch to handle
00D8BD  2  D0 08                bne NoiseBeatHandler
00D8BF  2  AD C1 07             lda NoiseDataLoopbackOfs    ;if data is zero, reload original noise beat offset
00D8C2  2  8D B0 07             sta MusicOffset_Noise       ;and loopback next time around
00D8C5  2  D0 EE                bne FetchNoiseBeatData      ;unconditional branch
00D8C7  2               
00D8C7  2               NoiseBeatHandler:
00D8C7  2  20 02 D9             jsr AlternateLengthHandler
00D8CA  2  8D BA 07             sta Noise_BeatLenCounter    ;store length in noise beat counter
00D8CD  2  8A                   txa
00D8CE  2  29 3E                and #%00111110              ;reload data and erase length bits
00D8D0  2  F0 24                beq SilentBeat              ;if no beat data, silence
00D8D2  2  C9 30                cmp #$30                    ;check the beat data and play the appropriate
00D8D4  2  F0 18                beq LongBeat                ;noise accordingly
00D8D6  2  C9 20                cmp #$20
00D8D8  2  F0 0C                beq StrongBeat
00D8DA  2  29 10                and #%00010000
00D8DC  2  F0 18                beq SilentBeat
00D8DE  2  A9 1C                lda #$1c        ;short beat data
00D8E0  2  A2 03                ldx #$03
00D8E2  2  A0 18                ldy #$18
00D8E4  2  D0 12                bne PlayBeat
00D8E6  2               
00D8E6  2               StrongBeat:
00D8E6  2  A9 1C                lda #$1c        ;strong beat data
00D8E8  2  A2 0C                ldx #$0c
00D8EA  2  A0 18                ldy #$18
00D8EC  2  D0 0A                bne PlayBeat
00D8EE  2               
00D8EE  2               LongBeat:
00D8EE  2  A9 1C                lda #$1c        ;long beat data
00D8F0  2  A2 03                ldx #$03
00D8F2  2  A0 58                ldy #$58
00D8F4  2  D0 02                bne PlayBeat
00D8F6  2               
00D8F6  2               SilentBeat:
00D8F6  2  A9 10                lda #$10        ;silence
00D8F8  2               
00D8F8  2               PlayBeat:
00D8F8  2  8D 0C 40             sta SND_NOISE_REG    ;load beat data into noise regs
00D8FB  2  8E 0E 40             stx SND_NOISE_REG+2
00D8FE  2  8C 0F 40             sty SND_NOISE_REG+3
00D901  2               
00D901  2               ExitMusicHandler:
00D901  2  60                   rts
00D902  2               
00D902  2               AlternateLengthHandler:
00D902  2  AA                   tax            ;save a copy of original byte into X
00D903  2  6A                   ror            ;save LSB from original byte into carry
00D904  2  8A                   txa            ;reload original byte and rotate three times
00D905  2  2A                   rol            ;turning xx00000x into 00000xxx, with the
00D906  2  2A                   rol            ;bit in carry as the MSB here
00D907  2  2A                   rol
00D908  2               
00D908  2               ProcessLengthData:
00D908  2  29 07                and #%00000111              ;clear all but the three LSBs
00D90A  2  18                   clc
00D90B  2  65 F0                adc NoteLenLookupTblOfs     ;add offset loaded from first header byte
00D90D  2  6D C4 07             adc NoteLengthTblAdder      ;add extra if time running out music
00D910  2  A8                   tay
00D911  2  B9 66 DF             lda MusicLengthLookupTbl,y  ;load length
00D914  2  60                   rts
00D915  2               
00D915  2               LoadControlRegs:
00D915  2  AD B1 07                lda EventMusicBuffer  ;check secondary buffer for win castle music
00D918  2  29 08                   and #EndOfCastleMusic
00D91A  2  F0 04                   beq NotECstlM
00D91C  2  A9 04                   lda #$04              ;this value is only used for win castle music
00D91E  2  D0 0C                   bne AllMus            ;unconditional branch
00D920  2  A5 F4        NotECstlM: lda AreaMusicBuffer
00D922  2  29 7D                   and #%01111101        ;check primary buffer for water music
00D924  2  F0 04                   beq WaterMus
00D926  2  A9 08                   lda #$08              ;this is the default value for all other music
00D928  2  D0 02                   bne AllMus
00D92A  2  A9 28        WaterMus:  lda #$28              ;this value is used for water music and all other event music
00D92C  2  A2 82        AllMus:    ldx #$82              ;load contents of other sound regs for square 2
00D92E  2  A0 7F                   ldy #$7f
00D930  2  60                      rts
00D931  2               
00D931  2               LoadEnvelopeData:
00D931  2  AD B1 07             lda EventMusicBuffer           ;check secondary buffer for win castle music
00D934  2  29 08                and #EndOfCastleMusic
00D936  2  F0 04                beq LoadUsualEnvData
00D938  2  B9 96 DF             lda EndOfCastleMusicEnvData,y  ;load data from offset for win castle music
00D93B  2  60                   rts
00D93C  2               
00D93C  2               LoadUsualEnvData:
00D93C  2  A5 F4                lda AreaMusicBuffer            ;check primary buffer for water music
00D93E  2  29 7D                and #%01111101
00D940  2  F0 04                beq LoadWaterEventMusEnvData
00D942  2  B9 9A DF             lda AreaMusicEnvData,y         ;load default data from offset for all other music
00D945  2  60                   rts
00D946  2               
00D946  2               LoadWaterEventMusEnvData:
00D946  2  B9 A2 DF             lda WaterEventMusEnvData,y     ;load data from offset for water music and all other event music
00D949  2  60                   rts
00D94A  2               
00D94A  2               MusicHeaderData:
00D94A  2  A0             .byte DeathMusHdr-MHD
00D94B  2  54             .byte GameOverMusHdr-MHD
00D94C  2  54             .byte GameOverMusHdr-MHD
00D94D  2  5F             .byte WinCastleMusHdr-MHD
00D94E  2  54             .byte GameOverMusHdr-MHD
00D94F  2  3C             .byte EndOfLevelMusHdr-MHD
00D950  2  31             .byte TimeRunningOutHdr-MHD
00D951  2  4B             .byte SilenceHdr-MHD
00D952  2               
00D952  2  64             .byte GroundLevelPart1Hdr-MHD   ;area music
00D953  2  59             .byte WaterMusHdr-MHD
00D954  2  46             .byte UndergroundMusHdr-MHD
00D955  2  4F             .byte CastleMusHdr-MHD
00D956  2  36             .byte Star_CloudHdr-MHD
00D957  2  88             .byte GroundLevelLeadInHdr-MHD
00D958  2  36             .byte Star_CloudHdr-MHD
00D959  2  4B             .byte SilenceHdr-MHD
00D95A  2               
00D95A  2  88             .byte GroundLevelLeadInHdr-MHD  ;ground level music layout
00D95B  2  64 64          .byte GroundLevelPart1Hdr-MHD, GroundLevelPart1Hdr-MHD
00D95D  2  6A 70 6A 76    .byte GroundLevelPart2AHdr-MHD, GroundLevelPart2BHdr-MHD, GroundLevelPart2AHdr-MHD, GroundLevelPart2CHdr-MHD
00D961  2  6A 70 6A 76    .byte GroundLevelPart2AHdr-MHD, GroundLevelPart2BHdr-MHD, GroundLevelPart2AHdr-MHD, GroundLevelPart2CHdr-MHD
00D965  2  7C 82 7C 88    .byte GroundLevelPart3AHdr-MHD, GroundLevelPart3BHdr-MHD, GroundLevelPart3AHdr-MHD, GroundLevelLeadInHdr-MHD
00D969  2  64 64          .byte GroundLevelPart1Hdr-MHD, GroundLevelPart1Hdr-MHD
00D96B  2  8E 94 8E 9A    .byte GroundLevelPart4AHdr-MHD, GroundLevelPart4BHdr-MHD, GroundLevelPart4AHdr-MHD, GroundLevelPart4CHdr-MHD
00D96F  2  8E 94 8E 9A    .byte GroundLevelPart4AHdr-MHD, GroundLevelPart4BHdr-MHD, GroundLevelPart4AHdr-MHD, GroundLevelPart4CHdr-MHD
00D973  2  7C 82 7C 88    .byte GroundLevelPart3AHdr-MHD, GroundLevelPart3BHdr-MHD, GroundLevelPart3AHdr-MHD, GroundLevelLeadInHdr-MHD
00D977  2  8E 94 8E 9A    .byte GroundLevelPart4AHdr-MHD, GroundLevelPart4BHdr-MHD, GroundLevelPart4AHdr-MHD, GroundLevelPart4CHdr-MHD
00D97B  2               
00D97B  2               ;music headers
00D97B  2               ;header format is as follows:
00D97B  2               ;1 byte - length byte offset
00D97B  2               ;2 bytes -  music data address
00D97B  2               ;1 byte - triangle data offset
00D97B  2               ;1 byte - square 1 data offset
00D97B  2               ;1 byte - noise data offset (not used by secondary music)
00D97B  2               
00D97B  2  08 AA DC 27  TimeRunningOutHdr:     .byte $08, <TimeRunOutMusData, >TimeRunOutMusData, $27, $18
00D97F  2  18           
00D980  2  20 F0 D9 2E  Star_CloudHdr:         .byte $20, <Star_CloudMData, >Star_CloudMData, $2e, $1a, $40
00D984  2  1A 40        
00D986  2  20 E8 DC 3D  EndOfLevelMusHdr:      .byte $20, <WinLevelMusData, >WinLevelMusData, $3d, $21
00D98A  2  21           
00D98B  2               .ifdef ANN
00D98B  2  20 FC DC 3F  ResidualHeaderData:    .byte $20, $fc, $dc, $3f, $1d
00D98F  2  1D           
00D990  2               .else
00D990  2               ResidualHeaderData:    .byte $20, $fb, $dc, $3f, $1d
00D990  2               .endif
00D990  2  18 49 DD 00  UndergroundMusHdr:     .byte $18, <UndergroundMusData, >UndergroundMusData, $00, $00
00D994  2  00           
00D995  2  08 54 DA 00  SilenceHdr:            .byte $08, <SilenceData, >SilenceData, $00
00D999  2  00 DC DB 93  CastleMusHdr:          .byte $00, <CastleMusData, >CastleMusData, $93, $62
00D99D  2  62           
00D99E  2  18 7D DC 1E  GameOverMusHdr:        .byte $18, <GameOverMusData, >GameOverMusData, $1e, $14
00D9A2  2  14           
00D9A3  2  08 8A DD A0  WaterMusHdr:           .byte $08, <WaterMusData, >WaterMusData, $a0, $70, $68
00D9A7  2  70 68        
00D9A9  2  08 89 DE 4C  WinCastleMusHdr:       .byte $08, <EndOfCastleMusData, >EndOfCastleMusData, $4c, $24
00D9AD  2  24           
00D9AE  2  18 39 DA 2D  GroundLevelPart1Hdr:   .byte $18, <GroundM_P1Data, >GroundM_P1Data, $2d, $1c, $b8
00D9B2  2  1C B8        
00D9B4  2  18 81 DA 20  GroundLevelPart2AHdr:  .byte $18, <GroundM_P2AData, >GroundM_P2AData, $20, $12, $70
00D9B8  2  12 70        
00D9BA  2  18 AD DA 1B  GroundLevelPart2BHdr:  .byte $18, <GroundM_P2BData, >GroundM_P2BData, $1b, $10, $44
00D9BE  2  10 44        
00D9C0  2  18 D5 DA 11  GroundLevelPart2CHdr:  .byte $18, <GroundM_P2CData, >GroundM_P2CData, $11, $0a, $1c
00D9C4  2  0A 1C        
00D9C6  2  18 FA DA 2D  GroundLevelPart3AHdr:  .byte $18, <GroundM_P3AData, >GroundM_P3AData, $2d, $10, $58
00D9CA  2  10 58        
00D9CC  2  18 13 DB 14  GroundLevelPart3BHdr:  .byte $18, <GroundM_P3BData, >GroundM_P3BData, $14, $0d, $3f
00D9D0  2  0D 3F        
00D9D2  2  18 31 DB 15  GroundLevelLeadInHdr:  .byte $18, <GroundMLdInData, >GroundMLdInData, $15, $0d, $21
00D9D6  2  0D 21        
00D9D8  2  18 5D DB 18  GroundLevelPart4AHdr:  .byte $18, <GroundM_P4AData, >GroundM_P4AData, $18, $10, $7a
00D9DC  2  10 7A        
00D9DE  2  18 83 DB 19  GroundLevelPart4BHdr:  .byte $18, <GroundM_P4BData, >GroundM_P4BData, $19, $0f, $54
00D9E2  2  0F 54        
00D9E4  2  18 AC DB 1E  GroundLevelPart4CHdr:  .byte $18, <GroundM_P4CData, >GroundM_P4CData, $1e, $12, $2b
00D9E8  2  12 2B        
00D9EA  2  18 AA DB 1E  DeathMusHdr:           .byte $18, <DeathMusData, >DeathMusData, $1e, $0f, $2d
00D9EE  2  0F 2D        
00D9F0  2               
00D9F0  2               ;--------------------------------
00D9F0  2               
00D9F0  2               ;MUSIC DATA
00D9F0  2               ;square 2/triangle format
00D9F0  2               ;d7 - length byte flag (0-note, 1-length)
00D9F0  2               ;if d7 is set to 0 and d6-d0 is nonzero:
00D9F0  2               ;d6-d0 - note offset in frequency look-up table (must be even)
00D9F0  2               ;if d7 is set to 1:
00D9F0  2               ;d6-d3 - unused
00D9F0  2               ;d2-d0 - length offset in length look-up table
00D9F0  2               ;value of $00 in square 2 data is used as null terminator, affects all sound channels
00D9F0  2               ;value of $00 in triangle data causes routine to skip note
00D9F0  2               
00D9F0  2               ;square 1 format
00D9F0  2               ;d7-d6, d0 - length offset in length look-up table (bit order is d0,d7,d6)
00D9F0  2               ;d5-d1 - note offset in frequency look-up table
00D9F0  2               ;value of $00 in square 1 data is flag alternate control reg data to be loaded
00D9F0  2               
00D9F0  2               ;noise format
00D9F0  2               ;d7-d6, d0 - length offset in length look-up table (bit order is d0,d7,d6)
00D9F0  2               ;d5-d4 - beat type (0 - rest, 1 - short, 2 - strong, 3 - long)
00D9F0  2               ;d3-d1 - unused
00D9F0  2               ;value of $00 in noise data is used as null terminator, affects only noise
00D9F0  2               
00D9F0  2               ;all music data is organized into sections (unless otherwise stated):
00D9F0  2               ;square 2, square 1, triangle, noise
00D9F0  2               
00D9F0  2               Star_CloudMData:
00D9F0  2  84 2C 2C 2C        .byte $84, $2c, $2c, $2c, $82, $04, $2c, $04, $85, $2c, $84, $2c, $2c
00D9F4  2  82 04 2C 04  
00D9F8  2  85 2C 84 2C  
00D9FD  2  2A 2A 2A 82        .byte $2a, $2a, $2a, $82, $04, $2a, $04, $85, $2a, $84, $2a, $2a, $00
00DA01  2  04 2A 04 85  
00DA05  2  2A 84 2A 2A  
00DA0A  2               
00DA0A  2  1F 1F 1F 98        .byte $1f, $1f, $1f, $98, $1f, $1f, $98, $9e, $98, $1f
00DA0E  2  1F 1F 98 9E  
00DA12  2  98 1F        
00DA14  2  1D 1D 1D 94        .byte $1d, $1d, $1d, $94, $1d, $1d, $94, $9c, $94, $1d
00DA18  2  1D 1D 94 9C  
00DA1C  2  94 1D        
00DA1E  2               
00DA1E  2  86 18 85 26        .byte $86, $18, $85, $26, $30, $84, $04, $26, $30
00DA22  2  30 84 04 26  
00DA26  2  30           
00DA27  2  86 14 85 22        .byte $86, $14, $85, $22, $2c, $84, $04, $22, $2c
00DA2B  2  2C 84 04 22  
00DA2F  2  2C           
00DA30  2               
00DA30  2  21 D0 C4 D0        .byte $21, $d0, $c4, $d0, $31, $d0, $c4, $d0, $00
00DA34  2  31 D0 C4 D0  
00DA38  2  00           
00DA39  2               
00DA39  2               GroundM_P1Data:
00DA39  2  85 2C 22 1C        .byte $85, $2c, $22, $1c, $84, $26, $2a, $82, $28, $26, $04
00DA3D  2  84 26 2A 82  
00DA41  2  28 26 04     
00DA44  2  87 22 34 3A        .byte $87, $22, $34, $3a, $82, $40, $04, $36, $84, $3a, $34
00DA48  2  82 40 04 36  
00DA4C  2  84 3A 34     
00DA4F  2  82 2C 30 85        .byte $82, $2c, $30, $85, $2a
00DA53  2  2A           
00DA54  2               
00DA54  2               SilenceData:
00DA54  2  00                 .byte $00
00DA55  2               
00DA55  2  5D 55 4D 15        .byte $5d, $55, $4d, $15, $19, $96, $15, $d5, $e3, $eb
00DA59  2  19 96 15 D5  
00DA5D  2  E3 EB        
00DA5F  2  2D A6 2B 27        .byte $2d, $a6, $2b, $27, $9c, $9e, $59
00DA63  2  9C 9E 59     
00DA66  2               
00DA66  2  85 22 1C 14        .byte $85, $22, $1c, $14, $84, $1e, $22, $82, $20, $1e, $04, $87
00DA6A  2  84 1E 22 82  
00DA6E  2  20 1E 04 87  
00DA72  2  1C 2C 34 82        .byte $1c, $2c, $34, $82, $36, $04, $30, $34, $04, $2c, $04, $26
00DA76  2  36 04 30 34  
00DA7A  2  04 2C 04 26  
00DA7E  2  2A 85 22           .byte $2a, $85, $22
00DA81  2               
00DA81  2               GroundM_P2AData:
00DA81  2  84 04 82 3A        .byte $84, $04, $82, $3a, $38, $36, $32, $04, $34
00DA85  2  38 36 32 04  
00DA89  2  34           
00DA8A  2  04 24 26 2C        .byte $04, $24, $26, $2c, $04, $26, $2c, $30, $00
00DA8E  2  04 26 2C 30  
00DA92  2  00           
00DA93  2               
00DA93  2  05 B4 B2 B0        .byte $05, $b4, $b2, $b0, $2b, $ac, $84
00DA97  2  2B AC 84     
00DA9A  2  9C 9E A2 84        .byte $9c, $9e, $a2, $84, $94, $9c, $9e
00DA9E  2  94 9C 9E     
00DAA1  2               
00DAA1  2  85 14 22 84        .byte $85, $14, $22, $84, $2c, $85, $1e
00DAA5  2  2C 85 1E     
00DAA8  2  82 2C 84 2C        .byte $82, $2c, $84, $2c, $1e
00DAAC  2  1E           
00DAAD  2               
00DAAD  2               GroundM_P2BData:
00DAAD  2  84 04 82 3A        .byte $84, $04, $82, $3a, $38, $36, $32, $04, $34
00DAB1  2  38 36 32 04  
00DAB5  2  34           
00DAB6  2  04 64 04 64        .byte $04, $64, $04, $64, $86, $64, $00
00DABA  2  86 64 00     
00DABD  2               
00DABD  2  05 B4 B2 B0        .byte $05, $b4, $b2, $b0, $2b, $ac, $84
00DAC1  2  2B AC 84     
00DAC4  2  37 B6 B6 45        .byte $37, $b6, $b6, $45
00DAC8  2               
00DAC8  2  85 14 1C 82        .byte $85, $14, $1c, $82, $22, $84, $2c
00DACC  2  22 84 2C     
00DACF  2  4E 82 4E 84        .byte $4e, $82, $4e, $84, $4e, $22
00DAD3  2  4E 22        
00DAD5  2               
00DAD5  2               GroundM_P2CData:
00DAD5  2  84 04 85 32        .byte $84, $04, $85, $32, $85, $30, $86, $2c, $04, $00
00DAD9  2  85 30 86 2C  
00DADD  2  04 00        
00DADF  2               
00DADF  2  05 A4 05 9E        .byte $05, $a4, $05, $9e, $05, $9d, $85
00DAE3  2  05 9D 85     
00DAE6  2               
00DAE6  2  84 14 85 24        .byte $84, $14, $85, $24, $28, $2c, $82
00DAEA  2  28 2C 82     
00DAED  2  22 84 22 14        .byte $22, $84, $22, $14
00DAF1  2               
00DAF1  2  21 D0 C4 D0        .byte $21, $d0, $c4, $d0, $31, $d0, $c4, $d0, $00
00DAF5  2  31 D0 C4 D0  
00DAF9  2  00           
00DAFA  2               
00DAFA  2               GroundM_P3AData:
00DAFA  2  82 2C 84 2C        .byte $82, $2c, $84, $2c, $2c, $82, $2c, $30
00DAFE  2  2C 82 2C 30  
00DB02  2  04 34 2C 04        .byte $04, $34, $2c, $04, $26, $86, $22, $00
00DB06  2  26 86 22 00  
00DB0A  2               
00DB0A  2  A4 25 25 A4        .byte $a4, $25, $25, $a4, $29, $a2, $1d, $9c, $95
00DB0E  2  29 A2 1D 9C  
00DB12  2  95           
00DB13  2               
00DB13  2               GroundM_P3BData:
00DB13  2  82 2C 2C 04        .byte $82, $2c, $2c, $04, $2c, $04, $2c, $30, $85, $34, $04, $04, $00
00DB17  2  2C 04 2C 30  
00DB1B  2  85 34 04 04  
00DB20  2               
00DB20  2  A4 25 25 A4        .byte $a4, $25, $25, $a4, $a8, $63, $04
00DB24  2  A8 63 04     
00DB27  2               
00DB27  2               ;triangle data used by both sections of third part
00DB27  2  85 0E 1A 84        .byte $85, $0e, $1a, $84, $24, $85, $22, $14, $84, $0c
00DB2B  2  24 85 22 14  
00DB2F  2  84 0C        
00DB31  2               
00DB31  2               GroundMLdInData:
00DB31  2  82 34 84 34        .byte $82, $34, $84, $34, $34, $82, $2c, $84, $34, $86, $3a, $04, $00
00DB35  2  34 82 2C 84  
00DB39  2  34 86 3A 04  
00DB3E  2               
00DB3E  2  A0 21 21 A0        .byte $a0, $21, $21, $a0, $21, $2b, $05, $a3
00DB42  2  21 2B 05 A3  
00DB46  2               
00DB46  2  82 18 84 18        .byte $82, $18, $84, $18, $18, $82, $18, $18, $04, $86, $3a, $22
00DB4A  2  18 82 18 18  
00DB4E  2  04 86 3A 22  
00DB52  2               
00DB52  2               ;noise data used by lead-in and third part sections
00DB52  2  31 90 31 90        .byte $31, $90, $31, $90, $31, $71, $31, $90, $90, $90, $00
00DB56  2  31 71 31 90  
00DB5A  2  90 90 00     
00DB5D  2               
00DB5D  2               GroundM_P4AData:
00DB5D  2  82 34 84 2C        .byte $82, $34, $84, $2c, $85, $22, $84, $24
00DB61  2  85 22 84 24  
00DB65  2  82 26 36 04        .byte $82, $26, $36, $04, $36, $86, $26, $00
00DB69  2  36 86 26 00  
00DB6D  2               
00DB6D  2  AC 27 5D 1D        .byte $ac, $27, $5d, $1d, $9e, $2d, $ac, $9f
00DB71  2  9E 2D AC 9F  
00DB75  2               
00DB75  2  85 14 82 20        .byte $85, $14, $82, $20, $84, $22, $2c
00DB79  2  84 22 2C     
00DB7C  2  1E 1E 82 2C        .byte $1e, $1e, $82, $2c, $2c, $1e, $04
00DB80  2  2C 1E 04     
00DB83  2               
00DB83  2               GroundM_P4BData:
00DB83  2  87 2A 40 40        .byte $87, $2a, $40, $40, $40, $3a, $36
00DB87  2  40 3A 36     
00DB8A  2  82 34 2C 04        .byte $82, $34, $2c, $04, $26, $86, $22, $00
00DB8E  2  26 86 22 00  
00DB92  2               
00DB92  2  E3 F7 F7 F7        .byte $e3, $f7, $f7, $f7, $f5, $f1, $ac, $27, $9e, $9d
00DB96  2  F5 F1 AC 27  
00DB9A  2  9E 9D        
00DB9C  2               
00DB9C  2  85 18 82 1E        .byte $85, $18, $82, $1e, $84, $22, $2a
00DBA0  2  84 22 2A     
00DBA3  2  22 22 82 2C        .byte $22, $22, $82, $2c, $2c, $22, $04
00DBA7  2  2C 22 04     
00DBAA  2               
00DBAA  2               DeathMusData:
00DBAA  2  86 04              .byte $86, $04 ;death music share data with fourth part c of ground level music
00DBAC  2               
00DBAC  2               GroundM_P4CData:
00DBAC  2  82 2A 36 04        .byte $82, $2a, $36, $04, $36, $87, $36, $34, $30, $86, $2c, $04, $00
00DBB0  2  36 87 36 34  
00DBB4  2  30 86 2C 04  
00DBB9  2               
00DBB9  2  00 68 6A 6C        .byte $00, $68, $6a, $6c, $45 ;death music only
00DBBD  2  45           
00DBBE  2               
00DBBE  2  A2 31 B0 F1        .byte $a2, $31, $b0, $f1, $ed, $eb, $a2, $1d, $9c, $95
00DBC2  2  ED EB A2 1D  
00DBC6  2  9C 95        
00DBC8  2               
00DBC8  2  86 04              .byte $86, $04 ;death music only
00DBCA  2               
00DBCA  2  85 22 82 22        .byte $85, $22, $82, $22, $87, $22, $26, $2a, $84, $2c, $22, $86, $14
00DBCE  2  87 22 26 2A  
00DBD2  2  84 2C 22 86  
00DBD7  2               
00DBD7  2               ;noise data used by fourth part sections
00DBD7  2  51 90 31 11        .byte $51, $90, $31, $11, $00
00DBDB  2  00           
00DBDC  2               
00DBDC  2               CastleMusData:
00DBDC  2  80 22 28 22        .byte $80, $22, $28, $22, $26, $22, $24, $22, $26
00DBE0  2  26 22 24 22  
00DBE4  2  26           
00DBE5  2  22 28 22 2A        .byte $22, $28, $22, $2a, $22, $28, $22, $26
00DBE9  2  22 28 22 26  
00DBED  2  22 28 22 26        .byte $22, $28, $22, $26, $22, $24, $22, $26
00DBF1  2  22 24 22 26  
00DBF5  2  22 28 22 2A        .byte $22, $28, $22, $2a, $22, $28, $22, $26
00DBF9  2  22 28 22 26  
00DBFD  2  20 26 20 24        .byte $20, $26, $20, $24, $20, $26, $20, $28
00DC01  2  20 26 20 28  
00DC05  2  20 26 20 28        .byte $20, $26, $20, $28, $20, $26, $20, $24
00DC09  2  20 26 20 24  
00DC0D  2  20 26 20 24        .byte $20, $26, $20, $24, $20, $26, $20, $28
00DC11  2  20 26 20 28  
00DC15  2  20 26 20 28        .byte $20, $26, $20, $28, $20, $26, $20, $24
00DC19  2  20 26 20 24  
00DC1D  2  28 30 28 32        .byte $28, $30, $28, $32, $28, $30, $28, $2e
00DC21  2  28 30 28 2E  
00DC25  2  28 30 28 2E        .byte $28, $30, $28, $2e, $28, $2c, $28, $2e
00DC29  2  28 2C 28 2E  
00DC2D  2  28 30 28 32        .byte $28, $30, $28, $32, $28, $30, $28, $2e
00DC31  2  28 30 28 2E  
00DC35  2  28 30 28 2E        .byte $28, $30, $28, $2e, $28, $2c, $28, $2e, $00
00DC39  2  28 2C 28 2E  
00DC3D  2  00           
00DC3E  2               
00DC3E  2  04 70 6E 6C        .byte $04, $70, $6e, $6c, $6e, $70, $72, $70, $6e
00DC42  2  6E 70 72 70  
00DC46  2  6E           
00DC47  2  70 6E 6C 6E        .byte $70, $6e, $6c, $6e, $70, $72, $70, $6e
00DC4B  2  70 72 70 6E  
00DC4F  2  6E 6C 6E 70        .byte $6e, $6c, $6e, $70, $6e, $70, $6e, $6c
00DC53  2  6E 70 6E 6C  
00DC57  2  6E 6C 6E 70        .byte $6e, $6c, $6e, $70, $6e, $70, $6e, $6c
00DC5B  2  6E 70 6E 6C  
00DC5F  2  76 78 76 74        .byte $76, $78, $76, $74, $76, $74, $72, $74
00DC63  2  76 74 72 74  
00DC67  2  76 78 76 74        .byte $76, $78, $76, $74, $76, $74, $72, $74
00DC6B  2  76 74 72 74  
00DC6F  2               
00DC6F  2  84 1A 83 18        .byte $84, $1a, $83, $18, $20, $84, $1e, $83, $1c, $28
00DC73  2  20 84 1E 83  
00DC77  2  1C 28        
00DC79  2  26 1C 1A 1C        .byte $26, $1c, $1a, $1c
00DC7D  2               
00DC7D  2               GameOverMusData:
00DC7D  2  82 2C 04 04        .byte $82, $2c, $04, $04, $22, $04, $04, $84, $1c, $87
00DC81  2  22 04 04 84  
00DC85  2  1C 87        
00DC87  2  26 2A 26 84        .byte $26, $2a, $26, $84, $24, $28, $24, $80, $22, $00
00DC8B  2  24 28 24 80  
00DC8F  2  22 00        
00DC91  2               
00DC91  2  9C 05 94 05        .byte $9c, $05, $94, $05, $0d, $9f, $1e, $9c, $98, $9d
00DC95  2  0D 9F 1E 9C  
00DC99  2  98 9D        
00DC9B  2               
00DC9B  2  82 22 04 04        .byte $82, $22, $04, $04, $1c, $04, $04, $84, $14
00DC9F  2  1C 04 04 84  
00DCA3  2  14           
00DCA4  2  86 1E 80 16        .byte $86, $1e, $80, $16, $80, $14
00DCA8  2  80 14        
00DCAA  2               
00DCAA  2               TimeRunOutMusData:
00DCAA  2  81 1C 30 04        .byte $81, $1c, $30, $04, $30, $30, $04, $1e, $32, $04, $32, $32
00DCAE  2  30 30 04 1E  
00DCB2  2  32 04 32 32  
00DCB6  2  04 20 34 04        .byte $04, $20, $34, $04, $34, $34, $04, $36, $04, $84, $36, $00
00DCBA  2  34 34 04 36  
00DCBE  2  04 84 36 00  
00DCC2  2               
00DCC2  2  46 A4 64 A4        .byte $46, $a4, $64, $a4, $48, $a6, $66, $a6, $4a, $a8, $68, $a8
00DCC6  2  48 A6 66 A6  
00DCCA  2  4A A8 68 A8  
00DCCE  2  6A 44 2B           .byte $6a, $44, $2b
00DCD1  2               
00DCD1  2  81 2A 42 04        .byte $81, $2a, $42, $04, $42, $42, $04, $2c, $64, $04, $64, $64
00DCD5  2  42 42 04 2C  
00DCD9  2  64 04 64 64  
00DCDD  2  04 2E 46 04        .byte $04, $2e, $46, $04, $46, $46, $04, $22, $04, $84, $22
00DCE1  2  46 46 04 22  
00DCE5  2  04 84 22     
00DCE8  2               
00DCE8  2               WinLevelMusData:
00DCE8  2  87 04 06 0C        .byte $87, $04, $06, $0c, $14, $1c, $22, $86, $2c, $22
00DCEC  2  14 1C 22 86  
00DCF0  2  2C 22        
00DCF2  2  87 04 60 0E        .byte $87, $04, $60, $0e, $14, $1a, $24, $86, $2c, $24
00DCF6  2  14 1A 24 86  
00DCFA  2  2C 24        
00DCFC  2  87 04 08 10        .byte $87, $04, $08, $10, $18, $1e, $28, $86, $30, $30
00DD00  2  18 1E 28 86  
00DD04  2  30 30        
00DD06  2  80 64 00           .byte $80, $64, $00
00DD09  2               
00DD09  2  CD D5 DD E3        .byte $cd, $d5, $dd, $e3, $ed, $f5, $bb, $b5, $cf, $d5
00DD0D  2  ED F5 BB B5  
00DD11  2  CF D5        
00DD13  2  DB E5 ED F3        .byte $db, $e5, $ed, $f3, $bd, $b3, $d1, $d9, $df, $e9
00DD17  2  BD B3 D1 D9  
00DD1B  2  DF E9        
00DD1D  2  F1 F7 BF FF        .byte $f1, $f7, $bf, $ff, $ff, $ff, $34
00DD21  2  FF FF 34     
00DD24  2  00                 .byte $00 ;unused byte
00DD25  2               
00DD25  2  86 04 87 14        .byte $86, $04, $87, $14, $1c, $22, $86, $34, $84, $2c
00DD29  2  1C 22 86 34  
00DD2D  2  84 2C        
00DD2F  2  04 04 04 87        .byte $04, $04, $04, $87, $14, $1a, $24, $86, $32, $84
00DD33  2  14 1A 24 86  
00DD37  2  32 84        
00DD39  2  2C 04 86 04        .byte $2c, $04, $86, $04, $87, $18, $1e, $28, $86, $36
00DD3D  2  87 18 1E 28  
00DD41  2  86 36        
00DD43  2  87 30 30 30        .byte $87, $30, $30, $30, $80, $2c
00DD47  2  80 2C        
00DD49  2               
00DD49  2               ;square 2 and triangle use the same data, square 1 is unused
00DD49  2               UndergroundMusData:
00DD49  2  82 14 2C 62        .byte $82, $14, $2c, $62, $26, $10, $28, $80, $04
00DD4D  2  26 10 28 80  
00DD51  2  04           
00DD52  2  82 14 2C 62        .byte $82, $14, $2c, $62, $26, $10, $28, $80, $04
00DD56  2  26 10 28 80  
00DD5A  2  04           
00DD5B  2  82 08 1E 5E        .byte $82, $08, $1e, $5e, $18, $60, $1a, $80, $04
00DD5F  2  18 60 1A 80  
00DD63  2  04           
00DD64  2  82 08 1E 5E        .byte $82, $08, $1e, $5e, $18, $60, $1a, $86, $04
00DD68  2  18 60 1A 86  
00DD6C  2  04           
00DD6D  2  83 1A 18 16        .byte $83, $1a, $18, $16, $84, $14, $1a, $18, $0e, $0c
00DD71  2  84 14 1A 18  
00DD75  2  0E 0C        
00DD77  2  16 83 14 20        .byte $16, $83, $14, $20, $1e, $1c, $28, $26, $87
00DD7B  2  1E 1C 28 26  
00DD7F  2  87           
00DD80  2  24 1A 12 10        .byte $24, $1a, $12, $10, $62, $0e, $80, $04, $04
00DD84  2  62 0E 80 04  
00DD88  2  04           
00DD89  2  00                 .byte $00
00DD8A  2               
00DD8A  2               ;noise data directly follows square 2 here unlike in other songs
00DD8A  2               WaterMusData:
00DD8A  2  82 18 1C 20        .byte $82, $18, $1c, $20, $22, $26, $28
00DD8E  2  22 26 28     
00DD91  2  81 2A 2A 2A        .byte $81, $2a, $2a, $2a, $04, $2a, $04, $83, $2a, $82, $22
00DD95  2  04 2A 04 83  
00DD99  2  2A 82 22     
00DD9C  2  86 34 32 34        .byte $86, $34, $32, $34, $81, $04, $22, $26, $2a, $2c, $30
00DDA0  2  81 04 22 26  
00DDA4  2  2A 2C 30     
00DDA7  2  86 34 83 32        .byte $86, $34, $83, $32, $82, $36, $84, $34, $85, $04, $81, $22
00DDAB  2  82 36 84 34  
00DDAF  2  85 04 81 22  
00DDB3  2  86 30 2E 30        .byte $86, $30, $2e, $30, $81, $04, $22, $26, $2a, $2c, $2e
00DDB7  2  81 04 22 26  
00DDBB  2  2A 2C 2E     
00DDBE  2  86 30 83 22        .byte $86, $30, $83, $22, $82, $36, $84, $34, $85, $04, $81, $22
00DDC2  2  82 36 84 34  
00DDC6  2  85 04 81 22  
00DDCA  2  86 3A 3A 3A        .byte $86, $3a, $3a, $3a, $82, $3a, $81, $40, $82, $04, $81, $3a
00DDCE  2  82 3A 81 40  
00DDD2  2  82 04 81 3A  
00DDD6  2  86 36 36 36        .byte $86, $36, $36, $36, $82, $36, $81, $3a, $82, $04, $81, $36
00DDDA  2  82 36 81 3A  
00DDDE  2  82 04 81 36  
00DDE2  2  86 34 82 26        .byte $86, $34, $82, $26, $2a, $36
00DDE6  2  2A 36        
00DDE8  2  81 34 34 85        .byte $81, $34, $34, $85, $34, $81, $2a, $86, $2c, $00
00DDEC  2  34 81 2A 86  
00DDF0  2  2C 00        
00DDF2  2               
00DDF2  2  84 90 B0 84        .byte $84, $90, $b0, $84, $50, $50, $b0, $00
00DDF6  2  50 50 B0 00  
00DDFA  2               
00DDFA  2  98 96 94 92        .byte $98, $96, $94, $92, $94, $96, $58, $58, $58, $44
00DDFE  2  94 96 58 58  
00DE02  2  58 44        
00DE04  2  5C 44 9F A3        .byte $5c, $44, $9f, $a3, $a1, $a3, $85, $a3, $e0, $a6
00DE08  2  A1 A3 85 A3  
00DE0C  2  E0 A6        
00DE0E  2  23 C4 9F 9D        .byte $23, $c4, $9f, $9d, $9f, $85, $9f, $d2, $a6, $23
00DE12  2  9F 85 9F D2  
00DE16  2  A6 23        
00DE18  2  C4 B5 B1 AF        .byte $c4, $b5, $b1, $af, $85, $b1, $af, $ad, $85, $95
00DE1C  2  85 B1 AF AD  
00DE20  2  85 95        
00DE22  2  9E A2 AA 6A        .byte $9e, $a2, $aa, $6a, $6a, $6b, $5e, $9d
00DE26  2  6A 6B 5E 9D  
00DE2A  2               
00DE2A  2  84 04 04 82        .byte $84, $04, $04, $82, $22, $86, $22
00DE2E  2  22 86 22     
00DE31  2  82 14 22 2C        .byte $82, $14, $22, $2c, $12, $22, $2a, $14, $22, $2c
00DE35  2  12 22 2A 14  
00DE39  2  22 2C        
00DE3B  2  1C 22 2C 14        .byte $1c, $22, $2c, $14, $22, $2c, $12, $22, $2a, $14
00DE3F  2  22 2C 12 22  
00DE43  2  2A 14        
00DE45  2  22 2C 1C 22        .byte $22, $2c, $1c, $22, $2c, $18, $22, $2a, $16, $20
00DE49  2  2C 18 22 2A  
00DE4D  2  16 20        
00DE4F  2  28 18 22 2A        .byte $28, $18, $22, $2a, $12, $22, $2a, $18, $22, $2a
00DE53  2  12 22 2A 18  
00DE57  2  22 2A        
00DE59  2  12 22 2A 14        .byte $12, $22, $2a, $14, $22, $2c, $0c, $22, $2c, $14, $22, $34, $12
00DE5D  2  22 2C 0C 22  
00DE61  2  2C 14 22 34  
00DE66  2  22 30 10 22        .byte $22, $30, $10, $22, $2e, $16, $22, $34, $18, $26
00DE6A  2  2E 16 22 34  
00DE6E  2  18 26        
00DE70  2  36 16 26 36        .byte $36, $16, $26, $36, $14, $26, $36, $12, $22, $36
00DE74  2  14 26 36 12  
00DE78  2  22 36        
00DE7A  2  5C 22 34 0C        .byte $5c, $22, $34, $0c, $22, $22, $81, $1e, $1e, $85, $1e
00DE7E  2  22 22 81 1E  
00DE82  2  1E 85 1E     
00DE85  2  81 12 86 14        .byte $81, $12, $86, $14
00DE89  2               
00DE89  2               EndOfCastleMusData:
00DE89  2  81 2C 22 1C        .byte $81, $2c, $22, $1c, $2c, $22, $1c, $85, $2c, $04
00DE8D  2  2C 22 1C 85  
00DE91  2  2C 04        
00DE93  2  81 2E 24 1E        .byte $81, $2e, $24, $1e, $2e, $24, $1e, $85, $2e, $04
00DE97  2  2E 24 1E 85  
00DE9B  2  2E 04        
00DE9D  2  81 32 28 22        .byte $81, $32, $28, $22, $32, $28, $22, $85, $32
00DEA1  2  32 28 22 85  
00DEA5  2  32           
00DEA6  2  87 36 36 36        .byte $87, $36, $36, $36, $84, $3a, $00
00DEAA  2  84 3A 00     
00DEAD  2               
00DEAD  2  5C 54 4C 5C        .byte $5c, $54, $4c, $5c, $54, $4c
00DEB1  2  54 4C        
00DEB3  2  5C 1C 1C 5C        .byte $5c, $1c, $1c, $5c, $5c, $5c, $5c
00DEB7  2  5C 5C 5C     
00DEBA  2  5E 56 4E 5E        .byte $5e, $56, $4e, $5e, $56, $4e
00DEBE  2  56 4E        
00DEC0  2  5E 1E 1E 5E        .byte $5e, $1e, $1e, $5e, $5e, $5e, $5e
00DEC4  2  5E 5E 5E     
00DEC7  2  62 5A 50 62        .byte $62, $5a, $50, $62, $5a, $50
00DECB  2  5A 50        
00DECD  2  62 22 22 62        .byte $62, $22, $22, $62, $e7, $e7, $e7, $2b
00DED1  2  E7 E7 E7 2B  
00DED5  2               
00DED5  2  86 14 81 14        .byte $86, $14, $81, $14, $80, $14, $14, $81, $14, $14, $14, $14
00DED9  2  80 14 14 81  
00DEDD  2  14 14 14 14  
00DEE1  2  86 16 81 16        .byte $86, $16, $81, $16, $80, $16, $16, $81, $16, $16, $16, $16
00DEE5  2  80 16 16 81  
00DEE9  2  16 16 16 16  
00DEED  2  81 28 22 1A        .byte $81, $28, $22, $1a, $28, $22, $1a, $28, $80, $28, $28
00DEF1  2  28 22 1A 28  
00DEF5  2  80 28 28     
00DEF8  2  81 28 87 2C        .byte $81, $28, $87, $2c, $2c, $2c, $84, $30
00DEFC  2  2C 2C 84 30  
00DF00  2               
00DF00  2               .ifndef ANN
00DF00  2               ;unused byte
00DF00  2                     .byte $ff
00DF00  2               .endif
00DF00  2               
00DF00  2               FreqRegLookupTbl:
00DF00  2  00 88 00 2F        .byte $00, $88, $00, $2f, $00, $00
00DF04  2  00 00        
00DF06  2  02 A6 02 80        .byte $02, $a6, $02, $80, $02, $5c, $02, $3a
00DF0A  2  02 5C 02 3A  
00DF0E  2  02 1A 01 DF        .byte $02, $1a, $01, $df, $01, $c4, $01, $ab
00DF12  2  01 C4 01 AB  
00DF16  2  01 93 01 7C        .byte $01, $93, $01, $7c, $01, $67, $01, $53
00DF1A  2  01 67 01 53  
00DF1E  2  01 40 01 2E        .byte $01, $40, $01, $2e, $01, $1d, $01, $0d
00DF22  2  01 1D 01 0D  
00DF26  2  00 FE 00 EF        .byte $00, $fe, $00, $ef, $00, $e2, $00, $d5
00DF2A  2  00 E2 00 D5  
00DF2E  2  00 C9 00 BE        .byte $00, $c9, $00, $be, $00, $b3, $00, $a9
00DF32  2  00 B3 00 A9  
00DF36  2  00 A0 00 97        .byte $00, $a0, $00, $97, $00, $8e, $00, $86
00DF3A  2  00 8E 00 86  
00DF3E  2  00 77 00 7E        .byte $00, $77, $00, $7e, $00, $71, $00, $54
00DF42  2  00 71 00 54  
00DF46  2  00 64 00 5F        .byte $00, $64, $00, $5f, $00, $59, $00, $50
00DF4A  2  00 59 00 50  
00DF4E  2  00 47 00 43        .byte $00, $47, $00, $43, $00, $3b, $00, $35
00DF52  2  00 3B 00 35  
00DF56  2  00 2A 00 23        .byte $00, $2a, $00, $23, $04, $75, $03, $57
00DF5A  2  04 75 03 57  
00DF5E  2  02 F9 02 CF        .byte $02, $f9, $02, $cf, $01, $fc, $00, $6a
00DF62  2  01 FC 00 6A  
00DF66  2               
00DF66  2               MusicLengthLookupTbl:
00DF66  2  05 0A 14 28        .byte $05, $0a, $14, $28, $50, $1e, $3c, $02
00DF6A  2  50 1E 3C 02  
00DF6E  2  04 08 10 20        .byte $04, $08, $10, $20, $40, $18, $30, $0c
00DF72  2  40 18 30 0C  
00DF76  2  03 06 0C 18        .byte $03, $06, $0c, $18, $30, $12, $24, $08
00DF7A  2  30 12 24 08  
00DF7E  2  36 03 09 06        .byte $36, $03, $09, $06, $12, $1b, $24, $0c
00DF82  2  12 1B 24 0C  
00DF86  2  24 02 06 04        .byte $24, $02, $06, $04, $0c, $12, $18, $08
00DF8A  2  0C 12 18 08  
00DF8E  2  12 01 03 02        .byte $12, $01, $03, $02, $06, $09, $0c, $04
00DF92  2  06 09 0C 04  
00DF96  2               
00DF96  2               EndOfCastleMusicEnvData:
00DF96  2  98 99 9A 9B        .byte $98, $99, $9a, $9b
00DF9A  2               
00DF9A  2               AreaMusicEnvData:
00DF9A  2  90 94 94 95        .byte $90, $94, $94, $95, $95, $96, $97, $98
00DF9E  2  95 96 97 98  
00DFA2  2               
00DFA2  2               WaterEventMusEnvData:
00DFA2  2  90 91 92 92        .byte $90, $91, $92, $92, $93, $93, $93, $94
00DFA6  2  93 93 93 94  
00DFAA  2  94 94 94 94        .byte $94, $94, $94, $94, $94, $95, $95, $95
00DFAE  2  94 95 95 95  
00DFB2  2  95 95 95 96        .byte $95, $95, $95, $96, $96, $96, $96, $96
00DFB6  2  96 96 96 96  
00DFBA  2  96 96 96 96        .byte $96, $96, $96, $96, $96, $96, $96, $96
00DFBE  2  96 96 96 96  
00DFC2  2  96 96 96 96        .byte $96, $96, $96, $96, $95, $95, $94, $93
00DFC6  2  95 95 94 93  
00DFCA  2               
00DFCA  2               BowserFlameEnvData:
00DFCA  2  15 16 16 17        .byte $15, $16, $16, $17, $17, $18, $19, $19
00DFCE  2  17 18 19 19  
00DFD2  2  1A 1A 1C 1D        .byte $1a, $1a, $1c, $1d, $1d, $1e, $1e, $1f
00DFD6  2  1D 1E 1E 1F  
00DFDA  2  1F 1F 1F 1E        .byte $1f, $1f, $1f, $1e, $1d, $1c, $1e, $1f
00DFDE  2  1D 1C 1E 1F  
00DFE2  2  1F 1E 1D 1C        .byte $1f, $1e, $1d, $1c, $1a, $18, $16, $14
00DFE6  2  1A 18 16 14  
00DFEA  2               
00DFEA  2               BrickShatterEnvData:
00DFEA  2  15 16 16 17        .byte $15, $16, $16, $17, $17, $18, $19, $19
00DFEE  2  17 18 19 19  
00DFF2  2  1A 1A 1C 1D        .byte $1a, $1a, $1c, $1d, $1d, $1e, $1e, $1f
00DFF6  2  1D 1E 1E 1F  
00DFFA  2               
00DFFA  2               .res $DFFA - *, $FF
00DFFA  2  A3 60                .word NMIHandler
00DFFC  2  00 60                .word Start
00DFFE  2  A5 61                .word IRQHandler
00E000  2               
00E000  1               .reloc
00A5BEr 1               .endscope
00A5BEr 1               MainEnd:
00A5BEr 1               
00A5BEr 1  03           .byte FileHeaderBlock
00A5BFr 1  04 20        .byte $04,$20
00A5C1r 1  4E 53 4D 44  .byte "NSMDATA2"
00A5C5r 1  41 54 41 32  
00A5C9r 1  70 C4        .word $c470
00A5CBr 1  00 0E        .word Data2End-Data2Start
00A5CDr 1  00 04        .byte PRG,FileDataBlock
00A5CFr 1               Data2Start:
00A5CFr 1               .scope FILE_SM2DATA2
00A5CFr 1               .org $C470
00C470  1               .include "ann_sm2data2.asm"
00C470  2               ;SMB2J DISASSEMBLY (SM2DATA2 portion)
00C470  2               
00C470  2               ;-------------------------------------------------------------------------------------
00C470  2               ;DEFINES
00C470  2               
00C470  2               ANN                   = $40
00C470  2               FrameCounter          = $09
00C470  2               Enemy_State           = $1e
00C470  2               Enemy_Y_Position      = $cf
00C470  2               PiranhaPlantUpYPos    = $0417
00C470  2               PiranhaPlantDownYPos  = $0434
00C470  2               PiranhaPlant_Y_Speed  = $58
00C470  2               PiranhaPlant_MoveFlag = $a0
00C470  2               
00C470  2               Player_X_Scroll       = $06ff
00C470  2               
00C470  2               Player_PageLoc        = $6d
00C470  2               Player_X_Position     = $86
00C470  2               
00C470  2               AreaObjectLength      = $0730
00C470  2               WindFlag              = $07f9
00C470  2               AreaType              = $074e
00C470  2               
00C470  2               TimerControl          = $0747
00C470  2               EnemyFrameTimer       = $078a
00C470  2               WorldNumber           = $075f
00C470  2               
00C470  2               Sprite_Y_Position     = $0200
00C470  2               Sprite_Tilenumber     = $0201
00C470  2               Sprite_Attributes     = $0202
00C470  2               Sprite_X_Position     = $0203
00C470  2               
00C470  2               Alt_SprDataOffset     = $06ec
00C470  2               
00C470  2               NoiseSoundQueue       = $fd
00C470  2               
00C470  2               MetatileBuffer        = $06a1
00C470  2               
00C470  2               ; import from other files
00C470  2               .import GetPipeHeight
00C470  2               .import FindEmptyEnemySlot
00C470  2               .import SetupPiranhaPlant
00C470  2               .import VerticalPipeData
00C470  2               .import RenderUnderPart
00C470  2               ; export to other files
00C470  2               .ifdef ANN
00C470  2               .export E_Area06
00C470  2               .export E_Area07
00C470  2               .export E_Area04
00C470  2               .export E_Area05
00C470  2               .export E_Area09
00C470  2               .export E_Area0B
00C470  2               .export E_Area1E
00C470  2               .export E_Area1F
00C470  2               .export E_Area12
00C470  2               .export E_Area21
00C470  2               .export E_Area15
00C470  2               .export E_Area16
00C470  2               .export E_Area18
00C470  2               .export E_Area19
00C470  2               .export E_Area1A
00C470  2               .export E_Area1B
00C470  2               .export E_Area22
00C470  2               .export E_Area27
00C470  2               .export E_Area28
00C470  2               .export E_Area2B
00C470  2               .export E_Area2A
00C470  2               .export L_Area06
00C470  2               .export L_Area07
00C470  2               .export L_Area04
00C470  2               .export L_Area05
00C470  2               .export L_Area09
00C470  2               .export L_Area0B
00C470  2               .export L_Area1E
00C470  2               .export L_Area1F
00C470  2               .export L_Area12
00C470  2               .export L_Area21
00C470  2               .export L_Area15
00C470  2               .export L_Area16
00C470  2               .export L_Area18
00C470  2               .export L_Area19
00C470  2               .export L_Area1A
00C470  2               .export L_Area1B
00C470  2               .export L_Area22
00C470  2               .export L_Area27
00C470  2               .export L_Area28
00C470  2               .export L_Area2B
00C470  2               .export L_Area2A
00C470  2               .export MRetainerCHRWorld5
00C470  2               .export MRetainerCHRWorld6
00C470  2               .export MRetainerCHRWorld7
00C470  2               .export HardWorldJumpSpringHandler
00C470  2               .export HardWorldEnemyGfxHandler
00C470  2               .else
00C470  2               .export E_CastleArea5
00C470  2               .export E_CastleArea6
00C470  2               .export E_CastleArea7
00C470  2               .export E_CastleArea8
00C470  2               .export E_GroundArea12
00C470  2               .export E_GroundArea13
00C470  2               .export E_GroundArea14
00C470  2               .export E_GroundArea15
00C470  2               .export E_GroundArea16
00C470  2               .export E_GroundArea17
00C470  2               .export E_GroundArea18
00C470  2               .export E_GroundArea19
00C470  2               .export E_GroundArea22
00C470  2               .export E_GroundArea23
00C470  2               .export E_GroundArea24
00C470  2               .export E_GroundArea29
00C470  2               .export E_UndergroundArea4
00C470  2               .export E_UndergroundArea5
00C470  2               .export E_WaterArea2
00C470  2               .export E_WaterArea4
00C470  2               .export E_WaterArea5
00C470  2               .export L_CastleArea5
00C470  2               .export L_CastleArea6
00C470  2               .export L_CastleArea7
00C470  2               .export L_CastleArea8
00C470  2               .export L_GroundArea12
00C470  2               .export L_GroundArea13
00C470  2               .export L_GroundArea14
00C470  2               .export L_GroundArea15
00C470  2               .export L_GroundArea16
00C470  2               .export L_GroundArea17
00C470  2               .export L_GroundArea18
00C470  2               .export L_GroundArea19
00C470  2               .export L_GroundArea22
00C470  2               .export L_GroundArea23
00C470  2               .export L_GroundArea24
00C470  2               .export L_GroundArea29
00C470  2               .export L_UndergroundArea4
00C470  2               .export L_UndergroundArea5
00C470  2               .export L_WaterArea2
00C470  2               .export L_WaterArea4
00C470  2               .export L_WaterArea5
00C470  2               .endif
00C470  2               
00C470  2               ;-------------------------------------------------------------------------------------------------
00C470  2               ;$06 - used to store vertical length of pipe
00C470  2               ;$07 - starts with adder from area parser, used to store row offset
00C470  2               
00C470  2               UpsideDownPipe_High:
00C470  2  A9 01               lda #$01                     ;start at second row
00C472  2  48                  pha
00C473  2  D0 03               bne UDP
00C475  2               UpsideDownPipe_Low:
00C475  2  A9 04               lda #$04                     ;start at fifth row
00C477  2  48                  pha
00C478  2  20 rr rr     UDP:   jsr GetPipeHeight            ;get pipe height from object byte
00C47B  2  68                  pla
00C47C  2  85 07               sta $07                      ;save buffer offset temporarily
00C47E  2  98                  tya
00C47F  2  48                  pha                          ;save pipe height temporarily
00C480  2  BC 30 07            ldy AreaObjectLength,x       ;if on second column of pipe, skip this
00C483  2  F0 23               beq NoUDP
00C485  2  20 rr rr            jsr FindEmptyEnemySlot       ;otherwise try to insert upside-down
00C488  2  B0 1E               bcs NoUDP                    ;piranha plant, if no empty slots, skip this
00C48A  2  A9 04               lda #$04
00C48C  2  20 rr rr            jsr SetupPiranhaPlant        ;set up upside-down piranha plant
00C48F  2  A5 06               lda $06
00C491  2  0A                  asl
00C492  2  0A                  asl                          ;multiply height of pipe by 16
00C493  2  0A                  asl                          ;and add enemy Y position previously set up
00C494  2  0A                  asl                          ;then subtract 10 pixels, save as new Y position
00C495  2  18                  clc
00C496  2  75 CF               adc Enemy_Y_Position,x
00C498  2  38                  sec
00C499  2  E9 0A               sbc #$0a
00C49B  2  95 CF               sta Enemy_Y_Position,x
00C49D  2  9D 34 04            sta PiranhaPlantDownYPos,x   ;set as "down" position
00C4A0  2  18                  clc                          ;add 24 pixels, save as "up" position
00C4A1  2  69 18               adc #$18                     ;note up and down here are reversed
00C4A3  2  9D 17 04            sta PiranhaPlantUpYPos,x
00C4A6  2  F6 A0               inc PiranhaPlant_MoveFlag,x  ;set movement flag
00C4A8  2  68           NoUDP: pla
00C4A9  2  A8                  tay                          ;return tile offset
00C4AA  2  48                  pha
00C4AB  2  A6 07               ldx $07
00C4AD  2  B9 rr rr            lda VerticalPipeData+2,y
00C4B0  2  A4 06               ldy $06                      ;render the pipe shaft
00C4B2  2  88                  dey
00C4B3  2  20 rr rr            jsr RenderUnderPart
00C4B6  2  68                  pla
00C4B7  2  A8                  tay
00C4B8  2  B9 rr rr            lda VerticalPipeData,y       ;and render the pipe end
00C4BB  2  9D A1 06            sta MetatileBuffer,x
00C4BE  2  60                  rts
00C4BF  2               
00C4BF  2  60                  rts                        ;unused, nothing jumps here
00C4C0  2               
00C4C0  2               MoveUpsideDownPiranhaP:
00C4C0  2  B5 1E              lda Enemy_State,x           ;check enemy state
00C4C2  2  D0 39              bne ExMoveUDPP              ;if set at all, branch to leave
00C4C4  2  BD 8A 07           lda EnemyFrameTimer,x       ;check enemy's timer here
00C4C7  2  D0 34              bne ExMoveUDPP              ;branch to end if not yet expired
00C4C9  2  B5 A0              lda PiranhaPlant_MoveFlag,x ;check movement flag
00C4CB  2  D0 0B              bne SetupToMovePPlant       ;if moving, skip to part ahead
00C4CD  2  B5 58              lda PiranhaPlant_Y_Speed,x  ;get vertical speed
00C4CF  2  49 FF              eor #$ff
00C4D1  2  18                 clc                         ;change to two's compliment
00C4D2  2  69 01              adc #$01
00C4D4  2  95 58              sta PiranhaPlant_Y_Speed,x  ;save as new vertical speed
00C4D6  2  F6 A0              inc PiranhaPlant_MoveFlag,x ;increment to set movement flag
00C4D8  2               
00C4D8  2               SetupToMovePPlant:
00C4D8  2  BD 17 04           lda PiranhaPlantUpYPos,x    ;get original vertical coordinate (lowest point)
00C4DB  2  B4 58              ldy PiranhaPlant_Y_Speed,x  ;get vertical speed
00C4DD  2  10 03              bpl RiseFallPiranhaPlant    ;branch if moving downwards
00C4DF  2  BD 34 04           lda PiranhaPlantDownYPos,x  ;otherwise get other vertical coordinate (highest point)
00C4E2  2               
00C4E2  2               RiseFallPiranhaPlant:
00C4E2  2  85 00               sta $00                     ;save vertical coordinate here
00C4E4  2  AD 47 07            lda TimerControl            ;get master timer control
00C4E7  2  D0 14               bne ExMoveUDPP              ;branch to leave if set (likely not necessary)
00C4E9  2  B5 CF               lda Enemy_Y_Position,x      ;get current vertical coordinate
00C4EB  2  18                  clc
00C4EC  2  75 58               adc PiranhaPlant_Y_Speed,x  ;add vertical speed to move up or down
00C4EE  2  95 CF               sta Enemy_Y_Position,x      ;save as new vertical coordinate
00C4F0  2  C5 00               cmp $00                     ;compare against low or high coordinate
00C4F2  2  D0 09               bne ExMoveUDPP              ;branch to leave if not yet reached
00C4F4  2  A9 00               lda #$00
00C4F6  2  95 A0               sta PiranhaPlant_MoveFlag,x ;otherwise clear movement flag
00C4F8  2  A9 20               lda #$20
00C4FA  2  9D 8A 07            sta EnemyFrameTimer,x       ;set timer to delay piranha plant movement
00C4FD  2               ExMoveUDPP:
00C4FD  2  60                  rts
00C4FE  2               
00C4FE  2               ;-------------------------------------------------------------------------------------
00C4FE  2               
00C4FE  2               .ifdef ANN
00C4FE  2               HardWorldJumpSpringHandler:
00C4FE  2  AC 5F 07       ldy WorldNumber
00C501  2  C0 01          cpy #$01
00C503  2  F0 04          beq @Shift
00C505  2  C0 02          cpy #$02
00C507  2  D0 02          bne @Done
00C509  2               @Shift:
00C509  2  A9 E0          lda #$E0
00C50B  2               @Done:
00C50B  2  60             rts
00C50C  2               
00C50C  2               HardWorldEnemyGfxHandler:
00C50C  2  AC 5F 07       ldy WorldNumber
00C50F  2  C0 01          cpy #$01
00C511  2  F0 04          beq @Shift
00C513  2  C0 02          cpy #$02
00C515  2  D0 01          bne @Done
00C517  2               @Shift:
00C517  2  4A             lsr a
00C518  2               @Done:
00C518  2  60             rts
00C519  2               
00C519  2               ;unused bytes
00C519  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C51D  2  FF FF FF FF  
00C521  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C525  2  FF FF FF FF  
00C529  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C52D  2  FF FF FF FF  
00C531  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C535  2  FF FF FF FF  
00C539  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C53D  2  FF FF FF FF  
00C541  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C545  2  FF FF FF FF  
00C549  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C54D  2  FF FF FF FF  
00C551  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C555  2  FF FF FF FF  
00C559  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C55D  2  FF FF FF FF  
00C561  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C565  2  FF FF FF FF  
00C569  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C56D  2  FF FF FF FF  
00C571  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C575  2  FF FF FF FF  
00C579  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C57D  2  FF FF FF FF  
00C581  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C585  2  FF FF FF FF  
00C589  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C58D  2  FF FF FF FF  
00C591  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C595  2  FF FF FF FF  
00C599  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C59D  2  FF FF FF FF  
00C5A1  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C5A5  2  FF FF FF FF  
00C5A9  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C5AD  2  FF FF FF FF  
00C5B1  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C5B5  2  FF FF FF FF  
00C5B9  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C5BD  2  FF FF FF FF  
00C5C1  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C5C5  2  FF FF FF FF  
00C5C9  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF
00C5CD  2  FF FF FF     
00C5D0  2               .else
00C5D0  2               BlowPlayerAround:
00C5D0  2                       lda WindFlag            ;if wind is turned off, just exit
00C5D0  2                       beq ExBlow
00C5D0  2                       lda AreaType            ;don't blow the player around unless
00C5D0  2                       cmp #$01                ;the area is ground type
00C5D0  2                       bne ExBlow
00C5D0  2                       ldy #$01
00C5D0  2                       lda FrameCounter        ;branch to set d0 if on an odd frame
00C5D0  2                       asl
00C5D0  2                       bcs BThr                ;otherwise wind will only blow
00C5D0  2                       ldy #$03                ;one out of every four frames
00C5D0  2               BThr:   sty $00
00C5D0  2                       lda FrameCounter        ;throttle wind blowing by using the frame counter
00C5D0  2                       and $00                 ;to mask out certain frames
00C5D0  2                       bne ExBlow
00C5D0  2                       lda Player_X_Position   ;move player slightly to the right
00C5D0  2                       clc                     ;to simulate the wind moving the player
00C5D0  2                       adc #$01
00C5D0  2                       sta Player_X_Position
00C5D0  2                       lda Player_PageLoc
00C5D0  2                       adc #$00
00C5D0  2                       sta Player_PageLoc
00C5D0  2                       inc Player_X_Scroll     ;add one to movement speed for scroll
00C5D0  2               ExBlow: rts
00C5D0  2               
00C5D0  2               ;note the position data values are overwritten in RAM
00C5D0  2               LeavesYPos:
00C5D0  2                       .byte $30, $70, $b8, $50, $98, $30
00C5D0  2                       .byte $70, $b8, $50, $98, $30, $70
00C5D0  2               
00C5D0  2               LeavesXPos:
00C5D0  2                       .byte $30, $30, $30, $60, $60, $a0
00C5D0  2                       .byte $a0, $a0, $d0, $d0, $d0, $60
00C5D0  2               
00C5D0  2               LeavesTile:
00C5D0  2                       .byte $7b, $7b, $7b, $7b, $7a, $7a
00C5D0  2                       .byte $7b, $7b, $7b, $7a, $7b, $7a
00C5D0  2               
00C5D0  2               SimulateWind:
00C5D0  2                         lda WindFlag             ;if no wind, branch to leave
00C5D0  2                         beq ExSimW
00C5D0  2                         lda #$04                 ;play wind sfx
00C5D0  2                         sta NoiseSoundQueue
00C5D0  2                         jsr ModifyLeavesPos      ;modify X and Y position data of leaves
00C5D0  2                         ldx #$00                 ;use mostly unused sprite data offset
00C5D0  2                         ldy Alt_SprDataOffset-1  ;for first six leaves
00C5D0  2               DrawLeaf: lda LeavesYPos,x
00C5D0  2                         sta Sprite_Y_Position,y  ;set up sprite data in OAM memory
00C5D0  2                         lda LeavesTile,x
00C5D0  2                         sta Sprite_Tilenumber,y
00C5D0  2                         lda #$41
00C5D0  2                         sta Sprite_Attributes,y
00C5D0  2                         lda LeavesXPos,x
00C5D0  2                         sta Sprite_X_Position,y
00C5D0  2                         iny
00C5D0  2                         iny
00C5D0  2                         iny
00C5D0  2                         iny
00C5D0  2                         inx                      ;if still on first six leaves, continue
00C5D0  2                         cpx #$06                 ;using the first sprite data offset
00C5D0  2                         bne DLLoop               ;otherwise use the next one instead
00C5D0  2                         ldy Alt_SprDataOffset    ;note the next one is also used by blocks
00C5D0  2               DLLoop:   cpx #$0c                 ;continue until done putting all leaves on the screen
00C5D0  2                         bne DrawLeaf
00C5D0  2               ExSimW:   rts
00C5D0  2               
00C5D0  2               LeavesPosAdder:
00C5D0  2                  .byte $57, $57, $56, $56, $58, $58, $56, $56, $57, $58, $57, $58
00C5D0  2                  .byte $59, $59, $58, $58, $5a, $5a, $58, $58, $59, $5a, $59, $5a
00C5D0  2               
00C5D0  2               ModifyLeavesPos:
00C5D0  2                        ldx #$0b
00C5D0  2               MLPLoop: lda LeavesXPos,x      ;add each adder to each X position twice
00C5D0  2                        clc                   ;and to each Y position once
00C5D0  2                        adc LeavesPosAdder,x
00C5D0  2                        adc LeavesPosAdder,x
00C5D0  2                        sta LeavesXPos,x
00C5D0  2                        lda LeavesYPos,x
00C5D0  2                        clc
00C5D0  2                        adc LeavesPosAdder,x
00C5D0  2                        sta LeavesYPos,x
00C5D0  2                        dex
00C5D0  2                        bpl MLPLoop
00C5D0  2                        rts
00C5D0  2               
00C5D0  2               WindOn:
00C5D0  2                    lda #$01         ;branch to turn the wind on
00C5D0  2                    bne WOn
00C5D0  2               WindOff:
00C5D0  2                    lda #$00         ;turn the wind off
00C5D0  2               WOn: sta WindFlag
00C5D0  2                    rts
00C5D0  2               
00C5D0  2               ;some unused bytes
00C5D0  2                  .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00C5D0  2               
00C5D0  2               ;-------------------------------------------------------------------------------------
00C5D0  2               .endif
00C5D0  2               
00C5D0  2               .ifdef ANN
00C5D0  2               
00C5D0  2               E_Area06:
00C5D0  2  49 9F 67 03  .byte $49,$9F,$67,$03,$79,$9D,$A0,$3A,$57,$9F,$BB,$1D,$D5,$25,$0F,$05
00C5D4  2  79 9D A0 3A  
00C5D8  2  57 9F BB 1D  
00C5E0  2  18 1D 74 00  .byte $18,$1D,$74,$00,$84,$00,$94,$00,$C6,$29,$49,$9D,$DB,$05,$0F,$08
00C5E4  2  84 00 94 00  
00C5E8  2  C6 29 49 9D  
00C5F0  2  05 1B 09 1D  .byte $05,$1B,$09,$1D,$B0,$38,$80,$95,$C0,$3C,$EC,$A8,$CC,$8C,$4A,$9B
00C5F4  2  B0 38 80 95  
00C5F8  2  C0 3C EC A8  
00C600  2  78 2D 90 B5  .byte $78,$2D,$90,$B5,$FF
00C604  2  FF           
00C605  2               
00C605  2               E_Area07:
00C605  2  74 80 F0 38  .byte $74,$80,$F0,$38,$A0,$BB,$40,$BC,$8C,$1D,$C9,$9D,$05,$9B,$1C,$0C
00C609  2  A0 BB 40 BC  
00C60D  2  8C 1D C9 9D  
00C615  2  59 1B B5 1D  .byte $59,$1B,$B5,$1D,$2C,$8C,$40,$15,$7C,$1B,$DC,$1D,$6C,$8C,$BC,$0C
00C619  2  2C 8C 40 15  
00C61D  2  7C 1B DC 1D  
00C625  2  78 AD A5 28  .byte $78,$AD,$A5,$28,$90,$B5,$FF
00C629  2  90 B5 FF     
00C62C  2               
00C62C  2               E_Area04:
00C62C  2  27 A9 4B 0C  .byte $27,$A9,$4B,$0C,$68,$29,$0F,$06,$77,$1B,$0F,$0B,$60,$15,$4B,$8C
00C630  2  68 29 0F 06  
00C634  2  77 1B 0F 0B  
00C63C  2  78 2D 90 B5  .byte $78,$2D,$90,$B5,$FF
00C640  2  FF           
00C641  2               
00C641  2               E_Area05:
00C641  2  19 9B 99 1B  .byte $19,$9B,$99,$1B,$2C,$8C,$59,$1B,$C5,$0F,$0E,$82,$E0,$0F,$06,$2E
00C645  2  2C 8C 59 1B  
00C649  2  C5 0F 0E 82  
00C651  2  65 E7 0F 08  .byte $65,$E7,$0F,$08,$9B,$07,$0E,$82,$E0,$39,$0E,$87,$10,$BD,$28,$59
00C655  2  9B 07 0E 82  
00C659  2  E0 39 0E 87  
00C661  2  9F 0F 0F 34  .byte $9F,$0F,$0F,$34,$0F,$77,$10,$9E,$65,$F1,$0F,$12,$0E,$65,$E3,$78
00C665  2  0F 77 10 9E  
00C669  2  65 F1 0F 12  
00C671  2  2D 0F 15 3B  .byte $2D,$0F,$15,$3B,$29,$57,$82,$0F,$18,$55,$1D,$78,$2D,$90,$B5,$FF
00C675  2  29 57 82 0F  
00C679  2  18 55 1D 78  
00C681  2               
00C681  2               E_Area09:
00C681  2  EB 8E 0F 03  .byte $EB,$8E,$0F,$03,$FB,$05,$17,$85,$DB,$8E,$0F,$07,$57,$05,$7B,$05
00C685  2  FB 05 17 85  
00C689  2  DB 8E 0F 07  
00C691  2  9B 80 2B 85  .byte $9B,$80,$2B,$85,$FB,$05,$0F,$0B,$1B,$05,$9B,$05,$FF
00C695  2  FB 05 0F 0B  
00C699  2  1B 05 9B 05  
00C69E  2               
00C69E  2               E_Area0B:
00C69E  2  0E C3 A6 AB  .byte $0E,$C3,$A6,$AB,$00,$BB,$8E,$6B,$82,$DE,$00,$A0,$33,$86,$43,$06
00C6A2  2  00 BB 8E 6B  
00C6A6  2  82 DE 00 A0  
00C6AE  2  3E BA A0 CB  .byte $3E,$BA,$A0,$CB,$02,$0F,$07,$7E,$43,$A4,$83,$02,$0F,$0A,$3B,$02
00C6B2  2  02 0F 07 7E  
00C6B6  2  43 A4 83 02  
00C6BE  2  CB 37 0F 0C  .byte $CB,$37,$0F,$0C,$E3,$0E,$FF
00C6C2  2  E3 0E FF     
00C6C5  2               
00C6C5  2               E_Area1E:
00C6C5  2  E6 A9 57 A8  .byte $E6,$A9,$57,$A8,$B5,$24,$19,$A4,$76,$28,$A2,$0F,$95,$8F,$9D,$A8
00C6C9  2  B5 24 19 A4  
00C6CD  2  76 28 A2 0F  
00C6D5  2  0F 07 09 29  .byte $0F,$07,$09,$29,$55,$24,$8B,$17,$A9,$24,$DB,$83,$04,$A9,$24,$8F
00C6D9  2  55 24 8B 17  
00C6DD  2  A9 24 DB 83  
00C6E5  2  65 0F FF     .byte $65,$0F,$FF
00C6E8  2               
00C6E8  2               E_Area1F:
00C6E8  2  0F 02 28 10  .byte $0F,$02,$28,$10,$E6,$03,$D8,$90,$0F,$05,$85,$0F,$78,$83,$C8,$10
00C6EC  2  E6 03 D8 90  
00C6F0  2  0F 05 85 0F  
00C6F8  2  18 83 58 83  .byte $18,$83,$58,$83,$F7,$90,$0F,$0C,$43,$0F,$73,$8F,$FF
00C6FC  2  F7 90 0F 0C  
00C700  2  43 0F 73 8F  
00C705  2               
00C705  2               E_Area12:
00C705  2  0B 80 60 38  .byte $0B,$80,$60,$38,$10,$B8,$C0,$3B,$DB,$8E,$40,$B8,$F0,$38,$7B,$8E
00C709  2  10 B8 C0 3B  
00C70D  2  DB 8E 40 B8  
00C715  2  A0 B8 C0 B8  .byte $A0,$B8,$C0,$B8,$FB,$00,$A0,$B8,$30,$BB,$EE,$43,$86,$0F,$0B,$2B
00C719  2  FB 00 A0 B8  
00C71D  2  30 BB EE 43  
00C725  2  0E 67 0E FF  .byte $0E,$67,$0E,$FF
00C729  2               
00C729  2               E_Area21:
00C729  2  0A AA 0E 31  .byte $0A,$AA,$0E,$31,$88,$FF
00C72D  2  88 FF        
00C72F  2               
00C72F  2               E_Area15:
00C72F  2  CD A5 B5 A8  .byte $CD,$A5,$B5,$A8,$07,$A8,$76,$28,$CC,$25,$65,$A4,$A9,$24,$E5,$24
00C733  2  07 A8 76 28  
00C737  2  CC 25 65 A4  
00C73F  2  19 A4 64 8F  .byte $19,$A4,$64,$8F,$95,$A8,$E6,$24,$19,$A4,$D7,$29,$16,$A9,$58,$29
00C743  2  95 A8 E6 24  
00C747  2  19 A4 D7 29  
00C74F  2  97 29 FF     .byte $97,$29,$FF
00C752  2               
00C752  2               E_Area16:
00C752  2  0F 02 02 11  .byte $0F,$02,$02,$11,$0F,$07,$02,$11,$FF
00C756  2  0F 07 02 11  
00C75A  2  FF           
00C75B  2               
00C75B  2               E_Area18:
00C75B  2  2B 82 AB 38  .byte $2B,$82,$AB,$38,$DE,$43,$E2,$1B,$B8,$EB,$3B,$DB,$80,$8B,$B8,$1B
00C75F  2  DE 43 E2 1B  
00C763  2  B8 EB 3B DB  
00C76B  2  82 FB B8 7B  .byte $82,$FB,$B8,$7B,$80,$FB,$3C,$5B,$BC,$7B,$B8,$1B,$8E,$CB,$0E,$1B
00C76F  2  80 FB 3C 5B  
00C773  2  BC 7B B8 1B  
00C77B  2  8E 0F 0D 2B  .byte $8E,$0F,$0D,$2B,$3B,$BB,$B8,$EB,$82,$4B,$B8,$BB,$38,$3B,$B7,$BB
00C77F  2  3B BB B8 EB  
00C783  2  82 4B B8 BB  
00C78B  2  02 0F 13 1B  .byte $02,$0F,$13,$1B,$00,$CB,$80,$6B,$BC,$FF
00C78F  2  00 CB 80 6B  
00C793  2  BC FF        
00C795  2               
00C795  2               E_Area19:
00C795  2  7B 80 AE 00  .byte $7B,$80,$AE,$00,$80,$8B,$8E,$E8,$05,$F9,$86,$17,$86,$16,$85,$4E
00C799  2  80 8B 8E E8  
00C79D  2  05 F9 86 17  
00C7A5  2  39 80 AB 8E  .byte $39,$80,$AB,$8E,$87,$85,$C3,$05,$8B,$82,$9B,$02,$AB,$02,$BB,$86
00C7A9  2  87 85 C3 05  
00C7AD  2  8B 82 9B 02  
00C7B5  2  CB 06 D3 03  .byte $CB,$06,$D3,$03,$3B,$8E,$6B,$0E,$A7,$8E,$FF
00C7B9  2  3B 8E 6B 0E  
00C7BD  2  A7 8E FF     
00C7C0  2               
00C7C0  2               E_Area1A:
00C7C0  2  29 8E 52 11  .byte $29,$8E,$52,$11,$83,$0E,$0F,$03,$3B,$0E,$9B,$0E,$2B,$8E,$5B,$0E
00C7C4  2  83 0E 0F 03  
00C7C8  2  3B 0E 9B 0E  
00C7D0  2  CB 8E FB 0E  .byte $CB,$8E,$FB,$0E,$FB,$82,$9B,$82,$BB,$02,$FE,$43,$E6,$BB,$8E,$0F
00C7D4  2  FB 82 9B 82  
00C7D8  2  BB 02 FE 43  
00C7E0  2  0A AB 0E CB  .byte $0A,$AB,$0E,$CB,$0E,$F9,$0E,$88,$86,$A6,$06,$DB,$02,$B6,$8E,$FF
00C7E4  2  0E F9 0E 88  
00C7E8  2  86 A6 06 DB  
00C7F0  2               
00C7F0  2               E_Area1B:
00C7F0  2  AB CE DE 43  .byte $AB,$CE,$DE,$43,$C0,$CB,$CE,$5B,$8E,$1B,$CE,$4B,$85,$67,$45,$0F
00C7F4  2  C0 CB CE 5B  
00C7F8  2  8E 1B CE 4B  
00C800  2  07 2B 00 7B  .byte $07,$2B,$00,$7B,$85,$97,$05,$0F,$0A,$92,$02,$FF
00C804  2  85 97 05 0F  
00C808  2  0A 92 02 FF  
00C80C  2               
00C80C  2               E_Area22:
00C80C  2  0A AA 1E 23  .byte $0A,$AA,$1E,$23,$AA,$FF
00C810  2  AA FF        
00C812  2               
00C812  2               E_Area27:
00C812  2  1E B3 C7 0F  .byte $1E,$B3,$C7,$0F,$03,$1E,$30,$E7,$0F,$05,$1E,$23,$AB,$0F,$07,$1E
00C816  2  03 1E 30 E7  
00C81A  2  0F 05 1E 23  
00C822  2  2A 8A 2E 23  .byte $2A,$8A,$2E,$23,$A2,$2E,$32,$EA,$FF
00C826  2  A2 2E 32 EA  
00C82A  2  FF           
00C82B  2               
00C82B  2               E_Area28:
00C82B  2  3B 87 66 27  .byte $3B,$87,$66,$27,$CC,$27,$EE,$31,$87,$EE,$23,$A7,$3B,$87,$DB,$07
00C82F  2  CC 27 EE 31  
00C833  2  87 EE 23 A7  
00C83B  2  FF           .byte $FF
00C83C  2               
00C83C  2               E_Area2B:
00C83C  2  2E B8 C1 5B  .byte $2E,$B8,$C1,$5B,$07,$AB,$07,$69,$87,$BA,$07,$FB,$87,$65,$A7,$6A
00C840  2  07 AB 07 69  
00C844  2  87 BA 07 FB  
00C84C  2  27 A6 A7 AC  .byte $27,$A6,$A7,$AC,$27,$1B,$87,$88,$07,$2B,$83,$7B,$07,$A7,$90,$E5
00C850  2  27 1B 87 88  
00C854  2  07 2B 83 7B  
00C85C  2  83 14 A7 19  .byte $83,$14,$A7,$19,$27,$77,$07,$F8,$07,$47,$8F,$B9,$07,$FF
00C860  2  27 77 07 F8  
00C864  2  07 47 8F B9  
00C86A  2               
00C86A  2               E_Area2A:
00C86A  2  07 9B 0A 07  .byte $07,$9B,$0A,$07,$B9,$1B,$66,$9B,$78,$07,$AE,$65,$E5,$FF
00C86E  2  B9 1B 66 9B  
00C872  2  78 07 AE 65  
00C878  2               
00C878  2               L_Area06:
00C878  2  9B 07 05 32  .byte $9B,$07,$05,$32,$06,$33,$07,$34,$4E,$03,$5C,$02,$0C,$F1,$27,$00
00C87C  2  06 33 07 34  
00C880  2  4E 03 5C 02  
00C888  2  3C 74 47 0B  .byte $3C,$74,$47,$0B,$FC,$00,$FE,$0B,$77,$8B,$EE,$09,$FE,$0A,$45,$B2
00C88C  2  FC 00 FE 0B  
00C890  2  77 8B EE 09  
00C898  2  55 0B 99 32  .byte $55,$0B,$99,$32,$B9,$0B,$FE,$02,$0E,$85,$FE,$02,$16,$8B,$2E,$0C
00C89C  2  B9 0B FE 02  
00C8A0  2  0E 85 FE 02  
00C8A8  2  AE 0A EE 05  .byte $AE,$0A,$EE,$05,$1E,$82,$47,$0B,$07,$BD,$C4,$72,$DE,$0A,$FE,$02
00C8AC  2  1E 82 47 0B  
00C8B0  2  07 BD C4 72  
00C8B8  2  03 8B 07 0B  .byte $03,$8B,$07,$0B,$13,$3C,$17,$3D,$E3,$02,$EE,$0A,$F3,$04,$F7,$02
00C8BC  2  13 3C 17 3D  
00C8C0  2  E3 02 EE 0A  
00C8C8  2  FE 0E FE 8A  .byte $FE,$0E,$FE,$8A,$38,$E4,$4A,$72,$68,$64,$37,$B0,$98,$64,$A8,$64
00C8CC  2  38 E4 4A 72  
00C8D0  2  68 64 37 B0  
00C8D8  2  E8 64 F8 64  .byte $E8,$64,$F8,$64,$0D,$C4,$71,$64,$CD,$43,$CE,$09,$DD,$42,$DE,$0B
00C8DC  2  0D C4 71 64  
00C8E0  2  CD 43 CE 09  
00C8E8  2  FE 02 5D C7  .byte $FE,$02,$5D,$C7,$FD
00C8EC  2  FD           
00C8ED  2               
00C8ED  2               L_Area07:
00C8ED  2  9B 87 05 32  .byte $9B,$87,$05,$32,$06,$33,$07,$34,$03,$E2,$0E,$06,$1E,$0C,$7E,$0A
00C8F1  2  06 33 07 34  
00C8F5  2  03 E2 0E 06  
00C8FD  2  8E 05 8E 82  .byte $8E,$05,$8E,$82,$8A,$8B,$8E,$0A,$EE,$02,$0A,$E0,$19,$61,$23,$04
00C901  2  8A 8B 8E 0A  
00C905  2  EE 02 0A E0  
00C90D  2  28 62 2E 0B  .byte $28,$62,$2E,$0B,$7E,$0A,$81,$62,$87,$30,$8E,$04,$A7,$31,$C7,$0B
00C911  2  7E 0A 81 62  
00C915  2  87 30 8E 04  
00C91D  2  D7 33 FE 03  .byte $D7,$33,$FE,$03,$03,$8B,$0E,$0A,$11,$62,$1E,$04,$27,$32,$4E,$0A
00C921  2  03 8B 0E 0A  
00C925  2  11 62 1E 04  
00C92D  2  51 62 57 0B  .byte $51,$62,$57,$0B,$5E,$04,$67,$34,$9E,$0A,$A1,$62,$AE,$03,$B3,$0B
00C931  2  5E 04 67 34  
00C935  2  9E 0A A1 62  
00C93D  2  BE 0B EE 09  .byte $BE,$0B,$EE,$09,$FE,$0A,$2E,$82,$7A,$0B,$7E,$0A,$97,$31,$A6,$10
00C941  2  FE 0A 2E 82  
00C945  2  7A 0B 7E 0A  
00C94D  2  BE 04 DA 0B  .byte $BE,$04,$DA,$0B,$EE,$0A,$F1,$62,$FE,$02,$3E,$8A,$7E,$06,$AE,$0A
00C951  2  EE 0A F1 62  
00C955  2  FE 02 3E 8A  
00C95D  2  CE 06 FE 0A  .byte $CE,$06,$FE,$0A,$0D,$C4,$11,$53,$21,$52,$24,$08,$51,$52,$61,$52
00C961  2  0D C4 11 53  
00C965  2  21 52 24 08  
00C96D  2  CD 43 CE 09  .byte $CD,$43,$CE,$09,$DD,$42,$DE,$0B,$FE,$02,$5D,$C7,$FD
00C971  2  DD 42 DE 0B  
00C975  2  FE 02 5D C7  
00C97A  2               
00C97A  2               L_Area04:
00C97A  2  5B 07 05 32  .byte $5B,$07,$05,$32,$06,$33,$07,$34,$FE,$0A,$AE,$86,$BE,$07,$FE,$02
00C97E  2  06 33 07 34  
00C982  2  FE 0A AE 86  
00C98A  2  0D 02 27 32  .byte $0D,$02,$27,$32,$46,$61,$55,$62,$5E,$0E,$1E,$82,$68,$3C,$74,$3A
00C98E  2  46 61 55 62  
00C992  2  5E 0E 1E 82  
00C99A  2  7D 4B 5E 8E  .byte $7D,$4B,$5E,$8E,$7D,$4B,$7E,$82,$84,$62,$94,$61,$A4,$31,$BD,$4B
00C99E  2  7D 4B 7E 82  
00C9A2  2  84 62 94 61  
00C9AA  2  CE 06 FE 02  .byte $CE,$06,$FE,$02,$0D,$06,$34,$31,$3E,$0A,$64,$32,$75,$0B,$7B,$61
00C9AE  2  0D 06 34 31  
00C9B2  2  3E 0A 64 32  
00C9BA  2  A4 33 AE 02  .byte $A4,$33,$AE,$02,$DE,$0E,$3E,$82,$64,$32,$78,$32,$B4,$36,$C8,$36
00C9BE  2  DE 0E 3E 82  
00C9C2  2  64 32 78 32  
00C9CA  2  DD 4B 44 B2  .byte $DD,$4B,$44,$B2,$58,$32,$94,$63,$A4,$3E,$BA,$30,$C9,$61,$CE,$06
00C9CE  2  58 32 94 63  
00C9D2  2  A4 3E BA 30  
00C9DA  2  DD 4B CE 86  .byte $DD,$4B,$CE,$86,$DD,$4B,$FE,$0A,$2E,$86,$5E,$0A,$7E,$06,$FE,$02
00C9DE  2  DD 4B FE 0A  
00C9E2  2  2E 86 5E 0A  
00C9EA  2  1E 86 3E 0A  .byte $1E,$86,$3E,$0A,$5E,$06,$7E,$02,$9E,$06,$FE,$0A,$0D,$C4,$CD,$43
00C9EE  2  5E 06 7E 02  
00C9F2  2  9E 06 FE 0A  
00C9FA  2  CE 09 DE 0B  .byte $CE,$09,$DE,$0B,$DD,$42,$FE,$02,$5D,$C7,$FD
00C9FE  2  DD 42 FE 02  
00CA02  2  5D C7 FD     
00CA05  2               
00CA05  2               L_Area05:
00CA05  2  5B 03 05 34  .byte $5B,$03,$05,$34,$06,$35,$07,$36,$6E,$0A,$EE,$02,$FE,$05,$0D,$01
00CA09  2  06 35 07 36  
00CA0D  2  6E 0A EE 02  
00CA15  2  17 0B 97 0B  .byte $17,$0B,$97,$0B,$9E,$02,$C6,$04,$FA,$30,$FE,$0A,$4E,$82,$57,$0B
00CA19  2  9E 02 C6 04  
00CA1D  2  FA 30 FE 0A  
00CA25  2  58 62 68 62  .byte $58,$62,$68,$62,$79,$61,$8A,$60,$8E,$0A,$F5,$31,$F9,$7B,$39,$F3
00CA29  2  79 61 8A 60  
00CA2D  2  8E 0A F5 31  
00CA35  2  97 33 B5 71  .byte $97,$33,$B5,$71,$39,$F3,$4D,$48,$9E,$02,$AE,$05,$CD,$4A,$ED,$4B
00CA39  2  39 F3 4D 48  
00CA3D  2  9E 02 AE 05  
00CA45  2  0E 81 17 04  .byte $0E,$81,$17,$04,$39,$73,$5C,$02,$85,$65,$95,$32,$A9,$7B,$CC,$03
00CA49  2  39 73 5C 02  
00CA4D  2  85 65 95 32  
00CA55  2  5E 8F 6D 47  .byte $5E,$8F,$6D,$47,$FE,$02,$0D,$07,$39,$73,$4E,$0A,$AE,$02,$E7,$23
00CA59  2  FE 02 0D 07  
00CA5D  2  39 73 4E 0A  
00CA65  2  07 88 39 73  .byte $07,$88,$39,$73,$E6,$04,$39,$FB,$4E,$0A,$C4,$31,$EB,$61,$FE,$02
00CA69  2  E6 04 39 FB  
00CA6D  2  4E 0A C4 31  
00CA75  2  07 B0 1E 0A  .byte $07,$B0,$1E,$0A,$4E,$06,$57,$0B,$BE,$02,$C9,$61,$DA,$60,$ED,$4B
00CA79  2  4E 06 57 0B  
00CA7D  2  BE 02 C9 61  
00CA85  2  0E 85 0D 0E  .byte $0E,$85,$0D,$0E,$FE,$0A,$78,$E4,$8E,$06,$BF,$47,$EE,$0F,$6D,$C7
00CA89  2  FE 0A 78 E4  
00CA8D  2  8E 06 BF 47  
00CA95  2  0E 82 39 73  .byte $0E,$82,$39,$73,$9A,$60,$A9,$61,$AE,$06,$DE,$0A,$E7,$02,$EB,$79
00CA99  2  9A 60 A9 61  
00CA9D  2  AE 06 DE 0A  
00CAA5  2  F7 02 FE 06  .byte $F7,$02,$FE,$06,$0D,$14,$FE,$0A,$5E,$82,$78,$74,$9E,$0A,$F8,$64
00CAA9  2  0D 14 FE 0A  
00CAAD  2  5E 82 78 74  
00CAB5  2  FE 0B 9E 84  .byte $FE,$0B,$9E,$84,$BE,$05,$BE,$82,$DA,$60,$E9,$61,$F8,$62,$FE,$0A
00CAB9  2  BE 05 BE 82  
00CABD  2  DA 60 E9 61  
00CAC5  2  0D C4 11 64  .byte $0D,$C4,$11,$64,$51,$62,$CD,$43,$CE,$09,$DD,$42,$DE,$0B,$FE,$02
00CAC9  2  51 62 CD 43  
00CACD  2  CE 09 DD 42  
00CAD5  2  5D C7 FD     .byte $5D,$C7,$FD
00CAD8  2               
00CAD8  2               L_Area09:
00CAD8  2  90 B1 0F 26  .byte $90,$B1,$0F,$26,$29,$91,$7E,$42,$FE,$40,$28,$92,$4E,$42,$2E,$C0
00CADC  2  29 91 7E 42  
00CAE0  2  FE 40 28 92  
00CAE8  2  57 73 C3 27  .byte $57,$73,$C3,$27,$C7,$27,$D3,$05,$5C,$81,$77,$63,$88,$62,$99,$61
00CAEC  2  C7 27 D3 05  
00CAF0  2  5C 81 77 63  
00CAF8  2  AA 60 BC 01  .byte $AA,$60,$BC,$01,$EE,$42,$4E,$C0,$69,$11,$7E,$42,$DE,$40,$F8,$62
00CAFC  2  EE 42 4E C0  
00CB00  2  69 11 7E 42  
00CB08  2  0E C2 AE 40  .byte $0E,$C2,$AE,$40,$D7,$63,$E7,$63,$33,$A5,$37,$27,$82,$42,$93,$05
00CB0C  2  D7 63 E7 63  
00CB10  2  33 A5 37 27  
00CB18  2  A3 20 CC 01  .byte $A3,$20,$CC,$01,$E7,$73,$0C,$81,$3E,$42,$0D,$0A,$5E,$40,$88,$72
00CB1C  2  E7 73 0C 81  
00CB20  2  3E 42 0D 0A  
00CB28  2  BE 42 E7 88  .byte $BE,$42,$E7,$88,$FE,$40,$39,$E1,$4E,$00,$69,$60,$87,$60,$A5,$60
00CB2C  2  FE 40 39 E1  
00CB30  2  4E 00 69 60  
00CB38  2  C3 31 FE 31  .byte $C3,$31,$FE,$31,$6D,$C1,$BE,$42,$EF,$20,$8D,$C7,$FD
00CB3C  2  6D C1 BE 42  
00CB40  2  EF 20 8D C7  
00CB45  2               
00CB45  2               L_Area0B:
00CB45  2  54 21 0F 26  .byte $54,$21,$0F,$26,$A7,$22,$37,$FB,$73,$05,$83,$08,$87,$02,$93,$20
00CB49  2  A7 22 37 FB  
00CB4D  2  73 05 83 08  
00CB55  2  C7 73 04 F1  .byte $C7,$73,$04,$F1,$06,$31,$39,$71,$59,$71,$E7,$73,$37,$A0,$47,$08
00CB59  2  06 31 39 71  
00CB5D  2  59 71 E7 73  
00CB65  2  86 7C E5 71  .byte $86,$7C,$E5,$71,$E7,$31,$33,$A4,$39,$71,$A9,$71,$D3,$23,$08,$F2
00CB69  2  E7 31 33 A4  
00CB6D  2  39 71 A9 71  
00CB75  2  13 06 27 02  .byte $13,$06,$27,$02,$49,$71,$75,$75,$E8,$72,$67,$F3,$99,$71,$E7,$20
00CB79  2  49 71 75 75  
00CB7D  2  E8 72 67 F3  
00CB85  2  F4 72 F7 31  .byte $F4,$72,$F7,$31,$17,$A0,$33,$20,$39,$71,$73,$28,$BC,$05,$39,$F1
00CB89  2  17 A0 33 20  
00CB8D  2  39 71 73 28  
00CB95  2  79 71 A6 21  .byte $79,$71,$A6,$21,$C3,$21,$DC,$00,$FC,$00,$07,$A2,$13,$20,$23,$07
00CB99  2  C3 21 DC 00  
00CB9D  2  FC 00 07 A2  
00CBA5  2  5F 32 8C 00  .byte $5F,$32,$8C,$00,$98,$7A,$C7,$63,$D9,$61,$03,$A2,$07,$22,$74,$72
00CBA9  2  98 7A C7 63  
00CBAD  2  D9 61 03 A2  
00CBB5  2  77 31 E7 73  .byte $77,$31,$E7,$73,$39,$F1,$58,$72,$77,$73,$D8,$72,$7F,$B1,$97,$73
00CBB9  2  39 F1 58 72  
00CBBD  2  77 73 D8 72  
00CBC5  2  B6 64 C5 65  .byte $B6,$64,$C5,$65,$D4,$66,$E3,$67,$F3,$67,$8D,$C1,$CF,$26,$AD,$C7
00CBC9  2  D4 66 E3 67  
00CBCD  2  F3 67 8D C1  
00CBD5  2  FD           .byte $FD
00CBD6  2               
00CBD6  2               L_Area1E:
00CBD6  2  50 11 0F 26  .byte $50,$11,$0F,$26,$FE,$10,$8B,$93,$A9,$0C,$14,$C1,$CC,$16,$CF,$11
00CBDA  2  FE 10 8B 93  
00CBDE  2  A9 0C 14 C1  
00CBE6  2  2F 95 B7 14  .byte $2F,$95,$B7,$14,$C7,$96,$D6,$44,$2B,$92,$39,$0C,$72,$41,$A7,$00
00CBEA  2  C7 96 D6 44  
00CBEE  2  2B 92 39 0C  
00CBF6  2  1B 95 97 13  .byte $1B,$95,$97,$13,$6C,$95,$6F,$11,$A2,$40,$BF,$15,$C2,$40,$0B,$9F
00CBFA  2  6C 95 6F 11  
00CBFE  2  A2 40 BF 15  
00CC06  2  53 16 62 44  .byte $53,$16,$62,$44,$72,$C2,$9B,$1D,$B7,$E0,$ED,$4A,$03,$E0,$8E,$11
00CC0A  2  72 C2 9B 1D  
00CC0E  2  B7 E0 ED 4A  
00CC16  2  9D 41 BE 42  .byte $9D,$41,$BE,$42,$EF,$20,$CD,$C7,$FD
00CC1A  2  EF 20 CD C7  
00CC1E  2  FD           
00CC1F  2               
00CC1F  2               L_Area1F:
00CC1F  2  50 11 0F 26  .byte $50,$11,$0F,$26,$AF,$32,$D8,$62,$DE,$10,$08,$E4,$5A,$62,$6C,$4C
00CC23  2  AF 32 D8 62  
00CC27  2  DE 10 08 E4  
00CC2F  2  86 43 AD 48  .byte $86,$43,$AD,$48,$3A,$E2,$53,$42,$88,$64,$9C,$36,$08,$E4,$4A,$62
00CC33  2  3A E2 53 42  
00CC37  2  88 64 9C 36  
00CC3F  2  5C 4D 3A E2  .byte $5C,$4D,$3A,$E2,$9C,$32,$FC,$41,$3C,$B1,$83,$00,$AC,$42,$2A,$E2
00CC43  2  9C 32 FC 41  
00CC47  2  3C B1 83 00  
00CC4F  2  3C 46 AA 62  .byte $3C,$46,$AA,$62,$BC,$4E,$C6,$43,$46,$C3,$AA,$62,$BD,$48,$0B,$96
00CC53  2  BC 4E C6 43  
00CC57  2  46 C3 AA 62  
00CC5F  2  47 05 C7 12  .byte $47,$05,$C7,$12,$3C,$C2,$9C,$41,$CD,$48,$DC,$32,$4C,$C2,$BC,$32
00CC63  2  3C C2 9C 41  
00CC67  2  CD 48 DC 32  
00CC6F  2  1C B1 5A 62  .byte $1C,$B1,$5A,$62,$6C,$44,$76,$43,$BA,$62,$DC,$32,$5D,$CA,$73,$12
00CC73  2  6C 44 76 43  
00CC77  2  BA 62 DC 32  
00CC7F  2  E3 12 8E 91  .byte $E3,$12,$8E,$91,$9D,$41,$BE,$42,$EF,$20,$CD,$C7,$FD
00CC83  2  9D 41 BE 42  
00CC87  2  EF 20 CD C7  
00CC8C  2               
00CC8C  2               L_Area12:
00CC8C  2  95 B1 0F 26  .byte $95,$B1,$0F,$26,$0D,$02,$C8,$72,$1C,$81,$38,$72,$0D,$05,$97,$34
00CC90  2  0D 02 C8 72  
00CC94  2  1C 81 38 72  
00CC9C  2  98 62 A3 20  .byte $98,$62,$A3,$20,$B3,$07,$C3,$20,$CC,$03,$F9,$91,$2C,$81,$48,$62
00CCA0  2  B3 07 C3 20  
00CCA4  2  CC 03 F9 91  
00CCAC  2  0D 09 37 63  .byte $0D,$09,$37,$63,$47,$03,$57,$02,$8C,$02,$C5,$79,$C7,$31,$F9,$11
00CCB0  2  47 03 57 02  
00CCB4  2  8C 02 C5 79  
00CCBC  2  39 F1 A9 11  .byte $39,$F1,$A9,$11,$6F,$B4,$D3,$65,$E3,$65,$7D,$C1,$BF,$26,$9D,$C7
00CCC0  2  6F B4 D3 65  
00CCC4  2  E3 65 7D C1  
00CCCC  2  FD           .byte $FD
00CCCD  2               
00CCCD  2               L_Area21:
00CCCD  2  00 C1 4C 00  .byte $00,$C1,$4C,$00,$F4,$4F,$0D,$02,$02,$42,$43,$4F,$52,$C2,$DE,$00
00CCD1  2  F4 4F 0D 02  
00CCD5  2  02 42 43 4F  
00CCDD  2  5A C2 4D C7  .byte $5A,$C2,$4D,$C7,$FD
00CCE1  2  FD           
00CCE2  2               
00CCE2  2               L_Area15:
00CCE2  2  97 11 0F 26  .byte $97,$11,$0F,$26,$FE,$10,$2B,$92,$57,$12,$8B,$12,$C0,$41,$F7,$13
00CCE6  2  FE 10 2B 92  
00CCEA  2  57 12 8B 12  
00CCF2  2  5B 92 69 0C  .byte $5B,$92,$69,$0C,$BB,$12,$B2,$46,$19,$93,$71,$00,$17,$94,$7C,$14
00CCF6  2  BB 12 B2 46  
00CCFA  2  19 93 71 00  
00CD02  2  7F 11 93 41  .byte $7F,$11,$93,$41,$BF,$15,$FC,$13,$FF,$11,$2F,$95,$50,$42,$51,$12
00CD06  2  BF 15 FC 13  
00CD0A  2  FF 11 2F 95  
00CD12  2  58 14 A6 12  .byte $58,$14,$A6,$12,$DB,$12,$1B,$93,$46,$43,$7B,$12,$8D,$49,$B7,$14
00CD16  2  DB 12 1B 93  
00CD1A  2  46 43 7B 12  
00CD22  2  1B 94 49 0C  .byte $1B,$94,$49,$0C,$BB,$12,$FC,$13,$FF,$12,$03,$C1,$2F,$15,$43,$12
00CD26  2  BB 12 FC 13  
00CD2A  2  FF 12 03 C1  
00CD32  2  4B 13 77 13  .byte $4B,$13,$77,$13,$9D,$4A,$15,$C1,$A1,$41,$C3,$12,$FE,$01,$7D,$C1
00CD36  2  9D 4A 15 C1  
00CD3A  2  A1 41 C3 12  
00CD42  2  9E 42 CF 20  .byte $9E,$42,$CF,$20,$9D,$C7,$FD
00CD46  2  9D C7 FD     
00CD49  2               
00CD49  2               L_Area16:
00CD49  2  52 21 0F 20  .byte $52,$21,$0F,$20,$6E,$44,$0C,$F1,$4C,$01,$AA,$35,$D9,$34,$EE,$20
00CD4D  2  6E 44 0C F1  
00CD51  2  4C 01 AA 35  
00CD59  2  08 B3 37 32  .byte $08,$B3,$37,$32,$43,$08,$4E,$21,$53,$20,$7C,$01,$97,$21,$B7,$05
00CD5D  2  43 08 4E 21  
00CD61  2  53 20 7C 01  
00CD69  2  9C 81 E7 42  .byte $9C,$81,$E7,$42,$5F,$B3,$97,$63,$AC,$02,$C5,$41,$49,$E0,$58,$61
00CD6D  2  5F B3 97 63  
00CD71  2  AC 02 C5 41  
00CD79  2  76 64 85 65  .byte $76,$64,$85,$65,$94,$66,$A4,$22,$A6,$03,$C8,$22,$DC,$02,$68,$F2
00CD7D  2  94 66 A4 22  
00CD81  2  A6 03 C8 22  
00CD89  2  96 42 13 82  .byte $96,$42,$13,$82,$17,$02,$AF,$34,$F6,$21,$FC,$06,$26,$80,$2A,$24
00CD8D  2  17 02 AF 34  
00CD91  2  F6 21 FC 06  
00CD99  2  36 01 8C 00  .byte $36,$01,$8C,$00,$FF,$35,$4E,$A0,$55,$21,$77,$20,$87,$08,$89,$22
00CD9D  2  FF 35 4E A0  
00CDA1  2  55 21 77 20  
00CDA9  2  AE 21 4C 82  .byte $AE,$21,$4C,$82,$9F,$34,$EC,$01,$03,$E7,$13,$67,$8D,$4A,$AD,$41
00CDAD  2  9F 34 EC 01  
00CDB1  2  03 E7 13 67  
00CDB9  2  0F A6 CD 47  .byte $0F,$A6,$CD,$47,$FD
00CDBD  2  FD           
00CDBE  2               
00CDBE  2               L_Area18:
00CDBE  2  92 31 0F 20  .byte $92,$31,$0F,$20,$6E,$40,$0D,$02,$37,$73,$EC,$00,$0C,$80,$3C,$00
00CDC2  2  6E 40 0D 02  
00CDC6  2  37 73 EC 00  
00CDCE  2  6C 00 9C 00  .byte $6C,$00,$9C,$00,$06,$C0,$C7,$73,$06,$84,$28,$72,$96,$40,$E7,$73
00CDD2  2  06 C0 C7 73  
00CDD6  2  06 84 28 72  
00CDDE  2  26 C0 87 7B  .byte $26,$C0,$87,$7B,$D2,$41,$39,$F1,$C8,$F2,$97,$E3,$A3,$23,$E7,$02
00CDE2  2  D2 41 39 F1  
00CDE6  2  C8 F2 97 E3  
00CDEE  2  E3 08 F3 22  .byte $E3,$08,$F3,$22,$37,$E3,$9C,$00,$BC,$00,$EC,$00,$0C,$80,$3C,$00
00CDF2  2  37 E3 9C 00  
00CDF6  2  BC 00 EC 00  
00CDFE  2  86 27 5C 80  .byte $86,$27,$5C,$80,$7C,$00,$9C,$00,$29,$E1,$DC,$05,$F6,$41,$DC,$80
00CE02  2  7C 00 9C 00  
00CE06  2  29 E1 DC 05  
00CE0E  2  E8 72 0C 81  .byte $E8,$72,$0C,$81,$27,$73,$4C,$01,$66,$74,$A6,$07,$0D,$11,$3F,$35
00CE12  2  27 73 4C 01  
00CE16  2  66 74 A6 07  
00CE1E  2  B6 41 2C 82  .byte $B6,$41,$2C,$82,$36,$40,$7C,$02,$86,$40,$F9,$61,$16,$83,$39,$61
00CE22  2  36 40 7C 02  
00CE26  2  86 40 F9 61  
00CE2E  2  AC 04 C6 41  .byte $AC,$04,$C6,$41,$0C,$83,$16,$41,$88,$F2,$39,$F1,$7C,$00,$89,$61
00CE32  2  0C 83 16 41  
00CE36  2  88 F2 39 F1  
00CE3E  2  9C 00 A7 63  .byte $9C,$00,$A7,$63,$BC,$00,$C5,$65,$DC,$00,$E3,$67,$F3,$67,$8D,$C1
00CE42  2  BC 00 C5 65  
00CE46  2  DC 00 E3 67  
00CE4E  2  CF 26 AD C7  .byte $CF,$26,$AD,$C7,$FD
00CE52  2  FD           
00CE53  2               
00CE53  2               L_Area19:
00CE53  2  55 B1 0F 26  .byte $55,$B1,$0F,$26,$CF,$33,$07,$B2,$15,$11,$52,$42,$99,$0C,$AC,$02
00CE57  2  CF 33 07 B2  
00CE5B  2  15 11 52 42  
00CE63  2  D3 24 D6 42  .byte $D3,$24,$D6,$42,$D7,$25,$23,$85,$CF,$33,$07,$E3,$19,$61,$78,$7A
00CE67  2  D7 25 23 85  
00CE6B  2  CF 33 07 E3  
00CE73  2  EF 33 2C 81  .byte $EF,$33,$2C,$81,$46,$64,$55,$65,$65,$65,$0C,$F4,$53,$05,$62,$41
00CE77  2  46 64 55 65  
00CE7B  2  65 65 0C F4  
00CE83  2  63 21 96 22  .byte $63,$21,$96,$22,$9A,$41,$CC,$03,$B9,$91,$C3,$06,$E6,$02,$39,$F1
00CE87  2  9A 41 CC 03  
00CE8B  2  B9 91 C3 06  
00CE93  2  63 26 67 27  .byte $63,$26,$67,$27,$D3,$07,$FC,$01,$18,$E2,$D9,$08,$E9,$05,$0C,$86
00CE97  2  D3 07 FC 01  
00CE9B  2  18 E2 D9 08  
00CEA3  2  37 22 93 24  .byte $37,$22,$93,$24,$87,$85,$AC,$02,$C2,$41,$C3,$23,$D9,$71,$FC,$01
00CEA7  2  87 85 AC 02  
00CEAB  2  C2 41 C3 23  
00CEB3  2  7F B1 9C 00  .byte $7F,$B1,$9C,$00,$A7,$63,$B6,$64,$CC,$00,$D4,$66,$E3,$67,$F3,$67
00CEB7  2  A7 63 B6 64  
00CEBB  2  CC 00 D4 66  
00CEC3  2  8D C1 CF 26  .byte $8D,$C1,$CF,$26,$AD,$C7,$FD
00CEC7  2  AD C7 FD     
00CECA  2               
00CECA  2               L_Area1A:
00CECA  2  50 B1 0F 26  .byte $50,$B1,$0F,$26,$FC,$00,$1F,$B3,$5C,$00,$65,$65,$74,$66,$83,$67
00CECE  2  FC 00 1F B3  
00CED2  2  5C 00 65 65  
00CEDA  2  93 67 DC 73  .byte $93,$67,$DC,$73,$4C,$80,$B3,$20,$C3,$09,$C9,$0C,$D3,$2F,$DC,$00
00CEDE  2  4C 80 B3 20  
00CEE2  2  C3 09 C9 0C  
00CEEA  2  2C 80 4C 00  .byte $2C,$80,$4C,$00,$8C,$00,$D3,$2E,$ED,$4A,$FC,$00,$93,$85,$97,$02
00CEEE  2  8C 00 D3 2E  
00CEF2  2  ED 4A FC 00  
00CEFA  2  EC 01 4C 80  .byte $EC,$01,$4C,$80,$59,$11,$D8,$11,$DA,$10,$37,$A0,$47,$08,$99,$11
00CEFE  2  59 11 D8 11  
00CF02  2  DA 10 37 A0  
00CF0A  2  E7 21 3A 90  .byte $E7,$21,$3A,$90,$67,$20,$76,$10,$77,$60,$87,$20,$D8,$12,$39,$F1
00CF0E  2  67 20 76 10  
00CF12  2  77 60 87 20  
00CF1A  2  AC 00 E9 71  .byte $AC,$00,$E9,$71,$0C,$80,$2C,$00,$4C,$05,$C7,$7B,$39,$F1,$EC,$00
00CF1E  2  0C 80 2C 00  
00CF22  2  4C 05 C7 7B  
00CF2A  2  F9 11 0C 82  .byte $F9,$11,$0C,$82,$6F,$34,$F8,$11,$FA,$10,$7F,$B2,$AC,$00,$B6,$64
00CF2E  2  6F 34 F8 11  
00CF32  2  FA 10 7F B2  
00CF3A  2  CC 01 E3 67  .byte $CC,$01,$E3,$67,$F3,$67,$8D,$C1,$CF,$26,$AD,$C7,$FD
00CF3E  2  F3 67 8D C1  
00CF42  2  CF 26 AD C7  
00CF47  2               
00CF47  2               L_Area1B:
00CF47  2  52 B1 0F 20  .byte $52,$B1,$0F,$20,$6E,$45,$39,$91,$B3,$08,$C3,$21,$C8,$11,$CA,$10
00CF4B  2  6E 45 39 91  
00CF4F  2  B3 08 C3 21  
00CF57  2  49 91 7C 71  .byte $49,$91,$7C,$71,$97,$00,$A7,$01,$E8,$12,$88,$91,$8A,$10,$E7,$20
00CF5B  2  97 00 A7 01  
00CF5F  2  E8 12 88 91  
00CF67  2  F7 08 05 91  .byte $F7,$08,$05,$91,$07,$30,$17,$21,$49,$11,$9C,$01,$C8,$72,$2C,$E6
00CF6B  2  07 30 17 21  
00CF6F  2  49 11 9C 01  
00CF77  2  2C 76 D3 03  .byte $2C,$76,$D3,$03,$D8,$7A,$89,$91,$D8,$72,$39,$F1,$A9,$11,$09,$F1
00CF7B  2  D8 7A 89 91  
00CF7F  2  D8 72 39 F1  
00CF87  2  33 26 37 27  .byte $33,$26,$37,$27,$A3,$08,$D8,$62,$28,$91,$2A,$10,$56,$21,$70,$05
00CF8B  2  A3 08 D8 62  
00CF8F  2  28 91 2A 10  
00CF97  2  79 0C 8C 00  .byte $79,$0C,$8C,$00,$94,$21,$9F,$35,$2F,$B8,$3D,$C1,$7F,$26,$5D,$C7
00CF9B  2  94 21 9F 35  
00CF9F  2  2F B8 3D C1  
00CFA7  2  FD           .byte $FD
00CFA8  2               
00CFA8  2               L_Area22:
00CFA8  2  06 C1 4C 00  .byte $06,$C1,$4C,$00,$F4,$4F,$0D,$02,$06,$20,$24,$4F,$35,$A0,$36,$20
00CFAC  2  F4 4F 0D 02  
00CFB0  2  06 20 24 4F  
00CFB8  2  53 46 D5 20  .byte $53,$46,$D5,$20,$D6,$20,$34,$A1,$73,$49,$74,$20,$94,$20,$B4,$20
00CFBC  2  D6 20 34 A1  
00CFC0  2  73 49 74 20  
00CFC8  2  D4 20 F4 20  .byte $D4,$20,$F4,$20,$2E,$80,$59,$42,$4D,$C7,$FD
00CFCC  2  2E 80 59 42  
00CFD0  2  4D C7 FD     
00CFD3  2               
00CFD3  2               L_Area27:
00CFD3  2  48 01 0E 01  .byte $48,$01,$0E,$01,$00,$5A,$3E,$06,$45,$46,$47,$46,$53,$44,$AE,$01
00CFD7  2  00 5A 3E 06  
00CFDB  2  45 46 47 46  
00CFE3  2  DF 4A 4D C7  .byte $DF,$4A,$4D,$C7,$0E,$81,$00,$5A,$2E,$04,$37,$28,$3A,$48,$46,$47
00CFE7  2  0E 81 00 5A  
00CFEB  2  2E 04 37 28  
00CFF3  2  C7 08 CE 0F  .byte $C7,$08,$CE,$0F,$DF,$4A,$4D,$C7,$0E,$81,$00,$5A,$2E,$02,$36,$47
00CFF7  2  DF 4A 4D C7  
00CFFB  2  0E 81 00 5A  
00D003  2  37 52 3A 49  .byte $37,$52,$3A,$49,$47,$25,$A7,$52,$D7,$05,$DF,$4A,$4D,$C7,$0E,$81
00D007  2  47 25 A7 52  
00D00B  2  D7 05 DF 4A  
00D013  2  00 5A 3E 02  .byte $00,$5A,$3E,$02,$44,$51,$53,$44,$54,$44,$55,$24,$A1,$54,$AE,$01
00D017  2  44 51 53 44  
00D01B  2  54 44 55 24  
00D023  2  B4 21 DF 4A  .byte $B4,$21,$DF,$4A,$E5,$08,$4D,$C7,$FD
00D027  2  E5 08 4D C7  
00D02B  2  FD           
00D02C  2               
00D02C  2               L_Area28:
00D02C  2  41 01 B4 34  .byte $41,$01,$B4,$34,$C8,$52,$F2,$51,$47,$D3,$6C,$03,$65,$49,$9E,$07
00D030  2  C8 52 F2 51  
00D034  2  47 D3 6C 03  
00D03C  2  BE 01 CC 03  .byte $BE,$01,$CC,$03,$FE,$07,$0D,$C9,$1E,$01,$6C,$01,$62,$35,$63,$53
00D040  2  FE 07 0D C9  
00D044  2  1E 01 6C 01  
00D04C  2  8A 41 AC 01  .byte $8A,$41,$AC,$01,$B3,$53,$E9,$51,$26,$C3,$27,$33,$63,$43,$64,$33
00D050  2  B3 53 E9 51  
00D054  2  26 C3 27 33  
00D05C  2  BA 60 C9 61  .byte $BA,$60,$C9,$61,$CE,$0B,$D4,$31,$E5,$0A,$EE,$0F,$7D,$CA,$7D,$47
00D060  2  CE 0B D4 31  
00D064  2  E5 0A EE 0F  
00D06C  2  FD           .byte $FD
00D06D  2               
00D06D  2               L_Area2B:
00D06D  2  41 01 27 D3  .byte $41,$01,$27,$D3,$79,$51,$C4,$56,$00,$E2,$03,$53,$0C,$0F,$12,$3B
00D071  2  79 51 C4 56  
00D075  2  00 E2 03 53  
00D07D  2  1A 42 43 54  .byte $1A,$42,$43,$54,$6D,$49,$83,$53,$99,$53,$C3,$54,$DA,$52,$0C,$84
00D081  2  6D 49 83 53  
00D085  2  99 53 C3 54  
00D08D  2  09 53 53 64  .byte $09,$53,$53,$64,$63,$31,$67,$34,$86,$41,$8C,$01,$A3,$30,$B3,$64
00D091  2  63 31 67 34  
00D095  2  86 41 8C 01  
00D09D  2  CC 03 D9 42  .byte $CC,$03,$D9,$42,$5C,$84,$A0,$62,$A8,$62,$B0,$62,$B8,$62,$C0,$62
00D0A1  2  5C 84 A0 62  
00D0A5  2  A8 62 B0 62  
00D0AD  2  C8 62 D0 62  .byte $C8,$62,$D0,$62,$D8,$62,$E0,$62,$E8,$62,$16,$C2,$58,$52,$8C,$04
00D0B1  2  D8 62 E0 62  
00D0B5  2  E8 62 16 C2  
00D0BD  2  A7 55 D0 63  .byte $A7,$55,$D0,$63,$D7,$65,$E2,$61,$E7,$65,$F2,$61,$F7,$65,$13,$B8
00D0C1  2  D7 65 E2 61  
00D0C5  2  E7 65 F2 61  
00D0CD  2  17 38 8C 03  .byte $17,$38,$8C,$03,$1D,$C9,$50,$62,$5C,$0B,$62,$3E,$63,$52,$8A,$52
00D0D1  2  1D C9 50 62  
00D0D5  2  5C 0B 62 3E  
00D0DD  2  93 54 AA 42  .byte $93,$54,$AA,$42,$D3,$51,$EA,$41,$03,$D3,$1C,$04,$1A,$52,$33,$55
00D0E1  2  D3 51 EA 41  
00D0E5  2  03 D3 1C 04  
00D0ED  2  73 44 77 44  .byte $73,$44,$77,$44,$16,$D2,$19,$31,$1A,$32,$5C,$0F,$9A,$47,$95,$64
00D0F1  2  16 D2 19 31  
00D0F5  2  1A 32 5C 0F  
00D0FD  2  A5 64 B5 64  .byte $A5,$64,$B5,$64,$C5,$64,$D5,$64,$E5,$64,$F5,$64,$05,$E4,$40,$61
00D101  2  C5 64 D5 64  
00D105  2  E5 64 F5 64  
00D10D  2  42 35 56 34  .byte $42,$35,$56,$34,$5C,$09,$A2,$61,$A6,$61,$B3,$34,$B7,$34,$FC,$08
00D111  2  5C 09 A2 61  
00D115  2  A6 61 B3 34  
00D11D  2  0C 87 28 54  .byte $0C,$87,$28,$54,$59,$53,$9A,$30,$A9,$61,$B8,$62,$BE,$0B,$C4,$31
00D121  2  59 53 9A 30  
00D125  2  A9 61 B8 62  
00D12D  2  D5 0A DE 0F  .byte $D5,$0A,$DE,$0F,$0D,$CA,$7D,$47,$FD
00D131  2  0D CA 7D 47  
00D135  2  FD           
00D136  2               
00D136  2               L_Area2A:
00D136  2  07 0F 0E 02  .byte $07,$0F,$0E,$02,$39,$73,$05,$8B,$2E,$0B,$B7,$0B,$64,$8B,$6E,$02
00D13A  2  39 73 05 8B  
00D13E  2  2E 0B B7 0B  
00D146  2  CE 06 DE 0F  .byte $CE,$06,$DE,$0F,$E6,$0A,$7D,$C7,$FD
00D14A  2  E6 0A 7D C7  
00D14E  2  FD           
00D14F  2               
00D14F  2               MRetainerCHRWorld5:
00D14F  2  0F 3F 7F 7F  .byte $0F,$3F,$7F,$7F,$F3,$ED,$FF,$FD
00D153  2  F3 ED FF FD  
00D157  2  0F 3F 78 60  .byte $0F,$3F,$78,$60,$C0,$C0,$80,$00
00D15B  2  C0 C0 80 00  
00D15F  2  FF FB 7C FF  .byte $FF,$FB,$7C,$FF,$70,$7F,$FF,$FF
00D163  2  70 7F FF FF  
00D167  2  00 00 00 80  .byte $00,$00,$00,$80,$43,$40,$E0,$F8
00D16B  2  43 40 E0 F8  
00D16F  2  FC FE 7F 10  .byte $FC,$FE,$7F,$10,$00,$00,$00,$FC
00D173  2  00 00 00 FC  
00D177  2  FF FF 63 0F  .byte $FF,$FF,$63,$0F,$3F,$7C,$78,$FC
00D17B  2  3F 7C 78 FC  
00D17F  2  F0 FC FE FE  .byte $F0,$FC,$FE,$FE,$CF,$B7,$FF,$BF
00D183  2  CF B7 FF BF  
00D187  2  F0 FC 1E 06  .byte $F0,$FC,$1E,$06,$03,$03,$01,$00
00D18B  2  03 03 01 00  
00D18F  2  FF DF 3E FF  .byte $FF,$DF,$3E,$FF,$0E,$FE,$FF,$FF
00D193  2  0E FE FF FF  
00D197  2  00 00 00 01  .byte $00,$00,$00,$01,$42,$02,$07,$1F
00D19B  2  42 02 07 1F  
00D19F  2  3F 7F FE 08  .byte $3F,$7F,$FE,$08,$00,$00,$00,$3F
00D1A3  2  00 00 00 3F  
00D1A7  2  FF FF C6 F0  .byte $FF,$FF,$C6,$F0,$FC,$3E,$1E,$3F
00D1AB  2  FC 3E 1E 3F  
00D1AF  2               
00D1AF  2               MRetainerCHRWorld6:
00D1AF  2  03 07 1F 7F  .byte $03,$07,$1F,$7F,$7F,$FF,$FD,$FF
00D1B3  2  7F FF FD FF  
00D1B7  2  03 07 1F 7F  .byte $03,$07,$1F,$7F,$7F,$FF,$FC,$F8
00D1BB  2  7F FF FC F8  
00D1BF  2  71 39 0F 0F  .byte $71,$39,$0F,$0F,$1F,$1F,$1E,$3F
00D1C3  2  1F 1F 1E 3F  
00D1C7  2  4A 03 01 01  .byte $4A,$03,$01,$01,$11,$10,$18,$39
00D1CB  2  11 10 18 39  
00D1CF  2  3B 3F 3C 3C  .byte $3B,$3F,$3C,$3C,$18,$00,$00,$3F
00D1D3  2  18 00 00 3F  
00D1D7  2  24 03 03 02  .byte $24,$03,$03,$02,$07,$07,$07,$3F
00D1DB  2  07 07 07 3F  
00D1DF  2  C0 F0 F0 FC  .byte $C0,$F0,$F0,$FC,$FE,$FF,$8F,$FF
00D1E3  2  FE FF 8F FF  
00D1E7  2  C0 F0 F0 FC  .byte $C0,$F0,$F0,$FC,$9E,$17,$07,$01
00D1EB  2  9E 17 07 01  
00D1EF  2  8E 9E F8 F8  .byte $8E,$9E,$F8,$F8,$FE,$FE,$3F,$F7
00D1F3  2  FE FE 3F F7  
00D1F7  2  50 40 00 00  .byte $50,$40,$00,$00,$86,$07,$0F,$CF
00D1FB  2  86 07 0F CF  
00D1FF  2  F7 F7 02 00  .byte $F7,$F7,$02,$00,$1C,$3E,$3E,$1C
00D203  2  1C 3E 3E 1C  
00D207  2  1B FB FC DC  .byte $1B,$FB,$FC,$DC,$FC,$3E,$3E,$1C
00D20B  2  FC 3E 3E 1C  
00D20F  2               
00D20F  2               MRetainerCHRWorld7:
00D20F  2  1F 7F 70 C1  .byte $1F,$7F,$70,$C1,$C1,$95,$A3,$CB
00D213  2  C1 95 A3 CB  
00D217  2  1F 7F 7F FE  .byte $1F,$7F,$7F,$FE,$FE,$EA,$C4,$08
00D21B  2  FE EA C4 08  
00D21F  2  F3 FD FC 3F  .byte $F3,$FD,$FC,$3F,$38,$1C,$1F,$17
00D223  2  38 1C 1F 17  
00D227  2  00 02 03 00  .byte $00,$02,$03,$00,$00,$63,$70,$F8
00D22B  2  00 63 70 F8  
00D22F  2  10 38 7F 7F  .byte $10,$38,$7F,$7F,$3F,$7F,$78,$00
00D233  2  3F 7F 78 00  
00D237  2  FF DF 9F 3B  .byte $FF,$DF,$9F,$3B,$3F,$7F,$78,$F8
00D23B  2  3F 7F 78 F8  
00D23F  2  F0 FC 1C 06  .byte $F0,$FC,$1C,$06,$06,$82,$82,$46
00D243  2  06 82 82 46  
00D247  2  F0 FC FC FE  .byte $F0,$FC,$FC,$FE,$FE,$7E,$1E,$48
00D24B  2  FE 7E 1E 48  
00D24F  2  3E FE 7E F8  .byte $3E,$FE,$7E,$F8,$38,$70,$E0,$D6
00D253  2  38 70 E0 D6  
00D257  2  00 00 80 00  .byte $00,$00,$80,$00,$00,$88,$1C,$38
00D25B  2  00 88 1C 38  
00D25F  2  1F 3F FF FE  .byte $1F,$3F,$FF,$FE,$F8,$FC,$3E,$00
00D263  2  F8 FC 3E 00  
00D267  2  F0 F0 F0 B8  .byte $F0,$F0,$F0,$B8,$F8,$FC,$3E,$3F
00D26B  2  F8 FC 3E 3F  
00D26F  2               
00D26F  2               ;unused byte
00D26F  2  FF           .byte $FF
00D270  2               
00D270  2               .else
00D270  2               ;level 5-4
00D270  2               E_CastleArea5:
00D270  2                 .byte $2a, $a9, $6b, $0c, $cb, $0c, $15, $9c, $89, $1c, $cc, $1d, $09, $9d, $f5, $1c
00D270  2                 .byte $6b, $a9, $ab, $0c, $db, $29, $48, $9d, $9b, $0c, $5b, $8c, $a5, $1c, $49, $9d
00D270  2                 .byte $79, $1d, $09, $9d, $6b, $0c, $c9, $1f, $3b, $8c, $88, $95, $b9, $1c, $19, $9d
00D270  2                 .byte $30, $cc, $78, $2d, $a6, $28, $90, $b5, $ff
00D270  2               
00D270  2               ;level 6-4
00D270  2               E_CastleArea6:
00D270  2                 .byte $0f, $02, $09, $1f, $8b, $85, $2b, $8c, $e9, $1b, $25, $9d, $0f, $07, $09, $1d
00D270  2                 .byte $6d, $28, $99, $1b, $b5, $2c, $4b, $8c, $09, $9f, $fb, $15, $9d, $a8, $0f, $0c
00D270  2                 .byte $2b, $0c, $78, $2d, $90, $b5, $ff
00D270  2               
00D270  2               ;level 7-4
00D270  2               E_CastleArea7:
00D270  2                 .byte $05, $9d, $0d, $a8, $dd, $1d, $07, $ac, $54, $2c, $a2, $2c, $f4, $2c, $42, $ac
00D270  2                 .byte $26, $9d, $d4, $03, $24, $83, $64, $03, $2b, $82, $4b, $02, $7b, $02, $9b, $02
00D270  2                 .byte $5b, $82, $7b, $02, $0b, $82, $2b, $02, $c6, $1b, $28, $82, $48, $02, $a6, $1b
00D270  2                 .byte $7b, $95, $85, $0c, $9d, $9b, $0f, $0e, $78, $2d, $7a, $1d, $90, $b5, $ff
00D270  2               
00D270  2               ;level 8-4
00D270  2               E_CastleArea8:
00D270  2                 .byte $19, $9b, $99, $1b, $2c, $8c, $59, $1b, $c5, $0f, $0e, $83, $e0, $0f, $06, $2e
00D270  2                 .byte $67, $e7, $0f, $08, $9b, $07, $0e, $83, $e0, $39, $0e, $87, $10, $bd, $28, $59
00D270  2                 .byte $9f, $0f, $0f, $34, $0f, $77, $10, $9e, $67, $f1, $0f, $12, $0e, $67, $e3, $78
00D270  2                 .byte $2d, $0f, $15, $3b, $29, $57, $82, $0f, $18, $55, $1d, $78, $2d, $90, $b5, $ff
00D270  2               
00D270  2               ;level 5-1
00D270  2               E_GroundArea12:
00D270  2                 .byte $1b, $82, $4b, $02, $7b, $02, $ab, $02, $0f, $03, $f9, $0e, $d0, $be, $8e, $c4
00D270  2                 .byte $86, $f8, $0e, $c0, $ba, $0f, $0d, $3a, $0e, $bb, $02, $30, $b7, $80, $bc, $c0
00D270  2                 .byte $bc, $0f, $12, $24, $0f, $54, $0f, $ce, $3c, $80, $d3, $0f, $cb, $8e, $f9, $0e
00D270  2                 .byte $ff
00D270  2               
00D270  2               ;level 5-3
00D270  2               E_GroundArea13:
00D270  2                 .byte $0a, $aa, $15, $8f, $44, $0f, $4e, $44, $80, $d8, $07, $57, $90, $0f, $06, $67
00D270  2                 .byte $24, $8b, $17, $b9, $24, $ab, $97, $16, $87, $2a, $28, $84, $0f, $57, $a9, $a5
00D270  2                 .byte $29, $f5, $29, $a7, $a4, $0a, $a4, $ff
00D270  2               
00D270  2               ;level 6-1
00D270  2               E_GroundArea14:
00D270  2                 .byte $07, $82, $67, $0e, $40, $bd, $e0, $38, $d0, $bc, $6e, $84, $a0, $9b, $05, $0f
00D270  2                 .byte $06, $bb, $05, $0f, $08, $0b, $0e, $4b, $0e, $0f, $0a, $05, $29, $85, $29, $0f
00D270  2                 .byte $0c, $dd, $28, $ff
00D270  2               
00D270  2               ;level 6-3
00D270  2               E_GroundArea15:
00D270  2                 .byte $0f, $02, $28, $10, $e6, $03, $d8, $90, $0f, $05, $85, $0f, $78, $83, $c8, $10
00D270  2                 .byte $18, $83, $58, $83, $f7, $90, $0f, $0c, $43, $0f, $73, $8f, $ff
00D270  2               
00D270  2               ;level 7-1
00D270  2               E_GroundArea16:
00D270  2                 .byte $a7, $83, $d7, $03, $0f, $03, $6b, $00, $0f, $06, $e3, $0f, $14, $8f, $3e, $44
00D270  2                 .byte $c3, $0b, $80, $87, $05, $ab, $05, $db, $83, $0f, $0b, $07, $05, $13, $0e, $2b
00D270  2                 .byte $02, $4b, $02, $0f, $10, $0b, $0e, $b0, $37, $90, $bc, $80, $bc, $ae, $44, $c0
00D270  2                 .byte $ff
00D270  2               
00D270  2               ;level 7-2
00D270  2               E_GroundArea17:
00D270  2                 .byte $0a, $aa, $d5, $8f, $03, $8f, $3e, $44, $c6, $d8, $83, $0f, $06, $a6, $11, $b9
00D270  2                 .byte $0e, $39, $9d, $79, $1b, $a6, $11, $e8, $03, $87, $83, $16, $90, $a6, $11, $b9
00D270  2                 .byte $1d, $05, $8f, $38, $29, $89, $29, $26, $8f, $46, $29, $ff
00D270  2               
00D270  2               ;level 7-3
00D270  2               E_GroundArea18:
00D270  2                 .byte $0f, $04, $a3, $10, $0f, $09, $e3, $29, $0f, $0d, $55, $24, $a9, $24, $0f, $11
00D270  2                 .byte $59, $1d, $a9, $1b, $23, $8f, $15, $9b, $ff
00D270  2               
00D270  2               ;level 8-1
00D270  2               E_GroundArea19:
00D270  2                 .byte $0f, $01, $db, $02, $30, $b7, $80, $3b, $1b, $8e, $4a, $0e, $eb, $03, $3b, $82
00D270  2                 .byte $5b, $02, $e5, $0f, $14, $8f, $44, $0f, $5b, $82, $0c, $85, $35, $8f, $06, $85
00D270  2                 .byte $e3, $05, $db, $83, $3e, $84, $e0, $ff
00D270  2               
00D270  2               ;level 8-2
00D270  2               E_GroundArea22:
00D270  2                 .byte $0f, $02, $0a, $29, $f7, $02, $80, $bc, $6b, $82, $7b, $02, $9b, $02, $ab, $02
00D270  2                 .byte $39, $8e, $0f, $07, $ce, $35, $ec, $f5, $0f, $fb, $85, $fb, $85, $3e, $c4, $e3
00D270  2                 .byte $a7, $02, $ff
00D270  2               
00D270  2               ;level 8-3
00D270  2               E_GroundArea23:
00D270  2                 .byte $09, $a9, $86, $11, $d5, $10, $a3, $8f, $d5, $29, $86, $91, $2b, $83, $58, $03
00D270  2                 .byte $5b, $85, $eb, $05, $3e, $bc, $e0, $0f, $09, $43, $0f, $74, $0f, $6b, $85, $db
00D270  2                 .byte $05, $c6, $a4, $19, $a4, $12, $8f
00D270  2               ;another unused area
00D270  2               E_GroundArea24:
00D270  2                 .byte $ff
00D270  2               
00D270  2               ;cloud level used with level 5-1
00D270  2               E_GroundArea29:
00D270  2                 .byte $0a, $aa, $2e, $2b, $98, $2e, $36, $e7, $ff
00D270  2               
00D270  2               ;level 5-2
00D270  2               E_UndergroundArea4:
00D270  2                 .byte $0b, $83, $b7, $03, $d7, $03, $0f, $05, $67, $03, $7b, $02, $9b, $02, $80, $b9
00D270  2                 .byte $3b, $83, $4e, $b4, $80, $86, $2b, $c9, $2c, $16, $ac, $67, $b4, $de, $3b, $81
00D270  2                 .byte $ff
00D270  2               
00D270  2               ;underground bonus rooms used with worlds 5-8
00D270  2               E_UndergroundArea5:
00D270  2                 .byte $1e, $af, $ca, $1e, $2c, $85, $0f, $04, $1e, $2d, $a7, $1e, $2f, $ce, $1e, $35
00D270  2                 .byte $e5, $0f, $07, $1e, $2b, $87, $1e, $30, $c5, $ff
00D270  2               
00D270  2               ;level 6-2
00D270  2               E_WaterArea2:
00D270  2                 .byte $0f, $01, $2e, $3b, $a1, $5b, $07, $ab, $07, $69, $87, $ba, $07, $fb, $87, $65
00D270  2                 .byte $a7, $6a, $27, $a6, $a7, $ac, $27, $1b, $87, $88, $07, $2b, $83, $7b, $07, $a7
00D270  2                 .byte $90, $e5, $83, $14, $a7, $19, $27, $77, $07, $f8, $07, $47, $8f, $b9, $07, $ff
00D270  2               
00D270  2               ;water area used in level 8-4
00D270  2               E_WaterArea4:
00D270  2                 .byte $07, $9b, $0a, $07, $b9, $1b, $66, $9b, $78, $07, $ae, $67, $e5, $ff
00D270  2               
00D270  2               ;water area used in level 6-1
00D270  2               E_WaterArea5:
00D270  2                 .byte $97, $87, $cb, $00, $ee, $2b, $f8, $fe, $2d, $ad, $75, $87, $d3, $27, $d9, $27
00D270  2                 .byte $0f, $04, $56, $0f, $ff
00D270  2               
00D270  2               ;level 5-4
00D270  2               L_CastleArea5:
00D270  2                 .byte $9b, $07, $05, $32, $06, $33, $07, $33, $3e, $03, $4c, $50, $4e, $07, $57, $31
00D270  2                 .byte $6e, $03, $7c, $52, $9e, $07, $fe, $0a, $7e, $89, $9e, $0a, $ee, $09, $fe, $0b
00D270  2                 .byte $13, $8e, $1e, $09, $3e, $0a, $6e, $09, $87, $0e, $9e, $02, $c6, $07, $ca, $0e
00D270  2                 .byte $f7, $62, $07, $8e, $08, $61, $17, $62, $1e, $0a, $4e, $06, $5e, $0a, $7e, $06
00D270  2                 .byte $8e, $0a, $ae, $06, $be, $07, $f3, $0e, $1e, $86, $2e, $0a, $84, $37, $93, $36
00D270  2                 .byte $a2, $45, $1e, $89, $46, $0e, $6e, $0a, $a7, $31, $db, $60, $f7, $60, $1b, $e0
00D270  2                 .byte $37, $31, $7e, $09, $8e, $0b, $a3, $0e, $fe, $04, $17, $bb, $47, $0e, $77, $0e
00D270  2                 .byte $be, $02, $ce, $0a, $07, $8e, $17, $31, $63, $31, $a7, $34, $c7, $0e, $13, $b1
00D270  2                 .byte $4e, $09, $1e, $8a, $7e, $02, $97, $34, $b7, $0e, $ce, $0a, $de, $02, $d8, $61
00D270  2                 .byte $f7, $62, $fe, $03, $07, $b4, $17, $0e, $47, $62, $4e, $0a, $5e, $03, $51, $61
00D270  2                 .byte $67, $62, $77, $34, $b7, $62, $c1, $61, $da, $60, $e9, $61, $f8, $62, $fe, $0a
00D270  2                 .byte $0d, $c4, $01, $52, $11, $52, $21, $52, $31, $52, $41, $52, $51, $52, $61, $52
00D270  2                 .byte $cd, $43, $ce, $09, $de, $0b, $dd, $42, $fe, $02, $5d, $c7, $fd
00D270  2               
00D270  2               ;level 6-4
00D270  2               L_CastleArea6:
00D270  2                 .byte $5b, $09, $05, $32, $06, $33, $4e, $0a, $87, $31, $fe, $02, $88, $f2, $c7, $33
00D270  2                 .byte $0d, $02, $07, $0e, $17, $34, $6e, $0a, $8e, $02, $bf, $67, $ed, $4b, $b7, $b6
00D270  2                 .byte $c3, $35, $1e, $8a, $2e, $02, $33, $3f, $37, $3f, $88, $f2, $c7, $33, $ed, $4b
00D270  2                 .byte $0d, $06, $03, $33, $0f, $74, $47, $73, $67, $73, $7e, $09, $9e, $0a, $ed, $4b
00D270  2                 .byte $f7, $32, $07, $8e, $97, $0e, $ae, $00, $de, $02, $e3, $35, $e7, $35, $3e, $8a
00D270  2                 .byte $4e, $02, $53, $3e, $57, $3e, $07, $8e, $a7, $34, $bf, $63, $ed, $4b, $2e, $8a
00D270  2                 .byte $fe, $06, $2e, $88, $34, $33, $35, $33, $6e, $06, $8e, $0c, $be, $06, $fe, $0a
00D270  2                 .byte $01, $d2, $0d, $44, $11, $52, $21, $52, $31, $52, $41, $52, $42, $0b, $51, $52
00D270  2                 .byte $61, $52, $cd, $43, $ce, $09, $dd, $42, $de, $0b, $fe, $02, $5d, $c7, $fd
00D270  2               
00D270  2               ;level 7-4
00D270  2               L_CastleArea7:
00D270  2                 .byte $58, $07, $05, $35, $06, $3d, $07, $3d, $be, $06, $de, $0c, $f3, $3d, $03, $8e
00D270  2                 .byte $6e, $43, $ce, $0a, $e1, $67, $f1, $67, $01, $e7, $11, $67, $1e, $05, $28, $39
00D270  2                 .byte $6e, $40, $be, $01, $c7, $06, $db, $0e, $de, $00, $1f, $80, $6f, $00, $bf, $00
00D270  2                 .byte $0f, $80, $5f, $00, $7e, $05, $a8, $37, $fe, $02, $24, $8e, $34, $30, $3e, $0c
00D270  2                 .byte $4e, $43, $ae, $0a, $be, $0c, $ee, $0a, $fe, $0c, $2e, $8a, $3e, $0c, $7e, $02
00D270  2                 .byte $8e, $0e, $98, $36, $b9, $34, $08, $bf, $09, $3f, $0e, $82, $2e, $86, $4e, $0c
00D270  2                 .byte $9e, $09, $c1, $62, $c4, $0e, $ee, $0c, $0e, $86, $5e, $0c, $7e, $09, $a1, $62
00D270  2                 .byte $a4, $0e, $ce, $0c, $fe, $0a, $28, $b4, $a6, $31, $e8, $34, $8b, $b2, $9b, $0e
00D270  2                 .byte $fe, $07, $fe, $8a, $0d, $c4, $cd, $43, $ce, $09, $dd, $42, $de, $0b, $fe, $02
00D270  2                 .byte $5d, $c7, $fd
00D270  2               
00D270  2               ;level 8-4
00D270  2               L_CastleArea8:
00D270  2                 .byte $5b, $03, $05, $34, $06, $35, $07, $36, $6e, $0a, $ee, $02, $fe, $05, $0d, $01
00D270  2                 .byte $17, $0e, $97, $0e, $9e, $02, $c6, $05, $fa, $30, $fe, $0a, $4e, $82, $57, $0e
00D270  2                 .byte $58, $62, $68, $62, $79, $61, $8a, $60, $8e, $0a, $f5, $31, $f9, $7b, $39, $f3
00D270  2                 .byte $97, $33, $b5, $71, $39, $f3, $4d, $48, $9e, $02, $ae, $05, $cd, $4a, $ed, $4b
00D270  2                 .byte $0e, $81, $17, $06, $39, $73, $5c, $02, $85, $65, $95, $32, $a9, $7b, $cc, $03
00D270  2                 .byte $5e, $8f, $6d, $47, $fe, $02, $0d, $07, $39, $73, $4e, $0a, $ae, $02, $ec, $71
00D270  2                 .byte $07, $81, $17, $02, $39, $73, $e6, $05, $39, $fb, $4e, $0a, $c4, $31, $eb, $61
00D270  2                 .byte $fe, $02, $07, $b0, $1e, $0a, $4e, $06, $57, $0e, $be, $02, $c9, $61, $da, $60
00D270  2                 .byte $ed, $4b, $0e, $85, $0d, $0e, $fe, $0a, $78, $e4, $8e, $06, $b3, $06, $bf, $47
00D270  2                 .byte $ee, $0f, $6d, $c7, $0e, $82, $39, $73, $9a, $60, $a9, $61, $ae, $06, $de, $0a
00D270  2                 .byte $e7, $03, $eb, $79, $f7, $03, $fe, $06, $0d, $14, $fe, $0a, $5e, $82, $7f, $66
00D270  2                 .byte $9e, $0a, $f8, $64, $fe, $0b, $9e, $84, $be, $05, $be, $82, $da, $60, $e9, $61
00D270  2                 .byte $f8, $62, $fe, $0a, $0d, $c4, $11, $64, $51, $62, $cd, $43, $ce, $09, $dd, $42
00D270  2                 .byte $de, $0b, $fe, $02, $5d, $c7, $fd
00D270  2               
00D270  2               ;level 5-1
00D270  2               L_GroundArea12:
00D270  2                 .byte $52, $b1, $0f, $20, $6e, $75, $cc, $73, $a3, $b3, $bf, $74, $0c, $84, $83, $3f
00D270  2                 .byte $9f, $74, $ef, $71, $ec, $01, $2f, $f1, $2c, $01, $6f, $71, $6c, $01, $a8, $91
00D270  2                 .byte $aa, $10, $77, $fb, $56, $f4, $39, $f1, $bf, $37, $33, $e7, $43, $04, $47, $03
00D270  2                 .byte $6c, $05, $c3, $67, $d3, $67, $e3, $67, $ed, $4c, $fc, $07, $73, $e7, $83, $67
00D270  2                 .byte $93, $67, $a3, $67, $bc, $08, $43, $e7, $53, $67, $dc, $02, $59, $91, $c3, $33
00D270  2                 .byte $d9, $71, $df, $72, $2d, $cd, $5b, $71, $9b, $71, $3b, $f1, $a7, $c2, $db, $71
00D270  2                 .byte $0d, $10, $9b, $71, $0a, $b0, $1c, $04, $67, $63, $76, $64, $85, $65, $94, $66
00D270  2                 .byte $a3, $67, $b3, $67, $cc, $09, $73, $a3, $87, $22, $b3, $09, $d6, $83, $e3, $03
00D270  2                 .byte $fe, $3f, $0d, $15, $de, $31, $ec, $01, $03, $f7, $9d, $41, $df, $26, $0d, $18
00D270  2                 .byte $39, $71, $7f, $37, $f2, $68, $01, $e9, $11, $39, $68, $7a, $de, $3f, $6d, $c5
00D270  2                 .byte $fd
00D270  2               
00D270  2               ;level 5-3
00D270  2               L_GroundArea13:
00D270  2                 .byte $50, $11, $0f, $26, $df, $32, $fe, $10, $0d, $01, $98, $74, $c8, $13, $52, $e1
00D270  2                 .byte $63, $31, $61, $79, $c6, $61, $06, $e1, $8b, $71, $ab, $71, $e4, $19, $eb, $19
00D270  2                 .byte $60, $86, $c8, $13, $cd, $4b, $39, $f3, $98, $13, $17, $f5, $7c, $15, $7f, $13
00D270  2                 .byte $cf, $15, $d4, $40, $0b, $9a, $23, $16, $32, $44, $a3, $95, $b2, $43, $0d, $0a
00D270  2                 .byte $27, $14, $3d, $4a, $a4, $40, $bc, $16, $bf, $13, $c4, $40, $04, $c0, $1f, $16
00D270  2                 .byte $24, $40, $43, $31, $ce, $11, $dd, $41, $0e, $d2, $3f, $20, $3d, $c7, $fd
00D270  2               
00D270  2               ;level 6-1
00D270  2               L_GroundArea14:
00D270  2                 .byte $52, $a1, $0f, $20, $6e, $40, $d6, $61, $e7, $07, $f7, $21, $16, $e1, $34, $63
00D270  2                 .byte $47, $21, $54, $04, $67, $0a, $74, $63, $dc, $01, $06, $e1, $17, $26, $86, $61
00D270  2                 .byte $66, $c2, $58, $c1, $f7, $03, $04, $f6, $8a, $10, $9c, $04, $e8, $62, $f9, $61
00D270  2                 .byte $0a, $e0, $53, $31, $5f, $73, $7b, $71, $77, $25, $fc, $e2, $17, $aa, $23, $00
00D270  2                 .byte $3c, $67, $b3, $01, $cc, $63, $db, $71, $df, $73, $fc, $00, $4f, $b7, $ca, $7a
00D270  2                 .byte $c5, $31, $ec, $54, $3c, $dc, $5d, $4c, $0f, $b3, $47, $63, $6b, $f1, $8c, $0a
00D270  2                 .byte $39, $f1, $ec, $03, $f0, $33, $0f, $e2, $29, $73, $49, $61, $58, $62, $67, $73
00D270  2                 .byte $85, $65, $94, $66, $a3, $77, $ad, $4d, $4d, $c1, $6f, $26, $5d, $c7, $fd
00D270  2               
00D270  2               ;level 6-3
00D270  2               L_GroundArea15:
00D270  2                 .byte $50, $11, $0f, $26, $af, $32, $d8, $62, $de, $10, $08, $e4, $5a, $62, $6c, $4c
00D270  2                 .byte $86, $43, $ad, $48, $3a, $e2, $53, $42, $88, $64, $9c, $36, $08, $e4, $4a, $62
00D270  2                 .byte $5c, $4d, $3a, $e2, $9c, $32, $fc, $41, $3c, $b1, $83, $00, $ac, $42, $2a, $e2
00D270  2                 .byte $3c, $46, $aa, $62, $bc, $4e, $c6, $43, $46, $c3, $aa, $62, $bd, $48, $0b, $96
00D270  2                 .byte $47, $07, $c7, $12, $3c, $c2, $9c, $41, $cd, $48, $dc, $32, $4c, $c2, $bc, $32
00D270  2                 .byte $1c, $b1, $5a, $62, $6c, $44, $76, $43, $ba, $62, $dc, $32, $5d, $ca, $73, $12
00D270  2                 .byte $e3, $12, $8e, $91, $9d, $41, $be, $42, $ef, $20, $cd, $c7, $fd
00D270  2               
00D270  2               ;level 7-1
00D270  2               L_GroundArea16:
00D270  2                 .byte $52, $b1, $0f, $20, $6e, $76, $03, $b1, $09, $71, $0f, $71, $6f, $33, $a7, $63
00D270  2                 .byte $b7, $34, $bc, $0e, $4d, $cc, $03, $a6, $08, $72, $3f, $72, $6d, $4c, $73, $07
00D270  2                 .byte $77, $73, $83, $27, $ac, $00, $bf, $73, $3c, $80, $9a, $30, $ac, $5b, $c6, $3c
00D270  2                 .byte $6a, $b0, $75, $10, $96, $74, $b6, $0a, $da, $30, $e3, $28, $ec, $5b, $ed, $48
00D270  2                 .byte $aa, $b0, $33, $b4, $51, $79, $ad, $4a, $dd, $4d, $e3, $2c, $0c, $fa, $73, $07
00D270  2                 .byte $b3, $04, $cb, $71, $ec, $07, $0d, $0a, $39, $71, $df, $33, $ca, $b0, $d6, $10
00D270  2                 .byte $d7, $30, $dc, $0c, $03, $b1, $ad, $41, $ef, $26, $ed, $c7, $39, $f1, $0d, $10
00D270  2                 .byte $7d, $4c, $0d, $13, $a8, $11, $aa, $10, $1c, $83, $d7, $7b, $f3, $67, $5d, $cd
00D270  2                 .byte $6d, $47, $fd
00D270  2               
00D270  2               ;level 7-2
00D270  2               L_GroundArea17:
00D270  2                 .byte $56, $11, $0f, $26, $df, $32, $fe, $11, $0d, $01, $0c, $5f, $03, $80, $0c, $52
00D270  2                 .byte $29, $15, $7c, $5b, $23, $b2, $29, $1f, $31, $79, $1c, $de, $48, $3b, $ed, $4b
00D270  2                 .byte $39, $f1, $cf, $b3, $fe, $10, $37, $8e, $77, $0e, $9e, $11, $a8, $34, $a9, $34
00D270  2                 .byte $aa, $34, $f8, $62, $fe, $10, $37, $b6, $de, $11, $e7, $63, $f8, $62, $09, $e1
00D270  2                 .byte $0e, $10, $47, $36, $b7, $0e, $be, $91, $ca, $32, $ee, $10, $1d, $ca, $7e, $11
00D270  2                 .byte $83, $77, $9e, $10, $1e, $91, $2d, $41, $4f, $26, $4d, $c7, $fd
00D270  2               
00D270  2               ;level 7-3
00D270  2               L_GroundArea18:
00D270  2                 .byte $57, $11, $0f, $26, $fe, $10, $4b, $92, $59, $0f, $ad, $4c, $d3, $93, $0b, $94
00D270  2                 .byte $29, $0f, $7b, $93, $99, $0f, $0d, $06, $27, $12, $35, $0f, $23, $b1, $57, $75
00D270  2                 .byte $a3, $31, $ab, $71, $f7, $75, $23, $b1, $87, $13, $95, $0f, $0d, $0a, $23, $35
00D270  2                 .byte $38, $13, $55, $00, $9b, $16, $0b, $96, $c7, $75, $3b, $92, $49, $0f, $ad, $4c
00D270  2                 .byte $29, $92, $52, $40, $6c, $15, $6f, $11, $72, $40, $bf, $15, $03, $93, $0a, $13
00D270  2                 .byte $12, $41, $8b, $12, $99, $0f, $0d, $10, $47, $16, $46, $45, $b3, $32, $13, $b1
00D270  2                 .byte $57, $0e, $a7, $0e, $d3, $31, $53, $b1, $a6, $31, $03, $b2, $13, $0e, $8d, $4d
00D270  2                 .byte $ae, $11, $bd, $41, $ee, $52, $0f, $a0, $dd, $47, $fd
00D270  2               
00D270  2               ;level 8-1
00D270  2               L_GroundArea19:
00D270  2                 .byte $52, $a1, $0f, $20, $6e, $65, $57, $f3, $60, $21, $6f, $62, $ac, $75, $07, $80
00D270  2                 .byte $1c, $76, $87, $01, $9c, $70, $b0, $33, $cf, $66, $57, $e3, $6c, $04, $cd, $4c
00D270  2                 .byte $9a, $b0, $ac, $0c, $83, $b1, $8f, $74, $bd, $4d, $f8, $11, $fa, $10, $83, $87
00D270  2                 .byte $93, $22, $9f, $74, $59, $f1, $89, $61, $a9, $61, $bc, $0c, $67, $a0, $eb, $71
00D270  2                 .byte $77, $87, $7a, $10, $86, $51, $95, $52, $a4, $53, $b6, $04, $b3, $24, $26, $85
00D270  2                 .byte $4a, $10, $53, $23, $5c, $00, $6f, $73, $93, $08, $07, $fb, $2c, $04, $33, $30
00D270  2                 .byte $74, $76, $eb, $71, $57, $8b, $6c, $02, $96, $74, $e3, $30, $0c, $86, $7d, $41
00D270  2                 .byte $bf, $26, $bd, $c7, $fd
00D270  2               
00D270  2               ;level 8-2
00D270  2               L_GroundArea22:
00D270  2                 .byte $50, $61, $0f, $26, $bb, $f1, $dc, $06, $23, $87, $b5, $71, $b7, $31, $d7, $28
00D270  2                 .byte $06, $c5, $67, $08, $0d, $05, $39, $71, $7c, $00, $9e, $62, $b6, $0b, $e6, $08
00D270  2                 .byte $4e, $e0, $5d, $4c, $59, $0f, $6c, $02, $93, $67, $ac, $56, $ad, $4c, $1f, $b1
00D270  2                 .byte $3c, $01, $98, $0a, $9e, $20, $a8, $21, $f3, $09, $0e, $a1, $27, $20, $3e, $62
00D270  2                 .byte $56, $08, $7d, $4d, $c6, $08, $3e, $e0, $9e, $62, $b6, $08, $1e, $e0, $4c, $00
00D270  2                 .byte $6c, $00, $a7, $7b, $de, $2f, $6d, $c7, $fe, $10, $0b, $93, $5b, $15, $b7, $12
00D270  2                 .byte $03, $91, $ab, $1f, $bd, $41, $ef, $26, $ad, $c7, $fd
00D270  2               
00D270  2               ;level 8-3
00D270  2               L_GroundArea23:
00D270  2                 .byte $50, $50, $0f, $26, $0b, $1f, $57, $92, $8b, $12, $d2, $14, $4b, $92, $59, $0f
00D270  2                 .byte $0b, $95, $bb, $1f, $be, $52, $58, $e2, $9e, $50, $97, $08, $bb, $1f, $ae, $d2
00D270  2                 .byte $b6, $08, $bb, $1f, $dd, $4a, $f6, $07, $26, $89, $8e, $50, $98, $62, $eb, $11
00D270  2                 .byte $07, $f3, $0b, $1d, $2e, $52, $47, $0a, $ce, $50, $eb, $1f, $ee, $52, $5e, $d0
00D270  2                 .byte $d9, $0f, $ab, $9f, $be, $52, $8e, $d0, $ab, $1d, $ae, $52, $36, $8b, $56, $08
00D270  2                 .byte $5e, $50, $dc, $15, $df, $12, $2f, $95, $c3, $31, $5b, $9f, $6d, $41, $8e, $52
00D270  2                 .byte $af, $20, $ad, $c7
00D270  2               ;another unused area
00D270  2               L_GroundArea24:
00D270  2                 .byte $fd
00D270  2               
00D270  2               ;cloud level used with level 5-1
00D270  2               L_GroundArea29:
00D270  2                 .byte $00, $c1, $4c, $00, $f3, $4f, $fa, $c6, $68, $a0, $69, $20, $6a, $20, $7a, $47
00D270  2                 .byte $f8, $20, $f9, $20, $fa, $20, $0a, $cf, $b4, $49, $55, $a0, $56, $20, $73, $47
00D270  2                 .byte $f5, $20, $f6, $20, $22, $a1, $41, $48, $52, $20, $72, $20, $92, $20, $b2, $20
00D270  2                 .byte $fe, $00, $9b, $c2, $ad, $c7, $fd
00D270  2               
00D270  2               ;level 5-2
00D270  2               L_UndergroundArea4:
00D270  2                 .byte $48, $0f, $1e, $01, $27, $06, $5e, $02, $8f, $63, $8c, $01, $ef, $67, $1c, $81
00D270  2                 .byte $2e, $09, $3c, $63, $73, $01, $8c, $60, $fe, $02, $1e, $8e, $3e, $02, $44, $07
00D270  2                 .byte $45, $52, $4e, $0e, $8e, $02, $99, $71, $b5, $24, $b6, $24, $b7, $24, $fe, $02
00D270  2                 .byte $07, $87, $17, $22, $37, $52, $37, $0b, $47, $52, $4e, $0a, $57, $52, $5e, $02
00D270  2                 .byte $67, $52, $77, $52, $7e, $0a, $87, $52, $8e, $02, $96, $46, $97, $52, $a7, $52
00D270  2                 .byte $b7, $52, $c7, $52, $d7, $52, $e7, $52, $f7, $52, $fe, $04, $07, $a3, $47, $08
00D270  2                 .byte $57, $26, $c7, $0a, $e9, $71, $17, $a7, $97, $08, $9e, $01, $a0, $24, $c6, $74
00D270  2                 .byte $f0, $0c, $fe, $04, $0c, $80, $6f, $32, $98, $62, $a8, $62, $bc, $00, $c7, $73
00D270  2                 .byte $e7, $73, $fe, $02, $7f, $e7, $8e, $01, $9e, $00, $de, $02, $f7, $0b, $fe, $0e
00D270  2                 .byte $4e, $82, $54, $52, $64, $51, $6e, $00, $74, $09, $9f, $00, $df, $00, $2f, $80
00D270  2                 .byte $4e, $02, $59, $47, $ce, $0a, $07, $f5, $68, $54, $7f, $64, $88, $54, $a8, $54
00D270  2                 .byte $ae, $01, $b8, $52, $bf, $47, $c8, $52, $d8, $52, $e8, $52, $ee, $0f, $4d, $c7
00D270  2                 .byte $0d, $0d, $0e, $02, $68, $7a, $be, $01, $ee, $0f, $6d, $c5, $fd
00D270  2               
00D270  2               ;underground bonus rooms used with worlds 5-8
00D270  2               L_UndergroundArea5:
00D270  2                 .byte $08, $0f, $0e, $01, $2e, $05, $38, $2c, $3a, $4f, $08, $ac, $c7, $0b, $ce, $01
00D270  2                 .byte $df, $4a, $6d, $c7, $0e, $81, $00, $5a, $2e, $02, $b8, $4f, $cf, $65, $0f, $e5
00D270  2                 .byte $4f, $65, $8f, $65, $df, $4a, $6d, $c7, $0e, $81, $00, $5a, $30, $07, $34, $52
00D270  2                 .byte $3e, $02, $42, $47, $44, $47, $46, $27, $c0, $0b, $c4, $52, $df, $4a, $6d, $c7
00D270  2                 .byte $fd
00D270  2               
00D270  2               ;level 6-2
00D270  2               L_WaterArea2:
00D270  2                 .byte $41, $01, $27, $d3, $79, $51, $c4, $56, $00, $e2, $03, $53, $0c, $0f, $12, $3b
00D270  2                 .byte $1a, $42, $43, $54, $6d, $49, $83, $53, $99, $53, $c3, $54, $da, $52, $0c, $84
00D270  2                 .byte $09, $53, $53, $64, $63, $31, $67, $34, $86, $41, $8c, $01, $a3, $30, $b3, $64
00D270  2                 .byte $cc, $03, $d9, $42, $5c, $84, $a0, $62, $a8, $62, $b0, $62, $b8, $62, $c0, $62
00D270  2                 .byte $c8, $62, $d0, $62, $d8, $62, $e0, $62, $e8, $62, $16, $c2, $58, $52, $8c, $04
00D270  2                 .byte $a7, $55, $d0, $63, $d7, $65, $e2, $61, $e7, $65, $f2, $61, $f7, $65, $13, $b8
00D270  2                 .byte $17, $38, $8c, $03, $1d, $c9, $50, $62, $5c, $0b, $62, $3e, $63, $52, $8a, $52
00D270  2                 .byte $93, $54, $aa, $42, $d3, $51, $ea, $41, $03, $d3, $1c, $04, $1a, $52, $33, $55
00D270  2                 .byte $73, $44, $77, $44, $16, $d2, $19, $31, $1a, $32, $5c, $0f, $9a, $47, $95, $64
00D270  2                 .byte $a5, $64, $b5, $64, $c5, $64, $d5, $64, $e5, $64, $f5, $64, $05, $e4, $40, $61
00D270  2                 .byte $42, $35, $56, $34, $5c, $09, $a2, $61, $a6, $61, $b3, $34, $b7, $34, $fc, $08
00D270  2                 .byte $0c, $87, $28, $54, $59, $53, $9a, $30, $a9, $61, $b8, $62, $be, $0b, $d4, $60
00D270  2                 .byte $d5, $0d, $de, $0f, $0d, $ca, $7d, $47, $fd
00D270  2               
00D270  2               ;water area used in level 8-4
00D270  2               L_WaterArea4:
00D270  2                 .byte $07, $0f, $0e, $02, $39, $73, $05, $8e, $2e, $0b, $b7, $0e, $64, $8e, $6e, $02
00D270  2                 .byte $ce, $06, $de, $0f, $e6, $0d, $7d, $c7, $fd
00D270  2               
00D270  2               ;water area used in level 6-1
00D270  2               L_WaterArea5:
00D270  2                 .byte $01, $01, $77, $39, $a3, $43, $00, $bf, $29, $51, $39, $48, $61, $55, $d6, $54
00D270  2                 .byte $d2, $44, $0c, $82, $2e, $02, $31, $66, $44, $47, $47, $32, $4a, $47, $97, $32
00D270  2                 .byte $c1, $66, $ce, $01, $dc, $02, $fe, $0e, $0c, $8f, $08, $4f, $fe, $01, $27, $d3
00D270  2                 .byte $5c, $02, $9a, $60, $a9, $61, $b8, $62, $c7, $63, $ce, $0f, $d5, $0d, $7d, $c7
00D270  2                 .byte $fd
00D270  2               
00D270  2               ;unused bytes
00D270  2                 .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D270  2                 .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D270  2               .endif
00D270  2               
00D270  1               .reloc
00B3CFr 1               .endscope
00B3CFr 1               Data2End:
00B3CFr 1               
00B3CFr 1  03           .byte FileHeaderBlock
00B3D0r 1  05 30        .byte $05,$30
00B3D2r 1  4E 53 4D 44  .byte "NSMDATA3"
00B3D6r 1  41 54 41 33  
00B3DAr 1  D0 C5        .word $c5d0
00B3DCr 1  12 0D        .word Data3End-Data3Start
00B3DEr 1  00 04        .byte PRG,FileDataBlock
00B3E0r 1               Data3Start:
00B3E0r 1               .scope FILE_SM2DATA3
00B3E0r 1               .org $C5D0
00C5D0  1               .include "ann_sm2data3.asm"
00C5D0  2               ;SMB2J DISASSEMBLY (SM2DATA3 portion)
00C5D0  2               
00C5D0  2               ;-------------------------------------------------------------------------------------
00C5D0  2               ;DEFINES
00C5D0  2               
00C5D0  2               ANN                   = $40
00C5D0  2               OperMode              = $0770
00C5D0  2               OperMode_Task         = $0772
00C5D0  2               ScreenRoutineTask     = $073c
00C5D0  2               DiskIOTask            = $07fc
00C5D0  2               
00C5D0  2               Sprite_Y_Position     = $0200
00C5D0  2               Sprite_Tilenumber     = $0201
00C5D0  2               Sprite_Attributes     = $0202
00C5D0  2               Sprite_X_Position     = $0203
00C5D0  2               
00C5D0  2               VRAM_Buffer1          = $0301
00C5D0  2               VRAM_Buffer_AddrCtrl  = $0773
00C5D0  2               DisableScreenFlag     = $0774
00C5D0  2               SelectTimer           = $0780
00C5D0  2               ScreenTimer           = $07a0
00C5D0  2               WorldEndTimer         = $07a1
00C5D0  2               FantasyW9MsgFlag      = $07f5
00C5D0  2               
00C5D0  2               IRQUpdateFlag        = $0722
00C5D0  2               IRQAckFlag           = $077b
00C5D0  2               
00C5D0  2               FDSBIOS_DELAY     = $e149
00C5D0  2               FDSBIOS_LOADFILES = $e1f8
00C5D0  2               FDSBIOS_WRITEFILE = $e239
00C5D0  2               NameTableSelect   = $077a
00C5D0  2               CompletedWorlds   = $07fa
00C5D0  2               HardWorldFlag     = $07fb
00C5D0  2               FileListNumber    = $07f7
00C5D0  2               
00C5D0  2               GamePauseStatus   = $0776
00C5D0  2               
00C5D0  2               ObjectOffset        = $08
00C5D0  2               Enemy_ID            = $16
00C5D0  2               Enemy_Y_Position    = $cf
00C5D0  2               Enemy_Rel_XPos      = $03ae
00C5D0  2               Enemy_SprDataOffset = $06e5
00C5D0  2               
00C5D0  2               SelectedPlayer      = $0753
00C5D0  2               NumberofLives       = $075a
00C5D0  2               DigitModifier       = $0134
00C5D0  2               WorldNumber         = $075f
00C5D0  2               
00C5D0  2               ANNMushroomRetainerTmp  = $079C
00C5D0  2               
00C5D0  2               ;sound related defines
00C5D0  2               Squ2_NoteLenBuffer      = $0610
00C5D0  2               Squ2_NoteLenCounter     = $0611
00C5D0  2               Squ2_EnvelopeDataCtrl   = $0612
00C5D0  2               Squ1_NoteLenCounter     = $0613
00C5D0  2               Squ1_EnvelopeDataCtrl   = $0614
00C5D0  2               Tri_NoteLenBuffer       = $0615
00C5D0  2               Tri_NoteLenCounter      = $0616
00C5D0  2               Noise_BeatLenCounter    = $0617
00C5D0  2               FDSSND_LenBuffer        = $05f2
00C5D0  2               FDSSND_LenCounter       = $05f1
00C5D0  2               FDSSND_MasterEnvTimer   = $05f3
00C5D0  2               FDSSND_ModTableNumber   = $05f6
00C5D0  2               FDSSND_MasterEnvSet     = $05f7
00C5D0  2               FDSSND_VolumeEnvTimer   = $05f8
00C5D0  2               FDSSND_VolumeEnvOffset  = $05f9
00C5D0  2               FDSSND_SweepModTimer    = $05fa
00C5D0  2               FDSSND_SweepModOffset   = $05fb
00C5D0  2               
00C5D0  2               PauseSoundQueue       = $fa
00C5D0  2               Square1SoundQueue     = $ff
00C5D0  2               Square2SoundQueue     = $fe
00C5D0  2               NoiseSoundQueue       = $fd
00C5D0  2               AreaMusicQueue        = $fb
00C5D0  2               EventMusicQueue       = $fc
00C5D0  2               
00C5D0  2               Square1SoundBuffer    = $f1
00C5D0  2               Square2SoundBuffer    = $f2
00C5D0  2               NoiseSoundBuffer      = $f3
00C5D0  2               AreaMusicBuffer       = $f4
00C5D0  2               EventMusicBuffer      = $07b1
00C5D0  2               PauseSoundBuffer      = $07b2
00C5D0  2               AltMusicBuffer        = $0608
00C5D0  2               
00C5D0  2               PatternNumber         = $061d
00C5D0  2               
00C5D0  2               MusicData             = $66
00C5D0  2               MusicDataLow          = $66
00C5D0  2               MusicDataHigh         = $67
00C5D0  2               WaveformData          = $68
00C5D0  2               FDSSND_VolumeEnvData  = $6a
00C5D0  2               FDSSND_SweepModData   = $6c
00C5D0  2               MusicOffset_Square2   = $060a
00C5D0  2               MusicOffset_Square1   = $060b
00C5D0  2               MusicOffset_Triangle  = $060c
00C5D0  2               MusicOffset_Noise     = $060d
00C5D0  2               MusicOffset_FDSSND    = $061f
00C5D0  2               
00C5D0  2               NoteLenLookupTblOfs   = $f0
00C5D0  2               DAC_Counter           = $07c0
00C5D0  2               NoiseDataLoopbackOfs  = $061b
00C5D0  2               NoteLengthTblAdder    = $0609
00C5D0  2               AreaMusicBuffer_Alt   = $07c5
00C5D0  2               PauseModeFlag         = $07c6
00C5D0  2               GroundMusicHeaderOfs  = $07c7
00C5D0  2               AltRegContentFlag     = $07ca
00C5D0  2               
00C5D0  2               WaveformID            = $060e
00C5D0  2               
00C5D0  2               MsgCounter            = $0719
00C5D0  2               MsgFractional         = $0749
00C5D0  2               
00C5D0  2               EndControlCntr        = $0761
00C5D0  2               BlueColorOfs          = $0762
00C5D0  2               BlueDelayFlag         = $0763
00C5D0  2               MushroomRetDelay      = $0764
00C5D0  2               MRetainerOffset       = $0762
00C5D0  2               CurrentFlashMRet      = $0763
00C5D0  2               
00C5D0  2               MHD = MusicHeaderOffsetData
00C5D0  2               
00C5D0  2               GameOverMode          = 3
00C5D0  2               
00C5D0  2               SND_REGISTER          = $4000
00C5D0  2               SND_SQUARE1_REG       = $4000
00C5D0  2               SND_SQUARE2_REG       = $4004
00C5D0  2               SND_TRIANGLE_REG      = $4008
00C5D0  2               SND_NOISE_REG         = $400c
00C5D0  2               SND_DELTA_REG         = $4010
00C5D0  2               SND_MASTERCTRL_REG    = $4015
00C5D0  2               
00C5D0  2               SPR_DMA               = $4014
00C5D0  2               JOYPAD_PORT           = $4016
00C5D0  2               JOYPAD_PORT1          = $4016
00C5D0  2               JOYPAD_PORT2          = $4017
00C5D0  2               
00C5D0  2               FDS_IRQTIMER_LOW      = $4020
00C5D0  2               FDS_IRQTIMER_HIGH     = $4021
00C5D0  2               FDS_IRQTIMER_CTRL     = $4022
00C5D0  2               FDS_CTRL_REG          = $4025
00C5D0  2               FDS_STATUS            = $4030
00C5D0  2               FDS_DRIVE_STATUS      = $4032
00C5D0  2               
00C5D0  2               FDSSND_VOLUMECTRL      = $4080
00C5D0  2               FDSSND_FREQLOW         = $4082
00C5D0  2               FDSSND_FREQHIGH        = $4083
00C5D0  2               FDSSND_SWEEPCTRL       = $4084
00C5D0  2               FDSSND_SWEEPBIAS       = $4085
00C5D0  2               FDSSND_MODFREQLOW      = $4086
00C5D0  2               FDSSND_MODFREQHIGH     = $4087
00C5D0  2               FDSSND_MODTBLAPPEND    = $4088
00C5D0  2               FDSSND_WAVEENABLEWR    = $4089
00C5D0  2               FDSSND_WAVERAM         = $4040
00C5D0  2               
00C5D0  2               Sfx_ExtraLife          = %01000000
00C5D0  2               Sfx_CoinGrab           = %00000001
00C5D0  2               VictoryMusic           = %00000100
00C5D0  2               
00C5D0  2               ; imports from other files
00C5D0  2               .import MoveSpritesOffscreen
00C5D0  2               .import FreqRegLookupTbl
00C5D0  2               .import NextWorld
00C5D0  2               .import WriteTopStatusLine
00C5D0  2               .import WriteBottomStatusLine
00C5D0  2               .import GetAreaPalette
00C5D0  2               .import GetBackgroundColor
00C5D0  2               .import EndAreaPoints
00C5D0  2               .import JumpEngine
00C5D0  2               .import Square2SfxHandler
00C5D0  2               .import PrintStatusBarNumbers
00C5D0  2               .import DiskIDString
00C5D0  2               .import EnemyGfxHandler
00C5D0  2               .import SoundEngine
00C5D0  2               .import DiskScreen
00C5D0  2               .import WaitForEject
00C5D0  2               .import WaitForReinsert
00C5D0  2               .import ResetDiskVars
00C5D0  2               .import DiskErrorHandler
00C5D0  2               .import AttractModeSubs
00C5D0  2               .import SoundEngineJSRCode
00C5D0  2               .import InitScreenPalette
00C5D0  2               
00C5D0  2               ; exports to other files
00C5D0  2               .export EraseLivesLines
00C5D0  2               .export RunMushroomRetainers
00C5D0  2               .export EndingDiskRoutines
00C5D0  2               .export AwardExtraLives
00C5D0  2               .export PrintVictoryMsgsForWorld8
00C5D0  2               .export FadeToBlue
00C5D0  2               .export ScreenSubsForFinalRoom
00C5D0  2               .export WriteNameToVictoryMsg
00C5D0  2               .export UnusedAttribData
00C5D0  2               .export FinalRoomPalette
00C5D0  2               .export ThankYouMessageFinal
00C5D0  2               .export PeaceIsPavedMsg
00C5D0  2               .export WithKingdomSavedMsg
00C5D0  2               .export HurrahMsg
00C5D0  2               .export OurOnlyHeroMsg
00C5D0  2               .export ThisEndsYourTripMsg
00C5D0  2               .export OfALongFriendshipMsg
00C5D0  2               .export PointsAddedMsg
00C5D0  2               .export ForEachPlayerLeftMsg
00C5D0  2               .export PrincessPeachsRoom
00C5D0  2               .ifdef ANN
00C5D0  2               .export ANNEndingPalette
00C5D0  2               .else
00C5D0  2               .export FantasyWorld9Msg
00C5D0  2               .export SuperPlayerMsg
00C5D0  2               .export E_CastleArea9
00C5D0  2               .export E_CastleArea10
00C5D0  2               .export E_GroundArea25
00C5D0  2               .export E_GroundArea26
00C5D0  2               .export E_GroundArea27
00C5D0  2               .export E_WaterArea6
00C5D0  2               .export E_WaterArea7
00C5D0  2               .export E_WaterArea8
00C5D0  2               .export L_CastleArea9
00C5D0  2               .export L_CastleArea10
00C5D0  2               .export L_GroundArea25
00C5D0  2               .export L_GroundArea26
00C5D0  2               .export L_GroundArea27
00C5D0  2               .export L_WaterArea6
00C5D0  2               .export L_WaterArea7
00C5D0  2               .export L_WaterArea8
00C5D0  2               .endif
00C5D0  2               
00C5D0  2               ;-------------------------------------------------------------------------------------
00C5D0  2               
00C5D0  2               .ifndef ANN
00C5D0  2               PrintWorld9Msgs:
00C5D0  2                      lda OperMode              ;if in game over mode, branch
00C5D0  2                      cmp #GameOverMode         ;note this routine only runs after world 8 and replaces
00C5D0  2                      beq W9GameOver            ;the routine DemoReset in memory
00C5D0  2                      lda FantasyW9MsgFlag      ;if world 9 flag was set earlier, skip this part
00C5D0  2                      bne NoFW9
00C5D0  2                      lda #$1d                  ;otherwise set VRAM pointer to print
00C5D0  2                      sta VRAM_Buffer_AddrCtrl  ;the hidden fantasy "9 world" message
00C5D0  2                      lda #$10
00C5D0  2                      sta ScreenTimer
00C5D0  2                      inc FantasyW9MsgFlag      ;and set flag to keep it from getting printed again
00C5D0  2               NoFW9: lda #$00
00C5D0  2                      sta DisableScreenFlag     ;turn screen back on, move on to next screen sub
00C5D0  2                      jmp NextScreenTask
00C5D0  2               
00C5D0  2               W9GameOver:
00C5D0  2                   lda #$20
00C5D0  2                   sta ScreenTimer
00C5D0  2                   lda #$1e                  ;set VRAM pointer to print world 9 goodbye message
00C5D0  2                   sta VRAM_Buffer_AddrCtrl
00C5D0  2                   jmp NextOperTask          ;move on to next task
00C5D0  2               .endif
00C5D0  2               
00C5D0  2               ScreenSubsForFinalRoom:
00C5D0  2  AD 3C 07         lda ScreenRoutineTask
00C5D3  2  20 rr rr         jsr JumpEngine
00C5D6  2               
00C5D6  2  rr rr            .word InitScreenPalette
00C5D8  2  rr rr            .word WriteTopStatusLine
00C5DA  2  rr rr            .word WriteBottomStatusLine
00C5DC  2  E6 C5            .word DrawFinalRoom
00C5DE  2  rr rr            .word GetAreaPalette
00C5E0  2  rr rr            .word GetBackgroundColor
00C5E2  2               .ifdef ANN
00C5E2  2  F2 C5            .word DoANNThing
00C5E4  2               .endif
00C5E4  2  FB C5            .word RevealPrincess
00C5E6  2               
00C5E6  2               DrawFinalRoom:
00C5E6  2  A9 1B            lda #$1b                   ;draw the princess's room
00C5E8  2  8D 73 07         sta VRAM_Buffer_AddrCtrl
00C5EB  2  8D 22 07         sta IRQUpdateFlag
00C5EE  2               NextScreenTask:
00C5EE  2  EE 3C 07         inc ScreenRoutineTask
00C5F1  2  60               rts
00C5F2  2               
00C5F2  2               .ifdef ANN
00C5F2  2               DoANNThing:
00C5F2  2  A9 1E            lda #$1e
00C5F4  2  8D 73 07         sta VRAM_Buffer_AddrCtrl
00C5F7  2  EE 3C 07         inc ScreenRoutineTask
00C5FA  2  60               rts
00C5FB  2               .endif
00C5FB  2               
00C5FB  2               RevealPrincess:
00C5FB  2  A9 A2            lda #$a2                   ;print game timer
00C5FD  2  20 rr rr         jsr PrintStatusBarNumbers
00C600  2  A9 CC            lda #>AlternateSoundEngine
00C602  2  8D rr rr         sta SoundEngineJSRCode+2      ;change sound engine address
00C605  2  A9 B1            lda #<AlternateSoundEngine ;to run the alt music engine on every NMI
00C607  2  8D rr rr         sta SoundEngineJSRCode+1
00C60A  2  A9 01            lda #$01
00C60C  2  85 FB            sta AreaMusicQueue         ;play the only song available to it
00C60E  2  A9 00            lda #$00                   ;aka the victory music
00C610  2  85 0C            sta $0c                    ;residual, this does nothing
00C612  2  8D 7A 07         sta NameTableSelect
00C615  2  8D 22 07         sta IRQUpdateFlag          ;turn screen back on but without IRQs
00C618  2  8D 74 07         sta DisableScreenFlag
00C61B  2               NextOperTask:
00C61B  2  EE 72 07         inc OperMode_Task
00C61E  2  60               rts
00C61F  2               
00C61F  2               PrintVictoryMsgsForWorld8:
00C61F  2  AD 49 07              lda MsgFractional          ;if fractional not looped to zero
00C622  2  D0 19                 bne IncVMC                 ;then branch to increment it
00C624  2  AC 19 07              ldy MsgCounter
00C627  2  C0 0A                 cpy #$0a                   ;if message counter gone past a certain
00C629  2  B0 24                 bcs EndVictoryMessages     ;point, branch to set timer and stop printing messages
00C62B  2  C8                    iny
00C62C  2  C8                    iny
00C62D  2  C8                    iny                        ;add 3 to message counter to print the messages
00C62E  2  C0 05                 cpy #$05                   ;for world 8 (as opposed to worlds 1-7)
00C630  2  D0 04                 bne PrintVM
00C632  2  A9 04                 lda #VictoryMusic          ;residual code from original smb source, this will not
00C634  2  85 FC                 sta EventMusicQueue        ;be checked due to alternate vector for sound engine
00C636  2  98           PrintVM: tya
00C637  2  18                    clc
00C638  2  69 0C                 adc #$0c                   ;get appropriate range for victory messages
00C63A  2  8D 73 07              sta VRAM_Buffer_AddrCtrl
00C63D  2  AD 49 07     IncVMC:  lda MsgFractional
00C640  2  18                    clc
00C641  2  69 04                 adc #$04                   ;add four to counter's fractional
00C643  2  8D 49 07              sta MsgFractional
00C646  2  AD 19 07              lda MsgCounter             ;add carry to the message counter itself
00C649  2  69 00                 adc #$00
00C64B  2  8D 19 07              sta MsgCounter
00C64E  2  60                    rts
00C64F  2               
00C64F  2               EndVictoryMessages:
00C64F  2  A9 0C                lda #$0c                   ;set interval timer, then move onto next task
00C651  2  8D A1 07             sta WorldEndTimer
00C654  2  EE 72 07     ExAEL:  inc OperMode_Task
00C657  2               
00C657  2               EraseEndingCounters:
00C657  2  A9 00                lda #$00
00C659  2  8D 61 07             sta EndControlCntr
00C65C  2  8D 62 07             sta MRetainerOffset
00C65F  2  8D 63 07             sta CurrentFlashMRet
00C662  2  60           NotYet: rts
00C663  2               
00C663  2               AwardExtraLives:
00C663  2  AD A1 07         lda WorldEndTimer          ;wait until timer expires before running this sub
00C666  2  D0 FA            bne NotYet
00C668  2  AD 5A 07         lda NumberofLives          ;if counted all extra lives, branch
00C66B  2  30 E7            bmi ExAEL                  ;to run another task in victory mode
00C66D  2  AD 80 07         lda SelectTimer
00C670  2  D0 F0            bne NotYet                 ;if short delay between each count of extra lives
00C672  2  A9 30            lda #$30                   ;not expired, wait, otherwise, reset the timer
00C674  2  8D 80 07         sta SelectTimer
00C677  2  A9 40            lda #Sfx_ExtraLife
00C679  2  85 FE            sta Square2SoundQueue
00C67B  2  CE 5A 07         dec NumberofLives          ;count down each extra life
00C67E  2  A9 01            lda #$01                   ;give 100,000 points to player for each one
00C680  2  8D 35 01         sta DigitModifier+1
00C683  2               .ifdef ANN
00C683  2  20 rr rr         jsr EndAreaPoints          ;
00C686  2  AD 08 06         lda AltMusicBuffer         ; for some reason we're checking the alt music buffer?
00C689  2  D0 04            bne @Exit                  ;
00C68B  2  A9 01            lda #1                     ; and if it's empty we queue up some music..
00C68D  2  85 FB            sta AreaMusicQueue         ;
00C68F  2               @Exit:
00C68F  2  60               rts
00C690  2               .else
00C690  2                   jmp EndAreaPoints
00C690  2               .endif
00C690  2               
00C690  2               BlueTransPalette:
00C690  2  3F 00 10         .byte $3f, $00, $10
00C693  2  0F 30 0F 0F      .byte $0f, $30, $0f, $0f, $0f, $30, $10, $00, $0f, $21, $12, $21, $0f, $27, $17, $00
00C697  2  0F 30 10 00  
00C69B  2  0F 21 12 21  
00C6A3  2  00               .byte $00
00C6A4  2               
00C6A4  2               BlueTints:
00C6A4  2  01 02 11 21      .byte $01, $02, $11, $21
00C6A8  2               
00C6A8  2               TwoBlankRows:
00C6A8  2  22 86 55 24      .byte $22, $86, $55, $24
00C6AC  2  22 A6 55 24      .byte $22, $a6, $55, $24
00C6B0  2  00               .byte $00
00C6B1  2               
00C6B1  2               FadeToBlue:
00C6B1  2  EE 61 07               inc EndControlCntr   ;increment a counter
00C6B4  2  AD 63 07               lda BlueDelayFlag    ;if it's time to fade to blue, branch
00C6B7  2  D0 0D                  bne BlueUpdateTiming
00C6B9  2  AD 61 07               lda EndControlCntr
00C6BC  2  29 FF                  and #$ff             ;otherwise wait until counter wraps
00C6BE  2  D0 36                  bne ExFade           ;then set the flag
00C6C0  2  EE 63 07               inc BlueDelayFlag
00C6C3  2  4C CD C6               jmp BlueUpd          ;skip over next part if the flag was just set
00C6C6  2               
00C6C6  2               BlueUpdateTiming:
00C6C6  2  AD 61 07                lda EndControlCntr
00C6C9  2  29 0F                   and #$0f               ;execute the next part only every 16 frames
00C6CB  2  D0 29                   bne ExFade
00C6CD  2  A2 13        BlueUpd:   ldx #$13
00C6CF  2  BD 90 C6     BlueULoop: lda BlueTransPalette,x ;write palette to VRAM buffer
00C6D2  2  9D 01 03                sta VRAM_Buffer1,x
00C6D5  2  CA                      dex
00C6D6  2  10 F7                   bpl BlueULoop
00C6D8  2  A2 0C                   ldx #$0c
00C6DA  2  AC 62 07                ldy BlueColorOfs       ;get color offset
00C6DD  2  B9 A4 C6     NextBlue:  lda BlueTints,y        ;set background color based on color offset
00C6E0  2  9D 04 03                sta VRAM_Buffer1+3,x
00C6E3  2  CA                      dex                    ;be sure to set the same background color
00C6E4  2  CA                      dex                    ;in all four palettes (even though only the first
00C6E5  2  CA                      dex                    ;one is acknowledged)
00C6E6  2  CA                      dex
00C6E7  2  10 F4                   bpl NextBlue
00C6E9  2  EE 62 07                inc BlueColorOfs       ;increment to next color which will show up
00C6EC  2  AD 62 07                lda BlueColorOfs       ;16 frames later, thus causing a slow color change
00C6EF  2  C9 04                   cmp #$04               ;if not changed to last color, leave
00C6F1  2  D0 03                   bne ExFade
00C6F3  2  EE 72 07                inc OperMode_Task      ;otherwise move on to the next task
00C6F6  2  60           ExFade:    rts
00C6F7  2               
00C6F7  2               EraseLivesLines:
00C6F7  2  A2 08             ldx #$08                  ;erase bottom two lines
00C6F9  2  BD A8 C6     ELL: lda TwoBlankRows,x
00C6FC  2  9D 01 03          sta VRAM_Buffer1,x
00C6FF  2  CA                dex
00C700  2  10 F7             bpl ELL
00C702  2  EE 72 07          inc OperMode_Task
00C705  2  20 57 C6          jsr EraseEndingCounters   ;init ending counters
00C708  2  A9 60             lda #$60
00C70A  2  8D 64 07          sta MushroomRetDelay      ;wait before flashing each mushroom retainer in next sub
00C70D  2               .ifdef ANN
00C70D  2  A9 02             lda #$02
00C70F  2  8D 9C 07          sta ANNMushroomRetainerTmp ; mark some value for mushroom retainers?
00C712  2               .endif
00C712  2  60                rts
00C713  2               
00C713  2               RunMushroomRetainers:
00C713  2  20 A4 C7            jsr MushroomRetainersForW8  ;draw and flash the seven mushroom retainers
00C716  2  AD 08 06            lda AltMusicBuffer          ;if still playing victory music, branch to leave
00C719  2  D0 12               bne ExRMR
00C71B  2               .ifdef ANN
00C71B  2  AD 9C 07            lda ANNMushroomRetainerTmp  ; check temporary mushroom retainer value
00C71E  2  F0 05               beq @Done                   ; if zero - skip ahead
00C720  2  A9 01               lda #1                      ; otherwise queue up some music
00C722  2  85 FB               sta AreaMusicQueue          ; weird...
00C724  2  60                  rts                         ; exit
00C725  2               @Done:
00C725  2               .endif
00C725  2  AD FB 07            lda HardWorldFlag           ;if on world D, branch elsewhere
00C728  2  D0 36               bne BackToNormal
00C72A  2  EE 72 07            inc OperMode_Task           ;otherwise just move onto the last task
00C72D  2  60           ExRMR: rts
00C72E  2               
00C72E  2               EndingDiskRoutines:
00C72E  2  AD FC 07         lda DiskIOTask
00C731  2  20 rr rr         jsr JumpEngine
00C734  2               
00C734  2  rr rr            .word DiskScreen
00C736  2  4F C7            .word UpdateGamesBeaten
00C738  2  rr rr            .word WaitForEject
00C73A  2  rr rr            .word WaitForReinsert
00C73C  2  rr rr            .word ResetDiskVars
00C73E  2               
00C73E  2               SaveFileHeader:
00C73E  2  0F 53 4D 32      .byte $0f, "SM2SAVE "
00C742  2  53 41 56 45  
00C746  2  20           
00C747  2               .ifdef ANN
00C747  2  E3 D2            .word $d2e3
00C749  2               .else
00C749  2                   .word $d29f
00C749  2               .endif
00C749  2               
00C749  2  01 00 00         .byte $01, $00, $00
00C74C  2               .ifdef ANN
00C74C  2  E3 D2            .word $d2e3
00C74E  2               .else
00C74E  2                   .word $d29f
00C74E  2               .endif
00C74E  2  00               .byte $00
00C74F  2               
00C74F  2               UpdateGamesBeaten:
00C74F  2  A9 07            lda #$07               ;set file sequential position
00C751  2  20 39 E2         jsr FDSBIOS_WRITEFILE  ;save number of games beaten to SM2SAVE
00C754  2  rr rr            .word DiskIDString
00C756  2  3E C7            .word SaveFileHeader
00C758  2               
00C758  2               ;execution continues here
00C758  2  F0 06            beq BackToNormal       ;if no error, continue
00C75A  2  EE FC 07         inc DiskIOTask         ;otherwise move on to next disk task
00C75D  2  4C rr rr         jmp DiskErrorHandler   ;and jump to disk error handler
00C760  2               
00C760  2               BackToNormal:
00C760  2  A9 rr            lda #>SoundEngine        ;reset sound engine vector
00C762  2  8D rr rr         sta SoundEngineJSRCode+2  ;to run the original one
00C765  2  A9 rr            lda #<SoundEngine
00C767  2  8D rr rr         sta SoundEngineJSRCode+1
00C76A  2  A9 00            lda #$00
00C76C  2  8D FC 07         sta DiskIOTask           ;erase task numbers
00C76F  2  8D 72 07         sta OperMode_Task
00C772  2               .ifdef ANN
00C772  2  A9 00            lda #$00
00C774  2  8D 70 07         sta OperMode
00C777  2  4C rr rr         jmp AttractModeSubs
00C77A  2               .else
00C77A  2                   lda HardWorldFlag        ;if in world D, branch to end the game
00C77A  2                   bne EndTheGame
00C77A  2                   lda CompletedWorlds      ;if completed all worlds without skipping over any
00C77A  2                   cmp #$ff                 ;then branch elsewhere (note warping backwards may
00C77A  2                   beq GoToWorld9           ;allow player to complete skipped worlds)
00C77A  2               EndTheGame:
00C77A  2                   lda #$00
00C77A  2                   sta CompletedWorlds      ;init completed worlds flag, go back to title screen mode
00C77A  2                   sta OperMode
00C77A  2                   jmp AttractModeSubs      ;jump to title screen mode routines
00C77A  2               GoToWorld9:
00C77A  2                   lda #$00
00C77A  2                   sta CompletedWorlds      ;init completed worlds flag
00C77A  2                   sta NumberofLives        ;give the player one life
00C77A  2                   sta FantasyW9MsgFlag
00C77A  2                   jmp NextWorld            ;run world 9
00C77A  2               .endif
00C77A  2               
00C77A  2               FlashMRSpriteDataOfs:
00C77A  2  50 B0 E0 68      .byte $50, $b0, $e0, $68, $98, $c8
00C77E  2  98 C8        
00C780  2               
00C780  2               MRSpriteDataOfs:
00C780  2  80 50 68 80      .byte $80, $50, $68, $80, $98, $b0, $c8
00C784  2  98 B0 C8     
00C787  2               
00C787  2               MRetainerYPos:
00C787  2  E0 B8 90 70      .byte $e0, $b8, $90, $70, $68, $70, $90
00C78B  2  68 70 90     
00C78E  2               
00C78E  2               MRetainerXPos:
00C78E  2  B8 38 48 60      .byte $b8, $38, $48, $60, $80, $a0, $b8, $c8
00C792  2  80 A0 B8 C8  
00C796  2               
00C796  2               .ifdef ANN
00C796  2               ANNMRetainerTiles:
00C796  2  7A 80 86 8C      .byte $7A,$80,$86,$8C,$92,$98,$9E
00C79A  2  92 98 9E     
00C79D  2               ANNMRetainerAttr:
00C79D  2  02 03 01 02      .byte $02,$03,$01,$02,$03,$01,$03
00C7A1  2  03 01 03     
00C7A4  2               .endif
00C7A4  2               
00C7A4  2               MushroomRetainersForW8:
00C7A4  2  AD 64 07         lda MushroomRetDelay        ;wait a bit unless waiting is already done
00C7A7  2  F0 04            beq DrawFlashMRetainers
00C7A9  2  CE 64 07         dec MushroomRetDelay
00C7AC  2  60               rts
00C7AD  2               
00C7AD  2               DrawFlashMRetainers:
00C7AD  2  20 rr rr         jsr MoveSpritesOffscreen   ;init sprites
00C7B0  2  AE 62 07         ldx MRetainerOffset
00C7B3  2  E0 07            cpx #$07                   ;if 7 mushroom retainers added, branch elsewhere
00C7B5  2  F0 11            beq FlashMRetainers
00C7B7  2  AD 61 07         lda EndControlCntr
00C7BA  2  29 1F            and #$1f                   ;execute this part once every 32 frames
00C7BC  2  D0 20            bne DrawMRetainers
00C7BE  2  EE 62 07         inc MRetainerOffset        ;add another mushroom retainer
00C7C1  2  A9 01            lda #Sfx_CoinGrab
00C7C3  2  85 FE            sta Square2SoundQueue      ;play the coin grab sound
00C7C5  2  4C DE C7         jmp DrawMRetainers
00C7C8  2               
00C7C8  2               FlashMRetainers:
00C7C8  2  AD 61 07         lda EndControlCntr
00C7CB  2  29 1F            and #$1f                   ;execute this part once every 32 frames also
00C7CD  2  D0 0F            bne DrawMRetainers         ;after the counter reaches a certain point
00C7CF  2  EE 63 07         inc CurrentFlashMRet
00C7D2  2  AD 63 07         lda CurrentFlashMRet       ;increment what's now being used to select a
00C7D5  2  C9 0B            cmp #$0b                   ;mushroom retainer to flash, if not yet at $0b/11
00C7D7  2  90 05            bcc DrawMRetainers         ;then go ahead to next part
00C7D9  2  A9 04            lda #$04
00C7DB  2  8D 63 07         sta CurrentFlashMRet       ;otherwise reset to 4
00C7DE  2               DrawMRetainers:
00C7DE  2  EE 61 07         inc EndControlCntr         ;be sure to count frames
00C7E1  2               .ifndef ANN
00C7E1  2                   lda WorldNumber
00C7E1  2                   pha                        ;save world number and initial retainer offset
00C7E1  2               .endif
00C7E1  2  AD 62 07         lda MRetainerOffset
00C7E4  2  48               pha
00C7E5  2  AA               tax                        ;use second counter as offset to one of the spr data offset lists
00C7E6  2               DrawMRetLoop:
00C7E6  2  AD 63 07         lda CurrentFlashMRet       ;if offset not yet at 4 (first time it starts at 0), branch to skip this
00C7E9  2  C9 04            cmp #$04                   ;thus adding a delay between the appearance
00C7EB  2  90 0B            bcc SetupMRet              ;of mushroom retainers and their "flashing"
00C7ED  2  E9 04            sbc #$04
00C7EF  2  A8               tay                        ;otherwise subtract 4 to get the offset proper
00C7F0  2  B9 7A C7         lda FlashMRSpriteDataOfs,y ;if the sprite obj data offset pointed at by the current flashing retainer
00C7F3  2  DD 80 C7         cmp MRSpriteDataOfs,x      ;matches the one pointed at by the offset of the retainer being checked
00C7F6  2  F0 57            beq NextMRet               ;then branch to skip, do not draw that mushroom retainer
00C7F8  2               SetupMRet:
00C7F8  2  BC 80 C7         ldy MRSpriteDataOfs,x      ;get sprite data offset of the current mushroom retainer
00C7FB  2               .ifndef ANN
00C7FB  2                   sty Enemy_SprDataOffset
00C7FB  2                   lda #$35
00C7FB  2                   sta $16                    ;set mushroom retainer object ID
00C7FB  2               .endif
00C7FB  2  BD 87 C7         lda MRetainerYPos,x
00C7FE  2               .ifdef ANN
00C7FE  2  99 00 02         sta Sprite_Y_Position+0,y
00C801  2  99 0C 02         sta Sprite_Y_Position+12,y
00C804  2  18               clc
00C805  2  69 08            adc #$8
00C807  2  99 04 02         sta Sprite_Y_Position+4,y
00C80A  2  99 10 02         sta Sprite_Y_Position+16,y
00C80D  2  18               clc
00C80E  2  69 08            adc #$8
00C810  2  99 08 02         sta Sprite_Y_Position+8,y
00C813  2  99 14 02         sta Sprite_Y_Position+20,y
00C816  2  BD 8E C7         lda MRetainerXPos,x
00C819  2  99 03 02         sta Sprite_X_Position+0,y
00C81C  2  99 07 02         sta Sprite_X_Position+4,y
00C81F  2  99 0B 02         sta Sprite_X_Position+8,y
00C822  2  18               clc
00C823  2  69 08            adc #8
00C825  2  99 0F 02         sta Sprite_X_Position+12,y
00C828  2  99 13 02         sta Sprite_X_Position+16,y
00C82B  2  99 17 02         sta Sprite_X_Position+20,y
00C82E  2  BD 95 C7         lda ANNMRetainerTiles-1,x
00C831  2  85 00            sta $00
00C833  2  BD 9C C7         lda ANNMRetainerAttr-1,x
00C836  2  85 01            sta $01
00C838  2  A2 00            ldx #$00
00C83A  2  A5 00        :   lda $00
00C83C  2  99 01 02         sta Sprite_Tilenumber,y
00C83F  2  A5 01            lda $01
00C841  2  99 02 02         sta Sprite_Attributes,y
00C844  2  C8               iny
00C845  2  C8               iny
00C846  2  C8               iny
00C847  2  C8               iny
00C848  2  E6 00            inc $00
00C84A  2  E8               inx
00C84B  2  E0 06            cpx #$06
00C84D  2  D0 EB            bne :-
00C84F  2               .else
00C84F  2                   sta Enemy_Y_Position       ;use enemy object 0 for mushroom retainer temporarily
00C84F  2                   lda MRetainerXPos,x
00C84F  2                   sta Enemy_Rel_XPos
00C84F  2                   ldx #$00                   ;set world number and object offset for the graphics handler
00C84F  2                   stx WorldNumber            ;to prevent graphics handler from drawing princess instead
00C84F  2                   stx ObjectOffset
00C84F  2                   jsr EnemyGfxHandler        ;now draw the mushroom retainer
00C84F  2               .endif
00C84F  2               NextMRet:
00C84F  2  CE 62 07         dec MRetainerOffset        ;move to next mushroom retainer using offset
00C852  2  AE 62 07         ldx MRetainerOffset
00C855  2  D0 8F            bne DrawMRetLoop           ;if not drawn all retainers yet, loop to do so
00C857  2  68               pla
00C858  2  8D 62 07         sta MRetainerOffset        ;reset initial offset
00C85B  2               .ifndef ANN
00C85B  2                   pla
00C85B  2                   sta WorldNumber            ;return world number to what it was to draw princess
00C85B  2               .endif
00C85B  2  A9 30            lda #$30
00C85D  2  8D E5 06         sta Enemy_SprDataOffset
00C860  2  A9 B8            lda #$b8                   ;return original settings princess uses (note X position
00C862  2  85 CF            sta Enemy_Y_Position       ;will be returned later in enemy object core)
00C864  2  60               rts
00C865  2               
00C865  2               EndPlayerNameData:
00C865  2  16 0A 1B 12      .byte $16, $0a, $1b, $12, $18
00C869  2  18           
00C86A  2  15 1E 12 10      .byte $15, $1e, $12, $10, $12
00C86E  2  12           
00C86F  2               
00C86F  2               WriteNameToVictoryMsg:
00C86F  2  A9 00                lda #$00
00C871  2  8D 3C 07             sta ScreenRoutineTask    ;init screen routine task
00C874  2  A2 04                ldx #$04
00C876  2  AD 53 07             lda SelectedPlayer       ;check selected player
00C879  2  F0 02                beq SNameL               ;if mario, use by default
00C87B  2  A2 09                ldx #$09                 ;otherwise use luigi's name
00C87D  2  A0 04        SNameL: ldy #$04
00C87F  2  BD 65 C8     VMsgNL: lda EndPlayerNameData,x
00C882  2  99 B7 C8             sta ThankYouMessageFinal+13,y  ;overwrite name of player in two
00C885  2  99 FC C8             sta HurrahMsg+14,y             ;of the victory messages
00C888  2  CA                   dex
00C889  2  88                   dey
00C88A  2  10 F3                bpl VMsgNL
00C88C  2  60                   rts
00C88D  2               
00C88D  2               ;-------------------------------------------------------------------------------------
00C88D  2               
00C88D  2               UnusedAttribData:
00C88D  2  23 C0 48 55      .byte $23, $c0, $48, $55
00C891  2  23 C2 01 D5      .byte $23, $c2, $01, $d5
00C895  2  00               .byte $00
00C896  2               
00C896  2               FinalRoomPalette:
00C896  2  3F 00 10         .byte $3f, $00, $10
00C899  2  0F 0F 0F 0F      .byte $0f, $0f, $0f, $0f, $0f, $30, $10, $00
00C89D  2  0F 30 10 00  
00C8A1  2  0F 21 12 02      .byte $0f, $21, $12, $02, $0f, $27, $17, $00
00C8A5  2  0F 27 17 00  
00C8A9  2  00               .byte $00
00C8AA  2               
00C8AA  2               ThankYouMessageFinal:
00C8AA  2  20 E8 10         .byte $20, $e8, $10
00C8AD  2  1D 11 0A 17      .byte $1d, $11, $0a, $17, $14, $24, $22, $18, $1e, $24
00C8B1  2  14 24 22 18  
00C8B5  2  1E 24        
00C8B7  2  16 0A 1B 12      .byte $16, $0a, $1b, $12, $18, $2b
00C8BB  2  18 2B        
00C8BD  2               
00C8BD  2  23 C8 48 05      .byte $23, $c8, $48, $05
00C8C1  2  00               .byte $00
00C8C2  2               
00C8C2  2               PeaceIsPavedMsg:
00C8C2  2  21 09 0E         .byte $21, $09, $0e
00C8C5  2  19 0E 0A 0C      .byte $19, $0e, $0a, $0c, $0e, $24, $12, $1c, $24
00C8C9  2  0E 24 12 1C  
00C8CD  2  24           
00C8CE  2  19 0A 1F 0E      .byte $19, $0a, $1f, $0e, $0d
00C8D2  2  0D           
00C8D3  2  23 D0 58 AA      .byte $23, $d0, $58, $aa
00C8D7  2  00               .byte $00
00C8D8  2               
00C8D8  2               WithKingdomSavedMsg:
00C8D8  2  21 47 12         .byte $21, $47, $12
00C8DB  2  20 12 1D 11      .byte $20, $12, $1d, $11, $24, $14, $12, $17, $10, $0d, $18, $16, $24
00C8DF  2  24 14 12 17  
00C8E3  2  10 0D 18 16  
00C8E8  2  1C 0A 1F 0E      .byte $1c, $0a, $1f, $0e, $0d
00C8EC  2  0D           
00C8ED  2  00               .byte $00
00C8EE  2               
00C8EE  2               HurrahMsg:
00C8EE  2  21 89 10         .byte $21, $89, $10
00C8F1  2  11 1E 1B 1B      .byte $11, $1e, $1b, $1b, $0a, $11, $24, $1d, $18, $24, $24, $16, $0a
00C8F5  2  0A 11 24 1D  
00C8F9  2  18 24 24 16  
00C8FE  2  1B 12 18         .byte $1b, $12, $18
00C901  2  00               .byte $00
00C902  2               
00C902  2               OurOnlyHeroMsg:
00C902  2  21 CA 0D         .byte $21, $ca, $0d
00C905  2  18 1E 1B 24      .byte $18, $1e, $1b, $24, $18, $17, $15, $22, $24, $11, $0e, $1b, $18
00C909  2  18 17 15 22  
00C90D  2  24 11 0E 1B  
00C912  2  00               .byte $00
00C913  2               
00C913  2               ThisEndsYourTripMsg:
00C913  2  22 07 13         .byte $22, $07, $13
00C916  2  1D 11 12 1C      .byte $1d, $11, $12, $1c, $24, $0e, $17, $0d, $1c, $24, $22, $18, $1e
00C91A  2  24 0E 17 0D  
00C91E  2  1C 24 22 18  
00C923  2  1B 24 1D 1B      .byte $1b, $24, $1d, $1b, $12, $19
00C927  2  12 19        
00C929  2  00               .byte $00
00C92A  2               
00C92A  2               OfALongFriendshipMsg:
00C92A  2  22 46 14         .byte $22, $46, $14
00C92D  2  18 0F 24 0A      .byte $18, $0f, $24, $0a, $24, $15, $18, $17, $10, $24, $0f, $1b, $12
00C931  2  24 15 18 17  
00C935  2  10 24 0F 1B  
00C93A  2  0E 17 0D 1C      .byte $0e, $17, $0d, $1c, $11, $12, $19
00C93E  2  11 12 19     
00C941  2  00               .byte $00
00C942  2               
00C942  2               PointsAddedMsg:
00C942  2  22 88 10         .byte $22, $88, $10
00C945  2  01 00 00 00      .byte $01, $00, $00, $00, $00, $00, $24, $19, $1d, $1c, $af, $0a, $0d
00C949  2  00 00 24 19  
00C94D  2  1D 1C AF 0A  
00C952  2  0D 0E 0D         .byte $0d, $0e, $0d
00C955  2               
00C955  2  23 E8 48 FF      .byte $23, $e8, $48, $ff
00C959  2  00               .byte $00
00C95A  2               
00C95A  2               ForEachPlayerLeftMsg:
00C95A  2  22 A6 15         .byte $22, $a6, $15
00C95D  2  0F 18 1B 24      .byte $0f, $18, $1b, $24, $0e, $0a, $0c, $11, $24, $19, $15, $0a, $22
00C961  2  0E 0A 0C 11  
00C965  2  24 19 15 0A  
00C96A  2  0E 1B 24 15      .byte $0e, $1b, $24, $15, $0e, $0f, $1d, $af
00C96E  2  0E 0F 1D AF  
00C972  2  00               .byte $00
00C973  2               
00C973  2               .ifdef ANN
00C973  2               ANNEndingPalette:
00C973  2  3F 14 0C     .byte $3F,$14,$0C
00C976  2  0F 12 30 36  .byte $0F,$12,$30,$36,$0F,$36
00C97A  2  0F 36        
00C97C  2  30 16 0F 36  .byte $30,$16,$0F,$36,$30,$1A
00C980  2  30 1A        
00C982  2  00           .byte $00
00C983  2               .endif
00C983  2               
00C983  2               PrincessPeachsRoom:
00C983  2  20 80 60 5E      .byte $20, $80, $60, $5e
00C987  2  20 A0 60 5D      .byte $20, $a0, $60, $5d
00C98B  2  23 40 60 5E      .byte $23, $40, $60, $5e
00C98F  2  23 60 60 5D      .byte $23, $60, $60, $5d
00C993  2  23 80 60 5E      .byte $23, $80, $60, $5e
00C997  2  23 A0 60 5D      .byte $23, $a0, $60, $5d
00C99B  2  23 C0 50 55      .byte $23, $c0, $50, $55
00C99F  2  23 F0 50 55      .byte $23, $f0, $50, $55
00C9A3  2  00               .byte $00
00C9A4  2               
00C9A4  2               .ifdef ANN
00C9A4  2               ;; unused bytes
00C9A4  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C9A8  2  FF FF FF FF  
00C9AC  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C9B0  2  FF FF FF FF  
00C9B4  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C9B8  2  FF FF FF FF  
00C9BC  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C9C0  2  FF FF FF FF  
00C9C4  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C9C8  2  FF FF FF FF  
00C9CC  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C9D0  2  FF FF FF FF  
00C9D4  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C9D8  2  FF FF FF FF  
00C9DC  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C9E0  2  FF FF FF FF  
00C9E4  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C9E8  2  FF FF FF FF  
00C9EC  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C9F0  2  FF FF FF FF  
00C9F4  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C9F8  2  FF FF FF FF  
00C9FC  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CA00  2  FF FF FF FF  
00CA04  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CA08  2  FF FF FF FF  
00CA0C  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CA10  2  FF FF FF FF  
00CA14  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CA18  2  FF FF FF FF  
00CA1C  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CA20  2  FF FF FF FF  
00CA24  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CA28  2  FF FF FF FF  
00CA2C  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CA30  2  FF FF FF FF  
00CA34  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CA38  2  FF FF FF FF  
00CA3C  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CA40  2  FF FF FF FF  
00CA44  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CA48  2  FF FF FF FF  
00CA4C  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CA50  2  FF FF FF FF  
00CA54  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CA58  2  FF FF FF FF  
00CA5C  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CA60  2  FF FF FF FF  
00CA64  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CA68  2  FF FF FF FF  
00CA6C  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CA70  2  FF FF FF FF  
00CA74  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CA78  2  FF FF FF FF  
00CA7C  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CA80  2  FF FF FF FF  
00CA84  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CA88  2  FF FF FF FF  
00CA8C  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CA90  2  FF FF FF FF  
00CA94  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CA98  2  FF FF FF FF  
00CA9C  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CAA0  2  FF FF FF FF  
00CAA4  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CAA8  2  FF FF FF FF  
00CAAC  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CAB0  2  FF FF FF FF  
00CAB4  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CAB8  2  FF FF FF FF  
00CABC  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CAC0  2  FF FF FF FF  
00CAC4  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CAC8  2  FF FF FF FF  
00CACC  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CAD0  2  FF FF FF FF  
00CAD4  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CAD8  2  FF FF FF FF  
00CADC  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CAE0  2  FF FF FF FF  
00CAE4  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CAE8  2  FF FF FF FF  
00CAEC  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CAF0  2  FF FF FF FF  
00CAF4  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CAF8  2  FF FF FF FF  
00CAFC  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CB00  2  FF FF FF FF  
00CB04  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CB08  2  FF FF FF FF  
00CB0C  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CB10  2  FF FF FF FF  
00CB14  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CB18  2  FF FF FF FF  
00CB1C  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CB20  2  FF FF FF FF  
00CB24  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CB28  2  FF FF FF FF  
00CB2C  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CB30  2  FF FF FF FF  
00CB34  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CB38  2  FF FF FF FF  
00CB3C  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CB40  2  FF FF FF FF  
00CB44  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CB48  2  FF FF FF FF  
00CB4C  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CB50  2  FF FF FF FF  
00CB54  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CB58  2  FF FF FF FF  
00CB5C  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CB60  2  FF FF FF FF  
00CB64  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CB68  2  FF FF FF FF  
00CB6C  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CB70  2  FF FF FF FF  
00CB74  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CB78  2  FF FF FF FF  
00CB7C  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CB80  2  FF FF FF FF  
00CB84  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CB88  2  FF FF FF FF  
00CB8C  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CB90  2  FF FF FF FF  
00CB94  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CB98  2  FF FF FF FF  
00CB9C  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CBA0  2  FF FF FF FF  
00CBA4  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CBA8  2  FF FF FF FF  
00CBAC  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CBB0  2  FF FF FF FF  
00CBB4  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CBB8  2  FF FF FF FF  
00CBBC  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CBC0  2  FF FF FF FF  
00CBC4  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CBC8  2  FF FF FF FF  
00CBCC  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CBD0  2  FF FF FF FF  
00CBD4  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CBD8  2  FF FF FF FF  
00CBDC  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CBE0  2  FF FF FF FF  
00CBE4  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CBE8  2  FF FF FF FF  
00CBEC  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CBF0  2  FF FF FF FF  
00CBF4  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CBF8  2  FF FF FF FF  
00CBFC  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CC00  2  FF FF FF FF  
00CC04  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CC08  2  FF FF FF FF  
00CC0C  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CC10  2  FF FF FF FF  
00CC14  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CC18  2  FF FF FF FF  
00CC1C  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CC20  2  FF FF FF FF  
00CC24  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CC28  2  FF FF FF FF  
00CC2C  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CC30  2  FF FF FF FF  
00CC34  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CC38  2  FF FF FF FF  
00CC3C  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CC40  2  FF FF FF FF  
00CC44  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CC48  2  FF FF FF FF  
00CC4C  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CC50  2  FF FF FF FF  
00CC54  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CC58  2  FF FF FF FF  
00CC5C  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CC60  2  FF FF FF FF  
00CC64  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CC68  2  FF FF FF FF  
00CC6C  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CC70  2  FF FF FF FF  
00CC74  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CC78  2  FF FF FF FF  
00CC7C  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CC80  2  FF FF FF FF  
00CC84  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CC88  2  FF FF FF FF  
00CC8C  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CC90  2  FF FF FF FF  
00CC94  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CC98  2  FF FF FF FF  
00CC9C  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CCA0  2  FF FF FF FF  
00CCA4  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00CCA8  2  FF FF FF FF  
00CCAC  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF
00CCB0  2  FF           
00CCB1  2               .else
00CCB1  2               FantasyWorld9Msg:
00CCB1  2                   .byte $22, $24, $18
00CCB1  2                   .byte $20, $0e, $24, $19, $1b, $0e, $1c, $0e, $17, $1d, $24, $0f, $0a
00CCB1  2                   .byte $17, $1d, $0a, $1c, $22, $24, $20, $18, $1b, $15, $0d
00CCB1  2               
00CCB1  2                   .byte $22, $66, $13
00CCB1  2                   .byte $15, $0e, $1d, $f2, $1c, $24, $1d, $1b, $22, $24, $76, $09, $24
00CCB1  2                   .byte $20, $18, $1b, $15, $0d, $75
00CCB1  2               
00CCB1  2                   .byte $22, $a9, $0e
00CCB1  2                   .byte $20, $12, $1d, $11, $24, $18, $17, $0e, $24, $10, $0a, $16, $0e
00CCB1  2                   .byte $af
00CCB1  2                   .byte $00
00CCB1  2               
00CCB1  2               SuperPlayerMsg:
00CCB1  2                   .byte $21, $e0, $60, $24
00CCB1  2                   .byte $22, $40, $60, $24
00CCB1  2                   .byte $22, $25, $16
00CCB1  2                   .byte $22, $18, $1e, $f2, $1b, $0e, $24, $0a, $24, $1c, $1e, $19, $0e
00CCB1  2                   .byte $1b, $24, $19, $15, $0a, $22, $0e, $1b, $2b
00CCB1  2                   .byte $22, $69, $0d
00CCB1  2                   .byte $20, $0e, $24, $11, $18, $19, $0e, $24, $20, $0e, $f2, $15, $15
00CCB1  2                   .byte $22, $a9, $0e
00CCB1  2                   .byte $1c, $0e, $0e, $24, $22, $18, $1e, $24, $0a, $10, $0a, $12, $17
00CCB1  2                   .byte $af
00CCB1  2                   .byte $22, $e8, $10
00CCB1  2                   .byte $16, $0a, $1b, $12, $18, $24, $0a, $17, $0d, $24, $1c, $1d, $0a
00CCB1  2                   .byte $0f, $0f, $af
00CCB1  2                   .byte $00
00CCB1  2               
00CCB1  2               ;-------------------------------------------------------------------------------------
00CCB1  2               
00CCB1  2               ; unused space
00CCB1  2               .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
00CCB1  2               .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
00CCB1  2               .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
00CCB1  2               .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
00CCB1  2               .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
00CCB1  2               .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
00CCB1  2               .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
00CCB1  2               
00CCB1  2               ;level 9-3
00CCB1  2               E_CastleArea9:
00CCB1  2                   .byte $1f, $01, $0e, $69, $00, $1f, $0b, $78, $2d, $ff
00CCB1  2               
00CCB1  2               ;cloud level used in level 9-3
00CCB1  2               E_CastleArea10:
00CCB1  2                   .byte $1f, $01, $1e, $68, $06, $ff
00CCB1  2               
00CCB1  2               ;level 9-1 starting area
00CCB1  2               E_GroundArea25:
00CCB1  2                   .byte $1e, $05, $00, $ff
00CCB1  2               
00CCB1  2               ;two unused levels that have the same enemy data address as a used level
00CCB1  2               E_GroundArea26:
00CCB1  2               E_GroundArea27:
00CCB1  2               
00CCB1  2               ;level 9-1 water area
00CCB1  2               E_WaterArea6:
00CCB1  2                   .byte $26, $8f, $05, $ac, $46, $0f, $1f, $04, $e8, $10, $38, $90, $66, $11, $fb, $3c
00CCB1  2                   .byte $9b, $b7, $cb, $85, $29, $87, $95, $07, $eb, $02, $0b, $82, $96, $0e, $c3, $0e
00CCB1  2                   .byte $ff
00CCB1  2               
00CCB1  2               ;level 9-2
00CCB1  2               E_WaterArea7:
00CCB1  2                   .byte $1f, $01, $e6, $11, $ff
00CCB1  2               
00CCB1  2               ;level 9-4
00CCB1  2               E_WaterArea8:
00CCB1  2                   .byte $3b, $86, $7b, $00, $bb, $02, $2b, $8e, $7a, $05, $57, $87, $27, $8f, $9a, $0c
00CCB1  2                   .byte $ff
00CCB1  2               
00CCB1  2               ;level 9-3
00CCB1  2               L_CastleArea9:
00CCB1  2                   .byte $55, $31, $0d, $01, $cf, $33, $fe, $39, $fe, $b2, $2e, $be, $fe, $31, $29, $8f
00CCB1  2                   .byte $9e, $43, $fe, $30, $16, $b1, $23, $09, $4e, $31, $4e, $40, $d7, $e0, $e6, $61
00CCB1  2                   .byte $fe, $3e, $f5, $62, $fa, $60, $0c, $df, $0c, $df, $0c, $d1, $1e, $3c, $2d, $40
00CCB1  2                   .byte $4e, $32, $5e, $36, $5e, $42, $ce, $38, $0d, $0b, $8e, $36, $8e, $40, $87, $37
00CCB1  2                   .byte $96, $36, $be, $3a, $cc, $5d, $06, $bd, $07, $3e, $a8, $64, $b8, $64, $c8, $64
00CCB1  2                   .byte $d8, $64, $e8, $64, $f8, $64, $fe, $31, $09, $e1, $1a, $60, $6d, $41, $9f, $26
00CCB1  2                   .byte $7d, $c7, $fd
00CCB1  2               
00CCB1  2               ;cloud level used by level 9-3
00CCB1  2               L_CastleArea10:
00CCB1  2                   .byte $00, $f1, $fe, $b5, $0d, $02, $fe, $34, $07, $cf, $ce, $00, $0d, $05, $8d, $47
00CCB1  2                   .byte $fd
00CCB1  2               
00CCB1  2               ;level 9-1 starting area
00CCB1  2               L_GroundArea25:
00CCB1  2                   .byte $50, $02, $9f, $38, $ee, $01, $12, $b9, $77, $7b, $de, $0f, $6d, $c7, $fd
00CCB1  2               
00CCB1  2               ;two unused levels
00CCB1  2               L_GroundArea26:
00CCB1  2                   .byte $fd
00CCB1  2               L_GroundArea27:
00CCB1  2                   .byte $fd
00CCB1  2               
00CCB1  2               ;level 9-1 water area
00CCB1  2               L_WaterArea6:
00CCB1  2                   .byte $00, $a1, $0a, $60, $19, $61, $28, $62, $39, $71, $58, $62, $69, $61, $7a, $60
00CCB1  2                   .byte $7c, $f5, $a5, $11, $fe, $20, $1f, $80, $5e, $21, $80, $3f, $8f, $65, $d6, $74
00CCB1  2                   .byte $5e, $a0, $6f, $66, $9e, $21, $c3, $37, $47, $f3, $9e, $20, $fe, $21, $0d, $06
00CCB1  2                   .byte $57, $32, $64, $11, $66, $10, $83, $a7, $87, $27, $0d, $09, $1d, $4a, $5f, $38
00CCB1  2                   .byte $6d, $c1, $af, $26, $6d, $c7, $fd
00CCB1  2               
00CCB1  2               ;level 9-2
00CCB1  2               L_WaterArea7:
00CCB1  2                   .byte $50, $11, $d7, $73, $fe, $1a, $6f, $e2, $1f, $e5, $bf, $63, $c7, $a8, $df, $61
00CCB1  2                   .byte $15, $f1, $7f, $62, $9b, $2f, $a8, $72, $fe, $10, $69, $f1, $b7, $25, $c5, $71
00CCB1  2                   .byte $33, $ac, $5f, $71, $8d, $4a, $aa, $14, $d1, $71, $17, $95, $26, $42, $72, $42
00CCB1  2                   .byte $73, $12, $7a, $14, $c6, $14, $d5, $42, $fe, $11, $7f, $b8, $8d, $c1, $cf, $26
00CCB1  2                   .byte $6d, $c7, $fd
00CCB1  2               
00CCB1  2               ;level 9-4
00CCB1  2               L_WaterArea8:
00CCB1  2                   .byte $57, $00, $0b, $3f, $0b, $bf, $0b, $bf, $73, $36, $9a, $30, $a5, $64, $b6, $31
00CCB1  2                   .byte $d4, $61, $0b, $bf, $13, $63, $4a, $60, $53, $66, $a5, $34, $b3, $67, $e5, $65
00CCB1  2                   .byte $f4, $60, $0b, $bf, $14, $60, $53, $67, $67, $32, $c4, $62, $d4, $31, $f3, $61
00CCB1  2                   .byte $fa, $60, $0b, $bf, $04, $30, $09, $61, $14, $65, $63, $65, $6a, $60, $0b, $bf
00CCB1  2                   .byte $0f, $38, $0b, $bf, $1d, $41, $3e, $42, $5f, $20, $ce, $40, $0b, $bf, $3d, $47
00CCB1  2                   .byte $fd
00CCB1  2               
00CCB1  2               ;-------------------------------------------------------------------------------------
00CCB1  2               
00CCB1  2               ; unused space
00CCB1  2               
00CCB1  2               .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
00CCB1  2               .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
00CCB1  2               .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
00CCB1  2               .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
00CCB1  2               
00CCB1  2               AlternateSoundEngine:
00CCB1  2                   lda GamePauseStatus     ;check to see if game is paused
00CCB1  2                   beq RunAltSoundRoutines ;branch to play sfx and music if not
00CCB1  2                   lda #$80
00CCB1  2                   sta FDSSND_VOLUMECTRL   ;otherwise, silence everything
00CCB1  2                   lsr
00CCB1  2                   sta SND_MASTERCTRL_REG
00CCB1  2                   rts
00CCB1  2               .endif
00CCB1  2               
00CCB1  2               .ifdef ANN
00CCB1  2               AlternateSoundEngine:
00CCB1  2               .endif
00CCB1  2               RunAltSoundRoutines:
00CCB1  2  A9 FF            lda #$ff                ;disable irqs from apu and set frame counter mode
00CCB3  2  8D 17 40         sta JOYPAD_PORT2
00CCB6  2  A9 0F            lda #$0f
00CCB8  2  8D 15 40         sta SND_MASTERCTRL_REG  ;enable first four channels
00CCBB  2  20 rr rr         jsr Square2SfxHandler   ;play sfx on square channel 2
00CCBE  2  20 CB CC         jsr AltMusicHandler
00CCC1  2  A9 00            lda #$00
00CCC3  2  85 FB            sta AreaMusicQueue
00CCC5  2  85 FE            sta Square2SoundQueue
00CCC7  2  60               rts
00CCC8  2               
00CCC8  2               ContinueMusic:
00CCC8  2  4C 44 CD         jmp HandleSquare2Music
00CCCB  2               
00CCCB  2               AltMusicHandler:
00CCCB  2  A5 FB            lda AreaMusicQueue
00CCCD  2  D0 06            bne PlayMusic
00CCCF  2  AD 08 06         lda AltMusicBuffer
00CCD2  2  D0 F4            bne ContinueMusic
00CCD4  2  60               rts
00CCD5  2               
00CCD5  2               PlayMusic:
00CCD5  2  A0 00            ldy #$00                ;init song pattern number
00CCD7  2  8C 1D 06         sty PatternNumber
00CCDA  2  8D 08 06         sta AltMusicBuffer      ;dump queue contents into buffer
00CCDD  2               NextPattern:
00CCDD  2  EE 1D 06         inc PatternNumber
00CCE0  2  AC 1D 06         ldy PatternNumber
00CCE3  2  C0 0C            cpy #$0c
00CCE5  2  D0 03            bne LoadPatternHeader
00CCE7  2  4C 5C CD         jmp StopMusic
00CCEA  2               
00CCEA  2               LoadPatternHeader:
00CCEA  2  B9 F9 CF         lda MusicHeaderOffsetData-1,y  ;load pattern header offset using an address
00CCED  2  A8               tay                            ;one byte behind (because Y starts at 1)
00CCEE  2  B9 FA CF         lda MusicHeaderData-$b,y
00CCF1  2  8D 09 06         sta NoteLengthTblAdder
00CCF4  2  B9 FB CF         lda MusicHeaderData-$a,y       ;now load the pattern header data using addresses
00CCF7  2  85 66            sta MusicDataLow               ;that are relative of where the offset data is
00CCF9  2  B9 FC CF         lda MusicHeaderData-9,y        ;plus the offset data itself that was loaded
00CCFC  2  85 67            sta MusicDataHigh
00CCFE  2  B9 FD CF         lda MusicHeaderData-8,y
00CD01  2  8D 0C 06         sta MusicOffset_Triangle
00CD04  2  B9 FE CF         lda MusicHeaderData-7,y
00CD07  2  8D 0B 06         sta MusicOffset_Square1
00CD0A  2  B9 FF CF         lda MusicHeaderData-6,y
00CD0D  2  8D 0D 06         sta MusicOffset_Noise
00CD10  2  8D 1B 06         sta NoiseDataLoopbackOfs
00CD13  2  B9 00 D0         lda MusicHeaderData-5,y
00CD16  2  8D 1F 06         sta MusicOffset_FDSSND
00CD19  2  B9 01 D0         lda MusicHeaderData-4,y
00CD1C  2  8D 0E 06         sta WaveformID                 ;value here is not used, but retained (probably for testing)
00CD1F  2  85 01            sta $01
00CD21  2  20 30 CF         jsr ProcessWaveformData
00CD24  2  A9 01            lda #$01                       ;init note length counters
00CD26  2  8D 11 06         sta Squ2_NoteLenCounter
00CD29  2  8D 13 06         sta Squ1_NoteLenCounter
00CD2C  2  8D 16 06         sta Tri_NoteLenCounter
00CD2F  2  8D 17 06         sta Noise_BeatLenCounter
00CD32  2  8D F1 05         sta FDSSND_LenCounter
00CD35  2  A9 00            lda #$00
00CD37  2  8D 0A 06         sta MusicOffset_Square2
00CD3A  2  A9 0B            lda #$0b
00CD3C  2  8D 15 40         sta SND_MASTERCTRL_REG         ;disable and reenable triangle channel
00CD3F  2  A9 0F            lda #$0f
00CD41  2  8D 15 40         sta SND_MASTERCTRL_REG
00CD44  2               
00CD44  2               HandleSquare2Music:
00CD44  2  CE 11 06         dec Squ2_NoteLenCounter   ;if note length not expired, skip ahead to envelope
00CD47  2  D0 65            bne MiscSqu2MusicTasks
00CD49  2  AC 0A 06         ldy MusicOffset_Square2
00CD4C  2  EE 0A 06         inc MusicOffset_Square2   ;get next byte in music data
00CD4F  2  B1 66            lda (MusicData),y
00CD51  2  F0 04            beq EndPattern            ;if end terminator, branch to play the next pattern or stop
00CD53  2  10 3E            bpl Squ2NoteHandler       ;if positive, data is note, branch to play it
00CD55  2  D0 2E            bne Squ2LengthHandler     ;otherwise data is length, branch to process length
00CD57  2               EndPattern:
00CD57  2  AD 08 06         lda AltMusicBuffer        ;if music buffer still set, branch
00CD5A  2  D0 26            bne NextPatternJump
00CD5C  2               StopMusic:
00CD5C  2  A9 00            lda #$00                  ;otherwise init sound and sound related variables
00CD5E  2  8D 08 06         sta AltMusicBuffer        ;to silence everything
00CD61  2  8D 08 40         sta SND_TRIANGLE_REG
00CD64  2  85 67            sta MusicDataHigh
00CD66  2  85 66            sta MusicDataLow
00CD68  2  8D 0A 06         sta MusicOffset_Square2
00CD6B  2  8D 0B 06         sta MusicOffset_Square1
00CD6E  2  8D 0C 06         sta MusicOffset_Triangle
00CD71  2  8D 0D 06         sta MusicOffset_Noise
00CD74  2  A9 90            lda #$90
00CD76  2  8D 00 40         sta SND_SQUARE1_REG
00CD79  2  8D 04 40         sta SND_SQUARE2_REG
00CD7C  2  A9 80            lda #$80
00CD7E  2  8D 80 40         sta FDSSND_VOLUMECTRL
00CD81  2  60               rts
00CD82  2               
00CD82  2               NextPatternJump:
00CD82  2  4C DD CC         jmp NextPattern
00CD85  2               
00CD85  2               Squ2LengthHandler:
00CD85  2  20 EF CF         jsr ProcessLengthData     ;store length of note
00CD88  2  8D 10 06         sta Squ2_NoteLenBuffer
00CD8B  2  AC 0A 06         ldy MusicOffset_Square2
00CD8E  2  EE 0A 06         inc MusicOffset_Square2   ;fetch another byte (MUST NOT BE LENGTH BYTE!)
00CD91  2  B1 66            lda (MusicData),y
00CD93  2               
00CD93  2               Squ2NoteHandler:
00CD93  2  A6 F2            ldx Square2SoundBuffer    ;if playing sound on square 2 channel, skip
00CD95  2  D0 11            bne SkipFqL1
00CD97  2  20 C7 D2         jsr SetFreq_Squ2          ;otherwise play a note on square 2
00CD9A  2  F0 06            beq Rest
00CD9C  2  A9 10            lda #$10                  ;set envelope counter and regs for square 2
00CD9E  2  A2 82            ldx #$82
00CDA0  2  A0 7F            ldy #$7f
00CDA2  2               Rest:
00CDA2  2  8D 12 06         sta Squ2_EnvelopeDataCtrl
00CDA5  2  20 BD D2         jsr Dump_Sq2_Regs
00CDA8  2               SkipFqL1:
00CDA8  2  AD 10 06         lda Squ2_NoteLenBuffer    ;save length to counter
00CDAB  2  8D 11 06         sta Squ2_NoteLenCounter
00CDAE  2               
00CDAE  2               MiscSqu2MusicTasks:
00CDAE  2  A5 F2            lda Square2SoundBuffer    ;if playing sound on square 2 channel, skip
00CDB0  2  D0 0E            bne HandleSquare1Music
00CDB2  2  AC 12 06         ldy Squ2_EnvelopeDataCtrl ;get envelope counter
00CDB5  2  F0 03            beq NoDecEnv1             ;use to update envelope on square 2 unless expired
00CDB7  2  CE 12 06         dec Squ2_EnvelopeDataCtrl
00CDBA  2               NoDecEnv1:
00CDBA  2  B9 3C D2         lda VictoryMusEnvData,y
00CDBD  2  8D 04 40         sta SND_SQUARE2_REG
00CDC0  2               
00CDC0  2               HandleSquare1Music:
00CDC0  2  AC 0B 06         ldy MusicOffset_Square1   ;get offset, skip if none was ever loaded
00CDC3  2  F0 3A            beq HandleTriangleMusic
00CDC5  2  CE 13 06         dec Squ1_NoteLenCounter   ;if note length not expired, skip ahead to envelope
00CDC8  2  D0 22            bne MiscSqu1MusicTasks
00CDCA  2  AC 0B 06         ldy MusicOffset_Square1
00CDCD  2  EE 0B 06         inc MusicOffset_Square1
00CDD0  2  B1 66            lda (MusicData),y         ;get note and encoded length
00CDD2  2  20 E9 CF         jsr LengthDecoder         ;decode it
00CDD5  2  8D 13 06         sta Squ1_NoteLenCounter   ;save length
00CDD8  2  8A               txa
00CDD9  2  29 3E            and #$3e
00CDDB  2  20 A9 D2         jsr SetFreq_Squ1          ;play a note on square 1
00CDDE  2  F0 06            beq SkipCtrlL
00CDE0  2  A9 10            lda #$10                  ;set envelope counter and regs for square 1
00CDE2  2  A2 82            ldx #$82
00CDE4  2  A0 7F            ldy #$7f
00CDE6  2               SkipCtrlL:
00CDE6  2  8D 14 06         sta Squ1_EnvelopeDataCtrl
00CDE9  2  20 9F D2         jsr Dump_Squ1_Regs
00CDEC  2               MiscSqu1MusicTasks:
00CDEC  2  AC 14 06         ldy Squ1_EnvelopeDataCtrl ;get envelope counter
00CDEF  2  F0 03            beq NoDecEnv2             ;use to update envelope on square 1
00CDF1  2  CE 14 06         dec Squ1_EnvelopeDataCtrl
00CDF4  2               NoDecEnv2:
00CDF4  2  B9 3C D2         lda VictoryMusEnvData,y
00CDF7  2  8D 00 40         sta SND_SQUARE1_REG
00CDFA  2  A9 7F            lda #$7f
00CDFC  2  8D 01 40         sta SND_SQUARE1_REG+1
00CDFF  2               
00CDFF  2               HandleTriangleMusic:
00CDFF  2  AD 0C 06         lda MusicOffset_Triangle  ;get offset, skip if none was ever loaded
00CE02  2  F0 38            beq HandleFDSMusic
00CE04  2  CE 16 06         dec Tri_NoteLenCounter    ;if note length not expired, skip ahead
00CE07  2  D0 33            bne HandleFDSMusic
00CE09  2  AC 0C 06         ldy MusicOffset_Triangle
00CE0C  2  EE 0C 06         inc MusicOffset_Triangle  ;get next byte in music data
00CE0F  2  B1 66            lda (MusicData),y
00CE11  2  F0 26            beq LoadTriCtrlReg        ;if zero, skip all this and move on to the FDS channel
00CE13  2  10 10            bpl TriNoteHandler        ;if positive, branch to process note
00CE15  2  20 EF CF         jsr ProcessLengthData     ;otherwise process length
00CE18  2  8D 15 06         sta Tri_NoteLenBuffer
00CE1B  2  AC 0C 06         ldy MusicOffset_Triangle
00CE1E  2  EE 0C 06         inc MusicOffset_Triangle  ;get next byte in music data (must not be length byte!)
00CE21  2  B1 66            lda (MusicData),y
00CE23  2  F0 14            beq LoadTriCtrlReg        ;if zero, skip, as before
00CE25  2               TriNoteHandler:
00CE25  2  20 CB D2         jsr SetFreq_Tri           ;play a note on triangle
00CE28  2  AE 15 06         ldx Tri_NoteLenBuffer
00CE2B  2  8E 16 06         stx Tri_NoteLenCounter    ;save length to counter
00CE2E  2  8A               txa
00CE2F  2  C9 12            cmp #$12                  ;if playing a note longer than 12 frames,
00CE31  2  B0 04            bcs LongN                 ;branch to set triangle reg to $ff
00CE33  2  A9 18            lda #$18
00CE35  2  D0 02            bne LoadTriCtrlReg        ;otherwise set triangle reg to $18 for short notes
00CE37  2               LongN:
00CE37  2  A9 FF            lda #$ff
00CE39  2               LoadTriCtrlReg:
00CE39  2  8D 08 40         sta SND_TRIANGLE_REG
00CE3C  2               
00CE3C  2               HandleFDSMusic:
00CE3C  2  AD 1F 06         lda MusicOffset_FDSSND       ;if no offset loaded, skip to handle noise channel
00CE3F  2  D0 03            bne CheckForCutoff
00CE41  2  4C FE CE         jmp HandleNoiseMusic
00CE44  2               
00CE44  2               CheckForCutoff:
00CE44  2  AD F1 05         lda FDSSND_LenCounter        ;check to see if length at specific point in note
00CE47  2  C9 02            cmp #$02                     ;if not, skip this part
00CE49  2  D0 05            bne RunFDSChannel
00CE4B  2  A9 00            lda #$00                     ;otherwise perform note cutoff
00CE4D  2  8D 80 40         sta FDSSND_VOLUMECTRL
00CE50  2               RunFDSChannel:
00CE50  2  CE F1 05         dec FDSSND_LenCounter        ;if length not expired, skip ahead
00CE53  2  D0 5C            bne FDSSND_EnvModRun
00CE55  2  AC 1F 06         ldy MusicOffset_FDSSND
00CE58  2  EE 1F 06         inc MusicOffset_FDSSND       ;get next byte in music data
00CE5B  2  B1 66            lda (MusicData),y
00CE5D  2  10 0E            bpl FDSSND_NoteHandler       ;if positive, branch to process note
00CE5F  2  20 EF CF         jsr ProcessLengthData        ;otherwise process length
00CE62  2  8D F2 05         sta FDSSND_LenBuffer
00CE65  2  AC 1F 06         ldy MusicOffset_FDSSND
00CE68  2  EE 1F 06         inc MusicOffset_FDSSND       ;get next byte in music data (must not be length byte!)
00CE6B  2  B1 66            lda (MusicData),y
00CE6D  2               FDSSND_NoteHandler:
00CE6D  2  20 CF D2         jsr SetFreq_FDS              ;play a note on the FDS channel
00CE70  2  A8               tay
00CE71  2  D0 07            bne FDSSND_EnvModStart       ;if frequency high was nonzero, branch
00CE73  2  A2 80            ldx #$80
00CE75  2  8E 80 40         stx FDSSND_VOLUMECTRL        ;otherwise play a rest, use zero from frequency low data
00CE78  2  D0 06            bne InitialEnvData           ;to be loaded into envelope timer
00CE7A  2               FDSSND_EnvModStart:
00CE7A  2  20 A0 CF         jsr GetModulationTable       ;reload modulation table
00CE7D  2  AC F7 05         ldy FDSSND_MasterEnvSet
00CE80  2               InitialEnvData:
00CE80  2  8C F3 05         sty FDSSND_MasterEnvTimer    ;dump value from header data or zero if rest
00CE83  2  A0 00            ldy #$00                     ;as value into the timer
00CE85  2  8C F9 05         sty FDSSND_VolumeEnvOffset   ;init envelope and sweep counter offsets
00CE88  2  8C FB 05         sty FDSSND_SweepModOffset
00CE8B  2  B1 6A            lda (FDSSND_VolumeEnvData),y ;get volume and sweep envelope data for the start of the note
00CE8D  2  8D 80 40         sta FDSSND_VOLUMECTRL
00CE90  2  B1 6C            lda (FDSSND_SweepModData),y
00CE92  2  8D 84 40         sta FDSSND_SWEEPCTRL
00CE95  2  A9 00            lda #$00
00CE97  2  8D 85 40         sta FDSSND_SWEEPBIAS         ;set no sweep bias
00CE9A  2  C8               iny
00CE9B  2  B1 6A            lda (FDSSND_VolumeEnvData),y ;get timing for volume and sweep envelopes
00CE9D  2  8D F8 05         sta FDSSND_VolumeEnvTimer
00CEA0  2  B1 6C            lda (FDSSND_SweepModData),y
00CEA2  2  8D FA 05         sta FDSSND_SweepModTimer
00CEA5  2  8C F9 05         sty FDSSND_VolumeEnvOffset   ;set current offset
00CEA8  2  8C FB 05         sty FDSSND_SweepModOffset
00CEAB  2  AD F2 05         lda FDSSND_LenBuffer
00CEAE  2  8D F1 05         sta FDSSND_LenCounter        ;dump length of note
00CEB1  2               FDSSND_EnvModRun:
00CEB1  2  AD F3 05         lda FDSSND_MasterEnvTimer    ;get master counter, skip over this if at zero
00CEB4  2  F0 48            beq HandleNoiseMusic
00CEB6  2  CE F3 05         dec FDSSND_MasterEnvTimer    ;decrement the master counter
00CEB9  2  CE F8 05         dec FDSSND_VolumeEnvTimer    ;if envelope counter not expired, branch to skip this
00CEBC  2  D0 1B            bne SweepModCtrl
00CEBE  2               VolumeEnvCtrl:
00CEBE  2  EE F9 05         inc FDSSND_VolumeEnvOffset
00CEC1  2  AC F9 05         ldy FDSSND_VolumeEnvOffset   ;get next byte of data
00CEC4  2  B1 6A            lda (FDSSND_VolumeEnvData),y ;if positive, write and continue
00CEC6  2  10 05            bpl VolumeEnvTiming
00CEC8  2  8D 80 40         sta FDSSND_VOLUMECTRL        ;otherwise, write and loop to get another byte
00CECB  2  D0 F1            bne VolumeEnvCtrl
00CECD  2               VolumeEnvTiming:
00CECD  2  8D 80 40         sta FDSSND_VOLUMECTRL        ;write to control the envelope of FDS channel
00CED0  2  C8               iny
00CED1  2  B1 6A            lda (FDSSND_VolumeEnvData),y ;get another byte of data, set counter
00CED3  2  8D F8 05         sta FDSSND_VolumeEnvTimer
00CED6  2  8C F9 05         sty FDSSND_VolumeEnvOffset   ;save offset for later
00CED9  2               SweepModCtrl:
00CED9  2  CE FA 05         dec FDSSND_SweepModTimer
00CEDC  2  D0 20            bne HandleNoiseMusic         ;decrement sweep/modulation counter, skip if not expired
00CEDE  2  EE FB 05         inc FDSSND_SweepModOffset
00CEE1  2  AC FB 05         ldy FDSSND_SweepModOffset    ;get some more data
00CEE4  2  B1 6C            lda (FDSSND_SweepModData),y  ;save to sweep control, and mod frequency low and high
00CEE6  2  8D 84 40         sta FDSSND_SWEEPCTRL
00CEE9  2  C8               iny
00CEEA  2  B1 6C            lda (FDSSND_SweepModData),y
00CEEC  2  8D 86 40         sta FDSSND_MODFREQLOW
00CEEF  2  C8               iny
00CEF0  2  B1 6C            lda (FDSSND_SweepModData),y
00CEF2  2  8D 87 40         sta FDSSND_MODFREQHIGH
00CEF5  2  C8               iny
00CEF6  2  B1 6C            lda (FDSSND_SweepModData),y  ;get another byte of data, set counter
00CEF8  2  8D FA 05         sta FDSSND_SweepModTimer
00CEFB  2  8C FB 05         sty FDSSND_SweepModOffset    ;save offset for later
00CEFE  2               
00CEFE  2               HandleNoiseMusic:
00CEFE  2  CE 17 06         dec Noise_BeatLenCounter     ;if length not expired, branch to leave
00CF01  2  D0 2C            bne ExitMusicHandler
00CF03  2               FetchNoiseBeatData:
00CF03  2  AC 0D 06         ldy MusicOffset_Noise
00CF06  2  EE 0D 06         inc MusicOffset_Noise        ;get next byte in beat data
00CF09  2  B1 66            lda (MusicData),y
00CF0B  2  D0 08            bne ProcBeatData             ;if nonzero, branch to process beat data
00CF0D  2  AD 1B 06         lda NoiseDataLoopbackOfs
00CF10  2  8D 0D 06         sta MusicOffset_Noise        ;otherwise zero is loop, dump offset to loop
00CF13  2  D0 EE            bne FetchNoiseBeatData       ;the pattern and loop back, refetch data
00CF15  2               ProcBeatData:
00CF15  2  20 E9 CF         jsr LengthDecoder            ;decode length and save it
00CF18  2  8D 17 06         sta Noise_BeatLenCounter
00CF1B  2  8A               txa
00CF1C  2  29 3E            and #$3e                     ;get beat data
00CF1E  2  F0 06            beq PlayBeat                 ;if none, branch to play silent beat
00CF20  2  A9 1C            lda #$1c
00CF22  2  A2 03            ldx #$03                     ;otherwise play only one kind of beat
00CF24  2  A0 18            ldy #$18
00CF26  2               PlayBeat:
00CF26  2  8D 0C 40         sta SND_NOISE_REG
00CF29  2  8E 0E 40         stx SND_NOISE_REG+2          ;dump to noise regs
00CF2C  2  8C 0F 40         sty SND_NOISE_REG+3
00CF2F  2               ExitMusicHandler:
00CF2F  2  60               rts
00CF30  2               
00CF30  2               ProcessWaveformData:
00CF30  2  A5 01            lda $01                ;if last value in header was set to zero, leave
00CF32  2  D0 01            bne GetWaveformHeader  ;otherwise, use to load header for waveform
00CF34  2  60               rts                    ;and data for the envelope and modulation
00CF35  2               
00CF35  2               GetWaveformHeader:
00CF35  2  A0 00            ldy #$00
00CF37  2               FindHeader:
00CF37  2  C8               iny
00CF38  2  4A               lsr                           ;increment offset for every clear bit in value loaded
00CF39  2  90 FC            bcc FindHeader
00CF3B  2  B9 4B D2         lda WaveformHeaderOffsets-1,y ;get offset to header
00CF3E  2  A8               tay
00CF3F  2  B9 4C D2         lda WaveformHeaderData-2,y
00CF42  2  85 68            sta WaveformData              ;get header
00CF44  2  B9 4D D2         lda WaveformHeaderData-1,y
00CF47  2  85 69            sta WaveformData+1
00CF49  2  B9 4E D2         lda WaveformHeaderData,y
00CF4C  2  8D F7 05         sta FDSSND_MasterEnvSet
00CF4F  2  B9 4F D2         lda WaveformHeaderData+1,y
00CF52  2  85 6A            sta FDSSND_VolumeEnvData
00CF54  2  B9 50 D2         lda WaveformHeaderData+2,y
00CF57  2  85 6B            sta FDSSND_VolumeEnvData+1
00CF59  2  B9 51 D2         lda WaveformHeaderData+3,y
00CF5C  2  85 6C            sta FDSSND_SweepModData
00CF5E  2  B9 52 D2         lda WaveformHeaderData+4,y
00CF61  2  85 6D            sta FDSSND_SweepModData+1
00CF63  2  B9 53 D2         lda WaveformHeaderData+5,y
00CF66  2  8D F6 05         sta FDSSND_ModTableNumber
00CF69  2  20 72 CF         jsr GetWaveformData
00CF6C  2  A9 02            lda #$02                      ;set volume, overwriting the setting from sub
00CF6E  2  8D 89 40         sta FDSSND_WAVEENABLEWR       ;that just got returned from
00CF71  2  60               rts
00CF72  2               
00CF72  2               GetWaveformData:
00CF72  2  A9 80                  lda #$80                ;enable writes to FDS waveform RAM
00CF74  2  8D 89 40               sta FDSSND_WAVEENABLEWR
00CF77  2  A9 00                  lda #$00                ;init first byte of it
00CF79  2  8D 40 40               sta FDSSND_WAVERAM
00CF7C  2  A0 00                  ldy #$00
00CF7E  2  A2 3F                  ldx #$3f
00CF80  2  B1 68        GWDLoop:  lda (WaveformData),y    ;write each byte of data to the waveform RAM
00CF82  2  99 41 40               sta FDSSND_WAVERAM+1,y  ;both from start to middle and from end to middle
00CF85  2  C8                     iny                     ;so that the data eventually converge and mirror
00CF86  2  C0 20                  cpy #$20
00CF88  2  F0 06                  beq SetWMVol
00CF8A  2  9D 40 40               sta FDSSND_WAVERAM,x
00CF8D  2  CA                     dex
00CF8E  2  D0 F0                  bne GWDLoop
00CF90  2  AD 08 06     SetWMVol: lda AltMusicBuffer      ;if d6 was clear, branch to lower the volume
00CF93  2  29 40                  and #$40                ;otherwise set for full volume
00CF95  2  F0 04                  beq LowV
00CF97  2  A9 00                  lda #$00                ;this may have been used once for testing but is
00CF99  2  F0 02                  beq FullV               ;irrelevant now because the setting is overwritten
00CF9B  2  A9 03        LowV:     lda #$03
00CF9D  2  8D 89 40     FullV:    sta FDSSND_WAVEENABLEWR ;then fall through to next routine
00CFA0  2               
00CFA0  2               GetModulationTable:
00CFA0  2  A9 80                 lda #$80                  ;disable modulation
00CFA2  2  8D 87 40              sta FDSSND_MODFREQHIGH
00CFA5  2  A9 00                 lda #$00
00CFA7  2  8D 85 40              sta FDSSND_SWEEPBIAS      ;set no sweep bias
00CFAA  2  A2 20                 ldx #$20
00CFAC  2  AC F6 05              ldy FDSSND_ModTableNumber ;get value from header
00CFAF  2  84 02                 sty $02
00CFB1  2  A5 02        MTableL: lda $02                   ;divide loaded value by 2, use as counter and offset
00CFB3  2  4A                    lsr                       ;(original value is * 2 because it shifts LSB for odd/even)
00CFB4  2  A8                    tay
00CFB5  2  B9 C9 CF              lda ModTableData,y        ;get data, use lower nybble on every odd count
00CFB8  2  B0 04                 bcs OddT                  ;and the upper nybble on every even count
00CFBA  2  4A                    lsr
00CFBB  2  4A                    lsr                       ;otherwise shift upper nybble to use it instead
00CFBC  2  4A                    lsr
00CFBD  2  4A                    lsr
00CFBE  2  29 0F        OddT:    and #$0f                  ;write to modulation table
00CFC0  2  8D 88 40              sta FDSSND_MODTBLAPPEND
00CFC3  2  E6 02                 inc $02                   ;increment loaded value
00CFC5  2  CA                    dex
00CFC6  2  D0 E9                 bne MTableL
00CFC8  2  60                    rts
00CFC9  2               
00CFC9  2               ModTableData:
00CFC9  2  07 07 07 07  ModTable1: .byte $07, $07, $07, $07, $01, $01, $01, $01, $01, $01, $01, $01, $07, $07, $07, $07
00CFCD  2  01 01 01 01  
00CFD1  2  01 01 01 01  
00CFD9  2  77 77 77 77  ModTable2: .byte $77, $77, $77, $77, $11, $11, $11, $11, $11, $11, $11, $11, $77, $77, $77, $77
00CFDD  2  11 11 11 11  
00CFE1  2  11 11 11 11  
00CFE9  2               
00CFE9  2               LengthDecoder:
00CFE9  2  AA               tax
00CFEA  2  6A               ror
00CFEB  2  8A               txa
00CFEC  2  2A               rol
00CFED  2  2A               rol
00CFEE  2  2A               rol
00CFEF  2               ProcessLengthData:
00CFEF  2  29 07            and #$07                     ;save 3 LSB, add to header data loaded earlier
00CFF1  2  18               clc                          ;then use as offset to load note length
00CFF2  2  6D 09 06         adc NoteLengthTblAdder
00CFF5  2  A8               tay
00CFF6  2  B9 8F D2         lda MusicLengthLookupTbl,y
00CFF9  2  60               rts
00CFFA  2               
00CFFA  2               .ifndef ANN
00CFFA  2               Dump_Squ1_Regs:
00CFFA  2                   sty SND_SQUARE1_REG+1    ;set regs for envelope on square 1 channel
00CFFA  2                   stx SND_SQUARE1_REG
00CFFA  2                   rts
00CFFA  2               
00CFFA  2                   jsr Dump_Squ1_Regs       ;dead code, nothing branches here
00CFFA  2               SetFreq_Squ1:
00CFFA  2                   ldx #$00
00CFFA  2               Dump_Freq_Regs:
00CFFA  2                   tay
00CFFA  2                   lda FreqRegLookupTbl+1,y
00CFFA  2                   beq NoTone
00CFFA  2                   sta SND_REGISTER+2,x
00CFFA  2                   lda FreqRegLookupTbl,y
00CFFA  2                   ora #$08
00CFFA  2                   sta SND_REGISTER+3,x
00CFFA  2               NoTone:
00CFFA  2                   rts
00CFFA  2               
00CFFA  2               Dump_Sq2_Regs:
00CFFA  2                   stx SND_SQUARE2_REG       ;set regs for envelope on square 2 channel
00CFFA  2                   sty SND_SQUARE2_REG+1
00CFFA  2                   rts
00CFFA  2               
00CFFA  2                   jsr Dump_Sq2_Regs         ;dead code, nothing branches here
00CFFA  2               SetFreq_Squ2:
00CFFA  2                   ldx #$04                  ;set frequency regs for square 2 channel to play note
00CFFA  2                   bne Dump_Freq_Regs
00CFFA  2               SetFreq_Tri:
00CFFA  2                   ldx #$08                  ;if branched here, do that for triangle channel
00CFFA  2                   bne Dump_Freq_Regs
00CFFA  2               SetFreq_FDS:
00CFFA  2                   ldx #$80                  ;if branched here, start off by silencing the FDS channel
00CFFA  2                   stx FDSSND_FREQHIGH
00CFFA  2                   tay
00CFFA  2                   lda FDSFreqLookupTbl,y    ;now set the frequency regs for FDS channel
00CFFA  2                   sta FDSSND_FREQHIGH
00CFFA  2                   lda FDSFreqLookupTbl+1,y
00CFFA  2                   sta FDSSND_FREQLOW
00CFFA  2                   rts
00CFFA  2               .endif
00CFFA  2               
00CFFA  2               ;-------------------------------------------------------------------------------------
00CFFA  2               
00CFFA  2               MusicHeaderOffsetData:
00CFFA  2  0B 0B 13 0B      .byte VictoryPart1AHdr-MHD, VictoryPart1AHdr-MHD, VictoryPart1BHdr-MHD, VictoryPart1AHdr-MHD
00CFFE  2  1B 33 1B 33      .byte VictoryPart2AHdr-MHD, VictoryPart2BHdr-MHD, VictoryPart2AHdr-MHD, VictoryPart2BHdr-MHD
00D002  2  23 1B 2B         .byte VictoryPart2CHdr-MHD, VictoryPart2AHdr-MHD, VictoryPart2DHdr-MHD
00D005  2               
00D005  2               ;header format here is as follows:
00D005  2               ;1 byte - length byte offset
00D005  2               ;2 bytes - music data address
00D005  2               ;1 byte - triangle data offset
00D005  2               ;1 byte - square 1 data offset
00D005  2               ;1 byte - noise data offset
00D005  2               ;these two are unique to the sound engine in this file
00D005  2               ;1 byte - FDS channel data offset
00D005  2               ;1 byte - waveform ID
00D005  2               
00D005  2               MusicHeaderData:
00D005  2  00 38 D0 3E  VictoryPart1AHdr: .byte $00, <VictoryM_P1AData, >VictoryM_P1AData, $3e, $14, $b0, $24, $01
00D009  2  14 B0 24 01  
00D00D  2  00 87 D0 50  VictoryPart1BHdr: .byte $00, <VictoryM_P1BData, >VictoryM_P1BData, $50, $21, $61, $31, $02
00D011  2  21 61 31 02  
00D015  2  00 EF D0 43  VictoryPart2AHdr: .byte $00, <VictoryM_P2AData, >VictoryM_P2AData, $43, $1c, $b5, $29, $01
00D019  2  1C B5 29 01  
00D01D  2  00 43 D1 50  VictoryPart2CHdr: .byte $00, <VictoryM_P2CData, >VictoryM_P2CData, $50, $20, $61, $31, $02
00D021  2  20 61 31 02  
00D025  2  08 AB D1 09  VictoryPart2DHdr: .byte $08, <VictoryM_P2DData, >VictoryM_P2DData, $09, $04, $1e, $06, $01
00D029  2  04 1E 06 01  
00D02D  2  08 06 D1 3A  VictoryPart2BHdr: .byte $08, <VictoryM_P2BData, >VictoryM_P2BData, $3a, $10, $9e, $28, $01
00D031  2  10 9E 28 01  
00D035  2               
00D035  2               ;residual data, probably from an old header
00D035  2  00 4B D0         .byte $00, $4b, $d0
00D038  2               
00D038  2               ;music data format here is the same as in sm2main file
00D038  2               ;with a few exceptions: the value $00 does nothing special
00D038  2               ;for square 1, and noise data format plays only one kind of
00D038  2               ;beat for d5-d1 = nonzero, or rest for d5-d1 = 0
00D038  2               
00D038  2               VictoryM_P1AData:
00D038  2               ;square 2
00D038  2  84 12 86 0C      .byte $84, $12, $86, $0c, $84, $62, $10, $86
00D03C  2  84 62 10 86  
00D040  2  12 84 1C 22      .byte $12, $84, $1c, $22, $1e, $22, $26, $18
00D044  2  1E 22 26 18  
00D048  2  1E 04 1C 00      .byte $1e, $04, $1c, $00
00D04C  2               ;square 1
00D04C  2  E2 E0 E2 9D      .byte $e2, $e0, $e2, $9d, $1f, $21, $a3, $2d
00D050  2  1F 21 A3 2D  
00D054  2  74 F4 31 35      .byte $74, $f4, $31, $35, $37, $2b, $b1, $2d
00D058  2  37 2B B1 2D  
00D05C  2               ;FDS sound
00D05C  2  83 16 14 16      .byte $83, $16, $14, $16, $86, $10, $84, $12
00D060  2  86 10 84 12  
00D064  2  14 86 16 84      .byte $14, $86, $16, $84, $20, $81, $28, $83
00D068  2  20 81 28 83  
00D06C  2  28 84 24 28      .byte $28, $84, $24, $28, $2a, $1e, $86, $24
00D070  2  2A 1E 86 24  
00D074  2  84 20            .byte $84, $20
00D076  2               ;triangle
00D076  2  84 12 14 04      .byte $84, $12, $14, $04, $18, $1a, $1c, $14
00D07A  2  18 1A 1C 14  
00D07E  2  26 22 1E 1C      .byte $26, $22, $1e, $1c, $18, $1e, $22, $0c
00D082  2  18 1E 22 0C  
00D086  2  14               .byte $14
00D087  2               
00D087  2               VictoryM_P1BData:
00D087  2               ;square 2
00D087  2  81 22 83 22      .byte $81, $22, $83, $22, $86, $24, $85, $18
00D08B  2  86 24 85 18  
00D08F  2  82 1E 80 1E      .byte $82, $1e, $80, $1e, $83, $1c, $83, $18
00D093  2  83 1C 83 18  
00D097  2  84 1C 81 26      .byte $84, $1c, $81, $26, $83, $26, $86, $26
00D09B  2  83 26 86 26  
00D09F  2  85 1E 82 24      .byte $85, $1e, $82, $24, $86, $22, $84, $1e
00D0A3  2  86 22 84 1E  
00D0A7  2  00               .byte $00
00D0A8  2               ;square 1
00D0A8  2  74 F4 B5 6B      .byte $74, $f4, $b5, $6b, $b0, $30, $ec, $ea
00D0AC  2  B0 30 EC EA  
00D0B0  2  2D 76 F6 B7      .byte $2d, $76, $f6, $b7, $6d, $b0, $b5, $31
00D0B4  2  6D B0 B5 31  
00D0B8  2               ;FDS sound
00D0B8  2  81 10 83 10      .byte $81, $10, $83, $10, $86, $10, $85, $08
00D0BC  2  86 10 85 08  
00D0C0  2  82 0C 80 0C      .byte $82, $0c, $80, $0c, $83, $0a, $08, $84
00D0C4  2  83 0A 08 84  
00D0C8  2  0A 81 12 83      .byte $0a, $81, $12, $83, $12, $86, $12, $85
00D0CC  2  12 86 12 85  
00D0D0  2  0A 82 0C 86      .byte $0a, $82, $0c, $86, $10, $84, $0c
00D0D4  2  10 84 0C     
00D0D7  2               ;triangle
00D0D7  2  84 12 1C 20      .byte $84, $12, $1c, $20, $24, $2a, $26, $24
00D0DB  2  24 2A 26 24  
00D0DF  2  26 22 1E 22      .byte $26, $22, $1e, $22, $24, $1e, $22, $0c
00D0E3  2  24 1E 22 0C  
00D0E7  2  1E               .byte $1e
00D0E8  2               ;noise (also used by part 1A)
00D0E8  2  11 11 D0 D0      .byte $11, $11, $d0, $d0, $d0, $11, $00
00D0EC  2  D0 11 00     
00D0EF  2               
00D0EF  2               VictoryM_P2AData:
00D0EF  2               ;square 2
00D0EF  2  83 2C 2A 2C      .byte $83, $2c, $2a, $2c, $86, $26, $84, $28
00D0F3  2  86 26 84 28  
00D0F7  2  2A 86 2C 84      .byte $2a, $86, $2c, $84, $36, $81, $40, $83
00D0FB  2  36 81 40 83  
00D0FF  2  40 84 3A 40      .byte $40, $84, $3a, $40, $3e, $34, $00
00D103  2  3E 34 00     
00D106  2               
00D106  2               VictoryM_P2BData:
00D106  2               ;square 2
00D106  2  86 3A 84 36      .byte $86, $3a, $84, $36, $00
00D10A  2  00           
00D10B  2               ;square 1 of part 2A
00D10B  2  1D 95 19 1B      .byte $1d, $95, $19, $1b, $9d, $27, $2d, $29
00D10F  2  9D 27 2D 29  
00D113  2  2D 31 23         .byte $2d, $31, $23
00D116  2               ;square 1 of part 2B
00D116  2  A9 27            .byte $a9, $27
00D118  2               ;FDS sound of part 2A
00D118  2  83 20 1E 20      .byte $83, $20, $1e, $20, $86, $1a, $84, $1c
00D11C  2  86 1A 84 1C  
00D120  2  1E 86 20 84      .byte $1e, $86, $20, $84, $2a, $81, $32, $83
00D124  2  2A 81 32 83  
00D128  2  32 84 2E 32      .byte $32, $84, $2e, $32, $34, $28
00D12C  2  34 28        
00D12E  2               ;FDS sound of part 2B
00D12E  2  86 2E 84 2A      .byte $86, $2e, $84, $2a
00D132  2               ;triangle of part 2A
00D132  2  84 1C 1E 04      .byte $84, $1c, $1e, $04, $22, $24, $26, $1e
00D136  2  22 24 26 1E  
00D13A  2  30 2C 28 26      .byte $30, $2c, $28, $26, $22, $28
00D13E  2  22 28        
00D140  2               ;triangle of part 2B
00D140  2  2C 14 1E         .byte $2c, $14, $1e
00D143  2               
00D143  2               VictoryM_P2CData:
00D143  2               ;square 2
00D143  2  81 40 83 40      .byte $81, $40, $83, $40, $86, $40, $85, $34
00D147  2  86 40 85 34  
00D14B  2  82 3A 80 3A      .byte $82, $3a, $80, $3a, $83, $36, $34, $84
00D14F  2  83 36 34 84  
00D153  2  36 81 3E 83      .byte $36, $81, $3e, $83, $3e, $86, $3e, $85
00D157  2  3E 86 3E 85  
00D15B  2  36 82 3A 86      .byte $36, $82, $3a, $86, $40, $84, $3a, $00
00D15F  2  40 84 3A 00  
00D163  2               ;square 1
00D163  2  6C EC AF 63      .byte $6c, $ec, $af, $63, $a8, $29, $c4, $e6
00D167  2  A8 29 C4 E6  
00D16B  2  E2 27 70 F0      .byte $e2, $27, $70, $f0, $b1, $69, $ae, $ad
00D16F  2  B1 69 AE AD  
00D173  2  29               .byte $29
00D174  2               ;FDS sound
00D174  2  81 1A 83 1A      .byte $81, $1a, $83, $1a, $86, $1a, $85, $10
00D178  2  86 1A 85 10  
00D17C  2  82 16 80 16      .byte $82, $16, $80, $16, $83, $12, $10, $84
00D180  2  83 12 10 84  
00D184  2  12 81 1C 83      .byte $12, $81, $1c, $83, $1c, $86, $1c, $85
00D188  2  1C 86 1C 85  
00D18C  2  12 82 16 86      .byte $12, $82, $16, $86, $1a, $84, $16
00D190  2  1A 84 16     
00D193  2               ;triangle
00D193  2  84 1C 26 2A      .byte $84, $1c, $26, $2a, $2e, $34, $30, $2e
00D197  2  2E 34 30 2E  
00D19B  2  30 2C 28 2C      .byte $30, $2c, $28, $2c, $2e, $28, $2c, $14
00D19F  2  2E 28 2C 14  
00D1A3  2  28               .byte $28
00D1A4  2               ;noise of part 2A, 2B and 2C
00D1A4  2  11 11 D0 D0      .byte $11, $11, $d0, $d0, $d0, $11, $00
00D1A8  2  D0 11 00     
00D1AB  2               
00D1AB  2               VictoryM_P2DData:
00D1AB  2               ;square 2
00D1AB  2  87 3A 36 00      .byte $87, $3a, $36, $00
00D1AF  2               ;square 1
00D1AF  2  E9 E7            .byte $e9, $e7
00D1B1  2               ;FDS sound
00D1B1  2  87 2E 2A         .byte $87, $2e, $2a
00D1B4  2               ;triangle
00D1B4  2  83 16 1C 22      .byte $83, $16, $1c, $22, $28, $2e, $34, $84
00D1B8  2  28 2E 34 84  
00D1BC  2  3A 83 34 22      .byte $3a, $83, $34, $22, $34, $84, $36, $83
00D1C0  2  34 84 36 83  
00D1C4  2  1E 1E 1E 86      .byte $1e, $1e, $1e, $86, $1e
00D1C8  2  1E           
00D1C9  2               ;noise of part 2D
00D1C9  2  11 11 D0 D0      .byte $11, $11, $d0, $d0, $d0, $11, $00
00D1CD  2  D0 11 00     
00D1D0  2               
00D1D0  2               WaveformData2:
00D1D0  2  10 2C 2E 27      .byte $10, $2c, $2e, $27, $29, $2b, $2a, $28
00D1D4  2  29 2B 2A 28  
00D1D8  2  25 29 2F 2D      .byte $25, $29, $2f, $2d, $2c, $2a, $22, $24
00D1DC  2  2C 2A 22 24  
00D1E0  2  34 3F 31 2D      .byte $34, $3f, $31, $2d, $3a, $3b, $27, $12
00D1E4  2  3A 3B 27 12  
00D1E8  2  0A 1F 2C 27      .byte $0a, $1f, $2c, $27, $23, $28, $22, $1e
00D1EC  2  23 28 22 1E  
00D1F0  2               
00D1F0  2               VolEnvData2:
00D1F0  2  A0 04 18 60      .byte $a0, $04, $18, $60
00D1F4  2               VolEnvData1:
00D1F4  2  94 02 44 30      .byte $94, $02, $44, $30, $0a, $50, $a0, $02
00D1F8  2  0A 50 A0 02  
00D1FC  2  36 35 80 34      .byte $36, $35, $80, $34
00D200  2               
00D200  2               FDSFreqLookupTbl:
00D200  2  01 44 01 58      .byte $01, $44, $01, $58, $01, $99, $02, $22
00D204  2  01 99 02 22  
00D208  2  02 42 02 65      .byte $02, $42, $02, $65, $02, $b0, $02, $d9
00D20C  2  02 B0 02 D9  
00D210  2  03 04 03 32      .byte $03, $04, $03, $32, $03, $63, $03, $96
00D214  2  03 63 03 96  
00D218  2  03 CD 04 07      .byte $03, $cd, $04, $07, $04, $44, $04, $85
00D21C  2  04 44 04 85  
00D220  2  04 CA 05 13      .byte $04, $ca, $05, $13, $05, $60, $05, $b2
00D224  2  05 60 05 B2  
00D228  2  06 08 06 64      .byte $06, $08, $06, $64, $06, $c6, $07, $2d
00D22C  2  06 C6 07 2D  
00D230  2  07 9A 08 0E      .byte $07, $9a, $08, $0e, $08, $88, $09, $95
00D234  2  08 88 09 95  
00D238  2  0A 26 00 00      .byte $0a, $26, $00, $00
00D23C  2               
00D23C  2               VictoryMusEnvData:
00D23C  2  97 98 9A 9B      .byte $97, $98, $9a, $9b, $9b, $9a, $9a, $99
00D240  2  9B 9A 9A 99  
00D244  2  99 98 98 97      .byte $99, $98, $98, $97, $97, $96, $96, $95
00D248  2  97 96 96 95  
00D24C  2               
00D24C  2               ;header format here is as follows:
00D24C  2               ;2 bytes - waveform data address
00D24C  2               ;1 byte  - master envelope timing (used with both volume envelope and sweep/modulation)
00D24C  2               ;2 bytes - volume envelope data address
00D24C  2               ;2 bytes - sweep envelope/mod frequency data address
00D24C  2               ;1 byte  - modulation table data offset * 2
00D24C  2               
00D24C  2               WaveformHeaderOffsets:
00D24C  2  02 0A            .byte Wave1Hdr-WaveformHeaderOffsets, Wave2Hdr-WaveformHeaderOffsets
00D24E  2               
00D24E  2               WaveformHeaderData:
00D24E  2  5F D2 44 F4  Wave1Hdr:     .byte <WaveformData1, >WaveformData1, $44, <VolEnvData1
00D252  2  D1 7F D2 20                .byte >VolEnvData1, <SweepModData1, >SweepModData1, (ModTable2-ModTableData) * 2
00D256  2  D0 D1 60 F0  Wave2Hdr:     .byte <WaveformData2, >WaveformData2, $60, <VolEnvData2
00D25A  2  D1 89 D2 00                .byte >VolEnvData2, <SweepModData2, >SweepModData2, (ModTable1-ModTableData) * 2
00D25E  2  00                         .byte $00
00D25F  2               
00D25F  2               WaveformData1:
00D25F  2  01 02 03 04      .byte $01, $02, $03, $04, $06, $07, $09, $0b
00D263  2  06 07 09 0B  
00D267  2  0E 10 13 18      .byte $0e, $10, $13, $18, $20, $2b, $34, $3c
00D26B  2  20 2B 34 3C  
00D26F  2  3F 3F 3E 3D      .byte $3f, $3f, $3e, $3d, $3a, $36, $32, $2f
00D273  2  3A 36 32 2F  
00D277  2  2C 29 26 24      .byte $2c, $29, $26, $24, $21, $1e, $18, $19
00D27B  2  21 1E 18 19  
00D27F  2               
00D27F  2               SweepModData1:
00D27F  2  80 1B 81 0A      .byte $80, $1b, $81, $0a, $00, $04, $82, $10, $00, $60
00D283  2  00 04 82 10  
00D287  2  00 60        
00D289  2               SweepModData2:
00D289  2  80 02 80 00      .byte $80, $02, $80, $00, $00, $60
00D28D  2  00 60        
00D28F  2               
00D28F  2               MusicLengthLookupTbl:
00D28F  2  24 12 0D 09      .byte $24, $12, $0d, $09, $1b, $28, $36, $12
00D293  2  1B 28 36 12  
00D297  2  24 12 0D 09      .byte $24, $12, $0d, $09, $1b, $28, $36, $6c
00D29B  2  1B 28 36 6C  
00D29F  2               
00D29F  2               .ifdef ANN
00D29F  2               Dump_Squ1_Regs:
00D29F  2  8C 01 40         sty SND_SQUARE1_REG+1    ;set regs for envelope on square 1 channel
00D2A2  2  8E 00 40         stx SND_SQUARE1_REG
00D2A5  2  60               rts
00D2A6  2               
00D2A6  2  20 9F D2         jsr Dump_Squ1_Regs       ;dead code, nothing branches here
00D2A9  2               SetFreq_Squ1:
00D2A9  2  A2 00            ldx #$00
00D2AB  2               Dump_Freq_Regs:
00D2AB  2  A8               tay
00D2AC  2  B9 rr rr         lda FreqRegLookupTbl+1,y
00D2AF  2  F0 0B            beq NoTone
00D2B1  2  9D 02 40         sta SND_REGISTER+2,x
00D2B4  2  B9 rr rr         lda FreqRegLookupTbl,y
00D2B7  2  09 08            ora #$08
00D2B9  2  9D 03 40         sta SND_REGISTER+3,x
00D2BC  2               NoTone:
00D2BC  2  60               rts
00D2BD  2               
00D2BD  2               Dump_Sq2_Regs:
00D2BD  2  8E 04 40         stx SND_SQUARE2_REG       ;set regs for envelope on square 2 channel
00D2C0  2  8C 05 40         sty SND_SQUARE2_REG+1
00D2C3  2  60               rts
00D2C4  2               
00D2C4  2  20 BD D2         jsr Dump_Sq2_Regs         ;dead code, nothing branches here
00D2C7  2               SetFreq_Squ2:
00D2C7  2  A2 04            ldx #$04                  ;set frequency regs for square 2 channel to play note
00D2C9  2  D0 E0            bne Dump_Freq_Regs
00D2CB  2               SetFreq_Tri:
00D2CB  2  A2 08            ldx #$08                  ;if branched here, do that for triangle channel
00D2CD  2  D0 DC            bne Dump_Freq_Regs
00D2CF  2               SetFreq_FDS:
00D2CF  2  A2 80            ldx #$80                  ;if branched here, start off by silencing the FDS channel
00D2D1  2  8E 83 40         stx FDSSND_FREQHIGH
00D2D4  2  A8               tay
00D2D5  2  B9 00 D2         lda FDSFreqLookupTbl,y    ;now set the frequency regs for FDS channel
00D2D8  2  8D 83 40         sta FDSSND_FREQHIGH
00D2DB  2  B9 01 D2         lda FDSFreqLookupTbl+1,y
00D2DE  2  8D 82 40         sta FDSSND_FREQLOW
00D2E1  2  60               rts
00D2E2  2               .endif
00D2E2  2               
00D2E2  1               .reloc
00C0F2r 1               .endscope
00C0F2r 1               Data3End:
00C0F2r 1               
00C0F2r 1  03           .byte FileHeaderBlock
00C0F3r 1  06 40        .byte $06,$40
00C0F5r 1  4E 53 4D 44  .byte "NSMDATA4"
00C0F9r 1  41 54 41 34  
00C0FDr 1  96 C2        .word $c296
00C0FFr 1  F0 0D        .word Data4End-Data4Start
00C101r 1  00 04        .byte PRG,FileDataBlock
00C103r 1               Data4Start:
00C103r 1               .scope FILE_SM2DATA4
00C103r 1               .org $c296
00C296  1               .include "ann_sm2data4.asm"
00C296  2               ;SMB2J DISASSEMBLY (SM2DATA4 portion)
00C296  2               
00C296  2               ;-------------------------------------------------------------------------------------
00C296  2               ;DEFINES
00C296  2               
00C296  2               ANN                   = $40
00C296  2               AreaData              = $e7
00C296  2               AreaDataLow           = $e7
00C296  2               AreaDataHigh          = $e8
00C296  2               EnemyData             = $e9
00C296  2               EnemyDataLow          = $e9
00C296  2               EnemyDataHigh         = $ea
00C296  2               
00C296  2               FrameCounter          = $09
00C296  2               Enemy_State           = $1e
00C296  2               Enemy_Y_Position      = $cf
00C296  2               PiranhaPlantUpYPos    = $0417
00C296  2               PiranhaPlantDownYPos  = $0434
00C296  2               PiranhaPlant_Y_Speed  = $58
00C296  2               PiranhaPlant_MoveFlag = $a0
00C296  2               
00C296  2               Player_X_Scroll       = $06ff
00C296  2               
00C296  2               Player_PageLoc        = $6d
00C296  2               Player_X_Position     = $86
00C296  2               
00C296  2               AreaObjectLength      = $0730
00C296  2               WindFlag              = $07f9
00C296  2               
00C296  2               TimerControl          = $0747
00C296  2               EnemyFrameTimer       = $078a
00C296  2               
00C296  2               Sprite_Y_Position     = $0200
00C296  2               Sprite_Tilenumber     = $0201
00C296  2               Sprite_Attributes     = $0202
00C296  2               Sprite_X_Position     = $0203
00C296  2               
00C296  2               Alt_SprDataOffset     = $06ec
00C296  2               
00C296  2               NoiseSoundQueue       = $fd
00C296  2               
00C296  2               TerrainControl        = $0727
00C296  2               AreaStyle             = $0733
00C296  2               ForegroundScenery     = $0741
00C296  2               BackgroundScenery     = $0742
00C296  2               CloudTypeOverride     = $0743
00C296  2               BackgroundColorCtrl   = $0744
00C296  2               AreaType              = $074e
00C296  2               AreaAddrsLOffset      = $074f
00C296  2               AreaPointer           = $0750
00C296  2               
00C296  2               PlayerEntranceCtrl    = $0710
00C296  2               GameTimerSetting      = $0715
00C296  2               AltEntranceControl    = $0752
00C296  2               EntrancePage          = $0751
00C296  2               
00C296  2               WorldNumber           = $075f
00C296  2               AreaNumber            = $0760 ;internal number used to find areas
00C296  2               
00C296  2               ; imports from other files
00C296  2               .import HalfwayPageNybbles
00C296  2               .import GetPipeHeight
00C296  2               .import FindEmptyEnemySlot
00C296  2               .import SetupPiranhaPlant
00C296  2               .import VerticalPipeData
00C296  2               .import RenderUnderPart
00C296  2               .import MetatileBuffer
00C296  2               .import GetAreaType
00C296  2               .ifdef ANN
00C296  2               .import E_HArea10
00C296  2               .import E_HArea11
00C296  2               .import L_HArea10
00C296  2               .import L_HArea11
00C296  2               .else
00C296  2               .import E_GroundArea21
00C296  2               .import E_GroundArea28
00C296  2               .import L_GroundArea10
00C296  2               .import L_GroundArea28
00C296  2               .endif
00C296  2               
00C296  2               ; exports to other files
00C296  2               .export UpsideDownPipe_High
00C296  2               .export UpsideDownPipe_Low
00C296  2               .ifndef ANN
00C296  2               .export WindOn
00C296  2               .export WindOff
00C296  2               .export SimulateWind
00C296  2               .export BlowPlayerAround
00C296  2               .endif
00C296  2               .export MoveUpsideDownPiranhaP
00C296  2               .export ChangeHalfwayPages
00C296  2               
00C296  2               ;-------------------------------------------------------------------------------------------------
00C296  2               
00C296  2               FindAreaPointer:
00C296  2  AC 5F 07           ldy WorldNumber        ;load offset from world variable
00C299  2  B9 39 C3           lda WorldAddrOffsets,y
00C29C  2  18                 clc                    ;add area number used to find data
00C29D  2  6D 60 07           adc AreaNumber
00C2A0  2  A8                 tay
00C2A1  2  B9 41 C3           lda AreaAddrOffsets,y  ;from there we have our area pointer
00C2A4  2  60                 rts
00C2A5  2               
00C2A5  2               GetAreaDataAddrs:
00C2A5  2  AD 50 07                 lda AreaPointer          ;use 2 MSB for Y
00C2A8  2  20 rr rr                 jsr GetAreaType
00C2AB  2  A8                       tay
00C2AC  2  AD 50 07                 lda AreaPointer          ;mask out all but 5 LSB
00C2AF  2  29 1F                    and #%00011111
00C2B1  2  8D 4F 07                 sta AreaAddrsLOffset     ;save as low offset
00C2B4  2  B9 53 C3                 lda EnemyAddrHOffsets,y  ;load base value with 2 altered MSB,
00C2B7  2  18                       clc                      ;then add base value to 5 LSB, result
00C2B8  2  6D 4F 07                 adc AreaAddrsLOffset     ;becomes offset for level data
00C2BB  2  0A                       asl
00C2BC  2  A8                       tay
00C2BD  2  B9 58 C3                 lda EnemyDataAddrs+1,y   ;use offset to load pointer
00C2C0  2  85 EA                    sta EnemyDataHigh
00C2C2  2  B9 57 C3                 lda EnemyDataAddrs,y
00C2C5  2  85 E9                    sta EnemyDataLow
00C2C7  2  AC 4E 07                 ldy AreaType             ;use area type as offset
00C2CA  2  B9 81 C3                 lda AreaDataHOffsets,y   ;do the same thing but with different base value
00C2CD  2  18                       clc
00C2CE  2  6D 4F 07                 adc AreaAddrsLOffset
00C2D1  2  0A                       asl
00C2D2  2  A8                       tay
00C2D3  2  B9 86 C3                 lda AreaDataAddrs+1,y    ;use this offset to load another pointer
00C2D6  2  85 E8                    sta AreaDataHigh
00C2D8  2  B9 85 C3                 lda AreaDataAddrs,y
00C2DB  2  85 E7                    sta AreaDataLow
00C2DD  2  A0 00                    ldy #$00                 ;load first byte of header
00C2DF  2  B1 E7                    lda (AreaData),y
00C2E1  2  48                       pha                      ;save it to the stack for now
00C2E2  2  29 07                    and #%00000111           ;save 3 LSB for foreground scenery or bg color control
00C2E4  2  C9 04                    cmp #$04
00C2E6  2  90 05                    bcc StoreFore
00C2E8  2  8D 44 07                 sta BackgroundColorCtrl  ;if 4 or greater, save value here as bg color control
00C2EB  2  A9 00                    lda #$00
00C2ED  2  8D 41 07     StoreFore:  sta ForegroundScenery    ;if less, save value here as foreground scenery
00C2F0  2  68                       pla                      ;pull byte from stack and push it back
00C2F1  2  48                       pha
00C2F2  2  29 38                    and #%00111000           ;save player entrance control bits
00C2F4  2  4A                       lsr                      ;shift bits over to LSBs
00C2F5  2  4A                       lsr
00C2F6  2  4A                       lsr
00C2F7  2  8D 10 07                 sta PlayerEntranceCtrl   ;save value here as player entrance control
00C2FA  2  68                       pla                      ;pull byte again but do not push it back
00C2FB  2  29 C0                    and #%11000000           ;save 2 MSB for game timer setting
00C2FD  2  18                       clc
00C2FE  2  2A                       rol                      ;rotate bits over to LSBs
00C2FF  2  2A                       rol
00C300  2  2A                       rol
00C301  2  8D 15 07                 sta GameTimerSetting     ;save value here as game timer setting
00C304  2  C8                       iny
00C305  2  B1 E7                    lda (AreaData),y         ;load second byte of header
00C307  2  48                       pha                      ;save to stack
00C308  2  29 0F                    and #%00001111           ;mask out all but lower nybble
00C30A  2  8D 27 07                 sta TerrainControl
00C30D  2  68                       pla                      ;pull and push byte to copy it to A
00C30E  2  48                       pha
00C30F  2  29 30                    and #%00110000           ;save 2 MSB for background scenery type
00C311  2  4A                       lsr
00C312  2  4A                       lsr                      ;shift bits to LSBs
00C313  2  4A                       lsr
00C314  2  4A                       lsr
00C315  2  8D 42 07                 sta BackgroundScenery    ;save as background scenery
00C318  2  68                       pla
00C319  2  29 C0                    and #%11000000
00C31B  2  18                       clc
00C31C  2  2A                       rol                      ;rotate bits over to LSBs
00C31D  2  2A                       rol
00C31E  2  2A                       rol
00C31F  2  C9 03                    cmp #%00000011           ;if set to 3, store here
00C321  2  D0 05                    bne StoreStyle           ;and nullify other value
00C323  2  8D 43 07                 sta CloudTypeOverride    ;otherwise store value in other place
00C326  2  A9 00                    lda #$00
00C328  2  8D 33 07     StoreStyle: sta AreaStyle
00C32B  2  A5 E7                    lda AreaDataLow          ;increment area data address by 2 bytes
00C32D  2  18                       clc
00C32E  2  69 02                    adc #$02
00C330  2  85 E7                    sta AreaDataLow
00C332  2  A5 E8                    lda AreaDataHigh
00C334  2  69 00                    adc #$00
00C336  2  85 E8                    sta AreaDataHigh
00C338  2  60                       rts
00C339  2               
00C339  2               WorldAddrOffsets:
00C339  2  00 05             .byte WorldAAreas-AreaAddrOffsets, WorldBAreas-AreaAddrOffsets
00C33B  2  0A 0E             .byte WorldCAreas-AreaAddrOffsets, WorldDAreas-AreaAddrOffsets
00C33D  2  00 00 00 00       .byte 0,0,0,0
00C341  2               .ifndef ANN
00C341  2                    .byte 0
00C341  2               .endif
00C341  2               
00C341  2               AreaAddrOffsets:
00C341  2  20 2C 40 21  WorldAAreas: .byte $20, $2c, $40, $21, $60
00C345  2  60           
00C346  2  22 2C 00 23  WorldBAreas: .byte $22, $2c, $00, $23, $61
00C34A  2  61           
00C34B  2  24 25 26 62  WorldCAreas: .byte $24, $25, $26, $62
00C34F  2  27 28 29 63  WorldDAreas: .byte $27, $28, $29, $63
00C353  2               
00C353  2               EnemyAddrHOffsets:
00C353  2  14 04 12 00       .byte $14, $04, $12, $00
00C357  2               
00C357  2               EnemyDataAddrs:
00C357  2               .ifdef ANN
00C357  2  D0 C5 F5 C5       .addr E_HArea00,E_HArea01,E_HArea02,E_HArea03,E_HArea04,E_HArea05,E_HArea06,E_HArea07
00C35B  2  1C C6 5B C6  
00C35F  2  8A C6 C5 C6  
00C367  2  2E C7 51 C7       .addr E_HArea08,E_HArea09,E_HArea0A,E_HArea0B,E_HArea0C,E_HArea0D,E_HArea0E,E_HArea0F
00C36B  2  70 C7 89 C7  
00C36F  2  B2 C7 D3 C7  
00C377  2  rr rr rr rr       .addr E_HArea10,E_HArea11,E_HArea12,E_HArea13,E_HArea14
00C37B  2  09 C8 23 C8  
00C37F  2  3A C8        
00C381  2               .else
00C381  2                    .word E_CastleArea11, E_CastleArea12, E_CastleArea13, E_CastleArea14, E_GroundArea30, E_GroundArea31
00C381  2                    .word E_GroundArea32, E_GroundArea33, E_GroundArea34, E_GroundArea35, E_GroundArea36, E_GroundArea37
00C381  2                    .word E_GroundArea38, E_GroundArea39, E_GroundArea40, E_GroundArea41, E_GroundArea21, E_GroundArea28
00C381  2                    .word E_UndergroundArea6, E_UndergroundArea7, E_WaterArea9
00C381  2               .endif
00C381  2               
00C381  2               AreaDataHOffsets:
00C381  2  14 04 12 00       .byte $14, $04, $12, $00
00C385  2               
00C385  2               AreaDataAddrs:
00C385  2               .ifdef ANN
00C385  2  5E C8 D1 C8       .addr L_HArea00,L_HArea01,L_HArea02,L_HArea03,L_HArea04,L_HArea05,L_HArea06,L_HArea07
00C389  2  4E C9 E1 C9  
00C38D  2  70 CA F9 CA  
00C395  2  3A CC AD CC       .addr L_HArea08,L_HArea09,L_HArea0A,L_HArea0B,L_HArea0C,L_HArea0D,L_HArea0E,L_HArea0F
00C399  2  08 CD 7F CD  
00C39D  2  EE CD 3B CE  
00C3A5  2  rr rr rr rr       .addr L_HArea10,L_HArea11,L_HArea12,L_HArea13,L_HArea14
00C3A9  2  EA CE 5F CF  
00C3AD  2  BE CF        
00C3AF  2               .else
00C3AF  2                    .word L_CastleArea11, L_CastleArea12, L_CastleArea13, L_CastleArea14, L_GroundArea30, L_GroundArea31
00C3AF  2                    .word L_GroundArea32, L_GroundArea33, L_GroundArea34, L_GroundArea35, L_GroundArea36, L_GroundArea37
00C3AF  2                    .word L_GroundArea38, L_GroundArea39, L_GroundArea40, L_GroundArea41, L_GroundArea10, L_GroundArea28
00C3AF  2                    .word L_UndergroundArea6, L_UndergroundArea7, L_WaterArea9
00C3AF  2               .endif
00C3AF  2               
00C3AF  2               AtoDHalfwayPages:
00C3AF  2  76 50             .byte $76, $50
00C3B1  2               .ifdef ANN
00C3B1  2  D5 70             .byte $D5, $70
00C3B3  2               .else
00C3B3  2                    .byte $65, $50
00C3B3  2               .endif
00C3B3  2  75 B0             .byte $75, $b0
00C3B5  2  00 00             .byte $00, $00
00C3B7  2               
00C3B7  2               ChangeHalfwayPages:
00C3B7  2  A0 07                ldy #$07
00C3B9  2  B9 AF C3     CHalfL: lda AtoDHalfwayPages,y     ;load new halfway nybbles over the old ones
00C3BC  2  99 rr rr             sta HalfwayPageNybbles,y
00C3BF  2  88                   dey
00C3C0  2  10 F7                bpl CHalfL
00C3C2  2  60                   rts
00C3C3  2               
00C3C3  2               ; unused space
00C3C3  2  FF FF FF FF  .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
00C3C7  2  FF FF FF FF  
00C3CB  2  FF FF FF FF  
00C3D3  2  FF FF FF FF  .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
00C3D7  2  FF FF FF FF  
00C3DB  2  FF FF FF FF  
00C3E3  2  FF FF FF FF  .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
00C3E7  2  FF FF FF FF  
00C3EB  2  FF FF FF FF  
00C3F3  2  FF FF FF FF  .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
00C3F7  2  FF FF FF FF  
00C3FB  2  FF FF FF FF  
00C403  2  FF FF FF FF  .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
00C407  2  FF FF FF FF  
00C40B  2  FF FF FF FF  
00C413  2  FF FF FF FF  .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
00C417  2  FF FF FF FF  
00C41B  2  FF FF FF FF  
00C423  2  FF FF FF FF  .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
00C427  2  FF FF FF FF  
00C42B  2  FF FF FF FF  
00C433  2  FF FF FF FF  .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
00C437  2  FF FF FF FF  
00C43B  2  FF FF FF FF  
00C443  2  FF FF FF FF  .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
00C447  2  FF FF FF FF  
00C44B  2  FF FF FF FF  
00C451  2               .ifdef ANN
00C451  2  FF FF FF FF  .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
00C455  2  FF FF FF FF  
00C459  2  FF FF FF FF  
00C461  2  FF FF FF FF  .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
00C465  2  FF FF FF FF  
00C469  2  FF FF FF FF  
00C470  2               .endif
00C470  2               
00C470  2               ;-------------------------------------------------------------------------------------------------
00C470  2               ;$06 - used to store vertical length of pipe
00C470  2               ;$07 - starts with adder from area parser, used to store row offset
00C470  2               
00C470  2               UpsideDownPipe_High:
00C470  2  A9 01               lda #$01                     ;start at second row
00C472  2  48                  pha
00C473  2  D0 03               bne UDP
00C475  2               UpsideDownPipe_Low:
00C475  2  A9 04               lda #$04                     ;start at fifth row
00C477  2  48                  pha
00C478  2  20 rr rr     UDP:   jsr GetPipeHeight            ;get pipe height from object byte
00C47B  2  68                  pla
00C47C  2  85 07               sta $07                      ;save buffer offset temporarily
00C47E  2  98                  tya
00C47F  2  48                  pha                          ;save pipe height temporarily
00C480  2  BC 30 07            ldy AreaObjectLength,x       ;if on second column of pipe, skip this
00C483  2  F0 23               beq NoUDP
00C485  2  20 rr rr            jsr FindEmptyEnemySlot       ;otherwise try to insert upside-down
00C488  2  B0 1E               bcs NoUDP                    ;piranha plant, if no empty slots, skip this
00C48A  2  A9 04               lda #$04
00C48C  2  20 rr rr            jsr SetupPiranhaPlant        ;set up upside-down piranha plant
00C48F  2  A5 06               lda $06
00C491  2  0A                  asl
00C492  2  0A                  asl                          ;multiply height of pipe by 16
00C493  2  0A                  asl                          ;and add enemy Y position previously set up
00C494  2  0A                  asl                          ;then subtract 10 pixels, save as new Y position
00C495  2  18                  clc
00C496  2  75 CF               adc Enemy_Y_Position,x
00C498  2  38                  sec
00C499  2  E9 0A               sbc #$0a
00C49B  2  95 CF               sta Enemy_Y_Position,x
00C49D  2  9D 34 04            sta PiranhaPlantDownYPos,x   ;set as "down" position, which in this case is up
00C4A0  2  18                  clc                          ;add 24 pixels, save as "up" position
00C4A1  2  69 18               adc #$18                     ;note up and down here are reversed
00C4A3  2  9D 17 04            sta PiranhaPlantUpYPos,x
00C4A6  2  F6 A0               inc PiranhaPlant_MoveFlag,x  ;set movement flag
00C4A8  2  68           NoUDP: pla
00C4A9  2  A8                  tay                          ;return tile offset
00C4AA  2  48                  pha
00C4AB  2  A6 07               ldx $07
00C4AD  2  B9 rr rr            lda VerticalPipeData+2,y
00C4B0  2  A4 06               ldy $06                      ;render the pipe shaft
00C4B2  2  88                  dey
00C4B3  2  20 rr rr            jsr RenderUnderPart
00C4B6  2  68                  pla
00C4B7  2  A8                  tay
00C4B8  2  B9 rr rr            lda VerticalPipeData,y       ;and render the pipe end
00C4BB  2  9D rr rr            sta MetatileBuffer,x
00C4BE  2  60                  rts
00C4BF  2               
00C4BF  2  60                  rts                       ;unused, nothing jumps here
00C4C0  2               
00C4C0  2               MoveUpsideDownPiranhaP:
00C4C0  2  B5 1E              lda Enemy_State,x           ;check enemy state
00C4C2  2  D0 39              bne ExMoveUDPP              ;if set at all, branch to leave
00C4C4  2  BD 8A 07           lda EnemyFrameTimer,x       ;check enemy's timer here
00C4C7  2  D0 34              bne ExMoveUDPP              ;branch to end if not yet expired
00C4C9  2  B5 A0              lda PiranhaPlant_MoveFlag,x ;check movement flag
00C4CB  2  D0 0B              bne SetupToMovePPlant       ;if moving, skip to part ahead
00C4CD  2  B5 58              lda PiranhaPlant_Y_Speed,x  ;get vertical speed
00C4CF  2  49 FF              eor #$ff
00C4D1  2  18                 clc                         ;change to two's compliment
00C4D2  2  69 01              adc #$01
00C4D4  2  95 58              sta PiranhaPlant_Y_Speed,x  ;save as new vertical speed
00C4D6  2  F6 A0              inc PiranhaPlant_MoveFlag,x ;increment to set movement flag
00C4D8  2               
00C4D8  2               SetupToMovePPlant:
00C4D8  2  BD 17 04           lda PiranhaPlantUpYPos,x    ;get original vertical coordinate (lowest point)
00C4DB  2  B4 58              ldy PiranhaPlant_Y_Speed,x  ;get vertical speed
00C4DD  2  10 03              bpl RiseFallPiranhaPlant    ;branch if moving downwards
00C4DF  2  BD 34 04           lda PiranhaPlantDownYPos,x  ;otherwise get other vertical coordinate (highest point)
00C4E2  2               
00C4E2  2               RiseFallPiranhaPlant:
00C4E2  2  85 00               sta $00                     ;save vertical coordinate here
00C4E4  2  AD 47 07            lda TimerControl            ;get master timer control
00C4E7  2  D0 14               bne ExMoveUDPP              ;branch to leave if set (likely not necessary)
00C4E9  2  B5 CF               lda Enemy_Y_Position,x      ;get current vertical coordinate
00C4EB  2  18                  clc
00C4EC  2  75 58               adc PiranhaPlant_Y_Speed,x  ;add vertical speed to move up or down
00C4EE  2  95 CF               sta Enemy_Y_Position,x      ;save as new vertical coordinate
00C4F0  2  C5 00               cmp $00                     ;compare against low or high coordinate
00C4F2  2  D0 09               bne ExMoveUDPP              ;branch to leave if not yet reached
00C4F4  2  A9 00               lda #$00
00C4F6  2  95 A0               sta PiranhaPlant_MoveFlag,x ;otherwise clear movement flag
00C4F8  2  A9 20               lda #$20
00C4FA  2  9D 8A 07            sta EnemyFrameTimer,x       ;set timer to delay piranha plant movement
00C4FD  2               ExMoveUDPP:
00C4FD  2  60                  rts
00C4FE  2               
00C4FE  2               ;-------------------------------------------------------------------------------------
00C4FE  2               
00C4FE  2               .ifndef ANN
00C4FE  2               BlowPlayerAround:
00C4FE  2                       lda WindFlag            ;if wind is turned off, just exit
00C4FE  2                       beq ExBlow
00C4FE  2                       lda AreaType            ;don't blow the player around unless
00C4FE  2                       cmp #$01                ;the area is ground type
00C4FE  2                       bne ExBlow
00C4FE  2                       ldy #$01
00C4FE  2                       lda FrameCounter
00C4FE  2                       asl
00C4FE  2                       bcs BThr
00C4FE  2                       ldy #$03
00C4FE  2               BThr:   sty $00
00C4FE  2                       lda FrameCounter
00C4FE  2                       and $00
00C4FE  2                       bne ExBlow
00C4FE  2                       lda Player_X_Position   ;move player slightly to the right
00C4FE  2                       clc                     ;to simulate the wind moving the player
00C4FE  2                       adc #$01
00C4FE  2                       sta Player_X_Position
00C4FE  2                       lda Player_PageLoc
00C4FE  2                       adc #$00
00C4FE  2                       sta Player_PageLoc
00C4FE  2                       inc Player_X_Scroll     ;add one to movement speed for scroll
00C4FE  2               ExBlow: rts
00C4FE  2               
00C4FE  2               ;note the position data values are overwritten in RAM
00C4FE  2               LeavesYPos:
00C4FE  2                       .byte $30, $70, $b8, $50, $98, $30
00C4FE  2                       .byte $70, $b8, $50, $98, $30, $70
00C4FE  2               
00C4FE  2               LeavesXPos:
00C4FE  2                       .byte $30, $30, $30, $60, $60, $a0
00C4FE  2                       .byte $a0, $a0, $d0, $d0, $d0, $60
00C4FE  2               
00C4FE  2               LeavesTile:
00C4FE  2                       .byte $7b, $7b, $7b, $7b, $7a, $7a
00C4FE  2                       .byte $7b, $7b, $7b, $7a, $7b, $7a
00C4FE  2               
00C4FE  2               SimulateWind:
00C4FE  2                         lda WindFlag             ;if no wind, branch to leave
00C4FE  2                         beq ExSimW
00C4FE  2                         lda #$04                 ;play wind sfx
00C4FE  2                         sta NoiseSoundQueue
00C4FE  2                         jsr ModifyLeavesPos      ;modify X and Y position data of leaves
00C4FE  2                         ldx #$00
00C4FE  2                         ldy Alt_SprDataOffset-1  ;use first sprite data offset for first six leaves
00C4FE  2               DrawLeaf: lda LeavesYPos,x
00C4FE  2                         sta Sprite_Y_Position,y  ;set up sprite data in OAM memory
00C4FE  2                         lda LeavesTile,x
00C4FE  2                         sta Sprite_Tilenumber,y
00C4FE  2                         lda #$41
00C4FE  2                         sta Sprite_Attributes,y
00C4FE  2                         lda LeavesXPos,x
00C4FE  2                         sta Sprite_X_Position,y
00C4FE  2                         iny
00C4FE  2                         iny
00C4FE  2                         iny
00C4FE  2                         iny
00C4FE  2                         inx
00C4FE  2                         cpx #$06                 ;if still on first six leaves, continue
00C4FE  2                         bne DLLoop               ;using the first sprite data offset
00C4FE  2                         ldy Alt_SprDataOffset    ;otherwise use the second one instead
00C4FE  2               DLLoop:   cpx #$0c                 ;continue until done putting twelve leaves on the screen
00C4FE  2                         bne DrawLeaf
00C4FE  2               ExSimW:   rts
00C4FE  2               
00C4FE  2               LeavesPosAdder:
00C4FE  2                  .byte $57, $57, $56, $56, $58, $58, $56, $56, $57, $58, $57, $58
00C4FE  2                  .byte $59, $59, $58, $58, $5a, $5a, $58, $58, $59, $5a, $59, $5a
00C4FE  2               
00C4FE  2               ModifyLeavesPos:
00C4FE  2                        ldx #$0b
00C4FE  2               MLPLoop: lda LeavesXPos,x     ;add each adder to each X position twice
00C4FE  2                        clc                  ;and to each Y position once
00C4FE  2                        adc LeavesPosAdder,x
00C4FE  2                        adc LeavesPosAdder,x
00C4FE  2                        sta LeavesXPos,x
00C4FE  2                        lda LeavesYPos,x
00C4FE  2                        clc
00C4FE  2                        adc LeavesPosAdder,x
00C4FE  2                        sta LeavesYPos,x
00C4FE  2                        dex
00C4FE  2                        bpl MLPLoop
00C4FE  2                        rts
00C4FE  2               
00C4FE  2               WindOn:
00C4FE  2                    lda #$01       ;branch to turn the wind on
00C4FE  2                    bne WOn
00C4FE  2               WindOff:
00C4FE  2                    lda #$00       ;turn the wind off
00C4FE  2               WOn: sta WindFlag
00C4FE  2                    rts
00C4FE  2               
00C4FE  2               ;some unused bytes
00C4FE  2                  .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00C4FE  2               .endif
00C4FE  2               
00C4FE  2               .ifdef ANN
00C4FE  2               HardWorldJumpSpringHandler:
00C4FE  2  AC 5F 07       ldy WorldNumber
00C501  2  C0 01          cpy #$01
00C503  2  F0 04          beq @Shift
00C505  2  C0 02          cpy #$02
00C507  2  D0 02          bne @Done
00C509  2               @Shift:
00C509  2  A9 E0          lda #$E0
00C50B  2               @Done:
00C50B  2  60             rts
00C50C  2               
00C50C  2               HardWorldEnemyGfxHandler:
00C50C  2  AC 5F 07       ldy WorldNumber
00C50F  2  C0 01          cpy #$01
00C511  2  F0 04          beq @Shift
00C513  2  C0 02          cpy #$02
00C515  2  D0 01          bne @Done
00C517  2               @Shift:
00C517  2  4A             lsr a
00C518  2               @Done:
00C518  2  60             rts
00C519  2               
00C519  2               ;unused bytes
00C519  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C51D  2  FF FF FF FF  
00C521  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C525  2  FF FF FF FF  
00C529  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C52D  2  FF FF FF FF  
00C531  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C535  2  FF FF FF FF  
00C539  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C53D  2  FF FF FF FF  
00C541  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C545  2  FF FF FF FF  
00C549  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C54D  2  FF FF FF FF  
00C551  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C555  2  FF FF FF FF  
00C559  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C55D  2  FF FF FF FF  
00C561  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C565  2  FF FF FF FF  
00C569  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C56D  2  FF FF FF FF  
00C571  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C575  2  FF FF FF FF  
00C579  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C57D  2  FF FF FF FF  
00C581  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C585  2  FF FF FF FF  
00C589  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C58D  2  FF FF FF FF  
00C591  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C595  2  FF FF FF FF  
00C599  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C59D  2  FF FF FF FF  
00C5A1  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C5A5  2  FF FF FF FF  
00C5A9  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C5AD  2  FF FF FF FF  
00C5B1  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C5B5  2  FF FF FF FF  
00C5B9  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C5BD  2  FF FF FF FF  
00C5C1  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C5C5  2  FF FF FF FF  
00C5C9  2  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF
00C5CD  2  FF FF FF     
00C5D0  2               .endif
00C5D0  2               
00C5D0  2               
00C5D0  2               
00C5D0  2               .ifdef ANN
00C5D0  2               E_HArea00:
00C5D0  2  2A 9E 6B 0C  .byte $2A, $9E, $6B, $0C, $8D, $1C, $EA, $1F, $1B, $8C, $E6, $1C, $8C, $9C, $BB, $0C
00C5D4  2  8D 1C EA 1F  
00C5D8  2  1B 8C E6 1C  
00C5E0  2  F3 83 9B 8C  .byte $F3, $83, $9B, $8C, $DB, $0C, $1B, $8C, $6B, $0C, $BB, $0C, $0F, $09, $40, $15
00C5E4  2  DB 0C 1B 8C  
00C5E8  2  6B 0C BB 0C  
00C5F0  2  78 AD 90 B5  .byte $78, $AD, $90, $B5, $FF
00C5F4  2  FF           
00C5F5  2               
00C5F5  2               E_HArea01:
00C5F5  2  0F 02 38 1D  .byte $0F, $02, $38, $1D, $D9, $1B, $6E, $E1, $21, $3A, $A8, $18, $9D, $0F, $07, $18
00C5F9  2  D9 1B 6E E1  
00C5FD  2  21 3A A8 18  
00C605  2  1D 0F 09 18  .byte $1D, $0F, $09, $18, $1D, $0F, $0B, $18, $1D, $7B, $15, $8E, $21, $2E, $B9, $9D
00C609  2  1D 0F 0B 18  
00C60D  2  1D 7B 15 8E  
00C615  2  0F 0E 78 2D  .byte $0F, $0E, $78, $2D, $90, $B5, $FF
00C619  2  90 B5 FF     
00C61C  2               
00C61C  2               E_HArea02:
00C61C  2  05 9D 0D A8  .byte $05, $9D, $0D, $A8, $DD, $1D, $07, $AC, $54, $2C, $A2, $2C, $F4, $2C, $42, $AC
00C620  2  DD 1D 07 AC  
00C624  2  54 2C A2 2C  
00C62C  2  26 9D D4 03  .byte $26, $9D, $D4, $03, $24, $83, $64, $03, $2B, $82, $4B, $02, $7B, $02, $9B, $02
00C630  2  24 83 64 03  
00C634  2  2B 82 4B 02  
00C63C  2  5B 82 7B 02  .byte $5B, $82, $7B, $02, $0B, $82, $2B, $02, $C6, $1B, $28, $82, $48, $02, $A6, $1B
00C640  2  0B 82 2B 02  
00C644  2  C6 1B 28 82  
00C64C  2  7B 95 85 0C  .byte $7B, $95, $85, $0C, $9D, $9B, $0F, $0E, $78, $2D, $7A, $1D, $90, $B5, $FF
00C650  2  9D 9B 0F 0E  
00C654  2  78 2D 7A 1D  
00C65B  2               
00C65B  2               E_HArea03:
00C65B  2  19 9F 99 1B  .byte $19, $9F, $99, $1B, $2C, $8C, $59, $1B, $C5, $0F, $0F, $04, $09, $29, $BD, $1D
00C65F  2  2C 8C 59 1B  
00C663  2  C5 0F 0F 04  
00C66B  2  0F 06 6E 2A  .byte $0F, $06, $6E, $2A, $61, $0F, $09, $48, $2D, $46, $87, $79, $07, $8E, $63, $60
00C66F  2  61 0F 09 48  
00C673  2  2D 46 87 79  
00C67B  2  A5 07 B8 85  .byte $A5, $07, $B8, $85, $57, $A5, $8C, $8C, $76, $9D, $78, $2D, $90, $B5, $FF
00C67F  2  57 A5 8C 8C  
00C683  2  76 9D 78 2D  
00C68A  2               
00C68A  2               E_HArea04:
00C68A  2  07 83 37 03  .byte $07, $83, $37, $03, $6B, $0E, $E0, $3D, $20, $BE, $6E, $2B, $00, $A7, $85, $D3
00C68E  2  6B 0E E0 3D  
00C692  2  20 BE 6E 2B  
00C69A  2  05 E7 83 24  .byte $05, $E7, $83, $24, $83, $27, $03, $49, $00, $59, $00, $10, $BB, $B0, $3B, $6E
00C69E  2  83 27 03 49  
00C6A2  2  00 59 00 10  
00C6AA  2  C1 00 17 85  .byte $C1, $00, $17, $85, $53, $05, $36, $8E, $76, $0E, $B6, $0E, $E7, $83, $63, $83
00C6AE  2  53 05 36 8E  
00C6B2  2  76 0E B6 0E  
00C6BA  2  68 03 29 83  .byte $68, $03, $29, $83, $57, $03, $85, $03, $B5, $29, $FF
00C6BE  2  57 03 85 03  
00C6C2  2  B5 29 FF     
00C6C5  2               
00C6C5  2               E_Area1E:
00C6C5  2               E_HArea05:
00C6C5  2  56 87 44 87  .byte $56, $87, $44, $87, $0F, $04, $66, $87, $0F, $06, $86, $10, $0F, $08, $55, $0F
00C6C9  2  0F 04 66 87  
00C6CD  2  0F 06 86 10  
00C6D5  2  E5 8F FF     .byte $E5, $8F, $FF
00C6D8  2               
00C6D8  2               E_HArea06:
00C6D8  2  1B 82 4B 02  .byte $1B, $82, $4B, $02, $7B, $02, $AB, $02, $0F, $03, $F9, $0E, $D0, $BE, $8E, $C1
00C6DC  2  7B 02 AB 02  
00C6E0  2  0F 03 F9 0E  
00C6E8  2  24 F8 0E C0  .byte $24, $F8, $0E, $C0, $BA, $0F, $0D, $3A, $0E, $BB, $02, $30, $B7, $80, $BC, $C0
00C6EC  2  BA 0F 0D 3A  
00C6F0  2  0E BB 02 30  
00C6F8  2  BC 0F 12 24  .byte $BC, $0F, $12, $24, $0F, $54, $0F, $CE, $2B, $20, $D3, $0F, $CB, $8E, $F9, $0E
00C6FC  2  0F 54 0F CE  
00C700  2  2B 20 D3 0F  
00C708  2  FF           .byte $FF
00C709  2               
00C709  2               E_HArea07:
00C709  2  80 BE 83 03  .byte $80, $BE, $83, $03, $92, $10, $4B, $80, $B0, $3C, $07, $80, $B7, $24, $0C, $A4
00C70D  2  92 10 4B 80  
00C711  2  B0 3C 07 80  
00C719  2  96 A9 1B 83  .byte $96, $A9, $1B, $83, $7B, $24, $B7, $24, $97, $83, $E2, $0F, $A9, $A9, $38, $A9
00C71D  2  7B 24 B7 24  
00C721  2  97 83 E2 0F  
00C729  2  0F 0B 74 0F  .byte $0F, $0B, $74, $0F, $FF
00C72D  2  FF           
00C72E  2               
00C72E  2               E_HArea08:
00C72E  2  3A 8E 5B 0E  .byte $3A, $8E, $5B, $0E, $C3, $8E, $CA, $8E, $0B, $8E, $4A, $0E, $DE, $C1, $44, $0F
00C732  2  C3 8E CA 8E  
00C736  2  0B 8E 4A 0E  
00C73E  2  08 49 0E EB  .byte $08, $49, $0E, $EB, $0E, $8A, $90, $AB, $85, $0F, $0C, $03, $0F, $2E, $2B, $40
00C742  2  0E 8A 90 AB  
00C746  2  85 0F 0C 03  
00C74E  2  67 86 FF     .byte $67, $86, $FF
00C751  2               
00C751  2               E_HArea09:
00C751  2  15 8F 54 07  .byte $15, $8F, $54, $07, $AA, $83, $F8, $07, $0F, $04, $14, $07, $96, $10, $0F, $07
00C755  2  AA 83 F8 07  
00C759  2  0F 04 14 07  
00C761  2  95 0F 9D A8  .byte $95, $0F, $9D, $A8, $0B, $97, $09, $A9, $55, $24, $A9, $24, $BB, $17, $FF
00C765  2  0B 97 09 A9  
00C769  2  55 24 A9 24  
00C770  2               
00C770  2               E_HArea0A:
00C770  2  0F 04 A3 10  .byte $0F, $04, $A3, $10, $0F, $09, $E3, $29, $0F, $0D, $55, $24, $A9, $24, $0F, $11
00C774  2  0F 09 E3 29  
00C778  2  0F 0D 55 24  
00C780  2  59 1D A9 1B  .byte $59, $1D, $A9, $1B, $23, $8F, $15, $9B, $FF
00C784  2  23 8F 15 9B  
00C788  2  FF           
00C789  2               
00C789  2               E_HArea0B:
00C789  2  DB 82 30 B7  .byte $DB, $82, $30, $B7, $80, $3B, $1B, $8E, $4A, $0E, $EB, $03, $3B, $82, $5B, $02
00C78D  2  80 3B 1B 8E  
00C791  2  4A 0E EB 03  
00C799  2  E5 0F 14 8F  .byte $E5, $0F, $14, $8F, $44, $0F, $5E, $41, $60, $5B, $82, $0C, $85, $35, $8F, $06
00C79D  2  44 0F 5E 41  
00C7A1  2  60 5B 82 0C  
00C7A9  2  85 E3 05 2E  .byte $85, $E3, $05, $2E, $AB, $60, $DB, $03, $FF
00C7AD  2  AB 60 DB 03  
00C7B1  2  FF           
00C7B2  2               
00C7B2  2               E_HArea0C:
00C7B2  2  DB 82 F3 03  .byte $DB, $82, $F3, $03, $10, $B7, $80, $37, $1A, $8E, $4B, $0E, $7A, $0E, $AB, $0E
00C7B6  2  10 B7 80 37  
00C7BA  2  1A 8E 4B 0E  
00C7C2  2  0F 05 F9 0E  .byte $0F, $05, $F9, $0E, $D0, $BE, $2E, $C1, $62, $D4, $8F, $64, $8F, $7E, $2B, $60
00C7C6  2  D0 BE 2E C1  
00C7CA  2  62 D4 8F 64  
00C7D2  2  FF           .byte $FF
00C7D3  2               
00C7D3  2               E_HArea0D:
00C7D3  2  0F 03 AB 05  .byte $0F, $03, $AB, $05, $1B, $85, $A3, $85, $D7, $05, $0F, $08, $33, $03, $0B, $85
00C7D7  2  1B 85 A3 85  
00C7DB  2  D7 05 0F 08  
00C7E3  2  FB 85 8B 85  .byte $FB, $85, $8B, $85, $3A, $8E, $FF
00C7E7  2  3A 8E FF     
00C7EA  2               
00C7EA  2               E_HArea0E:
00C7EA  2  0F 02 09 05  .byte $0F, $02, $09, $05, $3E, $41, $64, $2B, $8E, $58, $0E, $CA, $07, $34, $87, $FF
00C7EE  2  3E 41 64 2B  
00C7F2  2  8E 58 0E CA  
00C7FA  2               
00C7FA  2               E_HArea0F:
00C7FA  2  0A AA 1E 20  .byte $0A, $AA, $1E, $20, $03, $1E, $22, $30, $2E, $24, $48, $2E, $28, $67, $FF
00C7FE  2  03 1E 22 30  
00C802  2  2E 24 48 2E  
00C809  2               
00C809  2               E_HArea12:
00C809  2  BB A9 1B A9  .byte $BB, $A9, $1B, $A9, $69, $29, $B8, $29, $59, $A9, $8D, $A8, $0F, $07, $15, $29
00C80D  2  69 29 B8 29  
00C811  2  59 A9 8D A8  
00C819  2  55 AC 6B 85  .byte $55, $AC, $6B, $85, $0E, $AD, $01, $67, $34, $FF
00C81D  2  0E AD 01 67  
00C821  2  34 FF        
00C823  2               
00C823  2               E_HArea13:
00C823  2  1E A0 09 1E  .byte $1E, $A0, $09, $1E, $27, $61, $0F, $03, $1E, $28, $68, $1E, $22, $27, $0F, $05
00C827  2  27 61 0F 03  
00C82B  2  1E 28 68 1E  
00C833  2  1E 24 48 1E  .byte $1E, $24, $48, $1E, $63, $68, $FF
00C837  2  63 68 FF     
00C83A  2               
00C83A  2               E_HArea14:
00C83A  2  EE AD 21 26  .byte $EE, $AD, $21, $26, $87, $F3, $0E, $66, $87, $CB, $00, $65, $87, $0F, $06, $06
00C83E  2  87 F3 0E 66  
00C842  2  87 CB 00 65  
00C84A  2  0E 97 07 CB  .byte $0E, $97, $07, $CB, $00, $75, $87, $D3, $27, $D9, $27, $0F, $09, $77, $1F, $46
00C84E  2  00 75 87 D3  
00C852  2  27 D9 27 0F  
00C85A  2  87 B1 0F FF  .byte $87, $B1, $0F, $FF
00C85E  2               
00C85E  2               
00C85E  2               
00C85E  2               
00C85E  2               L_HArea00:
00C85E  2  9B 87 05 32  .byte $9B, $87, $05, $32, $06, $33, $07, $34, $EE, $0A, $0E, $86, $28, $0B, $3E, $0A
00C862  2  06 33 07 34  
00C866  2  EE 0A 0E 86  
00C86E  2  6E 02 8B 0B  .byte $6E, $02, $8B, $0B, $97, $00, $9E, $0A, $CE, $06, $E8, $0B, $FE, $0A, $2E, $86
00C872  2  97 00 9E 0A  
00C876  2  CE 06 E8 0B  
00C87E  2  6E 0A 8E 08  .byte $6E, $0A, $8E, $08, $E4, $0B, $1E, $82, $8A, $0B, $8E, $0A, $FE, $02, $1A, $E0
00C882  2  E4 0B 1E 82  
00C886  2  8A 0B 8E 0A  
00C88E  2  29 61 2E 06  .byte $29, $61, $2E, $06, $3E, $09, $56, $60, $65, $61, $6E, $0C, $83, $60, $7E, $8A
00C892  2  3E 09 56 60  
00C896  2  65 61 6E 0C  
00C89E  2  BB 61 F9 63  .byte $BB, $61, $F9, $63, $27, $E5, $88, $64, $EB, $61, $FE, $05, $68, $90, $0A, $90
00C8A2  2  27 E5 88 64  
00C8A6  2  EB 61 FE 05  
00C8AE  2  FE 02 3A 90  .byte $FE, $02, $3A, $90, $3E, $0A, $AE, $02, $DA, $60, $E9, $61, $F8, $62, $FE, $0A
00C8B2  2  3E 0A AE 02  
00C8B6  2  DA 60 E9 61  
00C8BE  2  0D C4 A1 62  .byte $0D, $C4, $A1, $62, $B1, $62, $CD, $43, $CE, $09, $DE, $0B, $DD, $42, $FE, $02
00C8C2  2  B1 62 CD 43  
00C8C6  2  CE 09 DE 0B  
00C8CE  2  5D C7 FD     .byte $5D, $C7, $FD
00C8D1  2               
00C8D1  2               L_HArea01:
00C8D1  2  9B 07 05 32  .byte $9B, $07, $05, $32, $06, $33, $07, $33, $3E, $0A, $41, $3B, $42, $3B, $58, $64
00C8D5  2  06 33 07 33  
00C8D9  2  3E 0A 41 3B  
00C8E1  2  7A 62 C8 31  .byte $7A, $62, $C8, $31, $18, $E4, $39, $73, $5E, $09, $66, $3C, $0E, $82, $28, $05
00C8E5  2  18 E4 39 73  
00C8E9  2  5E 09 66 3C  
00C8F1  2  36 0B 3E 0A  .byte $36, $0B, $3E, $0A, $AE, $02, $D7, $0B, $FE, $0C, $FE, $8A, $11, $E5, $21, $65
00C8F5  2  AE 02 D7 0B  
00C8F9  2  FE 0C FE 8A  
00C901  2  31 65 4E 0C  .byte $31, $65, $4E, $0C, $FE, $02, $16, $8B, $2E, $0E, $FE, $02, $18, $FA, $3E, $0E
00C905  2  FE 02 16 8B  
00C909  2  2E 0E FE 02  
00C911  2  FE 02 16 8B  .byte $FE, $02, $16, $8B, $2E, $0E, $FE, $02, $18, $FA, $3E, $0E, $FE, $02, $16, $8B
00C915  2  2E 0E FE 02  
00C919  2  18 FA 3E 0E  
00C921  2  2E 0E FE 02  .byte $2E, $0E, $FE, $02, $18, $FA, $3E, $0E, $FE, $02, $16, $8B, $2E, $0E, $FE, $02
00C925  2  18 FA 3E 0E  
00C929  2  FE 02 16 8B  
00C931  2  18 FA 5E 0A  .byte $18, $FA, $5E, $0A, $6E, $02, $7E, $0A, $B7, $0B, $EE, $07, $FE, $8A, $0D, $C4
00C935  2  6E 02 7E 0A  
00C939  2  B7 0B EE 07  
00C941  2  CD 43 CE 09  .byte $CD, $43, $CE, $09, $DD, $42, $DE, $0B, $FE, $02, $5D, $C7, $FD
00C945  2  DD 42 DE 0B  
00C949  2  FE 02 5D C7  
00C94E  2               
00C94E  2               L_HArea02:
00C94E  2  58 07 05 35  .byte $58, $07, $05, $35, $06, $3D, $07, $3D, $BE, $06, $DE, $0C, $F3, $3D, $03, $8B
00C952  2  06 3D 07 3D  
00C956  2  BE 06 DE 0C  
00C95E  2  6E 43 CE 0A  .byte $6E, $43, $CE, $0A, $E1, $67, $F1, $67, $01, $E7, $11, $67, $1E, $05, $28, $39
00C962  2  E1 67 F1 67  
00C966  2  01 E7 11 67  
00C96E  2  6E 40 BE 01  .byte $6E, $40, $BE, $01, $C7, $04, $DB, $0B, $DE, $00, $1F, $80, $6F, $00, $BF, $00
00C972  2  C7 04 DB 0B  
00C976  2  DE 00 1F 80  
00C97E  2  0F 80 5F 00  .byte $0F, $80, $5F, $00, $7E, $05, $A8, $37, $FE, $02, $24, $8B, $34, $30, $3E, $0C
00C982  2  7E 05 A8 37  
00C986  2  FE 02 24 8B  
00C98E  2  4E 43 AE 0A  .byte $4E, $43, $AE, $0A, $BE, $0C, $EE, $0A, $FE, $0C, $2E, $8A, $3E, $0C, $7E, $02
00C992  2  BE 0C EE 0A  
00C996  2  FE 0C 2E 8A  
00C99E  2  8E 0E 98 36  .byte $8E, $0E, $98, $36, $B9, $34, $08, $BF, $09, $3F, $0E, $82, $2E, $86, $4E, $0C
00C9A2  2  B9 34 08 BF  
00C9A6  2  09 3F 0E 82  
00C9AE  2  9E 09 C1 62  .byte $9E, $09, $C1, $62, $C4, $0B, $EE, $0C, $0E, $86, $5E, $0C, $7E, $09, $A1, $62
00C9B2  2  C4 0B EE 0C  
00C9B6  2  0E 86 5E 0C  
00C9BE  2  A4 0B CE 0C  .byte $A4, $0B, $CE, $0C, $FE, $0A, $28, $B4, $A6, $31, $E8, $34, $8B, $B2, $9B, $0B
00C9C2  2  FE 0A 28 B4  
00C9C6  2  A6 31 E8 34  
00C9CE  2  FE 07 FE 8A  .byte $FE, $07, $FE, $8A, $0D, $C4, $CD, $43, $CE, $09, $DD, $42, $DE, $0B, $FE, $02
00C9D2  2  0D C4 CD 43  
00C9D6  2  CE 09 DD 42  
00C9DE  2  5D C7 FD     .byte $5D, $C7, $FD
00C9E1  2               
00C9E1  2               L_HArea03:
00C9E1  2  5B 03 05 34  .byte $5B, $03, $05, $34, $06, $35, $39, $71, $6E, $02, $AE, $0A, $FE, $05, $17, $8B
00C9E5  2  06 35 39 71  
00C9E9  2  6E 02 AE 0A  
00C9F1  2  97 0B 9E 02  .byte $97, $0B, $9E, $02, $A6, $04, $FA, $30, $FE, $0A, $4E, $82, $57, $0B, $58, $62
00C9F5  2  A6 04 FA 30  
00C9F9  2  FE 0A 4E 82  
00CA01  2  68 62 79 61  .byte $68, $62, $79, $61, $8A, $60, $8E, $0A, $F5, $31, $F9, $73, $39, $F3, $B5, $71
00CA05  2  8A 60 8E 0A  
00CA09  2  F5 31 F9 73  
00CA11  2  B7 31 4D C8  .byte $B7, $31, $4D, $C8, $8A, $62, $9A, $62, $AE, $05, $BB, $0B, $CD, $4A, $FE, $82
00CA15  2  8A 62 9A 62  
00CA19  2  AE 05 BB 0B  
00CA21  2  77 FB DE 0F  .byte $77, $FB, $DE, $0F, $4E, $82, $6D, $47, $39, $F3, $0C, $EA, $08, $3F, $B3, $00
00CA25  2  4E 82 6D 47  
00CA29  2  39 F3 0C EA  
00CA31  2  CC 63 F9 30  .byte $CC, $63, $F9, $30, $69, $F9, $EA, $60, $F9, $61, $FE, $07, $DE, $84, $E4, $62
00CA35  2  69 F9 EA 60  
00CA39  2  F9 61 FE 07  
00CA41  2  E9 61 F4 62  .byte $E9, $61, $F4, $62, $FA, $60, $04, $E2, $14, $62, $24, $62, $34, $62, $3E, $0A
00CA45  2  FA 60 04 E2  
00CA49  2  14 62 24 62  
00CA51  2  7E 0C 7E 8A  .byte $7E, $0C, $7E, $8A, $8E, $08, $94, $36, $FE, $0A, $0D, $C4, $61, $64, $71, $64
00CA55  2  8E 08 94 36  
00CA59  2  FE 0A 0D C4  
00CA61  2  81 64 CD 43  .byte $81, $64, $CD, $43, $CE, $09, $DD, $42, $DE, $0B, $FE, $02, $5D, $C7, $FD
00CA65  2  CE 09 DD 42  
00CA69  2  DE 0B FE 02  
00CA70  2               
00CA70  2               L_HArea04:
00CA70  2  52 71 0F 20  .byte $52, $71, $0F, $20, $6E, $70, $E3, $64, $FC, $61, $FC, $71, $13, $84, $2C, $61
00CA74  2  6E 70 E3 64  
00CA78  2  FC 61 FC 71  
00CA80  2  2C 71 43 64  .byte $2C, $71, $43, $64, $B2, $22, $B5, $62, $C7, $28, $22, $A2, $52, $06, $56, $61
00CA84  2  B2 22 B5 62  
00CA88  2  C7 28 22 A2  
00CA90  2  6C 03 DB 71  .byte $6C, $03, $DB, $71, $FC, $03, $F3, $20, $03, $A4, $0F, $71, $40, $09, $86, $47
00CA94  2  FC 03 F3 20  
00CA98  2  03 A4 0F 71  
00CAA0  2  8C 74 9C 66  .byte $8C, $74, $9C, $66, $D7, $00, $EC, $71, $89, $E1, $B6, $61, $B9, $2A, $C7, $26
00CAA4  2  D7 00 EC 71  
00CAA8  2  89 E1 B6 61  
00CAB0  2  F4 23 67 E2  .byte $F4, $23, $67, $E2, $E8, $F2, $7C, $F4, $03, $A6, $07, $26, $21, $79, $4B, $71
00CAB4  2  E8 F2 7C F4  
00CAB8  2  03 A6 07 26  
00CAC0  2  CF 33 06 E4  .byte $CF, $33, $06, $E4, $16, $2A, $39, $71, $58, $45, $5A, $45, $C6, $05, $DC, $04
00CAC4  2  16 2A 39 71  
00CAC8  2  58 45 5A 45  
00CAD0  2  3F E7 3B 71  .byte $3F, $E7, $3B, $71, $8C, $71, $AC, $01, $E7, $63, $39, $8C, $63, $20, $65, $08
00CAD4  2  8C 71 AC 01  
00CAD8  2  E7 63 39 8C  
00CAE0  2  68 62 8C 00  .byte $68, $62, $8C, $00, $0C, $81, $29, $63, $3C, $01, $57, $65, $6C, $01, $85, $67
00CAE4  2  0C 81 29 63  
00CAE8  2  3C 01 57 65  
00CAF0  2  9C 04 1D C1  .byte $9C, $04, $1D, $C1, $5F, $26, $3D, $C7, $FD
00CAF4  2  5F 26 3D C7  
00CAF8  2  FD           
00CAF9  2               
00CAF9  2               L_HArea05:
00CAF9  2  50 50 0B 1E  .byte $50, $50, $0B, $1E, $0F, $26, $19, $96, $84, $43, $C7, $1E, $6D, $C8, $E3, $12
00CAFD  2  0F 26 19 96  
00CB01  2  84 43 C7 1E  
00CB09  2  39 9C 56 43  .byte $39, $9C, $56, $43, $47, $9A, $A4, $12, $C1, $04, $F4, $42, $1B, $98, $A7, $14
00CB0D  2  47 9A A4 12  
00CB11  2  C1 04 F4 42  
00CB19  2  02 C2 03 12  .byte $02, $C2, $03, $12, $57, $1E, $AD, $48, $63, $9C, $82, $48, $86, $92, $08, $94
00CB1D  2  57 1E AD 48  
00CB21  2  63 9C 82 48  
00CB29  2  8E 11 B0 02  .byte $8E, $11, $B0, $02, $C9, $0C, $1D, $C1, $2D, $4A, $4E, $42, $6F, $20, $0D, $0E
00CB2D  2  C9 0C 1D C1  
00CB31  2  2D 4A 4E 42  
00CB39  2  0E 40 39 71  .byte $0E, $40, $39, $71, $7F, $37, $F2, $68, $01, $E9, $11, $39, $68, $7A, $DE, $1F
00CB3D  2  7F 37 F2 68  
00CB41  2  01 E9 11 39  
00CB49  2  6D C5 FD     .byte $6D, $C5, $FD
00CB4C  2               
00CB4C  2               L_HArea06:
00CB4C  2  52 B1 0F 20  .byte $52, $B1, $0F, $20, $6E, $75, $CC, $73, $A3, $B3, $BF, $74, $0C, $84, $83, $3F
00CB50  2  6E 75 CC 73  
00CB54  2  A3 B3 BF 74  
00CB5C  2  9F 74 EF 71  .byte $9F, $74, $EF, $71, $EC, $01, $2F, $F1, $2C, $01, $6F, $71, $A8, $91, $AA, $10
00CB60  2  EC 01 2F F1  
00CB64  2  2C 01 6F 71  
00CB6C  2  77 FB 56 F4  .byte $77, $FB, $56, $F4, $39, $F1, $BF, $37, $33, $E7, $43, $03, $47, $02, $6C, $05
00CB70  2  39 F1 BF 37  
00CB74  2  33 E7 43 03  
00CB7C  2  C3 67 D3 67  .byte $C3, $67, $D3, $67, $E3, $67, $FC, $07, $73, $E7, $83, $67, $93, $67, $A3, $67
00CB80  2  E3 67 FC 07  
00CB84  2  73 E7 83 67  
00CB8C  2  BC 08 43 E7  .byte $BC, $08, $43, $E7, $53, $67, $DC, $02, $59, $91, $C3, $33, $D9, $71, $DF, $72
00CB90  2  53 67 DC 02  
00CB94  2  59 91 C3 33  
00CB9C  2  5B F1 9B 71  .byte $5B, $F1, $9B, $71, $3B, $F1, $A7, $C2, $DB, $71, $0D, $10, $9B, $71, $0A, $B0
00CBA0  2  3B F1 A7 C2  
00CBA4  2  DB 71 0D 10  
00CBAC  2  1C 04 67 63  .byte $1C, $04, $67, $63, $76, $64, $85, $65, $94, $66, $A3, $67, $B3, $67, $CC, $09
00CBB0  2  76 64 85 65  
00CBB4  2  94 66 A3 67  
00CBBC  2  73 A3 87 22  .byte $73, $A3, $87, $22, $B3, $06, $D6, $82, $E3, $02, $FE, $3F, $0D, $15, $DE, $31
00CBC0  2  B3 06 D6 82  
00CBC4  2  E3 02 FE 3F  
00CBCC  2  EC 01 03 F7  .byte $EC, $01, $03, $F7, $9D, $41, $DF, $26, $BD, $C7, $FD
00CBD0  2  9D 41 DF 26  
00CBD4  2  BD C7 FD     
00CBD7  2               
00CBD7  2               L_HArea07:
00CBD7  2  55 10 0B 1F  .byte $55, $10, $0B, $1F, $0F, $26, $D6, $12, $07, $9F, $33, $1A, $FB, $1F, $F7, $94
00CBDB  2  0F 26 D6 12  
00CBDF  2  07 9F 33 1A  
00CBE7  2  24 88 53 14  .byte $24, $88, $53, $14, $71, $71, $CC, $15, $CF, $13, $1F, $98, $63, $12, $9B, $13
00CBEB  2  71 71 CC 15  
00CBEF  2  CF 13 1F 98  
00CBF7  2  A9 71 FB 17  .byte $A9, $71, $FB, $17, $09, $F1, $13, $13, $21, $42, $59, $0C, $EB, $13, $33, $93
00CBFB  2  09 F1 13 13  
00CBFF  2  21 42 59 0C  
00CC07  2  40 04 8C 14  .byte $40, $04, $8C, $14, $8F, $17, $93, $40, $CF, $13, $0B, $94, $57, $15, $07, $93
00CC0B  2  8F 17 93 40  
00CC0F  2  CF 13 0B 94  
00CC17  2  24 08 19 F3  .byte $24, $08, $19, $F3, $C6, $43, $C7, $13, $D3, $02, $E3, $02, $33, $B0, $4A, $72
00CC1B  2  C6 43 C7 13  
00CC1F  2  D3 02 E3 02  
00CC27  2  55 46 73 31  .byte $55, $46, $73, $31, $A8, $74, $E3, $12, $8E, $91, $AD, $41, $CE, $42, $EF, $20
00CC2B  2  A8 74 E3 12  
00CC2F  2  8E 91 AD 41  
00CC37  2  DD C7 FD     .byte $DD, $C7, $FD
00CC3A  2               
00CC3A  2               L_HArea08:
00CC3A  2  52 31 0F 20  .byte $52, $31, $0F, $20, $6E, $74, $0D, $02, $03, $33, $1F, $72, $39, $71, $65, $03
00CC3E  2  6E 74 0D 02  
00CC42  2  03 33 1F 72  
00CC4A  2  6C 70 77 00  .byte $6C, $70, $77, $00, $84, $72, $8C, $72, $B3, $34, $EC, $01, $EF, $72, $0D, $04
00CC4E  2  84 72 8C 72  
00CC52  2  B3 34 EC 01  
00CC5A  2  AC 67 CC 01  .byte $AC, $67, $CC, $01, $CF, $71, $E7, $2B, $23, $80, $3C, $62, $65, $71, $67, $33
00CC5E  2  CF 71 E7 2B  
00CC62  2  23 80 3C 62  
00CC6A  2  8C 61 DC 01  .byte $8C, $61, $DC, $01, $08, $FA, $45, $75, $63, $07, $73, $23, $7C, $02, $8F, $72
00CC6E  2  08 FA 45 75  
00CC72  2  63 07 73 23  
00CC7A  2  73 A9 9F 74  .byte $73, $A9, $9F, $74, $BF, $74, $EF, $73, $39, $F1, $FC, $0A, $0D, $0B, $13, $25
00CC7E  2  BF 74 EF 73  
00CC82  2  39 F1 FC 0A  
00CC8A  2  4C 01 4F 72  .byte $4C, $01, $4F, $72, $73, $08, $77, $02, $DC, $08, $23, $A2, $53, $06, $56, $02
00CC8E  2  73 08 77 02  
00CC92  2  DC 08 23 A2  
00CC9A  2  63 24 8C 02  .byte $63, $24, $8C, $02, $3F, $B3, $77, $63, $96, $74, $B3, $77, $5D, $C1, $8F, $26
00CC9E  2  3F B3 77 63  
00CCA2  2  96 74 B3 77  
00CCAA  2  7D C7 FD     .byte $7D, $C7, $FD
00CCAD  2               
00CCAD  2               L_HArea09:
00CCAD  2  54 11 0F 26  .byte $54, $11, $0F, $26, $CF, $32, $F8, $62, $FE, $10, $3C, $B2, $BD, $48, $EA, $62
00CCB1  2  CF 32 F8 62  
00CCB5  2  FE 10 3C B2  
00CCBD  2  FC 4D FC 4D  .byte $FC, $4D, $FC, $4D, $17, $C9, $DA, $62, $0B, $97, $B7, $12, $2C, $B1, $33, $43
00CCC1  2  17 C9 DA 62  
00CCC5  2  0B 97 B7 12  
00CCCD  2  6C 31 AC 41  .byte $6C, $31, $AC, $41, $0B, $98, $AD, $4A, $DB, $30, $27, $B0, $B7, $14, $C6, $42
00CCD1  2  0B 98 AD 4A  
00CCD5  2  DB 30 27 B0  
00CCDD  2  C7 96 D6 44  .byte $C7, $96, $D6, $44, $2B, $92, $39, $0C, $72, $41, $A7, $00, $1B, $95, $97, $13
00CCE1  2  2B 92 39 0C  
00CCE5  2  72 41 A7 00  
00CCED  2  6C 95 6F 11  .byte $6C, $95, $6F, $11, $A2, $40, $BF, $15, $C2, $40, $0B, $9A, $62, $42, $63, $12
00CCF1  2  A2 40 BF 15  
00CCF5  2  C2 40 0B 9A  
00CCFD  2  AD 4A 0E 91  .byte $AD, $4A, $0E, $91, $1D, $41, $4F, $26, $4D, $C7, $FD
00CD01  2  1D 41 4F 26  
00CD05  2  4D C7 FD     
00CD08  2               
00CD08  2               L_HArea0A:
00CD08  2  57 11 0F 26  .byte $57, $11, $0F, $26, $FE, $10, $4B, $92, $59, $0C, $D3, $93, $0B, $94, $29, $0C
00CD0C  2  FE 10 4B 92  
00CD10  2  59 0C D3 93  
00CD18  2  7B 93 99 0C  .byte $7B, $93, $99, $0C, $0D, $06, $27, $12, $35, $0C, $23, $B1, $57, $75, $A3, $31
00CD1C  2  0D 06 27 12  
00CD20  2  35 0C 23 B1  
00CD28  2  AB 71 F7 75  .byte $AB, $71, $F7, $75, $23, $B1, $87, $13, $95, $0C, $0D, $0A, $23, $35, $38, $13
00CD2C  2  23 B1 87 13  
00CD30  2  95 0C 0D 0A  
00CD38  2  55 00 9B 16  .byte $55, $00, $9B, $16, $0B, $96, $C7, $75, $3B, $92, $49, $0C, $29, $92, $52, $40
00CD3C  2  0B 96 C7 75  
00CD40  2  3B 92 49 0C  
00CD48  2  6C 15 6F 11  .byte $6C, $15, $6F, $11, $72, $40, $BF, $15, $02, $C3, $03, $13, $0A, $13, $8B, $12
00CD4C  2  72 40 BF 15  
00CD50  2  02 C3 03 13  
00CD58  2  99 0C 0D 10  .byte $99, $0C, $0D, $10, $47, $16, $46, $45, $94, $08, $B3, $32, $13, $B1, $57, $0B
00CD5C  2  47 16 46 45  
00CD60  2  94 08 B3 32  
00CD68  2  A7 0B D3 31  .byte $A7, $0B, $D3, $31, $53, $B1, $A6, $31, $03, $B2, $13, $0B, $AE, $11, $BD, $41
00CD6C  2  53 B1 A6 31  
00CD70  2  03 B2 13 0B  
00CD78  2  EE 52 0F A0  .byte $EE, $52, $0F, $A0, $DD, $47, $FD
00CD7C  2  DD 47 FD     
00CD7F  2               
00CD7F  2               L_HArea0B:
00CD7F  2  52 A1 0F 20  .byte $52, $A1, $0F, $20, $6E, $65, $39, $F1, $60, $21, $6F, $62, $AC, $75, $07, $80
00CD83  2  6E 65 39 F1  
00CD87  2  60 21 6F 62  
00CD8F  2  1C 78 B0 33  .byte $1C, $78, $B0, $33, $CF, $66, $57, $E3, $6C, $04, $9A, $B0, $AC, $0C, $83, $B1
00CD93  2  CF 66 57 E3  
00CD97  2  6C 04 9A B0  
00CD9F  2  8F 74 F8 11  .byte $8F, $74, $F8, $11, $FA, $10, $83, $85, $93, $22, $9F, $74, $59, $F9, $89, $61
00CDA3  2  FA 10 83 85  
00CDA7  2  93 22 9F 74  
00CDAF  2  A9 61 BC 0C  .byte $A9, $61, $BC, $0C, $67, $A0, $EB, $71, $77, $85, $7A, $10, $86, $51, $95, $52
00CDB3  2  67 A0 EB 71  
00CDB7  2  77 85 7A 10  
00CDBF  2  A4 53 B6 03  .byte $A4, $53, $B6, $03, $B3, $06, $D3, $23, $26, $84, $4A, $10, $53, $23, $5C, $00
00CDC3  2  B3 06 D3 23  
00CDC7  2  26 84 4A 10  
00CDCF  2  6F 73 93 05  .byte $6F, $73, $93, $05, $07, $F3, $2C, $04, $33, $30, $74, $76, $EB, $71, $57, $88
00CDD3  2  07 F3 2C 04  
00CDD7  2  33 30 74 76  
00CDDF  2  6C 02 96 74  .byte $6C, $02, $96, $74, $E3, $30, $0C, $86, $7D, $41, $BF, $26, $BD, $C7, $FD
00CDE3  2  E3 30 0C 86  
00CDE7  2  7D 41 BF 26  
00CDEE  2               
00CDEE  2               L_HArea0C:
00CDEE  2  55 A1 0F 26  .byte $55, $A1, $0F, $26, $9C, $01, $4F, $B6, $B3, $34, $C9, $3F, $13, $BA, $A3, $B3
00CDF2  2  9C 01 4F B6  
00CDF6  2  B3 34 C9 3F  
00CDFE  2  BF 74 0C 84  .byte $BF, $74, $0C, $84, $83, $3F, $9F, $74, $EF, $72, $EC, $01, $2F, $F2, $2C, $01
00CE02  2  83 3F 9F 74  
00CE06  2  EF 72 EC 01  
00CE0E  2  6F 72 6C 01  .byte $6F, $72, $6C, $01, $A8, $91, $AA, $10, $03, $B7, $10, $08, $61, $79, $6F, $75
00CE12  2  A8 91 AA 10  
00CE16  2  03 B7 10 08  
00CE1E  2  39 F1 DB 71  .byte $39, $F1, $DB, $71, $03, $A2, $17, $22, $33, $06, $43, $20, $5B, $71, $48, $8C
00CE22  2  03 A2 17 22  
00CE26  2  33 06 43 20  
00CE2E  2  4A 30 5C 5C  .byte $4A, $30, $5C, $5C, $93, $31, $2D, $C1, $5F, $26, $3D, $C7, $FD
00CE32  2  93 31 2D C1  
00CE36  2  5F 26 3D C7  
00CE3B  2               
00CE3B  2               L_HArea0D:
00CE3B  2  55 A1 0F 26  .byte $55, $A1, $0F, $26, $39, $91, $68, $12, $A7, $12, $AA, $10, $C7, $05, $E8, $12
00CE3F  2  39 91 68 12  
00CE43  2  A7 12 AA 10  
00CE4B  2  19 91 6C 00  .byte $19, $91, $6C, $00, $78, $74, $0E, $C2, $76, $A8, $FE, $40, $29, $91, $73, $29
00CE4F  2  78 74 0E C2  
00CE53  2  76 A8 FE 40  
00CE5B  2  77 53 86 47  .byte $77, $53, $86, $47, $8C, $76, $F7, $00, $59, $91, $87, $13, $B6, $14, $BA, $10
00CE5F  2  8C 76 F7 00  
00CE63  2  59 91 87 13  
00CE6B  2  E8 12 38 92  .byte $E8, $12, $38, $92, $19, $8C, $2C, $00, $33, $67, $4E, $42, $68, $08, $2E, $C0
00CE6F  2  19 8C 2C 00  
00CE73  2  33 67 4E 42  
00CE7B  2  38 72 A8 11  .byte $38, $72, $A8, $11, $AA, $10, $49, $91, $6E, $42, $DE, $40, $E7, $22, $0E, $C2
00CE7F  2  AA 10 49 91  
00CE83  2  6E 42 DE 40  
00CE8B  2  4E C0 6C 00  .byte $4E, $C0, $6C, $00, $79, $11, $8C, $01, $A7, $13, $BC, $01, $D5, $15, $EC, $01
00CE8F  2  79 11 8C 01  
00CE93  2  A7 13 BC 01  
00CE9B  2  03 97 0E 00  .byte $03, $97, $0E, $00, $6E, $01, $9D, $41, $CE, $42, $FF, $20, $9D, $C7, $FD
00CE9F  2  6E 01 9D 41  
00CEA3  2  CE 42 FF 20  
00CEAA  2               
00CEAA  2               L_HArea0E:
00CEAA  2  10 21 39 F1  .byte $10, $21, $39, $F1, $09, $F1, $A8, $60, $7C, $83, $96, $30, $5B, $F1, $C8, $04
00CEAE  2  09 F1 A8 60  
00CEB2  2  7C 83 96 30  
00CEBA  2  1F B7 93 67  .byte $1F, $B7, $93, $67, $A3, $67, $B3, $67, $B8, $60, $CC, $08, $54, $FE, $6E, $2F
00CEBE  2  A3 67 B3 67  
00CEC2  2  B8 60 CC 08  
00CECA  2  6D C7 FD     .byte $6D, $C7, $FD
00CECD  2               
00CECD  2               L_HArea0F:
00CECD  2  00 C1 4C 00  .byte $00, $C1, $4C, $00, $02, $C9, $BA, $49, $62, $C9, $A4, $20, $A5, $20, $1A, $C9
00CED1  2  02 C9 BA 49  
00CED5  2  62 C9 A4 20  
00CEDD  2  A3 2C B2 49  .byte $A3, $2C, $B2, $49, $56, $C2, $6E, $00, $95, $41, $AD, $C7, $FD
00CEE1  2  56 C2 6E 00  
00CEE5  2  95 41 AD C7  
00CEEA  2               
00CEEA  2               L_HArea12:
00CEEA  2  48 8F 1E 01  .byte $48, $8F, $1E, $01, $4E, $02, $00, $89, $09, $0C, $6E, $0A, $EE, $82, $2E, $80
00CEEE  2  4E 02 00 89  
00CEF2  2  09 0C 6E 0A  
00CEFA  2  30 20 7E 01  .byte $30, $20, $7E, $01, $87, $27, $07, $85, $17, $23, $3E, $00, $9E, $05, $5B, $F1
00CEFE  2  87 27 07 85  
00CF02  2  17 23 3E 00  
00CF0A  2  8B 71 BB 71  .byte $8B, $71, $BB, $71, $EB, $71, $3E, $82, $7F, $38, $FE, $0A, $3E, $84, $47, $29
00CF0E  2  EB 71 3E 82  
00CF12  2  7F 38 FE 0A  
00CF1A  2  48 2E AF 71  .byte $48, $2E, $AF, $71, $CB, $71, $E7, $07, $F7, $23, $2B, $F1, $37, $51, $3E, $00
00CF1E  2  CB 71 E7 07  
00CF22  2  F7 23 2B F1  
00CF2A  2  6F 00 8E 04  .byte $6F, $00, $8E, $04, $DF, $32, $9C, $82, $CA, $12, $DC, $00, $E8, $14, $FC, $00
00CF2E  2  DF 32 9C 82  
00CF32  2  CA 12 DC 00  
00CF3A  2  FE 08 4E 8A  .byte $FE, $08, $4E, $8A, $88, $74, $9E, $01, $A8, $52, $BF, $47, $B8, $52, $C8, $52
00CF3E  2  88 74 9E 01  
00CF42  2  A8 52 BF 47  
00CF4A  2  D8 52 E8 52  .byte $D8, $52, $E8, $52, $EE, $0F, $4D, $C7, $0D, $0D, $0E, $02, $68, $7A, $BE, $01
00CF4E  2  EE 0F 4D C7  
00CF52  2  0D 0D 0E 02  
00CF5A  2  EE 0F 6D C5  .byte $EE, $0F, $6D, $C5, $FD
00CF5E  2  FD           
00CF5F  2               
00CF5F  2               L_HArea13:
00CF5F  2  08 0F 0E 01  .byte $08, $0F, $0E, $01, $2E, $05, $38, $20, $3E, $04, $48, $05, $55, $45, $57, $45
00CF63  2  2E 05 38 20  
00CF67  2  3E 04 48 05  
00CF6F  2  58 25 B8 05  .byte $58, $25, $B8, $05, $BE, $05, $C8, $20, $CE, $01, $DF, $4A, $6D, $C7, $0E, $81
00CF73  2  BE 05 C8 20  
00CF77  2  CE 01 DF 4A  
00CF7F  2  00 5A 2E 02  .byte $00, $5A, $2E, $02, $34, $42, $36, $42, $37, $22, $73, $54, $83, $08, $87, $20
00CF83  2  34 42 36 42  
00CF87  2  37 22 73 54  
00CF8F  2  93 54 90 05  .byte $93, $54, $90, $05, $B4, $41, $B6, $41, $B7, $21, $DF, $4A, $6D, $C7, $0E, $81
00CF93  2  B4 41 B6 41  
00CF97  2  B7 21 DF 4A  
00CF9F  2  00 5A 14 56  .byte $00, $5A, $14, $56, $24, $56, $2E, $0C, $33, $43, $6E, $09, $8E, $0B, $96, $48
00CFA3  2  24 56 2E 0C  
00CFA7  2  33 43 6E 09  
00CFAF  2  1E 84 3E 05  .byte $1E, $84, $3E, $05, $4A, $48, $47, $08, $CE, $01, $DF, $4A, $6D, $C7, $FD
00CFB3  2  4A 48 47 08  
00CFB7  2  CE 01 DF 4A  
00CFBE  2               
00CFBE  2               L_HArea14:
00CFBE  2  41 01 DA 60  .byte $41, $01, $DA, $60, $E9, $61, $F8, $62, $FE, $0B, $FE, $81, $47, $D3, $8A, $60
00CFC2  2  E9 61 F8 62  
00CFC6  2  FE 0B FE 81  
00CFCE  2  99 61 A8 62  .byte $99, $61, $A8, $62, $B7, $63, $C6, $64, $D5, $65, $E4, $66, $ED, $49, $F3, $67
00CFD2  2  B7 63 C6 64  
00CFD6  2  D5 65 E4 66  
00CFDE  2  1A CB E3 67  .byte $1A, $CB, $E3, $67, $F3, $67, $FE, $02, $31, $D6, $3C, $02, $77, $53, $AC, $02
00CFE2  2  F3 67 FE 02  
00CFE6  2  31 D6 3C 02  
00CFEE  2  B1 56 E7 53  .byte $B1, $56, $E7, $53, $FE, $01, $77, $B9, $A3, $43, $00, $BF, $29, $51, $39, $48
00CFF2  2  FE 01 77 B9  
00CFF6  2  A3 43 00 BF  
00CFFE  2  61 55 D2 44  .byte $61, $55, $D2, $44, $D6, $54, $0C, $82, $2E, $02, $31, $66, $44, $47, $47, $32
00D002  2  D6 54 0C 82  
00D006  2  2E 02 31 66  
00D00E  2  4A 47 97 32  .byte $4A, $47, $97, $32, $C1, $66, $CE, $01, $DC, $02, $FE, $0E, $0C, $8F, $08, $4F
00D012  2  C1 66 CE 01  
00D016  2  DC 02 FE 0E  
00D01E  2  FE 02 75 E0  .byte $FE, $02, $75, $E0, $FE, $01, $0C, $87, $9A, $60, $A9, $61, $B8, $62, $C7, $63
00D022  2  FE 01 0C 87  
00D026  2  9A 60 A9 61  
00D02E  2  CE 0F D5 0A  .byte $CE, $0F, $D5, $0A, $6D, $CA, $7D, $47, $FD
00D032  2  6D CA 7D 47  
00D036  2  FD           
00D037  2               
00D037  2               ;unused bytes
00D037  2  FF FF FF FF  .byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF
00D03B  2  FF FF FF FF  
00D03F  2  FF FF FF FF  
00D047  2  FF FF FF FF  .byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF
00D04B  2  FF FF FF FF  
00D04F  2  FF FF FF FF  
00D057  2  FF FF FF FF  .byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF
00D05B  2  FF FF FF FF  
00D05F  2  FF FF FF FF  
00D067  2  FF FF FF FF  .byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF
00D06B  2  FF FF FF FF  
00D06F  2  FF FF FF FF  
00D077  2  FF FF FF FF  .byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF
00D07B  2  FF FF FF FF  
00D07F  2  FF FF FF FF  
00D086  2               .else
00D086  2               ;--------------------------------------------------
00D086  2               
00D086  2               ;level A-4
00D086  2               E_CastleArea11:
00D086  2                 .byte $2a, $9e, $6b, $0c, $8d, $1c, $ea, $1f, $1b, $8c, $e6, $1c, $8c, $9c, $bb, $0c
00D086  2                 .byte $f3, $83, $9b, $8c, $db, $0c, $1b, $8c, $6b, $0c, $bb, $0c, $0f, $09, $40, $15
00D086  2                 .byte $78, $ad, $90, $b5, $ff
00D086  2               
00D086  2               ;level B-4
00D086  2               E_CastleArea12:
00D086  2                 .byte $0f, $02, $38, $1d, $d9, $1b, $6e, $e1, $21, $3a, $a8, $18, $9d, $0f, $07, $18
00D086  2                 .byte $1d, $0f, $09, $18, $1d, $0f, $0b, $18, $1d, $7b, $15, $8e, $21, $2e, $b9, $9d
00D086  2                 .byte $0f, $0e, $78, $2d, $90, $b5, $ff
00D086  2               
00D086  2               ;level C-4
00D086  2               E_CastleArea13:
00D086  2                 .byte $05, $9d, $65, $1d, $0d, $a8, $dd, $1d, $07, $ac, $54, $2c, $a2, $2c, $f4, $2c
00D086  2                 .byte $42, $ac, $26, $9d, $d4, $03, $24, $83, $64, $03, $2b, $82, $4b, $02, $7b, $02
00D086  2                 .byte $9b, $02, $5b, $82, $7b, $02, $0b, $82, $2b, $02, $c6, $1b, $28, $82, $48, $02
00D086  2                 .byte $a6, $1b, $7b, $95, $85, $0c, $9d, $9b, $0f, $0e, $78, $2d, $7a, $1d, $90, $b5
00D086  2                 .byte $ff
00D086  2               
00D086  2               ;level D-4
00D086  2               E_CastleArea14:
00D086  2                 .byte $19, $9f, $99, $1b, $2c, $8c, $59, $1b, $c5, $0f, $0f, $04, $09, $29, $bd, $1d
00D086  2                 .byte $0f, $06, $6e, $2a, $61, $0f, $09, $48, $2d, $46, $87, $79, $07, $8e, $63, $60
00D086  2                 .byte $a5, $07, $b8, $85, $57, $a5, $8c, $8c, $76, $9d, $78, $2d, $90, $b5, $ff
00D086  2               
00D086  2               ;level A-1
00D086  2               E_GroundArea30:
00D086  2                 .byte $07, $83, $37, $03, $6b, $0e, $e0, $3d, $20, $be, $6e, $2b, $00, $a7, $85, $d3
00D086  2                 .byte $05, $e7, $83, $24, $83, $27, $03, $49, $00, $59, $00, $10, $bb, $b0, $3b, $6e
00D086  2                 .byte $c1, $00, $17, $85, $53, $05, $36, $8e, $76, $0e, $b6, $0e, $e7, $83, $63, $83
00D086  2                 .byte $68, $03, $29, $83, $57, $03, $85, $03, $b5, $29, $ff
00D086  2               
00D086  2               ;level A-3
00D086  2               E_GroundArea31:
00D086  2                 .byte $0f, $04, $66, $07, $0f, $06, $86, $10, $0f, $08, $55, $0f, $e5, $8f, $ff
00D086  2               
00D086  2               ;level B-1
00D086  2               E_GroundArea32:
00D086  2                 .byte $70, $b7, $ca, $00, $66, $80, $0f, $04, $79, $0e, $ab, $0e, $ee, $2b, $20, $eb
00D086  2                 .byte $80, $40, $bb, $fb, $00, $40, $b7, $cb, $0e, $0f, $09, $4b, $00, $76, $00, $d8
00D086  2                 .byte $00, $6b, $8e, $73, $06, $83, $06, $c7, $0e, $36, $90, $c5, $06, $ff
00D086  2               
00D086  2               ;level B-3
00D086  2               E_GroundArea33:
00D086  2                 .byte $84, $8f, $a7, $24, $d3, $0f, $ea, $24, $45, $a9, $d5, $28, $45, $a9, $84, $25
00D086  2                 .byte $b4, $8f, $09, $90, $b5, $a8, $5b, $97, $cd, $28, $b5, $a4, $09, $a4, $65, $28
00D086  2                 .byte $92, $90, $e3, $83, $ff
00D086  2               
00D086  2               ;level C-1
00D086  2               E_GroundArea34:
00D086  2                 .byte $3a, $8e, $5b, $0e, $c3, $8e, $ca, $8e, $0b, $8e, $4a, $0e, $de, $c1, $44, $0f
00D086  2                 .byte $08, $49, $0e, $eb, $0e, $8a, $90, $ab, $85, $0f, $0c, $03, $0f, $2e, $2b, $40
00D086  2                 .byte $67, $86, $ff
00D086  2               
00D086  2               ;level C-2
00D086  2               E_GroundArea35:
00D086  2                 .byte $15, $8f, $54, $07, $aa, $83, $f8, $07, $0f, $04, $14, $07, $96, $10, $0f, $07
00D086  2                 .byte $95, $0f, $9d, $a8, $0b, $97, $09, $a9, $55, $24, $a9, $24, $bb, $17, $ff
00D086  2               
00D086  2               ;level C-3
00D086  2               E_GroundArea36:
00D086  2                 .byte $0f, $03, $a6, $11, $a3, $90, $a6, $91, $0f, $08, $a6, $11, $e3, $a9, $0f, $0d
00D086  2                 .byte $55, $24, $a9, $24, $0f, $11, $59, $1d, $a9, $1b, $23, $8f, $15, $9b, $ff
00D086  2               
00D086  2               ;level D-1
00D086  2               E_GroundArea37:
00D086  2                 .byte $87, $85, $9b, $05, $18, $90, $a4, $8f, $6e, $c1, $60, $9b, $02, $d0, $3b, $80
00D086  2                 .byte $b8, $03, $8e, $1b, $02, $3b, $02, $0f, $08, $03, $10, $f7, $05, $6b, $85, $ff
00D086  2               
00D086  2               ;level D-2
00D086  2               E_GroundArea38:
00D086  2                 .byte $db, $82, $f3, $03, $10, $b7, $80, $37, $1a, $8e, $4b, $0e, $7a, $0e, $ab, $0e
00D086  2                 .byte $0f, $05, $f9, $0e, $d0, $be, $2e, $c1, $62, $d4, $8f, $64, $8f, $7e, $2b, $60
00D086  2                 .byte $ff
00D086  2               
00D086  2               ;level D-3
00D086  2               E_GroundArea39:
00D086  2                 .byte $0f, $03, $ab, $05, $1b, $85, $a3, $85, $d7, $05, $0f, $08, $33, $03, $0b, $85
00D086  2                 .byte $fb, $85, $8b, $85, $3a, $8e, $ff
00D086  2               
00D086  2               ;ground level area used with level D-4
00D086  2               E_GroundArea40:
00D086  2                 .byte $0f, $02, $09, $05, $3e, $41, $64, $2b, $8e, $58, $0e, $ca, $07, $34, $87, $ff
00D086  2               
00D086  2               ;cloud level used with levels A-1, B-1 and D-2
00D086  2               E_GroundArea41:
00D086  2                 .byte $0a, $aa, $1e, $20, $03, $1e, $22, $27, $2e, $24, $48, $2e, $28, $67, $ff
00D086  2               
00D086  2               ;level A-2
00D086  2               E_UndergroundArea6:
00D086  2                 .byte $bb, $a9, $1b, $a9, $69, $29, $b8, $29, $59, $a9, $8d, $a8, $0f, $07, $15, $29
00D086  2                 .byte $55, $ac, $6b, $85, $0e, $ad, $01, $67, $34, $ff
00D086  2               
00D086  2               ;underground bonus rooms used with worlds A-D
00D086  2               E_UndergroundArea7:
00D086  2                 .byte $1e, $a0, $09, $1e, $27, $67, $0f, $03, $1e, $28, $68, $0f, $05, $1e, $24, $48
00D086  2                 .byte $1e, $63, $68, $ff
00D086  2               
00D086  2               ;level B-2
00D086  2               E_WaterArea9:
00D086  2                 .byte $ee, $ad, $21, $26, $87, $f3, $0e, $66, $87, $cb, $00, $65, $87, $0f, $06, $06
00D086  2                 .byte $0e, $97, $07, $cb, $00, $75, $87, $d3, $27, $d9, $27, $0f, $09, $77, $1f, $46
00D086  2                 .byte $87, $b1, $0f, $ff
00D086  2               
00D086  2               ;level A-4
00D086  2               L_CastleArea11:
00D086  2                 .byte $9b, $87, $05, $32, $06, $33, $07, $34, $ee, $0a, $0e, $86, $28, $0e, $3e, $0a
00D086  2                 .byte $6e, $02, $8b, $0e, $97, $00, $9e, $0a, $ce, $06, $e8, $0e, $fe, $0a, $2e, $86
00D086  2                 .byte $6e, $0a, $8e, $08, $e4, $0e, $1e, $82, $8a, $0e, $8e, $0a, $fe, $02, $1a, $e0
00D086  2                 .byte $29, $61, $2e, $06, $3e, $09, $56, $60, $65, $61, $6e, $0c, $83, $60, $7e, $8a
00D086  2                 .byte $bb, $61, $f9, $63, $27, $e5, $88, $64, $eb, $61, $fe, $05, $68, $90, $0a, $90
00D086  2                 .byte $fe, $02, $3a, $90, $3e, $0a, $ae, $02, $da, $60, $e9, $61, $f8, $62, $fe, $0a
00D086  2                 .byte $0d, $c4, $a1, $62, $b1, $62, $cd, $43, $ce, $09, $de, $0b, $dd, $42, $fe, $02
00D086  2                 .byte $5d, $c7, $fd
00D086  2               
00D086  2               ;level B-4
00D086  2               L_CastleArea12:
00D086  2                 .byte $9b, $07, $05, $32, $06, $33, $07, $33, $3e, $0a, $41, $3b, $42, $3b, $58, $64
00D086  2                 .byte $7a, $62, $c8, $31, $18, $e4, $39, $73, $5e, $09, $66, $3c, $0e, $82, $28, $07
00D086  2                 .byte $36, $0e, $3e, $0a, $ae, $02, $d7, $0e, $fe, $0c, $fe, $8a, $11, $e5, $21, $65
00D086  2                 .byte $31, $65, $4e, $0c, $fe, $02, $16, $8e, $2e, $0e, $fe, $02, $18, $fa, $3e, $0e
00D086  2                 .byte $fe, $02, $16, $8e, $2e, $0e, $fe, $02, $18, $fa, $3e, $0e, $fe, $02, $16, $8e
00D086  2                 .byte $2e, $0e, $fe, $02, $18, $fa, $3e, $0e, $fe, $02, $16, $8e, $2e, $0e, $fe, $02
00D086  2                 .byte $18, $fa, $5e, $0a, $6e, $02, $7e, $0a, $b7, $0e, $ee, $07, $fe, $8a, $0d, $c4
00D086  2                 .byte $cd, $43, $ce, $09, $dd, $42, $de, $0b, $fe, $02, $5d, $c7, $fd
00D086  2               
00D086  2               ;level C-4
00D086  2               L_CastleArea13:
00D086  2                 .byte $98, $07, $05, $35, $06, $3d, $07, $3d, $be, $06, $de, $0c, $f3, $3d, $03, $8e
00D086  2                 .byte $63, $0e, $6e, $43, $ce, $0a, $e1, $67, $f1, $67, $01, $e7, $11, $67, $1e, $05
00D086  2                 .byte $28, $39, $6e, $40, $be, $01, $c7, $06, $db, $0e, $de, $00, $1f, $80, $6f, $00
00D086  2                 .byte $bf, $00, $0f, $80, $5f, $00, $7e, $05, $a8, $37, $fe, $02, $24, $8e, $34, $30
00D086  2                 .byte $3e, $0c, $4e, $43, $ae, $0a, $be, $0c, $ee, $0a, $fe, $0c, $2e, $8a, $3e, $0c
00D086  2                 .byte $7e, $02, $8e, $0e, $98, $36, $b9, $34, $08, $bf, $09, $3f, $0e, $82, $2e, $86
00D086  2                 .byte $4e, $0c, $9e, $09, $a6, $60, $c1, $62, $c4, $0e, $ee, $0c, $0e, $86, $5e, $0c
00D086  2                 .byte $7e, $09, $86, $60, $a1, $62, $a4, $0e, $c6, $60, $ce, $0c, $fe, $0a, $28, $b4
00D086  2                 .byte $a6, $31, $e8, $34, $8b, $b2, $9b, $0e, $fe, $07, $fe, $8a, $0d, $c4, $cd, $43
00D086  2                 .byte $ce, $09, $dd, $42, $de, $0b, $fe, $02, $5d, $c7, $fd
00D086  2               
00D086  2               ;level D-4
00D086  2               L_CastleArea14:
00D086  2                 .byte $5b, $03, $05, $34, $06, $35, $39, $71, $6e, $02, $ae, $0a, $fe, $05, $17, $8e
00D086  2                 .byte $97, $0e, $9e, $02, $a6, $06, $fa, $30, $fe, $0a, $4e, $82, $57, $0e, $58, $62
00D086  2                 .byte $68, $62, $79, $61, $8a, $60, $8e, $0a, $f5, $31, $f9, $73, $39, $f3, $b5, $71
00D086  2                 .byte $b7, $31, $4d, $c8, $8a, $62, $9a, $62, $ae, $05, $bb, $0e, $cd, $4a, $fe, $82
00D086  2                 .byte $77, $fb, $de, $0f, $4e, $82, $6d, $47, $39, $f3, $0c, $ea, $08, $3f, $b3, $00
00D086  2                 .byte $cc, $63, $f9, $30, $69, $f9, $ea, $60, $f9, $61, $fe, $07, $de, $84, $e4, $62
00D086  2                 .byte $e9, $61, $f4, $62, $fa, $60, $04, $e2, $14, $62, $24, $62, $34, $62, $3e, $0a
00D086  2                 .byte $7e, $0c, $7e, $8a, $8e, $08, $94, $36, $fe, $0a, $0d, $c4, $61, $64, $71, $64
00D086  2                 .byte $81, $64, $cd, $43, $ce, $09, $dd, $42, $de, $0b, $fe, $02, $5d, $c7, $fd
00D086  2               
00D086  2               ;level A-1
00D086  2               L_GroundArea30:
00D086  2                 .byte $52, $71, $0f, $20, $6e, $70, $e3, $64, $fc, $61, $fc, $71, $13, $86, $2c, $61
00D086  2                 .byte $2c, $71, $43, $64, $b2, $22, $b5, $62, $c7, $28, $22, $a2, $52, $09, $56, $61
00D086  2                 .byte $6c, $03, $db, $71, $fc, $03, $f3, $20, $03, $a4, $0f, $71, $40, $0c, $8c, $74
00D086  2                 .byte $9c, $66, $d7, $01, $ec, $71, $89, $e1, $b6, $61, $b9, $2a, $c7, $26, $f4, $23
00D086  2                 .byte $67, $e2, $e8, $f2, $78, $82, $88, $01, $98, $02, $a8, $02, $b8, $02, $03, $a6
00D086  2                 .byte $07, $26, $21, $79, $4b, $71, $cf, $33, $06, $e4, $16, $2a, $39, $71, $58, $45
00D086  2                 .byte $5a, $45, $c6, $07, $dc, $04, $3f, $e7, $3b, $71, $8c, $71, $ac, $01, $e7, $63
00D086  2                 .byte $39, $8f, $63, $20, $65, $0b, $68, $62, $8c, $00, $0c, $81, $29, $63, $3c, $01
00D086  2                 .byte $57, $65, $6c, $01, $85, $67, $9c, $04, $1d, $c1, $5f, $26, $3d, $c7, $fd
00D086  2               
00D086  2               ;level A-3
00D086  2               L_GroundArea31:
00D086  2                 .byte $50, $50, $0b, $1f, $0f, $26, $19, $96, $84, $43, $b7, $1f, $5d, $cc, $6d, $48
00D086  2                 .byte $e0, $42, $e3, $12, $39, $9c, $56, $43, $47, $9b, $a4, $12, $c1, $06, $ed, $4d
00D086  2                 .byte $f4, $42, $1b, $98, $b7, $13, $02, $c2, $03, $12, $47, $1f, $ad, $48, $63, $9c
00D086  2                 .byte $82, $48, $76, $93, $08, $94, $8e, $11, $b0, $03, $c9, $0f, $1d, $c1, $2d, $4a
00D086  2                 .byte $4e, $42, $6f, $20, $0d, $0e, $0e, $40, $39, $71, $7f, $37, $f2, $68, $01, $e9
00D086  2                 .byte $11, $39, $68, $7a, $de, $1f, $6d, $c5, $fd
00D086  2               
00D086  2               ;level B-1
00D086  2               L_GroundArea32:
00D086  2                 .byte $52, $21, $0f, $20, $6e, $60, $6c, $f6, $ca, $30, $dc, $02, $08, $f2, $37, $04
00D086  2                 .byte $56, $74, $7c, $00, $dc, $01, $e7, $25, $47, $8b, $49, $20, $6c, $02, $96, $74
00D086  2                 .byte $06, $82, $36, $02, $66, $00, $a7, $22, $dc, $02, $0a, $e0, $63, $22, $78, $72
00D086  2                 .byte $93, $09, $97, $03, $a3, $25, $a7, $03, $b6, $24, $03, $a2, $5c, $75, $65, $71
00D086  2                 .byte $7c, $00, $9c, $00, $63, $a2, $67, $20, $77, $03, $87, $20, $93, $0a, $97, $03
00D086  2                 .byte $a3, $22, $a7, $20, $b7, $03, $bc, $00, $c7, $20, $dc, $00, $fc, $01, $19, $8f
00D086  2                 .byte $1e, $20, $46, $22, $4c, $61, $63, $00, $8e, $21, $d7, $73, $46, $a6, $4c, $62
00D086  2                 .byte $68, $62, $73, $01, $8c, $62, $d8, $62, $43, $a9, $c7, $73, $ec, $06, $57, $f3
00D086  2                 .byte $7c, $00, $b5, $65, $c5, $65, $dc, $00, $e3, $67, $7d, $c1, $bf, $26, $ad, $c7
00D086  2                 .byte $fd
00D086  2               
00D086  2               ;level B-3
00D086  2               L_GroundArea33:
00D086  2                 .byte $90, $10, $0b, $1b, $0f, $26, $07, $94, $bc, $14, $bf, $13, $c7, $40, $ff, $16
00D086  2                 .byte $d1, $80, $c3, $94, $cb, $17, $c2, $44, $29, $8f, $77, $31, $0b, $96, $76, $32
00D086  2                 .byte $c7, $75, $13, $f7, $1b, $61, $2b, $61, $4b, $12, $59, $0f, $3b, $b0, $3a, $40
00D086  2                 .byte $43, $12, $7a, $40, $7b, $30, $b5, $41, $b6, $20, $c6, $07, $f3, $13, $03, $92
00D086  2                 .byte $6b, $12, $79, $0f, $cc, $15, $cf, $11, $1f, $95, $c3, $14, $b3, $95, $a3, $95
00D086  2                 .byte $4d, $ca, $6b, $61, $7e, $11, $8d, $41, $be, $42, $df, $20, $bd, $c7, $fd
00D086  2               
00D086  2               ;level C-1
00D086  2               L_GroundArea34:
00D086  2                 .byte $52, $31, $0f, $20, $6e, $74, $0d, $02, $03, $33, $1f, $72, $39, $71, $65, $04
00D086  2                 .byte $6c, $70, $77, $01, $84, $72, $8c, $72, $b3, $34, $ec, $01, $ef, $72, $0d, $04
00D086  2                 .byte $ac, $67, $cc, $01, $cf, $71, $e7, $22, $17, $88, $23, $00, $27, $23, $3c, $62
00D086  2                 .byte $65, $71, $67, $33, $8c, $61, $dc, $01, $08, $fa, $45, $75, $63, $0a, $73, $23
00D086  2                 .byte $7c, $02, $8f, $72, $73, $a9, $9f, $74, $bf, $74, $ef, $73, $39, $f1, $fc, $0a
00D086  2                 .byte $0d, $0b, $13, $25, $4c, $01, $4f, $72, $73, $0b, $77, $03, $dc, $08, $23, $a2
00D086  2                 .byte $53, $09, $56, $03, $63, $24, $8c, $02, $3f, $b3, $77, $63, $96, $74, $b3, $77
00D086  2                 .byte $5d, $c1, $8f, $26, $7d, $c7, $fd
00D086  2               
00D086  2               ;level C-2
00D086  2               L_GroundArea35:
00D086  2                 .byte $54, $11, $0f, $26, $cf, $32, $f8, $62, $fe, $10, $3c, $b2, $bd, $48, $ea, $62
00D086  2                 .byte $fc, $4d, $fc, $4d, $17, $c9, $da, $62, $0b, $97, $b7, $12, $2c, $b1, $33, $43
00D086  2                 .byte $6c, $31, $ac, $41, $0b, $98, $ad, $4a, $db, $30, $27, $b0, $b7, $14, $c6, $42
00D086  2                 .byte $c7, $96, $d6, $44, $2b, $92, $39, $0f, $72, $41, $a7, $00, $1b, $95, $97, $13
00D086  2                 .byte $6c, $95, $6f, $11, $a2, $40, $bf, $15, $c2, $40, $0b, $9a, $62, $42, $63, $12
00D086  2                 .byte $ad, $4a, $0e, $91, $1d, $41, $4f, $26, $4d, $c7, $fd
00D086  2               
00D086  2               ;level C-3
00D086  2               L_GroundArea36:
00D086  2                 .byte $57, $11, $0f, $26, $fe, $10, $4b, $92, $59, $0f, $ad, $4c, $d3, $93, $0b, $94
00D086  2                 .byte $29, $0f, $7b, $93, $99, $0f, $0d, $06, $27, $12, $35, $0f, $23, $b1, $57, $75
00D086  2                 .byte $a3, $31, $ab, $71, $f7, $75, $23, $b1, $87, $13, $95, $0f, $0d, $0a, $23, $35
00D086  2                 .byte $38, $13, $55, $00, $9b, $16, $0b, $96, $c7, $75, $dd, $4a, $3b, $92, $49, $0f
00D086  2                 .byte $ad, $4c, $29, $92, $52, $40, $6c, $15, $6f, $11, $72, $40, $bf, $15, $03, $93
00D086  2                 .byte $0a, $13, $12, $41, $8b, $12, $99, $0f, $0d, $10, $47, $16, $46, $45, $b3, $32
00D086  2                 .byte $13, $b1, $57, $0e, $a7, $0e, $d3, $31, $53, $b1, $a6, $31, $03, $b2, $13, $0e
00D086  2                 .byte $8d, $4d, $ae, $11, $bd, $41, $ee, $52, $0f, $a0, $dd, $47, $fd
00D086  2               
00D086  2               ;level D-1
00D086  2               L_GroundArea37:
00D086  2                 .byte $52, $a1, $0f, $20, $6e, $65, $04, $a0, $14, $07, $24, $2d, $57, $25, $bc, $09
00D086  2                 .byte $4c, $80, $6f, $33, $a5, $11, $a7, $63, $b7, $63, $e7, $20, $35, $a0, $59, $11
00D086  2                 .byte $b4, $08, $c0, $04, $05, $82, $15, $02, $25, $02, $3a, $10, $4c, $01, $6c, $79
00D086  2                 .byte $95, $79, $73, $a7, $8f, $74, $f3, $0a, $03, $a0, $93, $08, $97, $73, $e3, $20
00D086  2                 .byte $39, $f1, $94, $07, $aa, $30, $bc, $5c, $c7, $30, $24, $f2, $27, $31, $8f, $33
00D086  2                 .byte $c6, $10, $c7, $63, $d7, $63, $e7, $63, $f7, $63, $03, $a5, $07, $25, $aa, $10
00D086  2                 .byte $03, $bf, $4f, $74, $6c, $00, $df, $74, $fc, $00, $5c, $81, $77, $73, $9d, $4c
00D086  2                 .byte $c5, $30, $e3, $30, $7d, $c1, $bd, $4d, $bf, $26, $ad, $c7, $fd
00D086  2               
00D086  2               ;level D-2
00D086  2               L_GroundArea38:
00D086  2                 .byte $55, $a1, $0f, $26, $9c, $01, $4f, $b6, $b3, $34, $c9, $3f, $13, $ba, $a3, $b3
00D086  2                 .byte $bf, $74, $0c, $84, $83, $3f, $9f, $74, $ef, $72, $ec, $01, $2f, $f2, $2c, $01
00D086  2                 .byte $6f, $72, $6c, $01, $a8, $91, $aa, $10, $03, $b7, $61, $79, $6f, $75, $39, $f1
00D086  2                 .byte $db, $71, $03, $a2, $17, $22, $33, $09, $43, $20, $5b, $71, $48, $8f, $4a, $30
00D086  2                 .byte $5c, $5c, $a3, $30, $2d, $c1, $5f, $26, $3d, $c7, $fd
00D086  2               
00D086  2               ;level D-3
00D086  2               L_GroundArea39:
00D086  2                 .byte $55, $a1, $0f, $26, $39, $91, $68, $12, $a7, $12, $aa, $10, $c7, $07, $e8, $12
00D086  2                 .byte $19, $91, $6c, $00, $78, $74, $0e, $c2, $76, $a8, $fe, $40, $29, $91, $73, $29
00D086  2                 .byte $77, $53, $8c, $77, $59, $91, $87, $13, $b6, $14, $ba, $10, $e8, $12, $38, $92
00D086  2                 .byte $19, $8f, $2c, $00, $33, $67, $4e, $42, $68, $0b, $2e, $c0, $38, $72, $a8, $11
00D086  2                 .byte $aa, $10, $49, $91, $6e, $42, $de, $40, $e7, $22, $0e, $c2, $4e, $c0, $6c, $00
00D086  2                 .byte $79, $11, $8c, $01, $a7, $13, $bc, $01, $d5, $15, $ec, $01, $03, $97, $0e, $00
00D086  2                 .byte $6e, $01, $9d, $41, $ce, $42, $ff, $20, $9d, $c7, $fd
00D086  2               
00D086  2               ;ground level area used with level D-4
00D086  2               L_GroundArea40:
00D086  2                 .byte $10, $21, $39, $f1, $09, $f1, $ad, $4c, $7c, $83, $96, $30, $5b, $f1, $c8, $05
00D086  2                 .byte $1f, $b7, $93, $67, $a3, $67, $b3, $67, $bd, $4d, $cc, $08, $54, $fe, $6e, $2f
00D086  2                 .byte $6d, $c7, $fd
00D086  2               
00D086  2               ;cloud level used with levels A-1, B-1 and D-2
00D086  2               L_GroundArea41:
00D086  2                 .byte $00, $c1, $4c, $00, $02, $c9, $ba, $49, $62, $c9, $a4, $20, $a5, $20, $1a, $c9
00D086  2                 .byte $a3, $2c, $b2, $49, $56, $c2, $6e, $00, $95, $41, $ad, $c7, $fd
00D086  2               
00D086  2               ;level A-2
00D086  2               L_UndergroundArea6:
00D086  2                 .byte $48, $8f, $1e, $01, $4e, $02, $00, $8c, $09, $0f, $6e, $0a, $ee, $82, $2e, $80
00D086  2                 .byte $30, $20, $7e, $01, $87, $27, $07, $87, $17, $23, $3e, $00, $9e, $05, $5b, $f1
00D086  2                 .byte $8b, $71, $bb, $71, $eb, $71, $3e, $82, $7f, $38, $fe, $0a, $3e, $84, $47, $29
00D086  2                 .byte $48, $2e, $af, $71, $cb, $71, $e7, $0a, $f7, $23, $2b, $f1, $37, $51, $3e, $00
00D086  2                 .byte $6f, $00, $8e, $04, $df, $32, $9c, $82, $ca, $12, $dc, $00, $e8, $14, $fc, $00
00D086  2                 .byte $fe, $08, $4e, $8a, $88, $74, $9e, $01, $a8, $52, $bf, $47, $b8, $52, $c8, $52
00D086  2                 .byte $d8, $52, $e8, $52, $ee, $0f, $4d, $c7, $0d, $0d, $0e, $02, $68, $7a, $be, $01
00D086  2                 .byte $ee, $0f, $6d, $c5, $fd
00D086  2               
00D086  2               ;underground bonus rooms used with worlds A-D
00D086  2               L_UndergroundArea7:
00D086  2                 .byte $08, $0f, $0e, $01, $2e, $05, $38, $20, $3e, $04, $48, $07, $55, $45, $57, $45
00D086  2                 .byte $58, $25, $b8, $08, $be, $05, $c8, $20, $ce, $01, $df, $4a, $6d, $c7, $0e, $81
00D086  2                 .byte $00, $5a, $2e, $02, $34, $42, $36, $42, $37, $22, $73, $54, $83, $0b, $87, $20
00D086  2                 .byte $93, $54, $90, $07, $b4, $41, $b6, $41, $b7, $21, $df, $4a, $6d, $c7, $0e, $81
00D086  2                 .byte $00, $5a, $14, $56, $24, $56, $2e, $0c, $33, $43, $6e, $09, $8e, $0b, $96, $48
00D086  2                 .byte $1e, $84, $3e, $05, $4a, $48, $47, $0b, $ce, $01, $df, $4a, $6d, $c7, $fd
00D086  2               
00D086  2               ;level B-2
00D086  2               L_WaterArea9:
00D086  2                 .byte $41, $01, $da, $60, $e9, $61, $f8, $62, $fe, $0b, $fe, $81, $47, $d3, $8a, $60
00D086  2                 .byte $99, $61, $a8, $62, $b7, $63, $c6, $64, $d5, $65, $e4, $66, $ed, $49, $f3, $67
00D086  2                 .byte $1a, $cb, $e3, $67, $f3, $67, $fe, $02, $31, $d6, $3c, $02, $77, $53, $ac, $02
00D086  2                 .byte $b1, $56, $e7, $53, $fe, $01, $77, $b9, $a3, $43, $00, $bf, $29, $51, $39, $48
00D086  2                 .byte $61, $55, $d2, $44, $d6, $54, $0c, $82, $2e, $02, $31, $66, $44, $47, $47, $32
00D086  2                 .byte $4a, $47, $97, $32, $c1, $66, $ce, $01, $dc, $02, $fe, $0e, $0c, $8f, $08, $4f
00D086  2                 .byte $fe, $02, $75, $e0, $fe, $01, $0c, $87, $9a, $60, $a9, $61, $b8, $62, $c7, $63
00D086  2                 .byte $ce, $0f, $d5, $0d, $6d, $ca, $7d, $47, $fd
00D086  2               
00D086  2               ;a bunch of unused space tacked on for no apparent reason
00D086  2                 .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D086  2                 .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D086  2                 .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D086  2                 .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D086  2                 .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D086  2                 .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D086  2                 .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D086  2                 .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D086  2                 .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D086  2                 .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D086  2                 .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D086  2                 .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D086  2                 .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D086  2                 .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D086  2                 .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D086  2                 .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D086  2                 .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D086  2                 .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D086  2                 .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D086  2                 .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D086  2                 .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D086  2                 .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D086  2                 .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D086  2                 .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D086  2                 .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D086  2                 .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D086  2                 .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D086  2               .endif
00D086  2               
00D086  1               .reloc
00CEF3r 1               .endscope
00CEF3r 1               Data4End:
00CEF3r 1               
00CEF3r 1  03           .byte FileHeaderBlock
00CEF4r 1  07 0F        .byte $07,$0f
00CEF6r 1  4E 53 4D 53  .byte "NSMSAVE "
00CEFAr 1  41 56 45 20  
00CEFEr 1  E3 D2 01 00  .word $d2e3, 1
00CF02r 1  00 04        .byte PRG,FileDataBlock
00CF04r 1  00           .byte 0
00CF04r 1               
